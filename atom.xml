<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CarpeDiem&#39;s Blog</title>
  
  <subtitle>虽不能至，心向往之</subtitle>
  <link href="https://qxienote.com/atom.xml" rel="self"/>
  
  <link href="https://qxienote.com/"/>
  <updated>2023-06-13T15:24:38.027Z</updated>
  <id>https://qxienote.com/</id>
  
  <author>
    <name>Carpe Diem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python数据结构与算法篇（十五）-- 二叉树的遍历：深度优先搜索与广度优先搜索</title>
    <link href="https://qxienote.com/article/49dac87b.html"/>
    <id>https://qxienote.com/article/49dac87b.html</id>
    <published>2023-06-11T10:01:24.000Z</published>
    <updated>2023-06-13T15:24:38.027Z</updated>
    
    <content type="html"><![CDATA[<p>本篇带你走进二叉树，使用深度优先搜索和广度优先搜索思想进行二叉树的顺序遍历和层序遍历，带你刷遍LeetCode上的二叉树遍历题目。</p><span id="more"></span><p>本篇开始总结二叉树的常用解题技巧，二叉树的顺序遍历和层序遍历刚好对应深度优先搜索和广度优先搜索。</p><h2 id="1-顺序遍历"><a href="#1-顺序遍历" class="headerlink" title="1 顺序遍历"></a>1 顺序遍历</h2><p><strong>题目列表</strong></p><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank">144. 前序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank">145. 二叉树的后序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">94. 二叉树的中序遍历</a></p></li></ul></blockquote> <p><strong>144. 二叉树的前序遍历</strong><br>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.6ualntxoeg80.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><p>递归算法三要素：确定递归函数的参数和返回值、确定终止条件、确定单层递归的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            result.append(root.val)                 <span class="comment"># 先将根节点值加入结果</span></span><br><span class="line">            <span class="keyword">if</span> root.left: traversal(root.left)      <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">if</span> root.right: traversal(root.right)    <span class="comment"># 右</span></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result </span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.f5i9bhxllkg.gif#pic_center" width = 48%><p><strong>94. 二叉树的中序遍历</strong></p><p>给你二叉树的根节点 root ，返回它节点值的 中序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.5jrflywetw00.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traversal(root.left)    <span class="comment"># 左</span></span><br><span class="line">            result.append(root.val) <span class="comment"># 中序</span></span><br><span class="line">            traversal(root.right)   <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:    <span class="keyword">return</span> []   <span class="comment"># 空树</span></span><br><span class="line">        stack = []                  <span class="comment"># 不能提前将root结点加入stack中&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:                 <span class="comment"># 先迭代访问最底层左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 到达最左节点后处理栈顶结点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right     <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.6tugbwc3y2s0.gif#pic_center" width = 48%><p><strong>145. 二叉树的后序遍历</strong><br>给你二叉树的根节点 root ，返回它节点值的 后序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.25hp5m11l5s0.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            self.traversal(root.left)               <span class="comment"># 左</span></span><br><span class="line">            self.traversal(root.right)              <span class="comment"># 右</span></span><br><span class="line">            self.result.append(root.val)            <span class="comment"># 中</span></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.3e8o26ewkj20.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="3-层序遍历"><a href="#3-层序遍历" class="headerlink" title="3 层序遍历"></a>3 层序遍历</h2><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank">102. 二叉树的层序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank">107. 二叉树的层次遍历II</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank">199. 二叉树的右视图</a></p></li><li><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank">637.二叉树的层平均值</a></p></li><li><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank">429. N叉树的层序遍历/a></p></li><li><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank">515. 在每个树行中找最大值</a></p></li><li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank">116. 填充每个节点的下一个右侧节点指针</a></p></li><li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank">117.填充每个节点的下一个右侧节点指针II</a></a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank">104. 二叉树的最大深度</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank">111. 二叉树的最小深度</a></p></li></ul></blockquote> <p><strong>102. 二叉树的层序遍历</strong></p><p>给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.6wjqhxodwm80.webp#pic_center" width = 48%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p></blockquote><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.6gyzeourbyc0.gif#pic_center" width = 64%><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 二叉树层序遍历迭代解法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):       <span class="comment"># 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的</span></span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><p>用广度优先处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.96gmi09otqg.webp#pic_center" width = 36%><p>我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个 list。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.ka118nd4zgw.webp#pic_center" width = 36%><p>按照深度优先的处理顺序，会先访问节点 1，再访问节点 2，接着是节点 3。 之后是第二列的 4 和 5，最后是第三列的 6。</p><p>每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。</p><p>动态演示如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.26ehjiwrja80.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 假设 res 是 [[1], [2,3]]， level 是 3，就再插入一个 [root.val] 放到 res 中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将当前节点的值加入到res中，level 代表当前层，假设 level 是 3，节点值是 99</span></span><br><span class="line">    <span class="comment"># res 是 [[1], [2,3], [4]]，加入后 res 就变为 [[1], [2,3], [4,99]]</span></span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            <span class="comment"># 递归的处理左子树，右子树，同时将层数 level+1</span></span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>107. 二叉树的层次遍历II</strong></p><p>给你二叉树的根节点 root ，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5xg8urhe4hw0.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        results.reverse()</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>) </span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>199. 二叉树的右视图</strong></p><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.17zbfv1u8sqo.webp#pic_center" width = 36%><blockquote><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># deque 相比list的好处是，list的 pop(0) 是 O(n) 复杂度，deque 的 popleft() 是 O(1) 复杂度</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            res.append(que[-<span class="number">1</span>].val)         <span class="comment"># 每次都取最后一个node就可以</span></span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):           <span class="comment"># 执行这个遍历的目的是获取下一层所有的node</span></span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>637. 二叉树的层平均值</strong></p><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.57u4p7etgy40.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><p>从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p><p>如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：</p><ul><li>初始时，将根节点加入队列；</li><li>每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。</li></ul><p>由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。</p><p>具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 $\textit{size}$，遍历时只遍历 $\textit{size}$ 个节点，即可满足每一轮遍历的是同一层的全部节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                total += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">            result.append(total/size)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><p>使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，$\textit{counts}$ 用于存储二叉树的每一层的节点数，$\textit{sums}$ 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 $i$ 层，则将 $\textit{counts}[i]$ 的值加 1，并将该节点的值加到 $\textit{sums}[i]$。</p><p>遍历结束之后，第 $i$ 层的平均值即为 $\textit{sums}[i] &#x2F; \textit{counts}[i]$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode], level: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(total) &lt; level:          </span><br><span class="line">                total.append(root.val)</span><br><span class="line">                count.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total[level-<span class="number">1</span>] += root.val</span><br><span class="line">                count[level-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        count, total = [], []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> [t/c <span class="keyword">for</span> t, c <span class="keyword">in</span> <span class="built_in">zip</span>(total, count)]</span><br></pre></td></tr></table></figure><p><strong>429. N叉树的层序遍历</strong></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.6di4q19r8ac0.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="comment"># cur.children 是 Node 对象组成的列表，也可能为 None</span></span><br><span class="line">                <span class="keyword">if</span> node.children:</span><br><span class="line">                    que.extend(node.children)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                dfs(child, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>515. 在每个树行中找最大值</strong></p><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.6b1t4g5prm40.webp#pic_center" width = 36%><blockquote><p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">             size = <span class="built_in">len</span>(que)</span><br><span class="line">             max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">             <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                 node = que.popleft()</span><br><span class="line">                 max_value = <span class="built_in">max</span>(max_value, node.val)</span><br><span class="line">                 <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                 <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">             res.append(max_value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>] = (<span class="built_in">max</span>(root.val, res[level-<span class="number">1</span>]))</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>116. 填充每个节点的下一个右侧节点指针</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.29xb4d83sgis.webp#pic_center" width = 64%><p><strong>方法一：层序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span>        <span class="comment"># 这里空树，直接返回None</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>: <span class="keyword">break</span>          <span class="comment"># 遍历到最右边，结束本行循环</span></span><br><span class="line">                cur.<span class="built_in">next</span> = que[<span class="number">0</span>]           <span class="comment"># 指向同一行的右边节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>117. 填充每个节点的下一个右侧节点指针 II</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.2g4tll9f5pxc.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size =  <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> i == size-<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">                cur.<span class="built_in">next</span> = que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>104. 二叉树的最大深度</strong></p><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><ul><li>说明: 叶子节点是指没有子节点的节点。</li><li>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></li></ul><p>返回它的最大深度 3。</p><p><strong>方法一：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><strong>方法二：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># DFS 自底向上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 感受一下这里是将最底层的结果往上抛</span></span><br><span class="line">        <span class="comment"># 因为这里的递归边界条件是叶子节点</span></span><br><span class="line">        left_height = self.maxDepth(root.left)</span><br><span class="line">        right_height = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># DFS 自顶向下</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, depth</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res = <span class="built_in">max</span>(res, depth)</span><br><span class="line">            dfs(root.left, depth+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, depth+<span class="number">1</span>)</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>自顶向下：直接return 函数调用自身下一级实现，比如 <code>return Fibonacci(n-1) + Fibonacci(n-2)</code>;</li><li>自底向上：先递归到最小单位(叶子节点)，再从最小单位往上抛结果，传递结果</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.2dn4dh1cdzms.gif#pic_center" width = 49%> <p><strong>111. 二叉树的最小深度</strong></p><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><ul><li>说明：叶子节点是指没有子节点的节点。</li><li>示例 1：</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.69r8h85mqxc0.webp#pic_center" width = 48%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p></blockquote><p><strong>方法一：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_depth = <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.left), min_depth)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.right), min_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>方法二：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        que = collections.deque([(root, <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            node, depth = que.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                que.append((node.left, depth + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                que.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>二叉树遍历暂时告一段落，但还有很多自己不满意的地方，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.58rb9k1endc0.gif#pic_center" width = 48%><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇带你走进二叉树，使用深度优先搜索和广度优先搜索思想进行二叉树的顺序遍历和层序遍历，带你刷遍LeetCode上的二叉树遍历题目。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先遍历" scheme="https://qxienote.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
    <category term="广度优先遍历" scheme="https://qxienote.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十四）-- 冒泡排序算法</title>
    <link href="https://qxienote.com/article/234fdd80.html"/>
    <id>https://qxienote.com/article/234fdd80.html</id>
    <published>2023-06-11T10:00:54.000Z</published>
    <updated>2023-06-14T02:20:39.704Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p><span id="more"></span><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p><p>当一趟操作完成时，序列中最大的未排序元素就被放置到了所有未排序的元素中最后的位置上，它就像水中的石块一样沉到了水底。而其它较小的元素则被移动到了序列的前面，就像水中的气泡冒到了水面一样。这就是为什么该算法被叫做冒泡排序的原因。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/ed777a810bb74acab8cd23b172ad3970.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/ed777a810bb74acab8cd23b172ad3970.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图1  冒泡排序的基本原理</div> </center><hr><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1.1 算法原理"></a>1.1 算法原理</h3><p>图1展示了冒泡排序的基本原理。假设一个序列中共有 n 个元素，那么上面的比较和交换过程一共需要进行$n-1$趟：</p><ul><li>第一趟需要比较序列中的所有元素，它的效果是将整个序列中最大的元素放置到了序列最后一个位置上。</li><li>第二趟只需要比较前面$n-1$个元素，因为前一趟中已经将最大的元素移到了它最终的位置上了。这一趟结束时，整个序列中第二大的元素就被放置到了倒数第二个位置上。</li><li>同样的，第三趟只需要比较前面$n-2$个元素。该趟结束时，序列中第三大的元素就被放到了倒数第三个位置上。<br>当进行第$i$趟的时候，需要比较的是前面$n-(i-1)$个元素，因为序列中最大的$i-1$个元素已经在前面的$i-1$趟排序中被排好了。注意，比较 $n-(i-1)$个元素需要进行$n-i$次比较。</li><li>当最终到达第$n-1$趟的时候，只需要比较序列中最前面的两个数而已。该趟结束时，序列中第二小的数就被放置到了顺数第二个位置上。同时，序列中最小的数也被放到了第一个位置上。整个排序过程完成。</li></ul><p>从以上对算法原理的讲解中，我们首先可以知道冒泡排序是一种交换排序，它需要进行大量的交换操作。其次，因为当两个元素相等时它们不会被交换，所以相等元素的相对位置在排序前后不会改变，因此冒泡排序又是一种稳定的排序算法。</p><p>假设待排序序列为[5,1,4,2,8]，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：</p><ol><li><p>第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图2所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.6dqaxm0x0p40.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.6dqaxm0x0p40.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图2  第一轮排序（白色字体表示参与比较的一对相邻元素）</div> </center>从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。</li><li><p>第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图3所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.8ij9ffq6n24.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.8ij9ffq6n24.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图3  第二轮排序</div> </center></li></ol><p>可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol><li>第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图4所示。<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.5aimida0q180.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.5aimida0q180.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图4  第三轮排序</div> </center></li></ol><p>经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol><li><p>第四轮排序，此时待排序序列包含前 2 个元素，对其进行冒泡排序的整个过程如图5所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.6ptwpdge2h00.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.6ptwpdge2h00.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图5  第四轮排序</div> </center>经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。</li><li><p>当进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列（如图6所示）。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.4t75fyuqob60.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.4t75fyuqob60.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图6  冒泡排序好的序列</div> </center></li></ol><p><strong>代码一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]        <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)     <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面n-(i-1)个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><h3 id="1-2-性能分析"><a href="#1-2-性能分析" class="headerlink" title="1.2 性能分析"></a>1.2 性能分析</h3><p>由上面的排序步骤可知：$N$个数字要排序完成，总共进行$N-1$趟排序，每$i$趟的排序次数为$(N-i)$次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><p>冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，每进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p><p>时间复杂度：1）如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数$C$和记录移动次数$M$均达到最小值，即：$C_{min}&#x3D;n-1; M_{min}&#x3D;0$；所以，冒泡排序最好的时间复杂度为$O(n)$；2）如果很不幸我们的数据是反序的，则需要进行$n-1$趟排序。每趟排序要进行$n-i$次比较($1≤i≤n-1$)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$$C_{max}&#x3D;\frac{n(n-1)}{2}&#x3D;O(n^2)\<br>M_{max}&#x3D;\frac{3n(n-1)}{2}&#x3D;O(n^2)$$</p><p>综上所述：冒泡排序总的平均时间复杂度为：$O(n^2)$时间复杂度和数据状况无关。</p><hr><h2 id="2-算法优化"><a href="#2-算法优化" class="headerlink" title="2 算法优化"></a>2 算法优化</h2><h3 id="2-1-第一次优化"><a href="#2-1-第一次优化" class="headerlink" title="2.1 第一次优化"></a>2.1 第一次优化</h3><p>因为冒泡排序必须要在最终位置找到之前不断交换数据项，所以它经常被认为是最低效的排序方法。这些“浪费式”的交换操作消耗了许多时间。比如序列中的元素有可能出现这样的情况，即经过前面几趟的排序后整个序列就已经排好序了，那么后面的那几趟排序就不需要再执行了。但是我们上面的第一版的冒泡排序即便是在这种情况下，仍然会执行所有的$n-1$趟的排序。即使后面几趟排序只进行比较而不需交换元素，但是当数据量很大的时候，这依旧会造成整体性能的明显下降。</p><p>因此，我们首先想到的优化方案就是当某一趟排序之后，如果整个序列已排好序了，那么就立即退出函数。这要怎么实现呢？其实很简单，只要在某一趟的排序中没有进行任何一次的元素交换，那么此时整个序列就排好序了。</p><p>因此，在每一趟排序的开始将一个标记<code>swapped</code>设置为<code>False</code>。在这一趟排序过程中，如果发生了数据交换，那么就将<code>swapped</code>设置为<code>True</code>。当这一趟排序结束，我们通过检查该<code>swapped</code>的值就可以知道整个序列是否已经排好序了。</p><p>假设我们有一个序列，它的元素分别为整数9、4、6、15、13。那么图7至图8则展示了经本次优化后的冒泡排序的完整执行过程。注意，虽然第一趟排序后整个序列就排好序了，但在第一趟排序中进行了元素交换（<code>swapped</code>被设置为<code>True</code>），算法此时并不知道整个序列已经排好了，所以还要进行第二趟排序。在第二趟排序中，不会进行任何元素交换（<code>swapped</code>最终为<code>False</code>），此时算法才知道整个序列已经是排好序了的。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.2rojc9iqteg0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.2rojc9iqteg0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%>  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图7  [9,4,6,15,13] 第1趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.33chi518g6e0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.33chi518g6e0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图8  [9,4,6,15,13] 第2趟排序</div> </center><p>综上，如果一个列表只需要几次遍历就可排好，冒泡排序就占有优势：它可以在发现列表已排好时立刻结束。代码二就是改良版冒泡排序。它通常被称作“短路冒泡排序”。<br><strong>代码二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;第一次优化&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False，False表示为交换，True表示交换</span></span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面n-(i-1)个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>在最好的情况下，第二版冒泡排序只需进行$n-1$次比较和0次元素移动；在最坏的情况下，还是进行$n(n-1)&#x2F;2$次比较和$3n(n-1)&#x2F;2$次元素移动。虽然这一版的冒泡排序的时间复杂度依旧是$O(n^2)$，但是和第一版相比肯定性能上更好。</p><h3 id="2-2-第二次优化"><a href="#2-2-第二次优化" class="headerlink" title="2.2 第二次优化"></a>2.2 第二次优化</h3><p>在我们之前的想法中，当进行第$i$趟排序时，序列中只有最大的$i-1$个元素已经排好序了。因为那时我们认为每一趟仅排好一个元素，即它比较的所有元素中最大的那一个。因此第$i$趟排序的时候，需要对前面$n-(i-1)$个元素进行比较和交换。但其实此时这前$n-(i-1)$个元素中可能最大的那几个元素已经在它们最终的位置上了，这时第$i$趟实际需要比较的元素个数就可以小于$n-(i-1)$。</p><p>比如有一个序列24、30、12、40、50，那么第1趟排序之后的结果为24、12、30、40、50。在原来的想法中，第2趟需要比较前面4个数。但此时前4个数中最大的两个30和40已经在它们最终的位置上了，不需要再对它们进行位置上的调整。因此，第2趟可以只比较前两个数。</p><p>注意这个例子中，虽然在序列的初始状态中40和50就已经在它们最终的位置上了，但第1趟排序还是需要比较全部的5个数。因为此时没有任何信息可以将序列的这种特殊状态告知算法，某一趟是否可以执行比它原本理论上更少的比较次数，需要前一趟排序对序列状态的了解。</p><p>在每一趟排序中，我们都用一个变量<code>last_index</code>记录下本趟排序最后一次元素交换中前一个元素的下标。在该下标之后没有发生交换，说明该下标之后的所有元素都已经排好序了。那么下一趟排序就只需要对该下标及其之前的元素进行比较而已。这样下一趟排序需要比较的次数可能比原本需要的次数更少，也就在一定程度上提升了算法的效率。<br><strong>代码三：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    last_index = length - <span class="number">1</span><span class="comment"># 记录每一趟中最后一次交换中前一个元素的下标，他的初值为n-1</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False，False表示为交换，True表示交换</span></span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面last_index+1个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(last_index):</span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">                last_index = j  <span class="comment"># 记录本次交换中前一个元素的下标</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>图9至图11详细展示了经过第二次优化后的冒泡排序对[24, 30, 12, 40, 50]这个序列的执行情况。该例子中另一个值得注意的问题是，虽然在第2趟排序后整个序列就已经排好序了，但是第2趟中进行了一次元素交换而导致<code>swapped</code>等于<code>True</code>。因此第2趟后并不会立即退出函数，还要进行第3趟排序。在第3趟中内层循环不会执行而立即退出，因为此时<code>last_index</code>等于0，<code>j</code>（此时也等于0）小于<code>last_index</code>的条件不满足。在第3趟最后<code>swapped</code>为<code>False</code>，此时才退出算法。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.47232a8lqkq0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.47232a8lqkq0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图9  [24, 30, 12, 40, 50] 第1趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3yaeqpkaep40.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3yaeqpkaep40.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图10  [24, 30, 12, 40, 50] 第2趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.jbnxksu0sxk.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.jbnxksu0sxk.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图11  [24, 30, 12, 40, 50] 第3趟排序</div> </center><h3 id="2-3-鸡尾酒排序"><a href="#2-3-鸡尾酒排序" class="headerlink" title="2.3 鸡尾酒排序"></a>2.3 鸡尾酒排序</h3><p><a href="https://baike.baidu.com/item/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/7515196#:~:text=%E9%B8%A1%E5%B0%BE%E9%85%92%20%E6%8E%92%E5%BA%8F%E5%8F%88%E7%A7%B0%E5%8F%8C%E5%90%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%B8%A1%E5%B0%BE%E9%85%92%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F%E3%80%81%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F%E3%80%81%E6%B6%9F%E6%BC%AA%E6%8E%92%E5%BA%8F%E3%80%81%E6%9D%A5%E5%9B%9E%E6%8E%92%E5%BA%8F%E6%88%96%E5%BF%AB%E4%B9%90%E5%B0%8F%E6%97%B6%E6%8E%92%E5%BA%8F,,%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%98%E5%BD%A2%E3%80%82%20%E8%AF%A5%E7%AE%97%E6%B3%95%E4%B8%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E5%9C%A8%E4%BA%8E%E6%8E%92%E5%BA%8F%E6%97%B6%E6%98%AF%E4%BB%A5%E5%8F%8C%E5%90%91%E5%9C%A8%E5%BA%8F%E5%88%97%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E3%80%82%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%9C%AC%E6%98%AF%E6%97%A0%E8%A7%84%E5%BE%8B%E7%9A%84%E6%8E%92%E6%94%BE%EF%BC%8C%E5%85%88%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E6%8A%8A%E4%BB%96%E6%94%BE%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E3%80%82">鸡尾酒排序</a>又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。因此，根据名字可以看到搅拌排序的原理，每次都是从左往右，交换相邻的元素，从而达到循环一边可以把最大的元素放在右边。而双向冒泡排序，在完成一次从左往右的冒泡排序后，再从右往左进行冒泡，从而把小的元素放在左边。<br>下面这张图可以很好地表达：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.5othrnnkxjg0.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.5othrnnkxjg0.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图12 双向排序动图演示</div> </center><p><strong>代码四：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cocktail_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;搅拌排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(length/<span class="number">2</span>)):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False</span></span><br><span class="line">        <span class="comment"># 正向：把当前循环最大的放到最右边</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">        <span class="keyword">if</span> swapped:</span><br><span class="line">            swapped = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 反向：把当前循环最小的放到最右边</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(length-i-<span class="number">1</span>, i-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> items[k-<span class="number">1</span>] &gt; items[k]:</span><br><span class="line">                    items[k], items[k-<span class="number">1</span>] = items[k-<span class="number">1</span>], items[k]</span><br><span class="line">                    swapped = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><hr><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h3><ul><li>图文详解冒泡排序：<a href="https://baijiahao.baidu.com/s?id=1662238914941980592&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1662238914941980592&wfr=spider&for=pc</a></li><li>Python 冒泡排序：<a href="https://www.runoob.com/python3/python-bubble-sort.html">https://www.runoob.com/python3/python-bubble-sort.html</a></li><li>冒泡排序算法：<a href="http://c.biancheng.net/view/6506.html">http://c.biancheng.net/view/6506.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="冒泡排序" scheme="https://qxienote.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    <category term="搅拌排序" scheme="https://qxienote.com/tags/%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十三）-- 位运算与使用技巧</title>
    <link href="https://qxienote.com/article/e701713c.html"/>
    <id>https://qxienote.com/article/e701713c.html</id>
    <published>2023-06-11T10:00:29.000Z</published>
    <updated>2023-06-13T15:01:04.617Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习Python中的二进制运算，通过位运算实现乘除法、交换两数、判断奇偶数、交换符号、求绝对值、二进制逆序、统计二进制中1的个数，最后结合LeetCode常见题目进行练习。</p><span id="more"></span><p>计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。</p><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1 操作符"></a>1 操作符</h2><h3 id="1-1-基本运算"><a href="#1-1-基本运算" class="headerlink" title="1.1 基本运算"></a>1.1 基本运算</h3><ul><li>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">&amp;  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">------------------------------   </span><br><span class="line">   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><ul><li>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">|   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">------------------------------   </span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><ul><li>^ 异或运算，两个位相同则为 0，不同则为 1，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">^   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">-----------------------------   </span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><ul><li>~ 取反运算，0 则变为 1，1 则变为 0，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">-----------------------------   </span><br><span class="line">   <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ​</span><br></pre></td></tr></table></figure><h3 id="1-2-左移操作-lt-lt-与-右移操作-gt-gt"><a href="#1-2-左移操作-lt-lt-与-右移操作-gt-gt" class="headerlink" title="1.2 左移操作&lt;&lt; 与 右移操作&gt;&gt;"></a>1.2 左移操作&lt;&lt; 与 右移操作&gt;&gt;</h3><p><strong>左移操作</strong><br>左移操作，左移一位相当于乘以 b，<code>a&lt;&lt;b, a&#39; = a*(2^b)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&lt;&lt;<span class="number">3</span>)     <span class="comment"># 2*2^3 = 16，2的二进制10，向左移动3位后10000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&lt;&lt;<span class="number">1</span>)     <span class="comment"># 2*2^1 = 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&lt;&lt;<span class="number">4</span>)     <span class="comment"># 3*2^4 = 48,3的二进制为11，向左移动四位后110000</span></span><br></pre></td></tr></table></figure><p><strong>右移操作</strong><br>右移操作，右移一位相当于除以 b，<code>a&gt;&gt;b, a&#39; = a//(2^b)</code>注意这里是整除，当向右移动位数大于能移动的位数时，置为0【可以理解为会将尾巴截掉】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&gt;&gt;<span class="number">3</span>)     <span class="comment"># 2//2^3 = 0，2的二进制10，向右最多移动2位后，所以多移动无疑为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&gt;&gt;<span class="number">1</span>)     <span class="comment"># 2//2^1 = 1，向右移动一位为 01,</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&gt;&gt;<span class="number">4</span>)     <span class="comment"># 3//2^4 = 0, 3 的二进制为11，向右移动四位后00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&gt;&gt;<span class="number">1</span>)     <span class="comment"># 3//2^1 = 1, 3 的二进制为11，向右移动一位后为01</span></span><br></pre></td></tr></table></figure><blockquote><p>$&gt;&gt;$ 和 $&lt;&lt;$ 都是位运算，对二进制数进行移位操作。$&lt;&lt;$ 是左移，末位补 0，类比十进制数在末尾添 0 相当于原数乘以 10，$x&lt;&lt;1$ 是将 $x$ 的二进制表示左移一位，相当于原数 $x$ 乘 2。比如整数 4 在二进制下是100，$4&lt;&lt;1$ 左移1位变成1000(二进制)，结果是 8。$&gt;&gt;$ 是右移，右移1位相当于除以2。<br><br></br><br>而 $&gt;&gt;&#x3D;$ 和 $&lt;&lt;&#x3D;$，就是对变量进行位运算移位之后的结果再赋值给原来的变量，可以类比赋值运算符 $+&#x3D;$ 和 $-&#x3D;$ 可以理解。比如 $x&gt;&gt;&#x3D;2$， 就是把变量 $x$ 右移2位，再保留x操作后的值。</p></blockquote><h2 id="2-常见位运算问题"><a href="#2-常见位运算问题" class="headerlink" title="2 常见位运算问题"></a>2 常见位运算问题</h2><h3 id="2-1-位操作实现乘除法"><a href="#2-1-位操作实现乘除法" class="headerlink" title="2.1 位操作实现乘除法"></a>2.1 位操作实现乘除法</h3><p>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">a &gt;&gt; <span class="number">1</span>  <span class="comment"># 1</span></span><br><span class="line">a &lt;&lt; <span class="number">1</span>  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h3 id="2-2-位操作交换两数"><a href="#2-2-位操作交换两数" class="headerlink" title="2.2 位操作交换两数"></a>2.2 位操作交换两数</h3><p>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a         <span class="comment"># 普通操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位操作</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li>第一步：a ^&#x3D; b —&gt; a &#x3D; (a^b)</li><li>第二步：b ^&#x3D; a —&gt; b &#x3D; b^(a^b) —&gt; b &#x3D; (b^b)^a &#x3D; a</li><li>第三步：a ^&#x3D; b —&gt; a &#x3D; (a^b)^a &#x3D; (a^a)^b &#x3D; b</li></ul><h3 id="2-3-位操作判断奇偶数"><a href="#2-3-位操作判断奇偶数" class="headerlink" title="2.3 位操作判断奇偶数"></a>2.3 位操作判断奇偶数</h3><p>要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;偶数&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-位操作交换符号"><a href="#2-4-位操作交换符号" class="headerlink" title="2.4 位操作交换符号"></a>2.4 位操作交换符号</h3><p>交换符号将正数变成负数，负数变成正数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversal</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> ~a + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><h3 id="2-5-位操作求绝对值"><a href="#2-5-位操作求绝对值" class="headerlink" title="2.5 位操作求绝对值"></a>2.5 位操作求绝对值</h3><p>正数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1，即 <code>0xffffffff</code>），然后根据符号进行相应的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">a</span>):</span><br><span class="line">    i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> (~a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面的操作可以进行优化，可以将 i &#x3D;&#x3D; 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i &#x3D; 0 为正，i &#x3D; -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 <code>0xffffffff</code> 进行异或就相当于对此数进行取反，因此可以将上面三目元算符转换为 <code>((a^i)-i)</code>，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 <code>0xffffffff</code> 异或将 a 进行取反，然后在加上 1，即减去 i(i &#x3D;-1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs2</span>(<span class="params">a</span>):</span><br><span class="line">     i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">     <span class="keyword">return</span> ((a^i)-i)</span><br></pre></td></tr></table></figure><h3 id="2-6-位操作进行高低位交换"><a href="#2-6-位操作进行高低位交换" class="headerlink" title="2.6 位操作进行高低位交换"></a>2.6 位操作进行高低位交换</h3><p>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">将其高<span class="number">8</span>位与低<span class="number">8</span>位进行交换，得到一个新的二进制数：</span><br><span class="line"><span class="number">11011000</span> <span class="number">10000110</span></span><br><span class="line">其十进制为<span class="number">55430</span></span><br></pre></td></tr></table></figure><p>从上面移位操作我们可以知道，只要将无符号数 <code>a &gt;&gt; 8</code> 即可得到其高 8 位移到低 8 位，高位补 0；将 <code>a &lt;&lt; 8</code> 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 <code>a &gt;&gt; 8</code> 和 <code>a &lt;&lt; 8</code> 进行或操作既可求得交换后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34520</span></span><br><span class="line">a = (a &gt;&gt; <span class="number">8</span>) | (a &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-位操作进行二进制逆序"><a href="#2-7-位操作进行二进制逆序" class="headerlink" title="2.7 位操作进行二进制逆序"></a>2.7 位操作进行二进制逆序</h3><p>将无符号数的二进制表示进行逆序，求取逆序后的结果，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数<span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">逆序后则为：</span><br><span class="line">00011011 01100001</span><br><span class="line">它的十进制为<span class="number">7009</span></span><br></pre></td></tr></table></figure><p>在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。</p><ul><li>第一步：以每 2 位为一组，组内进行高低位交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">10</span> <span class="number">00</span> 01 <span class="number">10</span> <span class="number">11</span> 01 <span class="number">10</span> <span class="number">00</span></span><br><span class="line">交换后： 01 <span class="number">00</span> <span class="number">10</span> 01 <span class="number">11</span> <span class="number">10</span> 01 <span class="number">00</span></span><br></pre></td></tr></table></figure></li><li>第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">0</span>100 <span class="number">1001</span> <span class="number">1110</span> <span class="number">0</span>100</span><br><span class="line">交换后： 0001 0110 <span class="number">1011</span> 0001</span><br></pre></td></tr></table></figure></li><li>第三步：以每 8 位为一组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">000</span>10110 <span class="number">10110001</span></span><br><span class="line">交换后： 01100001 00011011</span><br></pre></td></tr></table></figure></li><li>第四步：以每16位为一组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： 0110000100011011</span><br><span class="line">交换后： 0001101101100001</span><br></pre></td></tr></table></figure></li></ul><p>对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原数：  <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位： <span class="number">10000010</span> <span class="number">10001000</span></span><br><span class="line">偶数位： <span class="number">00000</span>100 <span class="number">0</span>1010000</span><br></pre></td></tr></table></figure><p>再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原数：  <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位右移一位： <span class="number">0</span> <span class="number">10000010</span> <span class="number">1000100</span></span><br><span class="line">偶数位左移一位：<span class="number">0000</span>100 <span class="number">0</span>1010000 <span class="number">0</span></span><br><span class="line">两数相或得到： <span class="number">0</span>1001001 <span class="number">11100100</span></span><br></pre></td></tr></table></figure><p>上面的方法用位操作可以表示为：</p><ul><li>取 a 的奇数位并用 0 进行填充可以表示为：<code>a &amp; 0xAAAA</code></li><li>取 a 的偶数为并用 0 进行填充可以表示为：<code>a &amp; 0x5555</code> 因此，上面的第一步可以表示为：<br><code>a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1)</code></li></ul><p>同理，可以得到其第二、三和四步为：</p><ul><li>a &#x3D; ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2)</li><li>a &#x3D; ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4)</li><li>a &#x3D; ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8)</li></ul><p>因此整个操作为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34520</span>;</span><br><span class="line">a = ((a &amp; <span class="number">0xAAAA</span>) &gt;&gt; <span class="number">1</span>) | ((a &amp; <span class="number">0x5555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xCCCC</span>) &gt;&gt; <span class="number">2</span>) | ((a &amp; <span class="number">0x3333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xF0F0</span>) &gt;&gt; <span class="number">4</span>) | ((a &amp; <span class="number">0x0F0F</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) | ((a &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="2-8-位操作统计二进制中-1-的个数"><a href="#2-8-位操作统计二进制中-1-的个数" class="headerlink" title="2.8 位操作统计二进制中 1 的个数"></a>2.8 位操作统计二进制中 1 的个数</h3><p>统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &amp;&#x3D; (a-1)的结果：</p><ul><li>第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000</li><li>第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000</li><li>第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000</li></ul><p>我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(a):</span><br><span class="line">    a = a &amp; (a-<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.3l5z91u11180.webp#pic_center" width = 36%><h3 id="2-9-原码、反码、补码"><a href="#2-9-原码、反码、补码" class="headerlink" title="2.9 原码、反码、补码"></a>2.9 原码、反码、补码</h3><p>机器数：一个数在计算机中的二进制表示形式，机器数带符号，在计算机用一个数的最高位存放符号，正数为0，负数为1</p><blockquote><p>例如： 十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011。其中，00000011 和 10000011就是机器数</p></blockquote><p>真值：将带符号位的机器数对应的真正数值称为机器数的真值。</p><p><strong>1. 原码</strong></p><p>原码就是符号位加上真值的绝对值，即用第一位表示符号, 其余位表示值。例如：如果是8位二进制，那么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>]原 = <span class="number">0000</span> 0001</span><br><span class="line">[-<span class="number">1</span>]原 = <span class="number">1000</span> 0001</span><br></pre></td></tr></table></figure><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1111</span> <span class="number">1111</span>, 0111 <span class="number">1111</span>]</span><br><span class="line">[-<span class="number">127</span>, <span class="number">127</span>]</span><br></pre></td></tr></table></figure><p><font color=#9900CC><strong>原码在展示上是与机器数相同的</font></strong></p><p><strong>2. 反码</strong></p><p>反码的表示方法是:</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [00000001]原 = [00000001]反</span><br><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反</span><br></pre></td></tr></table></figure><p><strong>3. 补码</strong></p><p>补码的表示方法是:</p><ul><li>正数的补码就是其本身</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。(即在反码的基础上+1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。不管 n 是正数还是负数，只需要下面的语句便可得到此数的补码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(n &amp; <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><p>了解更多，请移步：<a href="https://zhuanlan.zhihu.com/p/106535460">原码反码补码的通俗解释</a></p><h3 id="2-10-进制之间的转换"><a href="#2-10-进制之间的转换" class="headerlink" title="2.10 进制之间的转换"></a>2.10 进制之间的转换</h3><p>二进制、八进制、十进制、十六进制转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(-<span class="number">10</span>))         <span class="comment"># &#x27;-0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0o12&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0xa&#x27;</span></span><br><span class="line">a = <span class="number">0b1010</span></span><br><span class="line">b = <span class="number">0x11</span></span><br><span class="line">x = <span class="string">&#x27;1010&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;11&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)                <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(x, <span class="number">2</span>))        <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(b)                <span class="comment"># 17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(y, <span class="number">16</span>))       <span class="comment"># 17</span></span><br></pre></td></tr></table></figure><h3 id="2-11-加一减一"><a href="#2-11-加一减一" class="headerlink" title="2.11 加一减一"></a>2.11 加一减一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">n = -~n             <span class="comment"># +1</span></span><br><span class="line"><span class="built_in">print</span>(n)            <span class="comment"># 11</span></span><br><span class="line">n = ~-n             <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(n)            <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断两个数是否异号</span></span><br><span class="line">x, y = -<span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>((x^y)&lt;<span class="number">0</span>)          <span class="comment"># True</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>((x^y)&lt;<span class="number">0</span>)          <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3 常见题型"></a>3 常见题型</h2><h3 id="3-1-题库列表"><a href="#3-1-题库列表" class="headerlink" title="3.1 题库列表"></a>3.1 题库列表</h3><div style="text-align: center;"><table border="1" style="margin: auto；" width='60%'><tr><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/reverse-bits/" target="_blank">190. 颠倒二进制位</a></p></td><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/number-of-1-bits/" target="_blank">191. 位1的个数</a></p></td><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/hamming-distance/" target="_blank">461. 汉明距离</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/missing-number/" target="_blank">268. 丢失的数字</a></p></td><td><p><a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字</a></p></td><td><p><a href="https://leetcode.cn/problems/single-number-ii/" target="_blank">137. 只出现一次的数字 II</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/single-number-iii/" target="_blank">260. 只出现一次的数字 III</a></p></td><td><p><a href="https://leetcode.cn/problems/power-of-two/" target="_blank">231. 2 的幂</a></p></td><td><p><a href="https://leetcode.cn/problems/counting-bits/" target="_blank">338. 比特位计数</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/sum-of-two-integers/" target="_blank">371. 两整数之和</a></p></td><td><p><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/" target="_blank">405. 数字转换为十六进制数</a></p></td><td><p><a href="https://leetcode.cn/problems/number-complement/" target="_blank">476. 数字的补数</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/total-hamming-distance/" target="_blank">477. 汉明距离总和</a></p></td><td><p><a href="https://leetcode.cn/problems/beautiful-arrangement/" target="_blank">526. 优美的排列</a></p></td><td><p><a href="https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/" target="_blank">1178. 猜字谜</a></p></td></tr></table></div><h3 id="3-2-真题演练"><a href="#3-2-真题演练" class="headerlink" title="3.2 真题演练"></a>3.2 真题演练</h3><p><strong>190. 颠倒二进制位</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        res = 0</span></span><br><span class="line"><span class="string">        for _ in range(32):</span></span><br><span class="line"><span class="string">            res = (res &lt;&lt; 1) | (n &amp; 1)</span></span><br><span class="line"><span class="string">            n &gt;&gt;= 1</span></span><br><span class="line"><span class="string">        return res</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p><strong>191. 位1的个数</strong><br>题目描述：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p><strong>1. 消除二进制末尾的 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>2. 右移 32 次</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            count += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>3. 库函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>461. 汉明距离</strong></p><p>题目描述：两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p><strong>1. 异或速解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x^y).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>2. 统计1的个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        z = x ^ y           <span class="comment"># 异或运算，二进制位不同的位置为1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> z:            <span class="comment"># 统计运算之后结果中 1 的个数</span></span><br><span class="line">            z = z &amp; (z-<span class="number">1</span>)   </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>3. 字符串解题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        bx, by = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].zfill(<span class="number">32</span>), <span class="built_in">bin</span>(y)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> bx[i] != by[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>268. 丢失的数字</strong></p><p>题目描述：给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p>思路分析：以示例 1 为例 nums &#x3D; [3,0,1]，其长度为3，不难看出其不缺失的原数组为 [0, 1, 2, 3]。如果将nums与其原数组异或会发生什么呢？异或满足交互律 即 (a^b)^c &#x3D; a^(b^c)。我们不妨将其调整一下位置，即<br>nums    原数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   ^    <span class="number">0</span>     =&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   ^    <span class="number">1</span>     =&gt; <span class="number">0</span></span><br><span class="line">无 <span class="number">2</span> =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   ^    <span class="number">3</span>     =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所有一样的数全部异或之后成了0，最后所剩下的2与0异或即为本身，也就是所缺失的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  <span class="comment"># 此处 num 代表nums， i 代表原数组</span></span><br><span class="line">            ans ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> ans ^ <span class="built_in">len</span>(nums)          <span class="comment"># 因为原数组比nums长度多1, 所有这里多异或了一次</span></span><br></pre></td></tr></table></figure><p><strong>136. 只出现一次的数字</strong></p><p>题目描述：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p><ul><li>任何数和 0 做异或运算，结果仍然是原来的数，即 $a⊕0&#x3D;a$。</li><li>任何数和其自身做异或运算，结果是 0，即 $a⊕a&#x3D;0$。</li><li>异或运算满足交换律和结合律，即 $a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b$。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.6tbqu4dvz7w0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;异或运算&#x27;&#x27;&#x27;</span></span><br><span class="line">        re = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            re ^= num</span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure><p><strong>137. 只出现一次的数字 II</strong></p><p>题目描述：给你一个整数数组 nums，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/022.3jilsm2r0jg0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:’</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 数学运算</span></span><br><span class="line"><span class="string">        return (sum(set(nums))*3-sum(nums)) // 2</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):             <span class="comment"># nums[i] 是32位整数，</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span>                     <span class="comment"># 针对每一位的对应二进制数值求和</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="built_in">sum</span> += (num &gt;&gt; i) &amp; <span class="number">1</span>   <span class="comment"># 提取从右往左数第i位的数值，将所有nums[i], 二进制下的第i位数值进行求和</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">3</span> == <span class="number">1</span>:            <span class="comment"># 如果没办法被3整除，那么说明落单的那个数的第i位是 1 不是 0</span></span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i           <span class="comment"># 恢复第 i 位的值到 ans</span></span><br><span class="line">        <span class="keyword">return</span> ~(ans^<span class="number">0xffffffff</span>) <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">else</span> ans   <span class="comment"># 这里最后的sum是符号位，可以判断最后输出的数字是否是负数</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 由于 Python 的存储负数的特殊性，需要先将 0-32 位取反（即 <code>res^0xffffffff </code>），再将所有位取反（即 ~ ）。两个组合操作实质上是将数字 32 以上位取反，0-32位不变。</p><p><strong>260. 只出现一次的数字 III</strong></p><p>题目描述：给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        mask = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 异或运算，目的是找到两个落单数值的不同，便于后面分类</span></span><br><span class="line">            mask ^= num</span><br><span class="line">        mask  &amp;= (-mask)            <span class="comment"># 直接获取 mask 二进制表示的最低位的 1</span></span><br><span class="line">        type1, type2 = <span class="number">0</span>, <span class="number">0</span>         </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 把数组分为两部分，每部分再分别异或</span></span><br><span class="line">            <span class="keyword">if</span> mask &amp; num:          <span class="comment"># 对于 num，如果 mask 为1，分类为 type1，对这个 type1 进行异或，可以找到落单的数值</span></span><br><span class="line">                type1 ^= num</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 如果 num 的 mask 对应的是0，那么异或找到另一个落单的数值</span></span><br><span class="line">                type2 ^= num</span><br><span class="line">        <span class="keyword">return</span> [type1, type2] </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/023.27s42my22s9w.webp#pic_center" width = 36%><p><strong>231. 2 的幂</strong><br>题目描述：给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true；否则，返回 false。如果存在一个整数 x 使得 $n &#x3D;&#x3D; 2^x$ ，则认为 n 是 2 的幂次方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return n&gt;0 and n&amp;(-n)==n   </span></span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> n&amp;(n-<span class="number">1</span>)==<span class="number">0</span>   </span><br></pre></td></tr></table></figure><p><strong>338. 比特位计数</strong></p><p>题目描述：给你一个整数 $n$ ，对于 $0 &lt;&#x3D; i &lt;&#x3D; n$ 中的每个 $i$ ，计算其二进制表示中 1 的个数 ，返回一个长度为 $n + 1$ 的数组 ans 作为答案。</p><p>思路分析：对于正整数 $x$，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 $⌊\frac{x}{2}⌋$。如果 $bits[⌊\frac{x}{2}⌋]$ 的值已知，则可以得到 $bits[x]$ 的值：</p><ul><li>如果 $x$ 是偶数，则 $bits[x]&#x3D;bits[⌊\frac{x}{2}⌋]$；</li><li>如果 $x$ 是奇数，则 $bits[x]&#x3D;bits[⌊\frac{x}{2}⌋]+1$。</li></ul><p>上述两种情况可以合并成: $bits[x]$ 的值等于 $bits[⌊\frac{x}{2}⌋]$ 的值加上 $x$ 除以 2 的余数。由于$⌊\frac{x}{2}⌋$ 可以通过 $x &gt;&gt;1$ 得到，$x$ 除以 2 的余数可以通过 $x &amp; 1$ 得到，因此有: $bits[x] &#x3D; bits[x &gt;&gt; 1]+(x &amp; 1)$。</p><p>另一种思路：令 $y &#x3D; x &amp;(x —1)$，则 $y$ 为将 $x$ 的最低设置位从 1 变成 0 之后的数，显然 $0≤y&lt;x$, $bits[x]&#x3D; bits[y]＋+1$。因此对任意正整数 $x$，都有 $bits[x]&#x3D; bits[x &amp; (x-1)]+1$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 遍历与统计</span></span><br><span class="line"><span class="string">        return [bin(i).count(&#x27;1&#x27;) for i in range(n+1)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        ans = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            ans[i] = ans[i&gt;&gt;<span class="number">1</span>] + (i&amp;<span class="number">1</span>)      <span class="comment"># ans[i] = ans[i&amp;(i-1)]+1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>342. 4的幂</strong></p><p>题目描述：给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false。整数 n 是 4 的幂次方需满足：存在整数 x 使得 $n &#x3D;&#x3D; 4^x$</p><p>思路分析：如果 n 是 4 的幂，那么 n 一定也是 2 的幂。因此我们可以首先判断 n 是否是 2 的幂，在此基础上再判断 n 是否是 4 的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1，并且这个 1 出现在从低位开始的第偶数个二进制位上（这是因为这个 1 后面必须有偶数个0）。因此我们可以构造一个整数 mask，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。这样一来，我们将 n 和 mask 进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。</p><p>思路二：如果 n 是 4 的幂，可以发现它除以 3 的余数一定为 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return n &gt; 0 and n&amp;(n-1) == 0 and (n%3) == 1</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n&amp;(n-<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> (n&amp;<span class="number">0xaaaaaaaa</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>371. 两整数之和</strong></p><p>题目描述：给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSum</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mask1 = <span class="number">0xffffffff</span></span><br><span class="line">        a &amp;= mask1</span><br><span class="line">        b &amp;= mask1</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>        <span class="comment"># 将存在进位的位置置1</span></span><br><span class="line">            a ^= b                      <span class="comment"># 计算无进位的结果</span></span><br><span class="line">            b = carry</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt; <span class="number">0x80000000</span> <span class="keyword">else</span> ~(a^mask1)  <span class="comment"># 考虑负数时的输出</span></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/024.6nw71yc5zds0.webp#pic_center" width = 48%><p><strong>405. 数字转换为十六进制数</strong></p><p>题目描述：给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p><strong>1. 精简版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># return hex(num&amp;0xffffffff)[2:]       </span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;模拟法&#x27;&#x27;&#x27;</span></span><br><span class="line">        CONV = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            num = <span class="number">2</span> ** <span class="number">32</span> + num             </span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            num, res = <span class="built_in">divmod</span>(num, <span class="number">16</span>)</span><br><span class="line">            ans += CONV[res]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 详细版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        CONV = <span class="string">&quot;0123456789abcdef&quot;</span></span><br><span class="line">        ans = []    </span><br><span class="line">        <span class="comment"># 32位2进制数，转换成16进制 -&gt; 4个一组，一共八组</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="comment"># 当输入值num为-1 ，第一次进入循环</span></span><br><span class="line">            ans.append(num % <span class="number">16</span>)    <span class="comment"># num % 16 = 15</span></span><br><span class="line">            num //= <span class="number">16</span>              <span class="comment"># num // 16 = -1</span></span><br><span class="line">            <span class="comment"># Python中的//运算取整除：向下取接近商的整数</span></span><br><span class="line">            <span class="comment"># % 取模运算返回整除的余数 （余数 = 被除数 - 除数 * 商）</span></span><br><span class="line">            <span class="comment"># 负整数 // 正整数 的最大值为-1</span></span><br><span class="line">            <span class="comment"># -1 // 16 = -1</span></span><br><span class="line">            <span class="comment"># -1 % 16 = 15</span></span><br><span class="line">            <span class="comment"># 即如num为负数，则一定会跑满for的8次循环</span></span><br><span class="line">            <span class="comment"># 正整数 // 正整数 的最小值为0</span></span><br><span class="line">            <span class="comment"># 1 // 16 = 0</span></span><br><span class="line">            <span class="comment"># 1 % 16 = 1</span></span><br><span class="line">            <span class="comment"># 即num为正数时，有可能触发下面的if语句，提前结束for循环</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num:     <span class="comment"># 如果num不为0则继续下一次for循环</span></span><br><span class="line">                <span class="keyword">break</span>       <span class="comment"># 如果num为0则终止for循环</span></span><br><span class="line">            <span class="comment"># 正整数 // 负整数 的最大值为-1，如1 // -16 = -1; 1 % -16 = -15</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(CONV[n] <span class="keyword">for</span> n <span class="keyword">in</span> ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>476. 数字补数</strong></p><p>题目描述：对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。例如，整数 5 的二进制表示是 “101”，取反后得到 “010”，再转回十进制表示得到补数 2。给你一个整数 num ，输出它的补数。</p><p><strong>1. 与运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num &amp; <span class="number">1</span>):           <span class="comment"># 该位为0</span></span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>2. 异或运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_copy = num</span><br><span class="line">        num_1 = <span class="number">1</span>              </span><br><span class="line">        <span class="keyword">while</span> num_copy:</span><br><span class="line">            num_1 &lt;&lt;= <span class="number">1</span> </span><br><span class="line">            num_copy &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num ^ (num_1-<span class="number">1</span>)          <span class="comment"># num_1 二进制位数比num多一位，减1后与num二进制位数相同，且各位均为1</span></span><br></pre></td></tr></table></figure><p><strong>3. 遍历字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> bt <span class="keyword">in</span> <span class="built_in">bin</span>(num)[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> bt == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                result.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(result), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>477. 汉明距离的总和</strong><br>题目描述：两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。</p><p>对于某个 nums[i] 我们只关心在 nums 中有多少数的第 $x$ 位的与其不同，而不关心具体是哪些数与其不同，同时二进制表示中非 0 即 1。</p><p>这样我们可以建立两个集合 $s_0$ 和 $s_1$，分别统计出 nums 中所有数的第 $x$ 位中 0 的个数和 1 的个数，集合中的每次计数代表了 nums 中的某一元素，根据所在集合的不同代表了其第 $x$ 位的值。那么要找到在 nums 中有多少数与某一个数的第 $x$ 位不同，只需要读取另外一个集合的元素个数即可，变成了 $O(1)$ 操作。那么要求得「第 $x$ 位所有不同数」的对数的个数，只需要应用乘法原理，将两者元素个数相乘即可。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/025.2f84rabei5c0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalHammingDistance</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            temp = <span class="built_in">sum</span>((num &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line">            ans += temp * (<span class="built_in">len</span>(nums) - temp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>526. 优美的排列</strong></p><p>题目描述：假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：</p><ul><li>perm[i] 能够被 i 整除</li><li>i 能够被 perm[i] 整除</li></ul><p>给你一个整数 n ，返回可以构造的 优美排列 的 数量 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countArrangement</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        canFill = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j % i == <span class="number">0</span> <span class="keyword">or</span> i % j == <span class="number">0</span>:        <span class="comment"># 每个位置可以填入哪些数</span></span><br><span class="line">                    canFill[i].append(j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        order = <span class="built_in">sorted</span>(canFill.keys(), key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(canFill[x]))    <span class="comment"># 根据可填入数字的个数排序，优先填入个数少的</span></span><br><span class="line">        end = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">state</span>):</span><br><span class="line">            <span class="keyword">if</span> state == end:                    <span class="comment"># 全部填入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            cnts = ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):                  <span class="comment"># 当前该填第几个位置</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i) &amp; state:</span><br><span class="line">                    cnts += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> canFill[order[cnts]]:      <span class="comment"># 当前位置可以填哪些数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((<span class="number">1</span> &lt;&lt; i) &amp; state):      <span class="comment"># 哪些数还没被填</span></span><br><span class="line">                    ans += dfs(state ^ (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>1178. 猜字谜</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/026.7959elkbflg0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumOfValidWords</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], puzzles: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        frequency = collections.Counter()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(mask)).count(<span class="string">&quot;1&quot;</span>) &lt;= <span class="number">7</span>:</span><br><span class="line">                frequency[mask] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> puzzle <span class="keyword">in</span> puzzles:</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举子集方法一</span></span><br><span class="line">            <span class="comment"># for choose in range(1 &lt;&lt; 6):</span></span><br><span class="line">            <span class="comment">#     mask = 0</span></span><br><span class="line">            <span class="comment">#     for i in range(6):</span></span><br><span class="line">            <span class="comment">#         if choose &amp; (1 &lt;&lt; i):</span></span><br><span class="line">            <span class="comment">#             mask |= (1 &lt;&lt; (ord(puzzle[i + 1]) - ord(&quot;a&quot;)))</span></span><br><span class="line">            <span class="comment">#     mask |= (1 &lt;&lt; (ord(puzzle[0]) - ord(&quot;a&quot;)))</span></span><br><span class="line">            <span class="comment">#     if mask in frequency:</span></span><br><span class="line">            <span class="comment">#         total += frequency[mask]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举子集方法二</span></span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">            </span><br><span class="line">            subset = mask</span><br><span class="line">            <span class="keyword">while</span> subset:</span><br><span class="line">                s = subset | (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> frequency:</span><br><span class="line">                    total += frequency[s]</span><br><span class="line">                subset = (subset - <span class="number">1</span>) &amp; mask</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在枚举子集的过程中，要么会漏掉全集 mask，要么会漏掉空集</span></span><br><span class="line">            <span class="comment"># 这里会漏掉空集，因此需要额外判断空集</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))) <span class="keyword">in</span> frequency:</span><br><span class="line">                total += frequency[<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))]</span><br><span class="line"></span><br><span class="line">            ans.append(total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>位运算和使用技巧暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/027.4jw2tcniyw80.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python位运算——左移操作（＜＜）右移操作＞＞：<a href="https://blog.csdn.net/qq_45769063/article/details/118618810">https://blog.csdn.net/qq_45769063&#x2F;article&#x2F;details&#x2F;118618810</a></li><li>Python异或运算：<a href="https://www.jianshu.com/p/ffa9fdf192a5">https://www.jianshu.com/p/ffa9fdf192a5</a></li><li>位运算技巧：<a href="https://www.zhihu.com/question/38206659">https://www.zhihu.com/question/38206659</a></li><li>位运算：<a href="http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting">http://graphics.stanford.edu/~seander&#x2F;bithacks.html#OperationCounting</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要学习Python中的二进制运算，通过位运算实现乘除法、交换两数、判断奇偶数、交换符号、求绝对值、二进制逆序、统计二进制中1的个数，最后结合LeetCode常见题目进行练习。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://qxienote.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="二进制逆序" scheme="https://qxienote.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%86%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十二）-- 树和二叉树</title>
    <link href="https://qxienote.com/article/48fcde60.html"/>
    <id>https://qxienote.com/article/48fcde60.html</id>
    <published>2023-06-11T10:00:07.000Z</published>
    <updated>2023-06-13T14:49:35.810Z</updated>
    
    <content type="html"><![CDATA[<p>终于学到了二叉树，LeetCode里面三分之一都是关于二叉树，俗话说打铁还需自身硬，本节学习树的基本概念，二叉树的实现、遍历、转换二叉树等。</p><span id="more"></span><h2 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1 树的概念"></a>1 树的概念</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 $n$（$n\geq 1$）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.7c11iupwauk0.webp#pic_center" width = 48%><h3 id="1-2-树的术语"><a href="#1-2-树的术语" class="headerlink" title="1.2 树的术语"></a>1.2 树的术语</h3><ul><li>节点的度：一个节点含有的子树的个数称为该节点的度；</li><li>树的度：一棵树中，最大的节点的度称为树的度；</li><li>叶节点或终端节点：度为零的节点；</li><li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li><li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li></ul><p>如下图，A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.7d6hue0pbm00.webp#pic_center" width = 48%><ul><li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>树的高度或深度：树中节点的最大层次；</li><li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li><li>节点的祖先：从根到该节点所经分支上的所有节点；</li><li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙；</li><li>森林：由 $m$（$m\geq 0$）棵互不相交的树的集合称为森林。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.5sez1y8lbt40.webp#pic_center" width = 48%><ul><li>深度：对于任意节点n, n 的深度为从根到 n 的唯一路径长，根的深度为0；</li><li>高度：对于任意节点n, n的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0；</li><li>结点的层次：规定根结点在1层，其它任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列 $n_1, n_2, \cdots, n_k, n_i$ 是 $n_{i+1}$ 的父结点。路径所包含边的个数为路径的长度。</li></ul><h3 id="1-3-树的种类"><a href="#1-3-树的种类" class="headerlink" title="1.3 树的种类"></a>1.3 树的种类</h3><ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li><li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul><li>二叉树：每个节点最多含有两个子树的树称为二叉树；<ul><li>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</li><li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li>排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</li></ul></li><li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li><li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li></ul></li></ul><p>用图片来展示什么是完全二叉树，请看下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.1b9h32y2iji8.webp#pic_center" width = 48%><p>下面这两棵树都是搜索树</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.5ku881wu4to0.webp#pic_center" width = 48%><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.5fiprv9i92w0.webp#pic_center" width = 48%><h4 id="1-4-树的存储和表示"><a href="#1-4-树的存储和表示" class="headerlink" title="1.4 树的存储和表示"></a>1.4 树的存储和表示</h4><p><strong>1. 链式存储法</strong></p><p>一种基于指针或者引用的二叉链式存储法，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。结构如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.6kxybgrn4pg0.webp#pic_center" width = 48%><p><strong>2. 顺序存储法</strong></p><p>顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。我们把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。即如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.vvpo3mca8g0.webp#pic_center" width = 48%><p>不过上图是一颗完全二叉树，所以数组仅仅浪费了下标为0的存储位置，如果是非完全二叉树，则可能会浪费比较多的数组内存空间。所以当要存储的树是一颗完全二叉树时，数组才是最合适的选择。所以，二叉树通常以链式存储。</p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2 二叉树"></a>2 二叉树</h2><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”(left subtree)和“右子树”(right subtree)。</p><h3 id="2-1-二叉树的性质"><a href="#2-1-二叉树的性质" class="headerlink" title="2.1 二叉树的性质"></a>2.1 二叉树的性质</h3><p><strong>1.层结点</strong><br>在二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点(i&gt;&#x3D;1)</p><p><strong>2.总结点</strong><br>深度为 $k$ 的二叉树最多有 $2^{k+1}-1$ 个结点(k&gt;&#x3D;1)</p><p><strong>3.深度</strong><br>具有 $n$ 个结点的完全二叉树的深度为 $\lfloor \log_{2}n \rfloor$</p><p><strong>4. 结点数</strong></p><p>对于任意一棵二叉树，度为 0 的结点数等于度为 2 的结点数 +1。</p><p><strong>5. 孩子结点</strong></p><p>对完全二叉树，若从上至下、从左至右编号，则编号为 $i$ 的结点，其左孩子编号必为 $2i$，其右孩子编号必为 $2i＋1$ ；其双亲的编号必为i&#x2F;2（i＝1 时为根，除外）</p><blockquote><p>完全二叉树————若设二叉树的高度为$h$，除第 $h$ 层外，其它各层 $(1~h-1)$ 的结点数都达到最大个数，第 $h$ 层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.1fabcfnlkitc.webp#pic_center" width = 48%><blockquote><p>满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.4pofeqgfk9s0.webp#pic_center" width = 48%><h3 id="2-2-二叉树的实现"><a href="#2-2-二叉树的实现" class="headerlink" title="2.2 二叉树的实现"></a>2.2 二叉树的实现</h3><p><strong>1. 列表实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/27</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 树的列表实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_tree</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">return</span> [r, [], []]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">root, new_branch</span>):</span><br><span class="line">    t = root.pop(<span class="number">1</span>)     <span class="comment"># 取出左子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:      <span class="comment"># 左子树已存在</span></span><br><span class="line">        root.insert(<span class="number">1</span>, [new_branch, t, []])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">1</span>, [new_branch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">root, new_branch</span>):</span><br><span class="line">    t = root.pop(<span class="number">2</span>)     <span class="comment"># 取出右子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:      <span class="comment"># 右子树已存在</span></span><br><span class="line">        root.insert(<span class="number">2</span>, [new_branch, [], t])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>, [new_branch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_root_val</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_root_val</span>(<span class="params">root, new_val</span>):</span><br><span class="line">    root[<span class="number">0</span>] = new_val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_left_child</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_right_child</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">r = binary_tree(<span class="number">3</span>)</span><br><span class="line">insert_left(r, <span class="number">4</span>)</span><br><span class="line">insert_left(r, <span class="number">5</span>)</span><br><span class="line">insert_right(r, <span class="number">6</span>)</span><br><span class="line">insert_right(r, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">l = get_left_child(r)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line">set_root_val(l, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">insert_left(l, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(get_right_child(get_right_child(r)))</span><br></pre></td></tr></table></figure><p><strong>2. 链表实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_obj</span>):</span><br><span class="line">        self.key = root_obj</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">self, new_node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.left_child == <span class="literal">None</span>:</span><br><span class="line">            self.left_child = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(new_node)</span><br><span class="line">            t.left_child = self.left_child</span><br><span class="line">            self.left_child = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">self, new_node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.right_child == <span class="literal">None</span>:</span><br><span class="line">            self.right_child = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(new_node)</span><br><span class="line">            t.right_child = self.right_child</span><br><span class="line">            self.right_child = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_right_child</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.right_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_left_child</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.left_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_root_val</span>(<span class="params">self, obj</span>):</span><br><span class="line">        self.key = obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root_val</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure><h3 id="2-3-二叉树的遍历"><a href="#2-3-二叉树的遍历" class="headerlink" title="2.3 二叉树的遍历"></a>2.3 二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p><ul><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ul><p>从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.46af021h4fo0.webp#pic_center" width = 48%><p>下面以LeetCode为例，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="2-3-1-前序遍历"><a href="#2-3-1-前序遍历" class="headerlink" title="2.3.1 前序遍历"></a>2.3.1 前序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5qei5gwywa80.webp#pic_center" width = 48%><ul><li>遍历顺序：根结点-&gt;左子树-&gt;右子树</li><li>动态图解：和上面的动态图一样，先序遍历就像一个小人从根结点开始，围绕二叉树的外圈开始跑（遇到缝隙就钻进去），按照跑的顺序，依次输出序列</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归实现</span></span><br><span class="line">        self.result = []                <span class="comment"># 使用布局变量存储结果</span></span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.result.append(root.val)    <span class="comment"># 前序</span></span><br><span class="line">        self.traverse(root.left)        <span class="comment"># 左</span></span><br><span class="line">        self.traverse(root.right)       <span class="comment"># 右</span></span><br></pre></td></tr></table></figure><p><strong>2. 迭代遍历</strong></p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.5m8n41fvngc0.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)         <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)    <span class="comment"># 右子树先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)     <span class="comment"># 左子树先入栈</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-3-2-中序遍历"><a href="#2-3-2-中序遍历" class="headerlink" title="2.3.2 中序遍历"></a>2.3.2 中序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.zoh9hj3411s.webp#pic_center" width = 48%><ul><li>遍历顺序：左子树-&gt;根结点-&gt;右子树</li><li>动态图解：中序遍历就像投影仪一样，将二叉树从最左侧到最右侧依次投影到同一水平线上面，得到的从左到右的相关序列就是二叉树的中序遍历</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.result = []</span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        self.traversal(root.left)               <span class="comment"># 前</span></span><br><span class="line">        self.result.append(root.val)            <span class="comment"># 中</span></span><br><span class="line">        self.traversal(root.right)              <span class="comment"># 后</span></span><br></pre></td></tr></table></figure><p><strong>2. 顺序遍历</strong></p><p>分析一下为什么前面写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.a7oiu182jww.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = []                      <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:         </span><br><span class="line">            <span class="keyword">if</span> cur:                     <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 到达最左节点后处理栈顶结点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                cur = cur.right         <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-3-3-后序遍历"><a href="#2-3-3-后序遍历" class="headerlink" title="2.3.3 后序遍历"></a>2.3.3 后序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.4w5738j4umi0.webp#pic_center" width = 48%><ul><li>遍历顺序：左子树-&gt;右子树-&gt;根结点</li><li>动态图解： 后序遍历也是按照先序遍历的顺序输出，不过后序遍历就像剪葡萄，只能一个个剪，不能让超过1个的葡萄一起掉下来，那就错了。例如上图中的 B，剪去 B 后面的 D、E、H、I、J 都会掉下来，而 H 剪去只会掉下 H，规律就是这个规律</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.result = []</span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.traversal(root.left)               <span class="comment"># 左</span></span><br><span class="line">        self.traversal(root.right)              <span class="comment"># 右</span></span><br><span class="line">        self.result.append(root.val)            <span class="comment"># 中</span></span><br></pre></td></tr></table></figure><p><strong>2. 顺序遍历</strong></p><p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.6ln5rgj5w0w0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)                     <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)       <span class="comment"># 左子树先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)     <span class="comment"># 右子树后入栈</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]                             <span class="comment"># 将最终数组反转</span></span><br></pre></td></tr></table></figure><h4 id="2-3-4-层序遍历"><a href="#2-3-4-层序遍历" class="headerlink" title="2.3.4 层序遍历"></a>2.3.4 层序遍历</h4><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.5in2a4wgs600.gif#pic_center" width = 36%><p><strong>1. 迭代法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">        <span class="comment"># 二叉树层序遍历迭代解法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):       <span class="comment"># 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的</span></span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>2. 递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 递归法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.res = []</span><br><span class="line">        self.helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], depth</span>) -&gt; <span class="type">Optional</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.res) == depth: self.res.append([])</span><br><span class="line">        self.res[depth].append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.left: self.helper(root.left, depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right: self.helper(root.right, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>二叉树基础部分已整理完毕，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.32u2n6vhr4o0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>树结构详解：<a href="http://c.biancheng.net/data_structure/tree/">http://c.biancheng.net/data_structure&#x2F;tree&#x2F;</a></li><li>树和二叉树全面总结：<a href="https://juejin.cn/post/7065513748789723150">https://juejin.cn/post/7065513748789723150</a></li><li>数据结构与算法————二叉树：<a href="https://www.cnblogs.com/jasonbourne3/p/17143620.html">https://www.cnblogs.com/jasonbourne3/p/17143620.html</a></li><li>二叉树入门和刷题：<a href="https://zhuanlan.zhihu.com/p/136758152">https://zhuanlan.zhihu.com/p/136758152</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于学到了二叉树，LeetCode里面三分之一都是关于二叉树，俗话说打铁还需自身硬，本节学习树的基本概念，二叉树的实现、遍历、转换二叉树等。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十一）-- 链表的应用与常见题型</title>
    <link href="https://qxienote.com/article/ae2fd3ce.html"/>
    <id>https://qxienote.com/article/ae2fd3ce.html</id>
    <published>2023-06-11T09:59:42.000Z</published>
    <updated>2023-06-13T14:41:16.362Z</updated>
    
    <content type="html"><![CDATA[<p>本篇信息量巨大，首先对比链表和数组，接着解决单链表的反转、删除某一节点、插入数据、查找中间节点、求倒数第k个结点、对称链表、单链表是否有环、两个链表是否相交，最后用LeetCode上的真题来实战删除链表结点、反转链表、合并、排序、环形链表常用技巧。</p><span id="more"></span><p>这一部分的内容，前面的大佬总结的挺多，这里进行汇总，方便和大家一起学习和回顾，欢迎大家继续补充。</p><h2 id="1-链表和数组"><a href="#1-链表和数组" class="headerlink" title="1 链表和数组"></a>1 链表和数组</h2><p>作为线性表的两种存储方式————链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。</p><p>数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。</p><p>但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 $O(n)$。增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.22jcviirxk5c.gif#pic_center" width = 48%><p>删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.60mgplwxlw40.gif#pic_center" width = 48%><p> <strong>总结一下数组的优缺点：</strong></p><ul><li>优点：可以根据偏移实现快速的随机读写。</li><li>缺点：扩容，增删元素极慢。</li></ul><p>上面对数组增删元素的操作表明使用数组需要注意的东西真的很多很多，这样一来，我们就开始说说链表，链表也是一种数据结构，它弥补了数组带来的诸多不便，让我们可以任意为一些数据进行空间的分配，根据需要进行内存单元的开辟。</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，由若干个结点组成，在每一个结点里存到下一个结点的指针(Next)。采用动态分配存储单元方式。它能够有效地节省存储空间（同数组比较）。结点结构如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.35g0aiddrry0.webp#pic_center" width = 48%><p>一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.55ls7z5t19g0.webp#pic_center" width = 48%><p>对于链表而言，分为静态链表和动态链表，根据处理数据的方向又分为单向链表和双向链表。对于链表的更多操作，请阅读 <a href="https://blog.csdn.net/xq151750111/article/details/129130524?spm=1001.2014.3001.5501">Python数据结构与算法篇（四）– 链表的实现</a></p><p><strong>小结：</strong> 从本质上来讲，<font color=#9900CC><strong>链表与数组的确有相似之处，他们的相同点是都是线性数据结构，这与树和图不同，而它们的不同之处在于数组是一块连续的内存，而链表可以不是连续内存，链表的节点与节点之间通过指针来联系。</font></strong></p><hr><h2 id="2-常见链表问题解决思路"><a href="#2-常见链表问题解决思路" class="headerlink" title="2 常见链表问题解决思路"></a>2 常见链表问题解决思路</h2><h3 id="2-1-单链表的反转"><a href="#2-1-单链表的反转" class="headerlink" title="2.1 单链表的反转"></a>2.1 单链表的反转</h3><p><strong>方法一：头插法（迭代法）</strong><br>算法思想：&#x3D;&#x3D;逆置链表初始为空，表中节点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），&#x3D;&#x3D; 使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空。</p><p><strong>方法二：递归法：</strong><br>算法思想：从后向前改变指向，可以理解成向后的箭头变成了向前的箭头</p><p><strong>方法三：三指针法</strong><br>算法思想：从前向后改变指向，可以理解成向后的箭头变成了向前的箭头</p><h3 id="2-2-单链表的删除某一结点"><a href="#2-2-单链表的删除某一结点" class="headerlink" title="2.2 单链表的删除某一结点"></a>2.2 单链表的删除某一结点</h3><p><strong>方法一：遍历</strong><br>思路：查找到所要删除的节点，以及其前驱节点，让其前驱节点，指向其后继节点</p><p><strong>方法二：置换法（移花接木）</strong><br>思路：明确要删除的节点后，把其后继节点复制到该节点上，然后删除那个后继节点，也等于变相的删除节点（注意如果删除的是尾节点 删除的链表只有一个节点）</p><h3 id="2-3-在当前节点前插入一个数据"><a href="#2-3-在当前节点前插入一个数据" class="headerlink" title="2.3 在当前节点前插入一个数据"></a>2.3 在当前节点前插入一个数据</h3><p><strong>方法一：遍历</strong><br>思路：找出当前结点的前驱节点，完成插入；</p><p><strong>方法二：置换法</strong><br>思路：把插入节点的数据放到新节点上，把新节点的数据放到插入节点的数据上，这样我们就可以实现在当前节点前插入一个节点了。</p><h3 id="2-4-查找链表的中间结点"><a href="#2-4-查找链表的中间结点" class="headerlink" title="2.4 查找链表的中间结点"></a>2.4 查找链表的中间结点</h3><p><strong>快慢指针法</strong><br>思路：给一个快指针，让快指针每次移动两步，给一个慢指针，让慢指针每次移动一步，最后结果就是快指针移动到最后一个节点，慢指针最后移动到了中间的节点上。</p><p>设有两个指针 fast 和 slow，&#x3D;&#x3D;初始时指向头节点&#x3D;&#x3D;。每次移动时，fast 向后走两次，slow 向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n&#x2F;2 轮。&#x3D;&#x3D;当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠后一个。&#x3D;&#x3D;</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.6wtkyvc1a1g0.webp#pic_center" width = 48%><h3 id="2-5-单链表的倒数第k个结点"><a href="#2-5-单链表的倒数第k个结点" class="headerlink" title="2.5 单链表的倒数第k个结点"></a>2.5 单链表的倒数第k个结点</h3><p><strong>方法一：正数转换法</strong><br>思路：遍历一遍单链表，记录单链表的长度，倒数第k个，即正数 length-k+1 个，在重头遍历一次便能够找到</p><p><strong>方法二：快慢指针法</strong><br>思路：一个指针先走k步，然后两个指针同时走，当先走的那个指针指向空的时候，后面的指针所指即为倒数第K个节点。</p><p>设有两个指针 p 和 q，&#x3D;&#x3D;初始时均指向头结点&#x3D;&#x3D;。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1 个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.4g7u9ztqez20.webp#pic_center" width = 48%><h3 id="2-6-对称单链表"><a href="#2-6-对称单链表" class="headerlink" title="2.6 对称单链表"></a>2.6 对称单链表</h3><p><strong>1. 知道链表的长度</strong><br>思路：根据对称来确定两个指针的位置，对所指向的元素进行判断，不断前进指针</p><p><strong>2. 链表长度未知</strong><br>思路1：将前一半的节点压入栈中，并将当前节点继续遍历，每遍历一个都与栈弹出的节点相比较，若不同则不是。额外空间复杂度 O(N&#x2F;2)。</p><p>思路2：不使用辅助空间 两个指针，一个指向头 first，指向头的后继节点 last；first 走一步，last走两步；直到 last 为空或 last 的后继节点为空，此时 first 指向（链表长度为奇数，指向中间；为偶数，指向一半）；然后 fisrt 向后走，再申请一个节点指向头，不断进行比较，直到 first 指向空。</p><h3 id="2-7-单链表是否有环"><a href="#2-7-单链表是否有环" class="headerlink" title="2.7 单链表是否有环"></a>2.7 单链表是否有环</h3><p><strong>方法一：map表法</strong><br>算法思想：每走一步将走过的节点使用map表存储起来，当遇到第一个在map中存在的节点时，就说明回到了出发点，即链表有环，同时也找到了环的入口。</p><p><strong>方法二：快慢指针法</strong><br>算法思想：一个指针走两步；一个指针走一步；如果存在环，两个指针最终会指向同一个元素；如果不存在环，走两步的会最终走向空节点。</p><p>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.2t8k9zey8280.gif#pic_center" width = 24%><p><strong>确定有环后求环的长度</strong></p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.safh0w2cugw.webp#pic_left" width = "45%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.580tqn3izyk0.webp#pic_left"  width = "50%"></center></p><p>通过公式的推导我们发现 $L&#x3D;kc-n$（这里的 $k$ 是倍数，有可能快指针在环里转了 $k$ 圈），即<font color=#9900CC><strong>相遇节点到入环点的距离等于链表的头到入环点的距离</font></strong>。写代码的时候只需要找到相遇节点，再让一个指针从头开始走即可。</p><h3 id="2-8-判断两个链表是否相交"><a href="#2-8-判断两个链表是否相交" class="headerlink" title="2.8 判断两个链表是否相交"></a>2.8 判断两个链表是否相交</h3><p><strong>1. 相交则求交点（链表不带环）</strong><br>思路：若两个不带环的链表相交，则他们的尾节点必相同；若要求交点，则需要比较两个链表的长度，让较长的链表先向后遍历至和较短的链表长度相等，然后两个链表同时向后遍历，并比较节点是否相同，当遇到第一个相同的节点时，则为两个链表的交点。</p><p><strong>2. 相交则求交点（链表可能带环）</strong><br>情况分析：<br>若有两个链表，则他们的带环情况有以下三种可能：<br>（1）两个链表都不带环<br>直接采用上述思路即可；<br>（2）一个链表带环一个链表不带环<br>必定不想交；<br>（3）两个链表都带环<br>下面详细讨论：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.6rl0uys7mkc0.webp#pic_center" width = 48%><ul><li>当出现①情况时，两个链表不相交。</li><li>当出现②情况时，两个链表的交点在环外，那么我们可以转化为不带环链表判断相交即可。</li><li>当出现③情况时，两个链表的交点在环内，那么我们可以遍历其中一个链表的环，若在环内与另一个链表环的入口点相交，则两个链表相交，相遇点即为两个链表的交点。</li><li>要判断为情况②还是情况③，只需判断两个链表环的入口点是否相同即可。</li></ul><p><strong>链表的 <code>.next</code> 指向问题</strong></p><p>如果放在左边就表示是自己的指向，如果放在右边就表示是它的下一个节点。类似于代码中的这三行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="built_in">next</span> = head.<span class="built_in">next</span>;</span><br><span class="line">head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">node.<span class="built_in">next</span>.<span class="built_in">next</span> = head;</span><br></pre></td></tr></table></figure><p>这种就代表等号左边指向右边，左边的是指向，右边就代表确切的下一个节点。</p><p>如果类似于后两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = node.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">head = head.<span class="built_in">next</span>;</span><br></pre></td></tr></table></figure><p>像这样，左边不带 <code>.next</code> 的是类似于赋值语句，自己的指针指向右边位置。</p><hr><h2 id="3-LeetCode"><a href="#3-LeetCode" class="headerlink" title="3 LeetCode"></a>3 LeetCode</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.394jgp0avbs0.webp#pic_center" width = 100%><p>俗话说一图胜千言，接下来主要通过图片展示解决思路，通过代码展示实现的细节。</p><h3 id="3-1-删除结点"><a href="#3-1-删除结点" class="headerlink" title="3.1 删除结点"></a>3.1 删除结点</h3><h4 id="3-1-1-题解方法"><a href="#3-1-1-题解方法" class="headerlink" title="3.1.1 题解方法"></a>3.1.1 题解方法</h4><p> <strong>1. 画草图：</strong> 理解指针的变动与思考逻辑！！(重要！实用！)<br> <strong>2. 边界条件：</strong> 怎么处理不会有空指针异常？在循环里放什么停止条件</p><blockquote><ul><li>如果是遍历链表元素，<code>while(node!=null)</code> </li><li>如果是删除某个元素，需要，<code>while(node.next!=null)</code></li><li>需要考虑的仅仅是被改变 next 指针的部分，并且循环之后哪个指针在最后的节点处，就判断谁</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如快慢指针，输出中间节点，slow 和 fast 的指针都在变，但是 fast 先指向链表尾巴，所以判断 fast</span></span><br><span class="line"><span class="comment"># 同时每个判断 next.next 的都必须先判断，next，才能保证 奇偶链长 中不会出现空指针异常</span></span><br><span class="line"><span class="keyword">while</span>(fast.<span class="built_in">next</span>!=null &amp;&amp; fast.<span class="built_in">next</span>.<span class="built_in">next</span>!=null)&#123;</span><br><span class="line">            slow = slow.<span class="built_in">next</span>;</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><font color=#9900CC><strong>3. 只要会删除头结点，都要进行 dummy虚指针，有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性</font></strong><br><strong>4. 特殊的需求可以考虑结合各种工具类，比如删除重复里面，利用HashSet，删除倒数第k个，利用栈LinkedList</strong></p><h4 id="1-3-2-可能出现的问题"><a href="#1-3-2-可能出现的问题" class="headerlink" title="1.3.2 可能出现的问题"></a>1.3.2 可能出现的问题</h4><p>① NullPointerException，就是当前节点为空，我们还去操作它的 next；<br>② 输出不了结果，一定是指针移动出了问题</p><h4 id="1-3-3-题库列表"><a href="#1-3-3-题库列表" class="headerlink" title="1.3.3 题库列表"></a>1.3.3 题库列表</h4><blockquote>  <p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank">237. 删除链表中的节点</a> ====<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank">面试题 02.03. 删除中间节点</a></p>  <p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank">203. 移除链表元素</a>（虚拟头结点）</p>  <ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank">剑指 Offer 18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank">面试题 02.01. 移除重复节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank">82. 删除排序链表中的重复元素 II</a></li></ul>  <p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank">19. 删除链表的倒数第 N 个结点</a>（双指针经典类型）</p>  <ul><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank">876. 链表的中间结点</a></li><li><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank">328. 奇偶链表</a></li></ul> </blockquote><p><strong>237. 删除链表中的节点</strong></p><p>题目描述：给你一个需要删除的节点 node，但无法访问 第一个节点  head。链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 题目说 node 不是链表中最后一个结点，直接将当前节点的值改为next的值，next指向next.next，实现原地更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>203. 移除链表元素</strong></p><p>题目描述：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><blockquote><p>① 如果删除的节点是中间的节点，则问题似乎非常简单： </p><ul><li>选择要删除节点的前一个结点 prev。 </li><li>将 prev 的 next 设置为要删除结点的 next。</li></ul><p>② 当要删除的一个或多个节点位于链表的头部时，要另外处理</p></blockquote><p><strong>三种方法：</strong></p><blockquote><ul><li>删除头结点时另做考虑（由于头结点没有前一个结点） </li><li>添加一个虚拟头结点，删除头结点就不用另做考虑 </li><li>递归 </li><li>双指针法</li></ul></blockquote><p><strong>1. 对头结点单独考虑</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:<span class="comment"># 找到指定元素</span></span><br><span class="line">                <span class="keyword">if</span> prev:<span class="comment"># 不是头结点</span></span><br><span class="line">                    prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span><span class="comment"># 将删除位置的前一个节点的next指向删除位置的后一个结点</span></span><br><span class="line">                <span class="keyword">else</span>:<span class="comment"># 如果第一个就是删除结点</span></span><br><span class="line">                    head = cur.<span class="built_in">next</span><span class="comment"># 将头指针指向头节点的后一个结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5hja7yiu0cw0.gif#pic_center" width = 48%><p><strong>2. 添加一个虚拟头结点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)<span class="comment"># 创建虚结点</span></span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> prev <span class="keyword">and</span> prev.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> prev.<span class="built_in">next</span>.val == val:</span><br><span class="line">                prev.<span class="built_in">next</span> = prev.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.3b5w9nrdkj80.webp#pic_center" width = 48%><p><strong>3. 递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 因为递归函数返回的是已经删除节点之后的头结点</span></span><br><span class="line">        <span class="comment"># 所以直接接上在 head.next，最后就只剩下判断头结点是否与需要删除的值一致了</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.removeElements(head.<span class="built_in">next</span>, val)</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.r3e3eix9ae.gif#pic_center" width = 48%><p><strong>83. 删除排序链表中的重复元素</strong></p><p>题目描述：给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curr = head     <span class="comment"># 指针节点，这里不会删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:<span class="comment"># 如果两个结点元素值相同，则执行删除</span></span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.1z3s9s43bvi8.gif#pic_center" width = 36%><p>题目解法并不唯一，可以使用递归、双指针、虚拟头结点、栈的方法，详细了解可以阅读：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/342300/83-shan-chu-pai-xu-lian-biao-zhong-de-zhong-fu-21/?orderBy=most_votes">删除排序链表中的重复元素（五种方法）</a></p><p><strong>剑指 Offer 18. 删除链表的节点</strong></p><p>题目描述：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head.val == val:             <span class="comment"># 如果头指针相等，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        prev, cur = head, head.<span class="built_in">next</span>     <span class="comment"># 双指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur <span class="keyword">and</span> cur.val != val): <span class="comment"># 找元素</span></span><br><span class="line">            prev, cur = cur, cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur:                         <span class="comment"># 找到了，进行删除</span></span><br><span class="line">            prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span>        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong>  这里既可以添加虚拟头结点，也可以先判断第一个结点是否满足条件，第二种方法更快，这里就采用先判断再循环的方式。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.48py8rnrn6g0.webp#pic_center" width = 48%><p><strong>面试题 02.01. 移除重复节点</strong></p><p>题目描述：移除未排序链表中的重复节点。保留最开始出现的节点，由于未排序，重复的元素不一定连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head<span class="comment"># 初始化 pre, cur 节点引用（指针）</span></span><br><span class="line">        visited = <span class="built_in">set</span>()<span class="comment"># 初始化 set 用于保存节点值</span></span><br><span class="line">        <span class="keyword">while</span> cur:<span class="comment"># 遍历链表 </span></span><br><span class="line">            <span class="keyword">if</span> cur.val <span class="keyword">in</span> visited:<span class="comment"># 若节点值 cur.val 在 set 中</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span><span class="comment"># 删除节点 cur</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 若节点值 cur.val 不在 set 中</span></span><br><span class="line">                visited.add(cur.val)<span class="comment"># 将 cur.val 添加进 set</span></span><br><span class="line">                pre = cur<span class="comment"># 令 pre 指向 cur ，作为下一轮的前驱节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span><span class="comment"># 遍历下一节点</span></span><br><span class="line">        <span class="keyword">return</span> head<span class="comment"># 删除完成，返回链表头节点 head</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.72m13v2o2rg0.gif#pic_center" width = 48%><p><strong>82. 删除排序链表中的重复元素 II</strong></p><p>题目描述：给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;双指针记录 pre 用 cur 记录相同的数，加虚头节点&#x27;&#x27;&#x27;</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        prev, curr = dummy, dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:<span class="comment"># 如果有奇数个相同的值，就删不完，所以必须用 while 循环</span></span><br><span class="line">                    curr = curr.<span class="built_in">next</span>        <span class="comment"># 找到最后一个相等的数</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.8oxo1amj9zc.gif#pic_center" width = 48%><p><strong>19、删除链表的倒数第 N 个结点</strong></p><p>题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>1. 快慢指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        fast = dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 快指针先走n步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = dummy</span><br><span class="line">        <span class="keyword">while</span> fast:<span class="comment"># 快慢指针同时走，直到 fast 指针到达尾部节点，此时 slow 到达倒数第 N 个节点的前一个节点</span></span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 删除节点，并重新连接</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.401fcoye5po0.gif#pic_center" width = 48%><p><strong>2. 循环迭代 – 找到 length -n 个节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        cur, length = head, <span class="number">0</span> <span class="comment"># step1: 获取链表长度</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">        cur = dummy <span class="comment"># step2: 找到倒数第N个节点的前面一个节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length - n):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># step3: 删除节点，并重新连接</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><strong>3. 递归迭代 – 回溯时，进行节点计数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: </span><br><span class="line">            self.count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> head  </span><br><span class="line">        head.<span class="built_in">next</span> = self.removeNthFromEnd(head.<span class="built_in">next</span>, n) <span class="comment"># 递归调用</span></span><br><span class="line">        self.count += <span class="number">1</span> <span class="comment"># 回溯时进行节点计数</span></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span> <span class="keyword">if</span> self.count == n <span class="keyword">else</span> head </span><br></pre></td></tr></table></figure><p><strong>876、链表的中间结点</strong></p><p>题目描述：给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p><p>（1）若为奇数，指向中间的结点，若为偶数，指向中间靠后的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 如果不加 fast，链表元素个数为偶数时会报空指针异常；</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.4aza639wrhw0.webp#pic_center" width = 48%><p>（2）若为奇数，指向中间的结点，若为偶数，指向中间靠前的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.5096s37l9ow0.gif#pic_center" width = 48%><p><strong>86、分隔链表（两个临时链表）</strong></p><p>题目描述：给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)<span class="comment"># dummy1 存放小于x链表的虚拟头结点，dummy2存放不小于x的虚拟头结点</span></span><br><span class="line">        p, p1, p2 = head, dummy1, dummy2<span class="comment">#  p 负责遍历链表，类似合并两个有序链表的逻辑；p1, p2 指针负责生成结果链表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p </span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            temp = p.<span class="built_in">next</span><span class="comment"># 断开原链表中的每个结点的 next 指针</span></span><br><span class="line">            p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            p = temp</span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span><span class="comment"># 合并两个链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/022.2705dkyftrgg.webp#pic_center" width = 48%><p>这里为什么需要断开 next？</p><p>如果不断开直接 <code>p = p.next</code>，p 是正常往下走了，但是其中有个问题就是会陷入无限循环。以本题为例，由于14325的5在被p2连起来之后，其由于指向 p，因此 <code>p.next</code> 也是被继承过来的，所以后面是2，而 p 直接等于 <code>p.next</code> 后判断为2后，就直接加到 p1 后面了。现在问题就是 p1 中的 第一个2 指向的 第二个2 和 p2 中的 5 指向的 2 是一个指针(地址)，不把他们俩合并还好说，一旦合并，就成了 下图所示.的<code>1--&gt;2--&gt;2--&gt;4--&gt;3--&gt;5--&gt;2|--&gt;4--&gt;3--&gt;5--&gt;2|--&gt;4--&gt;...</code>，看出来了吗？形成了一个环了！</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/023.2ow0749423q0.webp#pic_center" width = 48%><p>因此在每步的赋值结束后，应当对next清除，以防止在最后的时候陷入这种无限循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 断开原链表中的每个结点的 next 指针</span></span><br><span class="line">temp = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span> = <span class="literal">None</span>   </span><br><span class="line">p = temp</span><br></pre></td></tr></table></figure><p>或者，如果不想每个都断开，其实在 p 往下走的时候，每个 p1 和 p2 的 next 都在同时进行着更新，因此只有 p2 的最后一个是存在问题的，因此也可以加一句 <code>p2.next = None</code> 来解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># dummy1 存放小于x链表的虚拟头结点， 度没有 存放不小于x的虚拟头结点</span></span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># p1, p2 指针负责生成结果链表</span></span><br><span class="line">        p1, p2 = dummy1, dummy2</span><br><span class="line">        <span class="comment"># p 负责遍历链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">        <span class="comment"># 这里是将两个链表分解成两个链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p </span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 合并两个链表</span></span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>328. 奇偶链表</strong></p><p>题目描述：给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。&#x3D;&#x3D;这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)</span><br><span class="line">        p, p1, p2 = head, dummy1, dummy2</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            temp = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            p = temp</span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/024.4donvqjwj440.gif#pic_center" width = 48%><h3 id="3-2-反转链表"><a href="#3-2-反转链表" class="headerlink" title="3.2 反转链表"></a>3.2 反转链表</h3><h4 id="3-2-1-题库列表"><a href="#3-2-1-题库列表" class="headerlink" title="3.2.1 题库列表"></a>3.2.1 题库列表</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank">206. 反转链表</a>====<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank">剑指 Offer 24. 反转链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank">92. 反转链表 II</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank">234. 回文链表</a>====<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank">面试题 02.06. 回文链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank">25. K 个一组翻转链表</a></p></blockquote> <p><strong>206、反转链表</strong><br>题目描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>1. 双指针法迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev, cur = <span class="literal">None</span>, head<span class="comment"># 申请两个节点，pre和 cur，pre指向None</span></span><br><span class="line">        <span class="keyword">while</span> cur:<span class="comment"># 遍历链表</span></span><br><span class="line">            temp = cur.<span class="built_in">next</span><span class="comment"># 记录当前节点的下一个节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev<span class="comment"># 然后将当前节点指向pre</span></span><br><span class="line">            prev = cur<span class="comment"># pre和cur节点都前进一位</span></span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/025.6glhs7jiai00.webp#pic_center" width = 48%><p><strong>2. 尾递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># reverse_head 表示 head.next 后面一整段反转之后的头结点，所以最后return reverse_head</span></span><br><span class="line">        reverse_head = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head<span class="comment"># 此时 head.next 指向的已经是反转部分的尾巴</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span><span class="comment"># head 指向 None，表示此时 head 已经是尾巴了</span></span><br><span class="line">        <span class="keyword">return</span> reverse_head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/026.2al8hft9no74.webp#pic_center" width = 48%><p><strong>92. 反转链表 II</strong></p><p>题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span>  head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):     <span class="comment"># 迭代法，先找到起点</span></span><br><span class="line">            prev= prev.<span class="built_in">next</span>         <span class="comment"># 来到 left 节点的前一个节点</span></span><br><span class="line">        curr = prev.<span class="built_in">next</span>            <span class="comment"># cur 是真正反转的指针</span></span><br><span class="line">        tail = curr</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right-left+<span class="number">1</span>):</span><br><span class="line">            node = curr.<span class="built_in">next</span>        <span class="comment"># node 保存 curr.next 的临时指针，保存后面的顺序</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span>   <span class="comment"># 将要反转的节点，接入到 left 节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = curr        </span><br><span class="line">            tail.<span class="built_in">next</span> = node</span><br><span class="line">            curr = node</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/027.6yezj4cz5100.gif#pic_center" width = 48%><p><strong>234. 回文链表</strong></p><p>题目描述：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br><strong>1. 数组模拟</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        prev, val_list = head, []</span><br><span class="line">        <span class="keyword">while</span> prev:</span><br><span class="line">            val_list.append(prev.val)</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> val_list == val_list[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 维持半条翻转链表（双指针）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        p, slow, fast = head, head, head<span class="comment"># p 存储前半段的尾结点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:   <span class="comment"># 快慢指针找到中间节点</span></span><br><span class="line">            p = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        left, right = head, self.reverse_list(slow)     <span class="comment"># 额外维持的半条链表；反转 slow 后面的元素</span></span><br><span class="line">        q = right<span class="comment"># 存储末尾的断点用于恢复原来链表的顺序</span></span><br><span class="line">        <span class="keyword">while</span> right:                                    <span class="comment"># 两个半长链表的比较 遍历两个 半长链表</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = self.reverse_list(q)<span class="comment"># 还原链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_list</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">        prev, curr = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            node = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = node</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p> <strong>温馨提示：</strong> 比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。可以记录前半段的尾结点，将后半部分翻转之后在比较完成之后再次翻转，再让前半段的尾结点指向两次翻转的后半部分即可还原链表。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/028.35rx78p4hwo0.gif#pic_center" width = 48%><p><strong>25. K 个一组翻转链表</strong></p><p>题目描述：给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br><strong>1. 模拟法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> k== <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev1, prev2, curr = dummy, dummy, dummy.<span class="built_in">next</span></span><br><span class="line">        count = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> prev1:        <span class="comment"># 查找节点个数</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            prev1 = prev1.<span class="built_in">next</span></span><br><span class="line">        tail = curr</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count//k):<span class="comment"># K个一组反转</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                prev2 = tail</span><br><span class="line">                tail = curr</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                temp = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev2.<span class="built_in">next</span></span><br><span class="line">                prev2.<span class="built_in">next</span> = curr</span><br><span class="line">                tail.<span class="built_in">next</span> = temp</span><br><span class="line">                curr = temp</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/029.6bao5ag72a80.gif#pic_center" width = 48%><h3 id="3-3-合并链表"><a href="#3-3-合并链表" class="headerlink" title="3.3  合并链表"></a>3.3  合并链表</h3><h4 id="3-3-1-题库列表"><a href="#3-3-1-题库列表" class="headerlink" title="3.3.1 题库列表"></a>3.3.1 题库列表</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank">21. 合并两个有序链表</a></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank">23. 合并K个升序链表</a></p></blockquote> <p><strong>21. 合并两个有序链表</strong><br>题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/030.7ky8cjucdmk0.gif#pic_center" width = 48%><p><strong>23. 合并K个升序链表</strong></p><p>题目描述：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>1. 顺序合并</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> lists[<span class="number">1</span>:]:</span><br><span class="line">            head = self.mergeTwoLists(head, item)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>2. 分治合并</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        n = <span class="built_in">len</span>(lists)                          <span class="comment"># 记录子链表数量</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(lists, <span class="number">0</span>, n - <span class="number">1</span>)  <span class="comment"># 调用归并排序函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode], l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> lists[l]</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        L = self.mergeSort(lists, l, m)         <span class="comment"># 循环的递归部分</span></span><br><span class="line">        R = self.mergeSort(lists, m + <span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(L, R)         <span class="comment"># 调用两链表合并函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/031.510611u0kd40.webp#pic_center" width = 30%><p><strong>3. 优先队列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">priority_queue = []</span><br><span class="line"><span class="keyword">for</span> llist <span class="keyword">in</span> lists: </span><br><span class="line">    <span class="keyword">while</span> llist:</span><br><span class="line">        heapq.heappush(priority_queue, llist.val)       <span class="comment"># 把llist中的数据逐个加到堆中</span></span><br><span class="line">        llist = llist.<span class="built_in">next</span></span><br><span class="line">dummy = ListNode(<span class="number">0</span>)                                     <span class="comment"># 构造虚节点</span></span><br><span class="line">p = dummy</span><br><span class="line"><span class="keyword">while</span> priority_queue:</span><br><span class="line">    p.<span class="built_in">next</span> = ListNode(heapq.heappop(priority_queue))    <span class="comment"># 依次弹出最小堆的数据</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/032.4vepkbla4040.gif#pic_center" width = 48%><h3 id="3-4-排序链表"><a href="#3-4-排序链表" class="headerlink" title="3.4 排序链表"></a>3.4 排序链表</h3><h4 id="3-4-1-解题方法"><a href="#3-4-1-解题方法" class="headerlink" title="3.4.1 解题方法"></a>3.4.1 解题方法</h4><p>在数组排序中，常见的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序等。</p><p>而对于链表排序而言，因为链表不支持随机访问，访问链表后面的节点只能依靠 next 指针从头部顺序遍历，所以相对于数组排序问题来说，链表排序问题会更加复杂一点。</p><p>下面先来总结一下 <strong>适合链表排序与不适合链表排序的算法：</strong></p><ul><li>适合链表的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、桶排序、基数排序。</li><li>不适合链表的排序算法：希尔排序。</li><li>可以用于链表排序但不建议使用的排序算法：堆排序。</li></ul><p> <strong>希尔排序为什么不适合链表排序？</strong><br>希尔排序：希尔排序中经常涉及到对序列中第 <code>i + gap</code> 的元素进行操作，其中<code>gap</code> 是希尔排序中当前的步长。而&#x3D;&#x3D;链表不支持随机访问的特性，导致这种操作不适合链表，因而希尔排序算法不适合进行链表排序。&#x3D;&#x3D;</p><p> <strong>为什么不建议使用堆排序？</strong></p><p>堆排序：堆排序所使用的最大堆 &#x2F; 最小堆结构本质上是一棵完全二叉树。而完全二叉树适合采用顺序存储结构（数组）。因为数组存储的完全二叉树可以很方便的通过下标序号来确定父亲节点和孩子节点，并且可以极大限度的节省存储空间。</p><p>而链表用在存储完全二叉树的时候，因为不支持随机访问的特性，导致其寻找子节点和父亲节点会比较耗时，如果增加指向父亲节点的变量，又会浪费大量存储空间。所以堆排序算法不适合进行链表排序。</p><p>如果一定要对链表进行堆排序，则可以使用额外的数组空间表示堆结构。然后将链表中各个节点的值依次添加入堆结构中，对数组进行堆排序。排序后，再按照堆中元素顺序，依次建立链表节点，构建新的链表并返回新链表头节点。</p><p>需要用到额外的辅助空间进行排序的算法</p><p>刚才我们说到如果一定要对链表进行堆排序，则需要使用额外的数组空间。除此之外，计数排序、桶排序、基数排序都需要用到额外的数组空间。</p><h4 id="3-4-2-题库列表："><a href="#3-4-2-题库列表：" class="headerlink" title="3.4.2 题库列表："></a>3.4.2 题库列表：</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank">147. 对链表进行插入排序</a></p><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank">148. 排序链表</a></p></blockquote> <p><strong>147. 对链表进行插入排序</strong><br>题目描述：给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)                 <span class="comment"># 会移动头结点，这里虚拟头结点</span></span><br><span class="line">        last_sorted, curr = head, head.<span class="built_in">next</span>        <span class="comment"># last_sorted 维护已排序部分的最后一个位置；curr 为遍历的待插入元素</span></span><br><span class="line">        <span class="keyword">while</span> curr:           <span class="comment"># 外层循环遍历完链表所有数；内层循环遍历[head, lastSort]这段位置找插入</span></span><br><span class="line">            <span class="keyword">if</span> curr.val &gt;= last_sorted.val:</span><br><span class="line">                last_sorted = last_sorted.<span class="built_in">next</span>      <span class="comment"># 大，直接后移，或者直接 last_sorted = cur</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummy                        <span class="comment"># 用来遍历已经排序的部分</span></span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val &lt;= curr.val:    <span class="comment"># 从前往后比较，找插入的位置</span></span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                last_sorted.<span class="built_in">next</span> = curr.<span class="built_in">next</span>        <span class="comment"># 找到位置进行插入操作</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            curr = last_sorted.<span class="built_in">next</span>                 <span class="comment"># 指针后移</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/033.74j918hmusw0.gif#pic_center" width = 48%><p><strong>148. 排序链表</strong><br>题目描述：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>插入排序的时间复杂度是 $O(n^2)$，其中 $n$ 是链表的长度。这里考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 $O(nlogn)$ 的时间复杂度和 $O(1)$ 的空间复杂度，时间复杂度是 $O(nlogn)$ 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 $O(n^2)$），其中最适合链表的排序算法是归并排序。</p><p><strong>1. 归并排序-迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]: </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:        <span class="comment"># 空链表直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        length = <span class="number">0</span>          <span class="comment"># 获取链表的长度</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node: </span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        sub_length = <span class="number">1</span>                                <span class="comment"># 归并的有效处理长度，最小为 1</span></span><br><span class="line">        <span class="keyword">while</span> sub_length &lt; length:</span><br><span class="line">            prev, curr = dummy_head, dummy_head.<span class="built_in">next</span>  <span class="comment"># 为了更好的实现迭代，定义 prev, curr 分别指向 dummy_head, dummy_head.next</span></span><br><span class="line">            <span class="keyword">while</span> curr:                               <span class="comment"># 当 cur 不为空时</span></span><br><span class="line">                head1 = curr                          <span class="comment"># 定义当前链表，head1 指向 cur</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sub_length):</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    当 i 等于 1 时, cur 不需要指向后下一个链表其余情况，</span></span><br><span class="line"><span class="string">                    cur 在链表 cur 不为空的情况, 向后移动 sub_length - 1 个位置</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                head2 = curr.<span class="built_in">next</span>   <span class="comment"># 切断链表，第一部分长度为 sub_length</span></span><br><span class="line">                curr.<span class="built_in">next</span> = <span class="literal">None</span>    <span class="comment"># 第二部分为 head 除 head1 以外的部分</span></span><br><span class="line">                curr = head2</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sub_length):  <span class="comment"># 将 cur 在满足 cur.next 不为空的情况下， 又往后移动 sub_length 长度</span></span><br><span class="line">                    <span class="keyword">if</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                remain = <span class="literal">None</span>         <span class="comment"># 定义 remain 链表，指向 null</span></span><br><span class="line">                <span class="keyword">if</span> curr:              <span class="comment"># 当移动完 sub_length 后，仍不为空，remain 等于 cur.next;</span></span><br><span class="line">                    remain = curr.<span class="built_in">next</span></span><br><span class="line">                    curr.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 切断链表， 这时候 head2 的长度与 head1 一致</span></span><br><span class="line">                </span><br><span class="line">                merged = self.merge(head1, head2)   <span class="comment"># merge , 然后 prev 的 next 指针指向将 merge 后的子链表</span></span><br><span class="line">                prev.<span class="built_in">next</span> = merged</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>:        <span class="comment"># 然后将 prev 指向与 merge 完成后的链表位置</span></span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                curr = remain           <span class="comment"># 然后当前节点位置指向 remain 部分链表</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            进入下一批次的归并排序操作，直到将相同 sub_length 的全部处理完，才会退出此处 while</span></span><br><span class="line"><span class="string">            再进入到下轮 sub_length, sub_length 以 1 -&gt; 2 -&gt; 4 -&gt; 8 的方法进行，符合自低向上不断迭代，</span></span><br><span class="line"><span class="string">            直到找到最终答案。其实递归底层本质也是一样的，到最短的1，才开始合并，不断合并，到最终结果</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            sub_length &lt;&lt;= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>)            <span class="comment"># 构建虚拟头结点</span></span><br><span class="line">        temp, temp1, temp2 = dummy_head, head1, head2</span><br><span class="line">        <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:              <span class="comment"># 开始合并操作</span></span><br><span class="line">            <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> temp1:                <span class="comment">#  如 temp1, temp2 还存在不为空的链表，将剩余部分赋值给 temp.next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">        <span class="keyword">elif</span> temp2:</span><br><span class="line">            temp.<span class="built_in">next</span> = temp2</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/034.1zary1lzo8e8.gif#pic_center" width = 48%><p><strong>2. 归并排序-递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">return</span> self.split_list(head) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_list</span>(<span class="params">self, head: ListNode</span>):   </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;处理归并排序的边界问题,下面两种场景都不需要进行分合操作&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        prev, slow, fast = head, head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:   <span class="comment"># 找中点,偶数找的后面那个中点的位置，奇数找到中点</span></span><br><span class="line">            prev = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = head, slow     <span class="comment"># 将链表分割成两个子链表</span></span><br><span class="line">        <span class="keyword">return</span> self.merge_sort(self.split_list(left), self.split_list(right))    <span class="comment"># 分割完后，进行合并部分操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;归并环节&#x27;&#x27;&#x27;</span></span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>)            <span class="comment"># 构建虚拟头结点</span></span><br><span class="line">        temp, temp1, temp2 = dummy_head, head1, head2</span><br><span class="line">        <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:              <span class="comment"># 开始合并操作</span></span><br><span class="line">            <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> temp1:                <span class="comment">#  如 temp1, temp2 还存在不为空的链表，将剩余部分赋值给 temp.next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">        <span class="keyword">elif</span> temp2:</span><br><span class="line">            temp.<span class="built_in">next</span> = temp2</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/035.69mibz76l6s0.gif#pic_center" width = 48%><p>了解更多，请阅读：<a href="https://leetcode.cn/problems/sort-list/solution/by-itcharge-01zg/">排序链表「八大排序算法」「Python 版」「链表、冒泡、选择、插入、归并、桶排序、计数排序、基数排序</a></p><h3 id="3-5-环形链表"><a href="#3-5-环形链表" class="headerlink" title="3.5 环形链表"></a>3.5 环形链表</h3><h4 id="3-5-1-题库列表"><a href="#3-5-1-题库列表" class="headerlink" title="3.5.1 题库列表"></a>3.5.1 题库列表</h4><blockquote> <ul><li> <p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank">160. 相交链表</a></p> </li><li> <p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank">141. 环形链表</a></p> <li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank">142. 环形链表 II</a></li></ul> </li></ul></blockquote> <p><strong>160. 相交链表</strong><br>题目描述：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p1, p2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:<span class="comment"># 退出的关键是：指向同一个指针（不是值相等），或者都指 None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                p1 = headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                p2 = headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p1<span class="comment"># 如果没有相等的那么nodeA==nodeB==null</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/036.6sj6veryvqs0.gif#pic_center" width = 48%><p><strong>141. 环形链表</strong><br>题目描述：给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 快指针在前面，所以只要判断快指针是否达到了队尾就可以</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/037.2x97g491nw60.gif#pic_center" width = 48%><p><strong>142. 环形链表 II</strong><br>题目描述：给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 快慢指针找重合点</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:<span class="comment"># 重合了，这个时候，从头来一个指针遍历</span></span><br><span class="line">                p1 = slow</span><br><span class="line">                p2 = head</span><br><span class="line">                <span class="keyword">while</span> p1 != p2:</span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    p2 = p2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> p2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span><span class="comment"># 没有环，返回 None</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/038.5kfy8p3vjk40.gif#pic_center" width = 48%><p><br></br></p><blockquote><p><font color=#9900CC><strong>终于小结完了，期待下一专题——二叉树，也期待各位小伙伴们一起来学习与交流！</font></strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/039.4anrfsp19o60.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>一文搞定常见的链表问题：<a href="https://leetcode.cn/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/">https://leetcode.cn/problems/linked-list-cycle/</a></li><li>链表常见问题解决思路：<a href="https://blog.csdn.net/weixin_43910851/article/details/105725577">https://blog.csdn.net/weixin_43910851&#x2F;article&#x2F;details&#x2F;105725577</a></li><li>一文通数据结构与算法之——链表+常见题型与解题策略+Leetcode经典题：<a href="https://blog.csdn.net/qq_42647903/article/details/120594925">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594925</a></li><li>两个技巧搞定常见面试链表题：<a href="https://blog.csdn.net/weixin_45750855/article/details/120065894#:~:text=%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7%E6%90%9E%E5%AE%9A%E5%8A%9B%E6%89%A3%E5%B8%B8%E8%A7%81%20%E9%93%BE%E8%A1%A8%20%E9%A2%98%201%201.%20%E6%8E%8C%E6%8F%A1%E5%93%91%E8%8A%82%E7%82%B9%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7%E5%AF%BC%E8%87%B4%E5%9C%A8%E6%88%91%E4%BB%AC%E5%AF%B9%E5%A4%B4%E7%BB%93%E7%82%B9%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%20%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%A4%B4%E8%8A%82%E7%82%B9%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E3%80%82,%E5%92%8C%20slow%EF%BC%8C%E5%88%9D%E5%A7%8B%E6%97%B6%E5%9D%87%E6%8C%87%E5%90%91%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82%20%E9%A6%96%E5%85%88%EF%BC%8C%E5%85%88%E8%AE%A9%20fast%20%E7%A7%BB%E5%8A%A8%20k%20%E6%AC%A1%E3%80%82%20">https://blog.csdn.net/weixin_45750855&#x2F;article&#x2F;details&#x2F;</a></li><li>算法面试题 | 链表问题总结：<a href="https://juejin.cn/post/6882370280946302983">https://juejin.cn/post/6882370280946302983</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇信息量巨大，首先对比链表和数组，接着解决单链表的反转、删除某一节点、插入数据、查找中间节点、求倒数第k个结点、对称链表、单链表是否有环、两个链表是否相交，最后用LeetCode上的真题来实战删除链表结点、反转链表、合并、排序、环形链表常用技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="反转链表" scheme="https://qxienote.com/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
    <category term="合并链表" scheme="https://qxienote.com/tags/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    
    <category term="排序链表" scheme="https://qxienote.com/tags/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    
    <category term="环形链表" scheme="https://qxienote.com/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>《计算机网络-自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</title>
    <link href="https://qxienote.com/article/396f3774.html"/>
    <id>https://qxienote.com/article/396f3774.html</id>
    <published>2023-06-11T03:09:59.000Z</published>
    <updated>2023-06-11T03:43:49.329Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。</p><span id="more"></span><p>要深入理解网络协议，需要仔细观察协议实体之间交换的报文序列。为探究协议操作细节，可使协议实体执行某些动作，观察这些动作及其影响。这些任务可以在仿真环境下或在如因特网这样的真实网络环境中完成。观察在正在运行协议实体间交换报文的基本工具被称为分组嗅探器(<code>packet sniffer</code>)。顾名思义，一个分组嗅探器捕获（嗅探）计算机发送和接收的报文。一般情况下，分组嗅探器将存储和显示出被捕获报文的各协议头部字段内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.6gwpvo7pots0.webp#pic_center" width = 48%><p>上图右边是计算机上正常运行的协议（在这里是因特网协议）和应用程序（如：<code>Web</code> 浏览器和 <code>ftp</code> 客户端）。分组嗅探器（虚线框中的部分）是附加在计算机普通软件上的，主要由两部分组成。分组捕获库接收计算机发送和接收的每一个链路层帧的拷贝。高层协议（如：<code>HTTP</code>、 <code>FTP</code>、 <code>TCP</code>、 <code>UDP</code>、 <code>DNS</code>、 <code>IP</code> 等）交换的报文都被封装在链路层帧(Frame)中，并沿着物理介质（如以太网的电缆）传输。上图假设所使用的物理媒体是以太网，上层协议的报文最终封装在以太网帧中。</p><p>分组嗅探器的第二个组成部分是分析器。分析器用来显示协议报文所有字段的内容。为此，分析器必须能够理解协议所交换的所有报文的结构。例如：我们要显示上图中 HTTP 协议所交换的报文的各个字段。分组分析器理解以太网帧格式，能够识别包含在帧中的 IP 数据报。分组分析器也要理解 IP 数据报的格式，并能从 IP 数据报中提取出 TCP 报文段。然后，它需要理解 TCP 报文段，并能够从中提取出 HTTP 消息。最后，它需要理解 HTTP 消息。</p><p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和Linux&#x2F;Unix计算机上运行，是进行网络实验的理想分组分析器。该软件具有庞大的用户基础，文档支持包括用户指南、手册和常见问题(详见<a href="http://www.wireshark.org/docs">http://www.wireshark.org/docs</a>)，丰富的功能包括分析数百种协议，以及精心设计的用户界面。可以运行在使用以太网、串行(PPP和SLIP)、802.11无线局域网和许多其他链路层技术的计算机上。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.6fvhzc6qeb40.webp#pic_center" width = 48%><p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark。</p><h2 id="1-下载并安装Wireshark软件"><a href="#1-下载并安装Wireshark软件" class="headerlink" title="1 下载并安装Wireshark软件"></a>1 下载并安装Wireshark软件</h2><p>WireShark 是一种可以运行在 Windows，UNIX，Linux 等操作系统上的分组分析器。运行Wireshark，需要有一台支持Wireshark和libpcap或WinPCap分组捕获库的计算机。安装Wireshark时，如果操作系统中未安装libpcap软件，它将会自动安装。支持的操作系统和下载站点的列表，请访问[<a href="http://www.wireshark.org/download.html]">http://www.wireshark.org/download.html]</a>(<a href="http://www.wireshark.org/download.html%E3%80%82%E6%8C%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E6%8C%89%E7%85%A7%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E4%B8%80%E8%B7%AFNext%E5%AE%89%E8%A3%85%E3%80%82">http://www.wireshark.org/download.html。按照系统版本选择下载，下载完成后，按照软件提示一路Next安装。</a></p><p> <strong>温馨提示：</strong> 当您在安装或运行Wireshark时遇到问题时，可以查看Wireshark FAQ，它包含一些有用的提示和信息。如果你是Win10系统，安装完成后，选择抓包但是不显示网卡，下载win10pcap兼容性安装包。下载路径：<a href="http://www.win10pcap.org/download/">下载路径：win10pcap兼容性安装包</a></p><h2 id="2-Wireshark-开始抓包示例"><a href="#2-Wireshark-开始抓包示例" class="headerlink" title="2 Wireshark 开始抓包示例"></a>2 Wireshark 开始抓包示例</h2><p>1、双击桌面上的图标，可启动Wireshark。启动后的用户界面如下图所示，中间列表部分列出了所有网络接口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.38sj0cnbnum0.webp#pic_center" width = 48%><p>2、选择菜单栏上捕获 -&gt; 选项，勾选WLAN网卡（这里需要根据各自电脑网卡使用情况选择，简单的办法可以看使用的IP对应的网卡）。点击Start。启动抓包。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4qe115vaeae0.webp#pic_center" width = 48%><p>3、wireshark启动后，wireshark处于抓包状态中。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.3la44n2lec40.webp#pic_center" width = 48%><p>4、执行需要抓包的操作，如在cmd窗口下执行<code>ping www.baidu.com</code>。</p><p>5、抓取分组操作</p><p>A.单击中间网络接口列表中，某一网络接口如<code>eth0</code>，选中网络接口，通过菜单“捕获”-“开始”或工具栏中的<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 按钮，开始捕获选定接口中的网络分组；B．也可以双击中间网络接口列表中，某一网络接口如<code>eth0</code>，可以开始抓取分组；C．通过菜单“捕获”-“停止”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 停止抓取分组。D．通过菜单“捕获”-“重新开始”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 重新开始抓取。</p><p>6、Wireshark窗口功能</p><p><strong>A．命令菜单和工具栏</strong><br>命令菜单位于窗口的最顶部，是标准的下拉式菜单。最常用菜单命令有两个： 文件、 捕获。 文件 菜单允许你保存捕获的分组数据，或打开一个已被保存的捕获分组数据文件，或退出 WireShark 程序。 捕获 菜单允许你开始捕获分组。</p><p>工具栏位于命令菜单的下方，提供常用功能的快捷方式。如<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：开始捕获、<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：停止捕获、<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：重新抓取分组。</p><p><strong>B．显示过滤规则</strong></p><p>在该字段中，可以填写协议的名称或其他信息，根据此内容可以对分组列表窗口中的分组进行过滤。</p><p><strong>C．捕获分组列表</strong></p><p>按行显示已被捕获的分组内容，其中包括： WireShark 赋予的分组序号、捕获时间、分组的源地址和目的地址、协议类型、分组中所包含的协议说明信息。单击某一列的列名，可以使分组按指定列进行排序。 在该列表中，所显示的协议类型是发送或接收分组的最高层协议的类型。</p><p><strong>D．分组头部明细</strong></p><p>显示捕获分组列表窗口中被选中分组的头部详细信息。包括：与以太网帧有关的信息，与包含在该分组中的 IP 数据报有关的信息。</p><p>单击以太网帧或 IP 数据报所在行左边的向右或向下的箭头可以展开或最小化相关信息。如果利用 TCP 或 UDP 承载分组， WireShark 也会显示 TCP 或 UDP 协议头部信息。分组最高层协议的头部字段也会显示在此窗口中。</p><p><strong>E．分组内容窗口</strong></p><p>以 ASCII 码和十六进制两种格式显示被捕获帧的完整内容。</p><p>7、通常，分组列表窗口中会显示许多类型的分组。即使仅仅是下载了一个网页，但是还有许多其他协议在您的计算机上运行，只是用户所看不见。可以在中间过滤窗口中输入过滤的分组协议如http， 选择应用按钮，就可以只让HTTP分组消息显示在分组列表窗口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.4x7p2hmwhiw0.webp#pic_center" width = 48%><p>8、操作完成后相关数据包就抓取到了。为避免其他无用的数据包影响分析，可以通过在过滤栏设置过滤条件进行数据包列表过滤，获取结果如下。说明：<code>ip.addr == 119.75.217.26 and icmp</code> 表示只显示ICPM协议且源主机IP或者目的主机IP为<code>119.75.217.26</code>的数据包。说明：协议名称icmp要小写。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.sm5aj8usjww.webp#pic_center" width = 48%><h2 id="3-Wireshakr抓包界面介绍"><a href="#3-Wireshakr抓包界面介绍" class="headerlink" title="3 Wireshakr抓包界面介绍"></a>3 Wireshakr抓包界面介绍</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.61b2vxymuhg0.webp#pic_center" width = 36%><p>说明：数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏 视图(View) –&gt; 着色规则(Coloring Rules)。如下所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.4owrci6ggh00.webp#pic_center" width = 48%><ol><li>显示过滤器(Display Filter)，用于设置过滤条件进行数据包列表过滤。菜单路径：分析(Analyze) –&gt; 显示过滤器(Display Filters)。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.726v80qr0vg0.webp#pic_center" width = 48%><ol><li>数据包列表(Packet List Pane)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。</li></ol><p>Time:时间；Source:发送主机IP地址；Destination: 接收主机IP地址；Protocol：分组协议；Length：分组长度；Info：分组内容</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.7829pakw1us0.webp#pic_center" width = 48%><ol><li>数据包详细信息(Packet Details Pane), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为<br>（1）Frame:   物理层的数据帧概况<br>（2）Ethernet II: 数据链路层以太网帧头部信息<br>（3）Internet Protocol Version 4: 互联网层IP包头部信息<br>（4）Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP<br>（5）Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.4xs9wudqaak0.webp#pic_center" width = 48%><p>TCP包的具体内容</p><p>从下图可以看到wireshark捕获到的TCP包中的每个字段。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.2sybmlwvjy00.webp#pic_center" width = 48%><ol><li>数据包字节区(Dissector Pane)。</li></ol><p>在分组内容窗口中，可以显示出该分组内容的16进制和ASCII两种格式的内容。鼠标指向内容窗口，可以将分组中某一字段的内容突出显示。在分组头部信息窗口中，展开选择某一头部信息时，分组内容中相应内容同步突出显示。</p><h2 id="4-Wireshark过滤器设置"><a href="#4-Wireshark过滤器设置" class="headerlink" title="4 Wireshark过滤器设置"></a>4 Wireshark过滤器设置</h2><p>初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己需要抓取的数据包部分。wireshark工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p><p><strong>1) 抓包过滤器</strong></p><p>捕获过滤器的菜单栏路径为Capture –&gt; Capture Filters。用于在抓取数据包前设置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.6uzm0lq7h800.webp#pic_center" width = 48%><p>如何使用？可以在抓取数据包前设置如下。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.5zbhvy2gomw0.webp#pic_center" width = 48%><p><code>ip host 60.207.246.216 and icmp</code> 表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.2k7fnwqaoo20.webp#pic_center" width = 48%><p><strong>（2）显示过滤器</strong></p><p>显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛或者没有设置导致抓取的数据包内容较多时使用显示过滤器设置条件过滤以方便分析。同样上述场景，在捕获时未设置抓包过滤规则直接通过网卡进行抓取所有数据包，如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.1p43gtotb00w.webp#pic_center" width = 48%><p>执行 <code>ping www.baidu.com</code> 获取的数据包列表如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.2hu9htl72eo0.webp#pic_center" width = 48%><p>观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。<code>ip.addr == 14.119.104.254 and icmp</code>。并进行过滤。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.4q6cjmtdeei0.webp#pic_center" width = 48%><p>上述介绍了抓包过滤器和显示过滤器的基本使用方法。在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。下面介绍一下两者间的语法以及它们的区别。</p><h2 id="5-wireshark过滤器表达式的规则"><a href="#5-wireshark过滤器表达式的规则" class="headerlink" title="5 wireshark过滤器表达式的规则"></a>5 wireshark过滤器表达式的规则</h2><p>1、抓包过滤器语法和实例</p><p>抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）</p><p>(1) 协议过滤</p><p>比较简单，直接在抓包过滤框中直接输入协议名即可。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><p>(2) IP过滤</p><ul><li>host 192.168.1.104</li><li>src host 192.168.1.104</li><li>dst host 192.168.1.104</li></ul><p>(3) 端口过滤</p><ul><li>port 80</li><li>src port 80</li><li>dst port 80</li></ul><p>(4) 逻辑运算符 &amp;&amp; 与、|| 或、！非</p><ul><li><code>src host 192.168.1.104 &amp;&amp; dst port 80</code> 抓取主机地址为192.168.1.80、目的端口为80的数据包</li><li><code>host 192.168.1.104 || host 192.168.1.102</code> 抓取主机为192.168.1.104或者192.168.1.102的数据包</li><li><code>!broadcast</code> 不抓取广播数据包</li></ul><p>2、显示过滤器语法和实例<br>(1) 比较操作符</p><p>比较操作符有&#x3D;&#x3D; 等于、！&#x3D; 不等于、&gt; 大于、&lt; 小于、&gt;&#x3D; 大于等于、&lt;&#x3D;小于等于。</p><p>(2) 协议过滤</p><p>比较简单，直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(3) ip过滤</p><ul><li><code>ip.src ==192.168.1.104</code>，显示源地址为192.168.1.104的数据包列表</li><li><code>ip.dst==192.168.1.104</code>，显示目标地址为192.168.1.104的数据包列表</li><li><code>ip.addr == 192.168.1.104</code>，显示源IP地址或目标IP地址为192.168.1.104的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(4) 端口过滤</p><ul><li>tcp.port &#x3D;&#x3D;80,  显示源主机或者目的主机端口为80的数据包列表。</li><li>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的源主机端口为80的数据包列表。</li><li>tcp.dstport &#x3D;&#x3D; 80，只显示TCP协议的目的主机端口为80的数据包列表。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/042.4ni1tou9im80.webp#pic_center" width = 48%><p>(5) Http模式过滤</p><p><code>http.request.method==&quot;GET&quot;</code>, 只显示HTTP GET方法的。</p><p>(6) 逻辑运算符为 and&#x2F;or&#x2F;not</p><p>过滤多个条件组合时，使用and&#x2F;or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为 <code>ip.addr == 14.119.104.254 and icmp</code></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.oe0q389yzmo.webp#pic_center" width = 48%><p>(7) 按照数据包内容过滤。假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.2eq42rto5h34.webp#pic_center" width = 48%><p>右键单击选中后出现如下界面</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.9tlmp06f5y8.webp#pic_center" width = 48%><p>选中Select后在过滤器中显示如下，后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含”abcd”内容的数据流。包含的关键词是contains 后面跟上内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4v5jwne3bpq0.webp#pic_center" width = 48%><p>调整数据包列表中时间戳显示格式。调整方法为View –&gt;Time Display Format –&gt; Date and Time of Day。调整后格式如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.3f70teoime8.webp#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>wireshark 基本使用：<a href="https://www.educoder.net/shixuns/5kuyi2hn/challenges">https://www.educoder.net/shixuns/5kuyi2hn/challenges</a></li><li>wireshark抓包新手使用教程：<a href="https://www.cnblogs.com/linyfeng/p/9496126.html">https://www.cnblogs.com/linyfeng/p/9496126.html</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络-自顶向下方法" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Wireshark" scheme="https://qxienote.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十）-- 链表的实现</title>
    <link href="https://qxienote.com/article/4e528de2.html"/>
    <id>https://qxienote.com/article/4e528de2.html</id>
    <published>2023-06-11T03:09:20.000Z</published>
    <updated>2023-06-11T09:57:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要学习使用Python实现链表，包括链表增加元素、删除元素、扫描、定位、遍历，以及循环单链表和双链表的实现。</p><span id="more"></span><p>实现线性表的另一种常用方式就是基于链接结构，用链接关系显式表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或者链表。</p><p>采用链接方式实现线性表的基本想法如下:</p><ul><li>把表中的元素分别存储在一批独立的存储块（称为表的结点）里。</li><li>保证从组成表结构中的任一个结点可找到与其相关的下一个结点。</li><li>在前一结点里用链接的方式显式地记录与下一结点之间的关联。</li></ul><p>这样，只要能找到组成一个表结构的第一个结点，就能顺序找到属于这个表的其他结点。从这些结点里可以看到这个表中的所有元素。</p><p>链接技术是一类非常灵活的数据组织技术，实现链表有多种不同的方式。下面首先讨论最简单的单链表，其中在每个表结点里记录着存储下一个表元素的结点的标识(引用&#x2F;链接)。后面将介绍另外一些结构的链表，它们各有所长，支持不同的需要。在下面的讨论中，将把“存储着下一个表元素的结点”简称为“下一结点”。</p><h2 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1 单链表"></a>1 单链表</h2><p>单向链接表（下面将简称为单链表或者链表）的结点是一个二元组，形式如下图a所示，其表元素域 elem 保存着作为表元素的数据项（或者数据项的关联信息），链接域 next 里保存同一个表里的下一个结点的标识。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6urmjtr0pm4.webp#pic_center" width = 48%><p>在最常见形式的单链表里，与表里的n个元素对应的n个结点通过链接形成一条结点链，如上图b所示。从引用表中首结点的变量（上图b中变量p）可以找到这个表的首结点，从表中任一结点可以找到保存着该表下一个元素的结点（表中下一结点），这样，从p出发就能找到这个表里的任一个结点。</p><p>要想掌握一个单链表，就需要（也只需要）掌握这个表的首结点，从它出发可以找到这个表里的第一个元素（即在这个表结点里保存的数据，保存在它的 elem域中），还可以找到这个表里的下一结点（有关信息保存在这个结点的 next 域中）。按照同样的方式继续下去，就可以找到表里的所有数据元素。</p><p>也就是说，为了掌握一个表，只需要用一个变量保存着这个表的首结点的引用（标识或称为链接）。今后将把这样的变量称为<font color=#9900CC><strong>表头变量或表头指针</font></strong>。</p><p><strong>小结一下：</strong></p><ul><li>—个单链表由一些具体的表结点构成。</li><li>每个结点是一个对象，有自己的标识，下面也常称其为该结点的链接。</li><li>结点之间通过结点链接建立起单向的顺序联系。</li></ul><p>为了表示一个链表的结束，只需给表的最后结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（称为空链接），在 Python 里自然可以用系统常量 None 表示这种情况，在上图里用接地符号“丄”表示链表结束，下面将一直这样表示。</p><p>通过判断一个（域或变量的）值是否为空链接，可知是否已到链表的结束。在顺序扫描表结点时，应该用这种方法确定操作是否完成。如果一个表头指针的值是空链接，就说明“它所引用的链表已经结束”，这是没有元素就已结束，说明该表是空表。</p><p>在实现链表上的算法时，并不需要关心在某个具体的表里各结点的具体链接值是什么（虽然保存在表结构里的值都是具体的），只需要关心链表的逻辑结构。对链表的操作也只需要根据链表的逻辑结构考虑和实现。</p><p>为方便下面的讨论，现在定义个简单的表结点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, elem=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.elem = elem    </span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h3><p> <strong>创建空链表：</strong> 只需要把相应的表头变量设置为空链接，在Python语言中将其设置为None，在其他语言里也有惯用值，例如有的语言里用0作为这个特殊值。</p><p> <strong>删除链表：</strong> 应丢弃这个链表里的所有结点。这个操作的实现与具体的语言环境有关。在一些语言（如C语言）里，需要通过明确的操作释放一个个结点所用的存储。在Python语言中这个操作很简单，只需简单地将表指针赋值为None，就抛弃了链表原有的所有结点。Python解释器的存储管理系统会自动回收不用的存储。</p><p> <strong>判断表是否为空：</strong> 将表头变量的值与空链接比较。在Python语言中，就是检查相应变量的值是否为None.</p><p> <strong>判断表是否满：</strong> 一般而言链表不会满，除非程序用完了所有可用的存储空间。</p><p><strong>加入元素</strong></p><p>现在考虑给单链表加入元素的操作，同样有插入位置问题，可以做首端插入、尾端插人或者定位插人。不同位置的操作复杂度可能不同。</p><p>首先应该注意，在链表里加入新元素时，并不需要移动已有的数据，只需为新元素安排一个新结点，然后根据操作要求，把新结点连在表中的正确位置。也就是说，插入新元素的操作是通过修改链接，接入新结点，从而改变表结构的方式实现的。</p><p><strong>表首端插入：</strong> 首端插入元素要求把新数据元素插入表中，作为表的第一个元素，这是最简单的情况。这一操作需要通过三步完成：</p><ol><li>创建一个新结点并存入数据（下图a表示要向表头变量 head 的链表加入新首元素13，为它创建了新结点，变量q指着该结点。这是实际插入前的状态）。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.1nk62pq0gjvk.webp#pic_center" width = 48%><ol><li><p>把原链表首结点的链接存入新结点的链接域 next，这一操作将原表的一串结点链接在刚创建的新结点之后。</p></li><li><p>修改表头变量，使之指向新结点，这个操作使新结点实际成为表头变量所指的结点，即表的首结点（上图b表示设置链接的这两步操作完成后的状态，新结点已成为 head 所指链表的首结点，13成为这个表的首元素。注意，示意图中链接指针的长度和形状都不表示任何意义，只有图中的链接指向关系有意义）。</p></li></ol><p>注意，即使在插入前head指向的是空表，上面三步也能正确完成工作。这个插人只是一次安排新存储和几次赋值，操作具有常量时间复杂度。</p><p>示例代码段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = ListNode(<span class="number">13</span>)</span><br><span class="line">q.<span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">head = q</span><br></pre></td></tr></table></figure><p> <strong>一般情况的元素插入：</strong> 要想在单链表里的某位置插入一个新结点，必须先找到该位置之前的那个结点，因为新结点需要插入在它的后面，需要修改它的next 域。如何找到这个结点的问题将在后面讨论，先看已经找到了这个结点之后怎样插入元素。</p><p>设变量pre已指向要插入元素位置的前一结点，操作也分为三步:</p><ol><li>创建一个新结点并存入数据（下图a是实际插入前的状态）。</li><li>把 pre 所指结点 next 域的值存入新结点的链接域 next，这个操作将原表在 pre 所指结点之后的一段链接到新结点之后。</li><li>修改 pre 的 next 域，使之指向新结点，这个操作把新结点链入被操作的表，整个操作完成后的状态如下图b所示。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.4nd11m338680.webp#pic_center" width = 48%><p>注意，即使在插入前 pre 所指结点是表中最后一个结点，上述操作也能将新结点正确接入，作为新的表尾结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = ListNode(<span class="number">13</span>)</span><br><span class="line">q.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">pre.<span class="built_in">next</span> = q</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><p>删除链表中元素，也可通过调整表结构删除表中结点的方式完成。这里也区分两种情况：删除表头结点的操作可以直接完成，删除其他结点也需要掌握其前一结点。</p><p> <strong>删除表首元素：</strong> 删除表中第一个元素对应于删除表的第一个结点，为此只需修改表头指针，令其指向表中第二个结点。丢弃不用的结点将被Python解释器自动回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>一般情况的元素删除：一般情况删除须先找到要删元素所在结点的前一结点，设用变量pre指向，然后修改pre的next域，使之指向被删结点的下一结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>显然，这两个操作都要求被删结点存在。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.11jtua2aafu8.webp#pic_center" width = 48%><p>如果在其他编程语言里删除结点，还可能要自己释放存储。Python的自动存储管理机制能自动处理这方面的问题，使编程工作更简单，也保证了安全性。</p><p><strong>扫描、定位和遍历</strong></p><p>在一般情况下插入和删除元素，都要求找到被删结点的前一结点。另外，程序里也可能需要定位链表中的元素、修改元素、逐个处理其中元素等。这些操作都需要检查链表的内容，实际上是检查表中的一些（或全部）结点。</p><p>由于单链表只有一个方向的链接，开始情况下只有表头变量在掌握中，所以对表内容的一切检查都只能从表头变量开始，沿着表中链接逐步进行。这种操作过程称为链表的扫描，这种过程的基本操作模式是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> 还需继续的其他条件:</span><br><span class="line">    对p所指结点里的数据做所需操作</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>根据Python语言的规定，这里的 <code>p is not None</code> 可以简单地只写一个 <code>p</code>。</p><p>循环的继续（或结束）条件、循环中的操作由具体问题决定。循环中使用的辅助变量p称为<font color=#9900CC><strong>扫描指针</font></strong>。注意，每个扫描循环必须用一个扫描指针作为控制变量，每步迭代前必须检查其值是否为None，保证随后操作的合法性。这与连续表的越界检查类似。</p><p>上面表扫描模式是最一般的链表操作模式，下面介绍几个常用操作的实现。</p><p> <strong>按下标定位：</strong> 按 Python 惯例，链表首结点的元素应看作下标0，其他元素依次排列。确定第i个元素所在结点的操作称为按下标定位，可以参考表扫描模式写出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> NOne <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>假设循环前变量i已有所需的值，循环结束时可能出现两种情况：或者扫描完表中所有结点还没有找到第i个结点，或者p所指结点就是所需。通过检查 p 值是否为None可以区分这两种情况。显然，如果现在需要删除第k个结点，可以先将i设置为k-1，循环后检查i是0且p.next不是None就可以执行删除了。</p><p> <strong>按元素定位：</strong> 假设需要在链表里找到满足谓词pred的元素。同样可以参考上面的表扫描模式，写出的检索循环如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> pred(p.elem):</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>循环结束时或者p是None；或者 <code>pred(p.elem)</code> 是 True，找到了所需元素。</p><p>完整的扫描称为遍历，这样做通常是需要对表中每个元素做一些事情，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(p.elem)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>这个循环依次输出表中各元素。只以条件 <code>p is not None</code> 控制循环，就能完成一遍完整的遍历。同样模式可用于做其他工作。</p><p><strong>链表操作的复杂度</strong><br>总结一下链表操作的时间复杂度。</p><ul><li><p>创建空表：$O(1)$。</p></li><li><p>删除表：在Python里是$O(1)$。当然，Python 解释器做存储管理也需要时间。</p></li><li><p>判断空表：$O(1)$。</p></li><li><p>加入元素（都需要加一个T(分配)的时间）</p><ul><li>首端加入元素：$O(1)$。</li><li>尾端加入元素：$O(n)$、因为需要找到表的最后结点。</li><li>定位加人元素：$O(n)$，平均情况和最坏情况。</li></ul></li><li><p>删除元素:</p><ul><li>首端删除元素：$O(1)$。</li><li>尾端删除元素：$O(n)$。</li><li>定位删除元素：$O(n)$，平均情况和最坏情况。</li><li>其他册除：通常需要扫描整个表或其一部分$O(n)$。</li></ul></li></ul><p>扫描、定位或遍历操作都需要检查一批表结点，其复杂度受到表结点数的约束，都是 $O(n)$ 操作。其他在工作中有此类行为的操作也至少具有 $O(n)$ 时间复杂度。</p><p><strong>求表的长度</strong></p><p>在使用链表时，经常需要求表的长度，为此可以定义一个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, n = head, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p>这个函数采用表扫描模式，遍历表中所有结点完成计数。显然，这个求表长度的算法所用时间与表结点个数成正比，具有 $O(n)$ 时间复杂度。</p><p><strong>实现方式的变化</strong></p><p>以求表的长度为例，如果程序经常需要调用上面函数，$O(n)$ 复杂度就可能成为效率问题。如果表很长，执行该函数就可能造成可察觉的停顿。解决这个问题的一种方法是改造单链表的实现结构，增加一个表长度记录。显然，这个记录不属于任何表元素，是有关表的整体的信息。表示这件事的恰当方法是定义一种链表对象，把表的长度和表中的结点链表都作为这个表对象的数据成分，如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.1og2k56a4zvk.webp#pic_center" width = 48%><p>图中变星p指向表对象，这个对象的一个数据域记录表中元素个数（图中的20表示这个表当时有20个结点），另一个域引用着该表的结点链。采用了这种表示方式，求表长度的操作就可以简单返回元素计数域的值。但另一方面，这种表的每个变动操作都需要维护计数值。从整体看有得有失。这种调整消除了一个线性时间操作，可能在一些应用中很有意义。</p><h3 id="1-2-单链表类的实现"><a href="#1-2-单链表类的实现" class="headerlink" title="1.2 单链表类的实现"></a>1.2 单链表类的实现</h3><p><strong>自定义异常</strong></p><p>为能合理地处理一些链表操作中遇到的错误状态（例如，方法执行时遇到了无法操作的错误参数），首先为链表类定义一个新的异常类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListUnderflow</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里把LinkedListUnderflow定义为标准异常类valueError的子类，准备在空表访问元索等场合抛出这个异常。在这些情况下抛出 valueError 也没问题，但定义了自己的异常类，就可以写专门的异常处理器，在一些情况下可能有用。</p><p><strong>LList类的定义，初始化函数和简单操作</strong></p><p>现在基于结点类 ListNode 定义一个单链表对象的类，在这种表对象里只有一个引用链接结点的_head域，初始化为None表示建立的是一个空表。判断表空的操作检查_head；在表头插入数据的操作是prepend，它把包含新元素的结点链接在最前面；操作 pop 删除表头结点并返回这个结点里的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self, elem</span>):</span><br><span class="line">        self._head = ListNode(elem, self._head)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:      <span class="comment"># 无结点，引发异常</span></span><br><span class="line">            <span class="keyword">raise</span> LinkedListUnorderflow(<span class="string">&quot;in pop&quot;</span>)</span><br><span class="line">        e = self._head.elem</span><br><span class="line">        self._head = self._head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure><p>这里把 LList 对象的 <code>_head</code> 域作为对象的内部表示，不希望外部使用。上面定义里的几个操作都很简单，只有 pop 操作需要检查对象的状态，表中无元素时引发异常。</p><p><strong>后端操作</strong></p><p>在链表的最后插入元素，必须先找到链表的最后一个结点。其实现首先是一个扫描循环，找到相应结点后把包含新元素的结点插入在其后。下面是定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, elem</span>):</span><br><span class="line">    <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._head = ListNone(elem)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    p.<span class="built_in">next</span> = ListNode(elem)</span><br></pre></td></tr></table></figure><p>这里需要区分两种情况：如果原表为空，引用新结点的就应该是表对象的_head域，否则就是已有的最后结点的next域。两种情况下需要修改的数据域不一样。许多链表变动操作都会遇到这个问题，只有表首端插入&#x2F;删除可以统一处理。</p><p>现在考虑删除表中最后元素的操作，也就是要删除最后的结点。前面说过，要从单链表中删除一个结点，就必须找到它的前一结点。在尾端删除操作里，扫描循环应该找到表中倒数第二个结点，也就是找到<code>p.next.next</code>为None的p。下面定义的<code>pop_last</code>函数不仅删去表中最后元素，还把它返回（与pop统一）。</p><p>在开始一般性扫描之前，需要处理两个特殊情况：如果表空没有可返回的元素时应该引发异常。表中只有一个元素的情况需要特殊处理，因为这时应该修改表头指针。一般情况是先通过循环找到位置，取出最后结点的数据后将其删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop_last</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:      <span class="comment"># 空表</span></span><br><span class="line">        <span class="keyword">raise</span> LinkeListUnderflow(<span class="string">&quot;in pop_last&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:          <span class="comment"># 表中只有一个元素</span></span><br><span class="line">        e = p.elem</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 直到p.next是最后结点</span></span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    e = p.<span class="built_in">next</span>.elem</span><br><span class="line">    p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure><p>LList类的下一个方法是找到满足给定条件的表元素。这个方法有一个参数，调用时通过参数提供一个判断谓词，该方法返回第一个满足谓词的表元素。显然，这个操作也需要采用前面的基本扫描模式。定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, pred</span>):</span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> pred(p.elem):</span><br><span class="line">            <span class="keyword">return</span> p.elem</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>最后一个方法非常简单，但实际中可能很有用。在开发一个表类的过程中，人们会经常想看看被操作的表的当时情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_all</span>(<span class="params">self</span>):</span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(p.elem, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;, &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 单链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="comment"># item 存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># next 下一个节点的标识</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkList</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取链表长度&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head        <span class="comment"># cur 初始时指向头结点</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:              <span class="comment"># 尾结点指向None，遍历结束</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>      <span class="comment"># 将cur后移一个节点</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)         <span class="comment"># 先创建一个保存 item 值的节点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self._head          <span class="comment"># 将新节点的链接域 next 指向头节点，即 _head 指向的位置</span></span><br><span class="line">        self._head = node               <span class="comment"># 将链表的头 _head 指向新节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="comment"># 若不为空，则找到尾部，将尾结点的 next 指向新节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向链表指定位置添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">            <span class="comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length() - <span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 找到指定位置</span></span><br><span class="line">            pre = self._head    <span class="comment"># pre 用来指向指定位置pos前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            <span class="keyword">while</span> count &lt; pos-<span class="number">1</span>:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">            node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:            <span class="comment"># 找到指定元素</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:                 <span class="comment"># 如果第一个就是删除节点</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span>   <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>     <span class="comment"># 将删除位置的前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 继续后移节点</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表查找节点是否存在，并返回True或者False&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l1 = SingleLinkList()</span><br><span class="line">    l1.add(<span class="number">1</span>)</span><br><span class="line">    l1.add(<span class="number">2</span>)</span><br><span class="line">    l1.append(<span class="number">3</span>)</span><br><span class="line">    l1.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())<span class="comment"># 4</span></span><br><span class="line">    l1.travel()<span class="comment"># 3 -&gt; 4 -&gt; 1 -&gt; 2</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">3</span>))<span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">5</span>))<span class="comment"># False</span></span><br><span class="line">    l1.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())<span class="comment"># 3</span></span><br><span class="line">    l1.travel()<span class="comment"># 3 -&gt; 4 -&gt; 2</span></span><br></pre></td></tr></table></figure><h2 id="2-循环单链表"><a href="#2-循环单链表" class="headerlink" title="2 循环单链表"></a>2 循环单链表</h2><p>单链表的另一常见变形是循环单链表（简称循环链表），其中最后一个结点的next域不用None，而是指向表的第一个结点，如下图a所示。但如果仔细考虑，就会发现在链表对象里记录表尾结点更合适（如下图b），这样可以同时支持 $O(1)$ 时间的表头&#x2F;表尾插入和 $O(1)$ 时间的表头删除。当然，由于循环链表里的结点连成一个圈，哪个结点算是表头或表尾，主要是概念问题，从表的内部形态上无法区分。</p><p>循环单链表操作与普通单链表的差异就在于扫描循环的结束控制。易见，一些不变操作的实现也要修改，如 printall。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.4t7xsu8n7s00.webp#pic_center" width = 64%><p>这种表对象只需一个数据域 _rear，它在逻辑上始终引用着表的尾结点。前端加入结点，就是在尾结点和首结点之间加人新的首结点，尾结点引用不变。通过尾结点引用很容易实现这个操作。另一方面，尾端加入结点也是在原尾结点之后（与首结点之间）插人新结点，只是插入后要把它作为新的尾结点，因此需要更新尾结点引用。这两个操作都要考虑空表插入的特殊情况。对于输出表元素的操作，关键在于循环结束的控制。下面实现中比较扫描指针与表头结点的标识，到达了表头结点就结束。前端弹出操作也很容易实现，后端弹出操作需要通过一个扫描循环确定位置。</p><p>下面循环单链表类定义只实现了几个典型方法，供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 单向循环链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinCycLinkedList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():     <span class="comment"># 如果链表长度为空，返回长度0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="built_in">print</span>(cur.item)</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部添加节点&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head      <span class="comment"># 添加的节点指向_head </span></span><br><span class="line">            cur = self._head            <span class="comment"># 移到链表尾部，将尾部的节点的 next指向node</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="comment"># _head 指向添加的node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部添加节点&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head        <span class="comment"># 移到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node         <span class="comment"># 将尾结点指向node</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head  <span class="comment"># 将node指向头节点_head</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除一个节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():     <span class="comment"># 若链表为空直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head        <span class="comment"># 将cur指向头节点</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:    <span class="comment"># 若头结点的元素就是要查找的元素item</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> != self._head:  </span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:   <span class="comment"># 先找到尾结点，将尾结点的next指向第二个节点</span></span><br><span class="line">                    cur = cur.<span class="built_in">next</span>      </span><br><span class="line">                cur.<span class="built_in">next</span> = self._head.<span class="built_in">next</span>      <span class="comment"># cur指向了尾结点</span></span><br><span class="line">                self._head = self._head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._head = <span class="literal">None</span>               <span class="comment"># 链表只有一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:        <span class="comment"># 第一个节点不是要删除的</span></span><br><span class="line">                <span class="keyword">if</span> cur.item == item:             <span class="comment"># 找到了要删除的元素</span></span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>          <span class="comment"># 删除</span></span><br><span class="line">                    <span class="keyword">return</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:                <span class="comment"># cur 指向尾结点</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>             <span class="comment"># 尾部删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l1 = SinCycLinkedList()</span><br><span class="line">    l1.add(<span class="number">1</span>)</span><br><span class="line">    l1.add(<span class="number">2</span>)</span><br><span class="line">    l1.append(<span class="number">3</span>)</span><br><span class="line">    l1.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    l1.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    l1.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())      <span class="comment"># 6</span></span><br><span class="line">    l1.travel()                         <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 6</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">3</span>))                 <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">7</span>))                 <span class="comment"># False</span></span><br><span class="line">    l1.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())      <span class="comment"># 5</span></span><br><span class="line">    l1.travel()                         <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 6</span></span><br></pre></td></tr></table></figure><h2 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3 双向链表"></a>3 双向链表</h2><p>单链表只有一个方向的链接，只能做一个方向的扫描和逐步操作。即使增加了尾结点引用，也只能支持 $O(1)$ 时间的首端元素加入&#x2F;删除和尾端加入。如果希望两端插入和删除操作都能高效完成，就必须修改结点（从而也是链表）的基本设计，加入另一方向的链接。这样就得到了双向链接表，简称双链表。有了结点之间的双向链接，不仅能支持两端的高效操作，一般结点操作也会更加方便。当然，这样做也需要付出代价：每个结点都需要增加一个链接域,增加的空间开销与结点数成正比，是 $O(n)$。如果每个表结点里的数据规模比较大，新增加的开销可能就显得不太重要了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.29pfjm7l0fr4.webp#pic_center" width = 48%><p>为了支持首尾两端的高效操作，双链表应该采用下图所示的结构，包含一个尾结点引用域。易见，从双链表中任一结点出发，可以直接找到其前后的相邻结点（都是 $O(1)$ 操作）。而对单链表而言，只能方便地找到下一个结点，要找前一结点，就必须从表头开始逐一检查（通过一次扫描）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.585qz3u8lv40.webp#pic_center" width = 36%><p>可以直接找到当前结点的前后结点，使得双链表的许多操作都很容易地进行。下面假定结点的下一结点引用域是next，前一结点引用域是prev。</p><p><strong>结点操作</strong></p><p>先考虑结点删除。实际上，只要掌握着双链表里一个结点，就可以把它从表中取下，并把其余结点正确链接好。下图说明了这个操作。示例代码是：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.6tfs63p4fuk0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.prev.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span>.prev = p.prev</span><br></pre></td></tr></table></figure><p>这两个语句使p所指结点从表中退出，其余结点保持顺序和链接。如果要考虑前后可能无结点的情况，只需增加适当的条件判断。</p><p>在任一结点的前后加入结点的操作也很容易局部完成，只需掌握确定加入位置的这个结点。易见，加入一个结点需要做四次引用赋值。</p><p><strong>指定位置插入节点</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.73x3h4o7cyg0.webp#pic_center" width = 48%><p><strong>完整代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 双向链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部插入元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node           <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head      <span class="comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            self._head.prev = node      <span class="comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head = node           <span class="comment"># 将_head 指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部插入元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node       <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head        <span class="comment"># 移动到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node         <span class="comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            node.prev = cur         <span class="comment"># 将node的prev指向cur</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):      <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.prev = cur             <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span>        <span class="comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = node        <span class="comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node             <span class="comment"># 将cur的next指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> == <span class="literal">None</span>:            <span class="comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                    self._head = <span class="literal">None</span>           <span class="comment"># 如果链表只有这一个节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span>.prev = <span class="literal">None</span>        <span class="comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span>       <span class="comment"># 将_head指向第二个节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span>    <span class="comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.<span class="built_in">next</span>.prev = cur.prev    <span class="comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, ll.length())   <span class="comment"># 6 </span></span><br><span class="line">    ll.travel()                     <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 6</span></span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">3</span>))             <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">4</span>))             <span class="comment"># True</span></span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, ll.length())   <span class="comment"># 5</span></span><br><span class="line">    ll.travel()                     <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要学习使用Python实现链表，包括链表增加元素、删除元素、扫描、定位、遍历，以及循环单链表和双链表的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="https://qxienote.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="循环单链表" scheme="https://qxienote.com/tags/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双链表" scheme="https://qxienote.com/tags/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（九）--单调栈与单调队列</title>
    <link href="https://qxienote.com/article/933f1d8e.html"/>
    <id>https://qxienote.com/article/933f1d8e.html</id>
    <published>2023-06-11T03:09:10.000Z</published>
    <updated>2023-06-11T09:38:22.082Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要以LeetCode上题目为例，合适的数据结构可以有效地降低算法的复杂度，本文分析单调栈和单调队列的使用技巧，以及如何在题目中灵活应用。</p><span id="more"></span><h2 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1 单调栈"></a>1 单调栈</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。</p><p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>用简洁的话来说就是：单调栈就是<font color=#9900CC><strong>栈内元素单调递增或者单调递减</strong></font>的栈，单调栈只能在栈顶操作。</p><p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。</p><p>比如说给一个数组 <code>arr = &#123; 5，4，6，7，2，3，0，1 &#125;</code>，我想知道每一个元素左边比该元素大且离得最近的元素和右边比该元素大且离得最近的元素都是什么。</p><p>如果数组有 $N$ 个元素，经典解法就是来到 $i$ 位置，左边遍历直到比 arr[i] 大的元素为止，右边遍历直到比 arr[i] 大的元素为止。确定一个位置的时间复杂度为 $O(N)$，确定 $N$ 个位置的时间复杂度就是 $O(N^2)$。</p><p>能不能将确定 $N$ 个位置的时间复杂度降到 $O(N)$？单调栈结构。</p><p>同样，如果使用单调栈能够找到每一个元素左边和右边比该元素大且离得最近的元素，同样也能找到每个元素左边和右边比该元素小且离得最近的元素。</p><h3 id="1-2-流程（无重复）"><a href="#1-2-流程（无重复）" class="headerlink" title="1.2 流程（无重复）"></a>1.2 流程（无重复）</h3><p>单调栈本身是支持数组中有重复值的，但是我们为了讲清原理，举得例子中数组是没有重复值的。</p><p>首先，准备一个栈。</p><p> &#x3D;&#x3D; 栈中存储的是数组中元素的下标。为什么不存储元素？是因为下标不仅仅能够表示元素，还能表示元素在数组中的位置，携带的信息更多。&#x3D;&#x3D;</p><p><font color=#9900CC><strong>如果要找到数组中每一个元素左右两边比该元素大且离得最近的元素，那么单调栈要保证从栈底到栈顶存储的下标对应的元素是从大到小的。</strong></font></p><p><font color=#9900CC><strong>如果要找到数组中每一个元素左右两边比该元素小且离得最近的元素，那么单调栈要保证从栈底到栈顶存储的下标对应的元素是从小到大的。</strong></font></p><p>本案例只找比该元素大且离得最近的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6frutsjjfw80.webp#pic_center" width = 64%><p>从头开始遍历数组：</p><ul><li>如果栈中没有元素，直接将元素的下标压栈。</li><li>如果栈中有元素，当前元素和栈顶的下标所指向的元素进行比较：<ul><li>当前元素比栈顶的下标所指向的元素小，将当前元素的下标压栈。</li><li>当前元素比栈顶的下标所指向的元素大，栈顶的下标弹栈，同时记录原栈顶下标对应的元素的信息。原栈顶下标对应的元素左边比该元素大且离得最近的元素就是在栈中原栈顶下标压在下面的相邻下标对应的元素；原栈顶下标对应的元素右边比该元素大且离得最近的元素就是让它的下标弹栈的下标对应的元素。记录完之后，当前元素继续和新栈顶下标对应的元素进行比较。如果栈中只有一个下标，则该下标左边没有比该下标对应的元素大且离得最近的元素，右边正常。</li></ul></li></ul><p>当数组遍历完后，如果栈中还有下标，则进入清算阶段：</p><ul><li>如果不是最后一个下标，依次弹出栈顶下标，原栈顶下标对应的元素左边比该元素大的且离得最近的元素就是在栈中原栈顶下标压在下面的相邻下标；原栈顶下标对应的元素右边没有比该元素大的且离得最近的元素。</li><li>是最后一个下标，弹出该下标，该下标对应的元素没有左边比该元素大的且离得最近的元素，也没有右边没有比该元素大的且离得最近的元素。</li></ul><blockquote><p>设计这种规则实际上就是在严格维护单调栈的单调性。</p></blockquote><h3 id="1-3-流程（有重复）"><a href="#1-3-流程（有重复）" class="headerlink" title="1.3 流程（有重复）"></a>1.3 流程（有重复）</h3><p>假设数组中有重复值，那么单调栈中存储的元素就不能只是一个下标了，可能会存储多个下标，这多个下标对应的数组中的值是一样的。</p><p>因此在实现上，我们偏向去使用一个链表来作为单调栈的元素类型，<font color=#9900CC><strong>同一个链表中所有下标指向的元素值是一样的</font></strong>。</p><p>这种结构可以处理有重复值的数组，也可以处理无重复值的数组，是万能的。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.52rh9uys4zc0.webp#pic_center" width = 64%><p>流程上和无重复的大致相同，区别在于：</p><ul><li>当前元素比栈顶的下标链表所指向的元素大，栈顶的下标链表弹栈，同时记录原栈顶下标链表中每一个下标对应的元素的信息。原栈顶下标链表中每一个下标对应的元素左边比该元素大且离得最近的元素都是在栈中原栈顶下标链表压在下边的相邻下标链表的最后一个下标对应的元素；原栈顶下标链表中每一个下标对应的元素有右边比该元素大且离得最近的元素就是让它的下标链表弹栈的下标链表中的下标对应的元素（此时下标链表中只会有一个元素）。如果栈中只有一个下标链表，则该链表中所有下标左边没有比该下标对应的元素大且离得最近的元素，右边正常。</li><li>当前元素与栈顶的下标链表所指向的元素相等，将该元素对应的下标连接到栈顶的下标链表的末尾。</li></ul><blockquote><p>为什么说使用单调栈可以将时间复杂度降低至 $O(N)$？<br>假设有数组中有 N 个元素，在我们计算出了所有元素的左右边比该元素大或者小且离得最近的元素的整个过程中，无论是使用有重复的模型还是无重复的模型，每一个元素都只进栈一次，出栈一次。</p></blockquote><h3 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h3><p>单调栈最经典的应用，就是在一个数列里寻找距离元素最近的比其大&#x2F;小的元素位置。</p><p>比如以下问题：</p><p>对数列中的每个元素，寻找其左侧第一个比它大的元素位置。</p><p>显而易见的，我们可以遍历每个元素，然后从其位置往左寻找，这样的暴力做法时间复杂度是 $O(n^2)$。</p><p>但单调栈可以将时间复杂度降到 $O(n)$ ————</p><p>我们只需从右往左遍历数列，依次将元素加入单调栈中，维护一个从栈底到栈顶递减的单调栈；</p><p>当某个元素被从栈内弹出时，代表它遇到了一个比它更大的元素，因为是从右往左遍历，所以该元素就是第一个比它大的元素，即所求。</p><p>如果最后仍在栈内，则说明该元素左侧没有比它更大的元素。</p><p>遍历的时间复杂度是 $O(n)$，每个元素最多被加入单调栈一次、弹出来一次，所以总时间复杂度是 $O(n)$。</p><p>对于要求解的这类问题，我们可以列一个简单的表格——</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>求解的问题</th><th>遍历方向</th><th>维护单调性（栈底-&gt;栈顶）</th></tr><tr><td>左侧第一个更大</td><td>从右到左</td><td>单调递减</td></tr><tr><td>左侧第一个更小</td><td>从右到左</td><td>单调递增</td></tr><tr><td>右侧第一个更大</td><td>从左到右</td><td>单调递减</td></tr><tr><td>右侧第一个更小</td><td>从左到右</td><td>单调递增</td></tr></tbody></table><h3 id="1-5-维护单调栈"><a href="#1-5-维护单调栈" class="headerlink" title="1.5 维护单调栈"></a>1.5 维护单调栈</h3><p>单调栈：栈内的元素按照某种方式排序下单调递增或单调递减，如果新入栈的元素破坏的单调性，就弹出栈内元素，直到满足单调性。</p><p>单调栈分为单调递增栈和单调递减栈：</p><ul><li>单调递增栈：栈中数据出栈的序列为单调递减序列；</li><li>单调递减栈：栈中数据出栈的序列为单调递增序列。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.2p0tvz21vwo0.webp#pic_center" width = 48%><p><strong>(1) 维护单调递增栈</strong></p><ul><li>遍历数组中每一个元素，执行入栈：每次入栈前先检验栈顶元素和进栈元素的大小。</li><li>如果栈空或进栈元素大于栈顶元素则直接入栈；如果进栈元素小于等于栈顶元素，则出栈，直至进栈元素大于栈顶元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monostoneStack</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = 定义一个长度和 arr 一样长的数组，并初始化为 -<span class="number">1</span></span><br><span class="line">        循环 i <span class="keyword">in</span>  arr:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &lt; arr[栈顶元素]:</span><br><span class="line">                peek = 弹出栈顶元素</span><br><span class="line">                ans[peek] = i - peek</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>(2) 维护单调递减栈</strong></p><ul><li>遍历数组中每一个元素，执行入栈：每次入栈前先检验栈顶元素和进栈元素的大小。</li><li>如果栈空或进栈元素小于栈顶元素则直接入栈；如果进栈元素大于等于栈顶元素，则出栈，直至进栈元素小于栈顶元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monostoneStack</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = 定义一个长度和 arr 一样长的数组，并初始化为 -<span class="number">1</span></span><br><span class="line">        循环 i <span class="keyword">in</span>  arr:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &gt; arr[栈顶元素]:</span><br><span class="line">                peek = 弹出栈顶元素</span><br><span class="line">                ans[peek] = i - peek</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h2 id="2-单调队列"><a href="#2-单调队列" class="headerlink" title="2 单调队列"></a>2 单调队列</h2><p>单调队列：队列中元素之间的关系具有单调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。</p><p>队尾入队的时候维护单调性：</p><ul><li>对于单调递增队列，设当前准备入队的元素为 e，从队尾开始把队列中的元素逐个与 e 对比，把比 e 大或者与 e 相等的元素逐个删除，直到遇到一个比 e 小的元素或者队列为空为止，然后把当前元素 e 插入到队尾。</li><li>对于单调递减队列也是同样道理，只不过从队尾删除的是比 e 小或者与 e 相等的元素。</li></ul><p>若队列有大小限制，则每次插入新元素的时候，需要从队头开始弹出元素，直到队列至少有一个空间留给当前元素。</p><p>举例来说，nums&#x3D;[3,2,8,4,5,7,6,4]，初始时，deque&#x3D;[]，限制队列长度不能超过 3，维护一个单增队列，</p><ul><li>3入队：$deque&#x3D;[3]$；</li><li>3从队尾出队，2 入队：deque&#x3D;[2]；</li><li>8入队：ddeque&#x3D;[2,8]；</li><li>8从队尾出队，4入队：deque&#x3D;[2,4]；</li><li>5入队：deque&#x3D;[2,4,5]；</li><li>2从队头出队，7入队：deque&#x3D;[4,5,7]；</li><li>7从队尾出队，6入队：deque&#x3D;[4,5,6]；</li><li>6从队尾出队，5从队尾出队，4从队尾出队，4入队：deque&#x3D;[4]。</li></ul><p>单调队列的作用：区间最小（最大）值问题、优化动态规划、优化多重背包</p><p><strong>单调栈和单调队列的区别和联系</strong></p><p><strong>相同点</strong></p><ul><li>单调队列和单调栈的“头部”都是最先添加的元素，“尾部”都是最后添加的元素。</li><li>递增和递减的判断依据是：从栈底（队尾）到栈顶（队首），元素大小的变化情况。队列和栈是相反的。</li><li>操作非常相似。当队列长度为无穷大时，递增的单调队列和递减的单调栈，排列是一样的！这是因为，长度为无穷大的的队列不会在“头部”有出队操作，而在“尾部”的操作是一模一样的：数据都从“尾部”进入，并按照相同的规则进行比较。</li><li>两者维护的时间复杂度都是O(n)，因为每个元素都只操作一次。</li></ul><p><strong>区别</strong></p><ul><li>队列可以从队列头弹出元素，可以方便地根据入队的时间顺序（访问的顺序）删除元素。这样导致了单调队列和单调栈维护的区间不同。当访问到第i个元素时，单调栈维护的区间为[0, i)，而单调队列维护的区间为(lastpop, i)</li><li>单调队列可以访问“头部”和“尾部”，而单调栈只能访问栈顶（也就是“尾部”）。这导致单调栈无法获取[0, i)的区间最大值&#x2F;最小值。</li></ul><p>综上所述，单调队列实际上是单调栈的的升级版。单调栈只支持访问尾部，而单调队列两端都可以。</p><hr><h2 id="3-真题演练"><a href="#3-真题演练" class="headerlink" title="3 真题演练"></a>3 真题演练</h2><h3 id="3-1-单调栈"><a href="#3-1-单调栈" class="headerlink" title="3.1 单调栈"></a>3.1 单调栈</h3><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>496</td><td><a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank">下一个更大元素 I</a>（简单）</td></tr><tr><td>503</td><td><a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank">下一个更大元素 II</a>（中等）</td></tr><tr><td>739</td><td><a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank">每日温度</a>（中等）</td></tr><tr><td>901</td><td><a href="https://leetcode.cn/problems/online-stock-span/description/?orderBy=most_votes" target="_blank">股票价格跨度</a>（中等）</td></tr><tr><td>962</td><td><a href="https://leetcode.cn/problems/online-stock-span/description/?orderBy=most_votes" target="_blank">最大宽度坡</a>（中等）</td></tr><tr><td>1019</td><td><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/description/?orderBy=most_votes" target="_blank">链表中的下一个更大节点</a>（中等）</td></tr><tr><td>42</td><td><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank">接雨水</a>（困难）</td></tr><tr><td>84</td><td><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank">柱状图中最大的矩形</a>（困难）</td></tr><tr><td>402</td><td><a href="https://leetcode.cn/problems/remove-k-digits/" target="_blank">移掉 K 位数字</a>（中等）</td></tr><tr><td>316</td><td><a href="https://leetcode.cn/problems/remove-duplicate-letters/" target="_blank">去除重复字母</a>（中等）</td></tr><tr><td>321</td><td><a href="https://leetcode.cn/problems/create-maximum-number/" target="_blank">拼接最大数</a>（困难）</td></tr></tbody></table><p><strong>496. 下一个更大元素 I</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.asr38dfoh7s.webp#pic_center" width = 64%><p><strong>1. 暴力法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        res = [<span class="number">0</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            j = nums2.index(nums1[i])</span><br><span class="line">            k = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; n <span class="keyword">and</span> nums2[k] &lt; nums2[j]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            res[i] = nums2[k] <span class="keyword">if</span> k &lt; n <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>2. 单调栈 + 哈希表</strong></p><p><strong>方式一：借助栈，正序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        <span class="comment"># 因为题目说了没有重复元素，因此可以使用字典来维护元素的下一个更大元素：key-元素，value-下一个更大的元素</span></span><br><span class="line">        hash_map, stack = &#123;&#125;, []        <span class="comment"># 单调递减栈：用于找到下一个更大的元素</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:       <span class="comment"># 单调栈</span></span><br><span class="line">                    hash_map[stack.pop()] = num</span><br><span class="line">                stack.append(num)                          </span><br><span class="line">        <span class="keyword">return</span> [hash_map.get(num, -<span class="number">1</span>) <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.123pvd91gnjk.gif#pic_center" width = 48%><p><strong>方式二：借助栈，逆序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res, stack = &#123;&#125;, []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2):         <span class="comment"># 由于是逆序遍历，所以栈中元素不可能是其之前某个元素的，下一个更大元素，所以将栈中元素清空</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            res[num] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(num)</span><br><span class="line">        <span class="keyword">return</span> [res[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.5kieuxflzjs0.gif#pic_center" width = 48%><p><strong>503. 下一个更大元素 II</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.6e436x1e73k0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span>]*length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length*<span class="number">2</span>):       <span class="comment"># 变为2倍模拟循环数组</span></span><br><span class="line">            ind = i % length</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[-<span class="number">1</span>]] &lt; nums[ind]:</span><br><span class="line">                res[stack.pop()] = nums[ind]</span><br><span class="line">            stack.append(ind)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.6092mqg90qo0.gif#pic_center" width = 48%><p><strong>739. 每日温度</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.2c0qd4k0b8lc.webp#pic_center" width = 64%><p><strong>方式一：单调栈 正序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []           <span class="comment"># 这里定义一个栈就不用说了</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(T)   <span class="comment"># 这里是最后要返回的result，因为题目中说没有匹配的就返回0，</span></span><br><span class="line">                             <span class="comment"># 所以这里初始化一个全是0的list，然后把那些有匹配的替换掉即可。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):  <span class="comment"># 下面是关键</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> t &gt; T[stack[-<span class="number">1</span>]]:       <span class="comment"># 当stack为空时，运行stack.append(idx)，则stack=[0]</span></span><br><span class="line">                                                    <span class="comment"># 然后仅当遍历元素 t 小于stack顶端的值时append进去，</span></span><br><span class="line">                                                    <span class="comment"># 这会导致stack中idx代表的元素是单调递减的，</span></span><br><span class="line">                                                    <span class="comment"># 如果此时遍历到一个 t，大于stack顶端的值，那这个t就是离stack</span></span><br><span class="line">                                                    <span class="comment"># 顶端值最近的那个大值。</span></span><br><span class="line">                res[stack.pop()] = idx-stack[-<span class="number">1</span>]    <span class="comment"># 然后pop出来，还是要注意stack.pop出来的是idx，这样res这</span></span><br><span class="line">                                                    <span class="comment"># 一串0里对应位置的0就会被替换成应有的值。                                        </span></span><br><span class="line">                                                    <span class="comment"># 再进入while循环判断t和stack.pop后的新的顶端值哪个大。</span></span><br><span class="line">                                                    <span class="comment"># 如此反复。</span></span><br><span class="line">            stack.append(idx)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.3274dsdu1j4.gif#pic_center" width = 48%><p><strong>901. 股票价格跨度</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.1rw1cbbrzygw.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 单调递减栈：存放元素及其跨度</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>] &lt;= price:</span><br><span class="line">            <span class="comment"># 找到了一个递增对，将其出栈（因为其历史跨度已经记录在了下一个元素中），并将其跨度叠加</span></span><br><span class="line">            cnt += self.stack.pop()[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        self.stack.append((price, cnt))     <span class="comment"># 保持元素及其跨度，便于下一次直接计算历史跨度</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.2i81r4pw2cm0.webp#pic_center" width = 48%><p><strong>962. 最大宽度坡</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.5xowsdt924k0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxWidthRamp</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> A[stack[-<span class="number">1</span>]] &gt; A[i]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="built_in">print</span>(stack)</span><br><span class="line">        i0 = stack[<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># while i &gt; res:  # 当res大于等于i时没必要继续遍历了 </span></span><br><span class="line">        <span class="keyword">while</span> i-i0 &gt; res:  <span class="comment"># 这样更快一点 </span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[stack[-<span class="number">1</span>]] &lt;= A[i]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - stack[-<span class="number">1</span>])</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="comment"># print(i,res)</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1019. 链表中的下一个更大节点</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.3b25ki2y4rw0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextLargerNodes</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        st = []  <span class="comment"># 单调栈（节点值，节点下标）</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> st[-<span class="number">1</span>][<span class="number">0</span>] &lt; head.val:</span><br><span class="line">                ans[st.pop()[<span class="number">1</span>]] = head.val  <span class="comment"># 用当前节点值更新答案</span></span><br><span class="line">            st.append((head.val, <span class="built_in">len</span>(ans)))  <span class="comment"># 当前 ans 的长度就是当前节点的下标</span></span><br><span class="line">            ans.append(<span class="number">0</span>)  <span class="comment"># 占位</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>42. 接雨水</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.2o5f4lad8ua0.webp#pic_center" width = 64%><p><strong>方法一：单调栈</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">while</span>  stack <span class="keyword">and</span> height[stack[-<span class="number">1</span>]] &lt; height[i]:</span><br><span class="line">                cur_ind = stack.pop()</span><br><span class="line">                <span class="comment"># 如果栈顶元素一直相等，那么全都pop出去，只留第一个。</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[-<span class="number">1</span>]] == height[cur_ind]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">if</span>  stack:</span><br><span class="line">                    stack_top = stack[-<span class="number">1</span>] <span class="comment"># stack_top 此时指向的是此次接住的雨水的左边界的位置。右边界是当前的柱体，即i。</span></span><br><span class="line">                    <span class="comment"># i - stack_top - 1 是雨水的宽度, min(height[stack_top], height[i]) 是左右柱子高度的min，减去height[cur_ind]就是雨水的高度。</span></span><br><span class="line">                    ans += (<span class="built_in">min</span>(height[stack_top], height[i])-height[cur_ind])*(i-stack_top-<span class="number">1</span>)</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.54qo3f432j40.gif#pic_center" width = 48%><p><strong>84. 柱状图中最大的矩形</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.21wii559t5xc.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [n] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                right[mono_stack[-<span class="number">1</span>]] = i</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.19msfwnlxcu8.gif#pic_center" width = 48%><p><strong>402. 移掉 K 位数字</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.1jfahdm1bgao.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num, k</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        remain = <span class="built_in">len</span>(num) - k</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>316. 去除重复字母</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.3hso6bvmdlk0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        remain_counter = collections.Counter(s)         <span class="comment"># 第 1 步：记录每个字符出现的次数</span></span><br><span class="line">        stack = []      <span class="comment"># 第 2 步：使用栈得到题目要求字典序最小的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> ch &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            remain_counter[ch] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)       <span class="comment"># 第 3 步：此时 stack 就是题目要求字典序最小的字符串</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.1g9rfsqh3gow.webp#pic_center" width = 48%><p><strong>321. 拼接最大数</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.2w1oos6zxni0.webp#pic_center" width = 64%><p><strong>方式一：单调栈合并 &amp;&amp; 比较</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumber</span>(<span class="params">self, nums1, nums2, k</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pick_max</span>(<span class="params">nums, k</span>):</span><br><span class="line">            stack = []</span><br><span class="line">            drop = <span class="built_in">len</span>(nums) - k</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    drop -= <span class="number">1</span></span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">return</span> stack[:k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, B</span>):</span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">                bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">                ans.append(bigger.pop(<span class="number">0</span>))           <span class="comment"># 把最大的取出来</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(merge(pick_max(nums1, i), pick_max(nums2, k-i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>) <span class="keyword">if</span> i &lt;= <span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i &lt;= <span class="built_in">len</span>(nums2))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.179bmzpcvvb4.gif#pic_center" width = 48%><p><strong>456. 132 模式</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.3qnau6nfxqo0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find132pattern</span>(<span class="params">self, nums</span>):</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        left_min = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            left_min[i] = <span class="built_in">min</span>(left_min[i - <span class="number">1</span>], nums[i - <span class="number">1</span>])</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            mask = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; nums[j]:</span><br><span class="line">                mask = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> left_min[j] &lt; mask:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            stack.append(nums[j])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.777nasb9srs0.gif#pic_center" width = 48%><h3 id="3-2-单调队列"><a href="#3-2-单调队列" class="headerlink" title="3.2 单调队列"></a>3.2 单调队列</h3><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>面试题 59-II</td><td><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank"> 队列的最大值</a>（单调队列模板题）</td></tr><tr><td>239</td><td><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank">滑动窗口最大值</a></td></tr><tr><td>862</td><td><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" target="_blank">和至少为 K 的最短子数组</a></td></tr><tr><td>1438</td><td><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank">绝对差不超过限制的最长连续子数组</a></td></tr></tbody></table><p><strong>面试题 59-II. 队列的最大值</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.22t7cg39y7nk.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line">        self.deque = queue.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="number">0</span>] <span class="keyword">if</span> self.deque <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_back</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue.put(value)</span><br><span class="line">        <span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[-<span class="number">1</span>] &lt; value:</span><br><span class="line">            self.deque.pop()</span><br><span class="line">        self.deque.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.queue.empty(): <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        val = self.queue.get()</span><br><span class="line">        <span class="keyword">if</span> val == self.deque[<span class="number">0</span>]:</span><br><span class="line">            self.deque.popleft()</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.5teiox96nts0.gif#pic_center" width = 48%><p><strong>239. 滑动窗口最大值</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.6zsm28b3g5s0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line"></span><br><span class="line">        ans = [nums[q[<span class="number">0</span>]]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            ans.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.1hwxt0mbht28.gif#pic_center" width = 48%><hr><blockquote><p><font color=#9900CC><strong>单调栈和单调队列暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.njs5lj3nf8.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>【数据结构与算法】单调栈详解：<a href="https://juejin.cn/post/7019648593694818334">https://juejin.cn/post/7019648593694818334</a></li><li>数据结构-单调栈：<a href="https://zhuanlan.zhihu.com/p/344988226">https://zhuanlan.zhihu.com/p/344988226</a></li><li>leetcode-屡试不爽的单调（递增\递减）栈：<a href="https://www.jianshu.com/p/f593d56adee7">https://www.jianshu.com/p/f593d56adee7</a></li><li>单调栈与单调队列算法详解及LeetCode经典题目（Python）：<a href="https://blog.csdn.net/Hanx09/article/details/108434955">https://blog.csdn.net/Hanx09/article/details/108434955</a></li><li>单调队列&#x2F;栈从入门到入土：<a href="https://www.cnblogs.com/wsyunine/p/14851199.html">https://www.cnblogs.com/wsyunine/p/14851199.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要以LeetCode上题目为例，合适的数据结构可以有效地降低算法的复杂度，本文分析单调栈和单调队列的使用技巧，以及如何在题目中灵活应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单调栈" scheme="https://qxienote.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="单调队列" scheme="https://qxienote.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（八）-- 队列的实现与应用</title>
    <link href="https://qxienote.com/article/1515a7fd.html"/>
    <id>https://qxienote.com/article/1515a7fd.html</id>
    <published>2023-06-11T03:08:58.000Z</published>
    <updated>2023-06-11T08:51:42.857Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍Python数据结构篇队列和双端队列的定义与实现，最后用经典的约瑟夫问题和回文词判定来演示队列的应用。</p><span id="more"></span><h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1 队列"></a>1 队列</h2><h3 id="1-1-简单队列"><a href="#1-1-简单队列" class="headerlink" title="1.1 简单队列"></a>1.1 简单队列</h3><p>队列是一种有次序的数据集合，其特征是新数据项的添加总发生在一端（通常称为“尾rear”端）；而现存数据项的移除总发生在另一端（通常称为“首front”端）。当一个元素被加入到队列之后，它就从队尾开始向队首前进，直到它成为下一个即将被移出队列的元素。</p><p>最新被加入的元素必须处于队尾，在队列停留最长时间的元素处于队首。这种原则有时候叫做“先进先出”（FIFO, first-in first-out），有时候也叫做“先到先服务”。</p><h3 id="1-2-双端队列"><a href="#1-2-双端队列" class="headerlink" title="1.2 双端队列"></a>1.2 双端队列</h3><p>双端队列（deque 或 double-ended queue）与队列类似，也是一系列元素的有序组合。其两端称为队首（front）和队尾（rear），元素在到达两端之前始终位于双端队列中。与队列不同的是，双端队列对元素添加和删除的限制不那么严格，元素可以从两端插入，也可以从两端删除。可以说，双端队列这种混合的线性数据结构拥有栈和队列各自拥有的所有功能。图3是一个由Python数据对象构成的双端队列。 应当指出，&#x3D;&#x3D;双端队列虽然具备栈和队列的许多特征，但其中的数据项不满足严格的“后进先出”或“先进先出”顺序，这使得插入和删除操作的规律性需要由用户自己维持。&#x3D;&#x3D;</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.11q15o2dt6y8.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.11q15o2dt6y8.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=48%><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图3 一个由 Python 数据对象构成的双端队列</div> </center><h2 id="2-队列的抽象数据类型"><a href="#2-队列的抽象数据类型" class="headerlink" title="2 队列的抽象数据类型"></a>2 队列的抽象数据类型</h2><h3 id="2-1-简单队列"><a href="#2-1-简单队列" class="headerlink" title="2.1 简单队列"></a>2.1 简单队列</h3><p>抽象数据类型队列通过以下的一些结构和操作来定义。如前文所述，一个队列由一系列有序的元素构成，它们从叫做“队尾”的一端进入队列，再从叫做“队首”的另一端被移出队列。队列保持“先进先出”的特性。下面是队列的一些操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue()：创建一个空队列对象，返回值为Queue对象；</span><br><span class="line">enqueue(item)：将数据项item添加到队尾，无返回值；</span><br><span class="line">dequeue()：从队首移除数据项，返回值为队首数据项，队列被修改；</span><br><span class="line">isEmpty()：测试是否空队列，返回值为布尔值</span><br><span class="line">size()：返回队列中数据项的个数。</span><br></pre></td></tr></table></figure><p>我们需要决定列表的哪一端做队尾，哪一端用来做队首。下面的一段代码设定队列的队尾在列表的0位置。这使得我们能够利用列表的insert 功能来向队列的队尾添加新的元素。而pop操作则可以用来移除队首的元素（也就是列表的最后一个元素）。这也意味着enqueue的复杂度是O(n)，而dequeue的复杂度是O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, item</span>):        <span class="comment"># 复杂度O(n)</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):      <span class="comment"># 复杂度O(1)</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><h2 id="2-2-双端队列"><a href="#2-2-双端队列" class="headerlink" title="2.2 双端队列"></a>2.2 双端队列</h2><p>双端队列的定义的操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque()：创建一个空双端队列</span><br><span class="line">addFront(item)：将item加入队首</span><br><span class="line">addRear(item)：将item加入队尾</span><br><span class="line">removeFront()：从队首移除数据项，返回值为移除的数据项</span><br><span class="line">removeRear()：从队尾移除数据项，返回值为移除的数据项</span><br><span class="line">isEmpty()：返回deque是否为空</span><br><span class="line">size()：返回deque中包含数据项的个数</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><h2 id="3-队列的应用"><a href="#3-队列的应用" class="headerlink" title="3 队列的应用"></a>3 队列的应用</h2><h3 id="3-1-热土豆问题"><a href="#3-1-热土豆问题" class="headerlink" title="3.1 热土豆问题"></a>3.1 热土豆问题</h3><p>首先，让我们来考虑一个叫做热土豆的儿童游戏。在这个游戏中（见图1）小孩子们围成一个圆圈并以最快的速度接连传递物品，并在游戏的一个特定时刻停止传递，这时手中拿着物品的小孩就离开圆圈，游戏进行至只剩下一个小孩。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.43fpvi3k4ju0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.43fpvi3k4ju0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图1 六人传土豆游戏</div> </center><p>现在，我们也将热土豆问题称作Josephus问题。这个故事是关于公元1世纪著名历史学家Flavius Josephus 的，传说在犹太民族反抗罗马统治的战争中，Josephus 和他的39个同胞在一个洞穴中与罗马人相对抗。当注定的失败即将来临之时，他们决定宁可死也不投降罗马。于是他们围成一个圆圈，其中一个人被指定为第一位然后他们按照顺时针进行计数，每数到第七个人就把他杀死。传说中Josephus 除了熟知历史之外还是一个精通于数学的人。他迅速找出了那个能留到最后的位置。最后一刻，他没有选择自杀而是加入了罗马的阵营。这个故事还有许多不同的版本。有些是以三为单位进行计数，有些则是让最后一个留下的骑马逃走。但不管是哪个版本，其核心原理都是一致的。</p><p>求解思路：1）模拟程序采用队列来存放所有参加游戏的人名，按照传递土豆方向从队首排到队尾；游戏时，队首始终是持有土豆的人。2）模拟游戏开始，只需要将队首的人出队，随即再到队尾入队，算是土豆的一次传递；传递了num次后，将队首的人移除，不再入队如此反复，直到队列中剩余1人。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.18ra4wy738n4.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.18ra4wy738n4.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图2 用队列模拟热土豆问题</div> </center><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hot_potato</span>(<span class="params">namelist, nums</span>):</span><br><span class="line">    sim_queue = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> namelist:</span><br><span class="line">        sim_queue.enqueue(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> sim_queue.size() &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">            sim_queue.enqueue(sim_queue.dequeue())</span><br><span class="line">        sim_queue.dequeue()</span><br><span class="line">    <span class="keyword">return</span> sim_queue.dequeue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hot_potato([<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Susan&quot;</span>, <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Kent&quot;</span>, <span class="string">&quot;Brad&quot;</span>], <span class="number">7</span>))</span><br></pre></td></tr></table></figure><h3 id="3-2-回文词判定"><a href="#3-2-回文词判定" class="headerlink" title="3.2 回文词判定"></a>3.2 回文词判定</h3><p>一个能用双端队列数据结构轻松解决的问题是经典的“回文词”问题。回文词指的是正读和反读都一样的词，如：radar、toot 和madam。我们想要编写一个算法来检查放入的字符串是否为回文词。</p><p>这个问题的解决方案是用一个双端队列来存储这个字符串。我们遍历这个字符串并把它的每个字母添加到双端队列的尾端。现在这个双端队列看起来非常像一个普通队列，但我们可以利用双端队列两端的对称性。双端队列的首端用来存储第一个字符，尾端用来存储最后一个字符。(如下图所示)<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.1utvwd5eu35s.webp#pic_center" width = 36%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palchecker</span>(<span class="params">aString</span>):</span><br><span class="line">    chardeque = Deque()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> aString:</span><br><span class="line">        chardeque.addRear(ch)</span><br><span class="line">    stillEqual = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> chardeque.size() &gt; <span class="number">1</span> <span class="keyword">and</span> stillEqual:</span><br><span class="line">        first = chardeque.removeFront()</span><br><span class="line">        last = chardeque.removeRear()</span><br><span class="line">        <span class="keyword">if</span> first != last:</span><br><span class="line">            stillEqual = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stillEqual</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(palchecker(<span class="string">&quot;lsdkjfskf&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(palchecker(<span class="string">&quot;radar&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要介绍Python数据结构篇队列和双端队列的定义与实现，最后用经典的约瑟夫问题和回文词判定来演示队列的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="队列" scheme="https://qxienote.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（七）-- 栈的实现与应用</title>
    <link href="https://qxienote.com/article/fa4199ab.html"/>
    <id>https://qxienote.com/article/fa4199ab.html</id>
    <published>2023-06-11T03:08:46.000Z</published>
    <updated>2023-06-11T08:47:01.794Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要学习栈的抽象数据类型，主要包括出栈、进栈、栈的大小、栈顶元素、栈是否为空，最后实现括号匹配和十进制转换为二进制来理解栈的反转次序、先进后出的特性。</p><span id="more"></span><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h2><p>堆栈是一种特殊的抽象数据结构或者组合，其主要的操作为将元素从头部加入栈中，称为进栈和将头部元素移除，称为出栈。</p><p>一个栈（有时称“叠加栈”）是一个项的有序集合。添加项和移除项都发生在同一“端”。这一端通常被称为“顶”。另一端的顶部被称为“底”。</p><p>栈的“底”是有标志性的，因为存储在栈中更靠近“底”的项就是栈中储存时间最长的项。最新添加的项在移除项时也会第一个被移除。这种排序原则有时也称为LIFO(LIFO-Last-In-First-Out)法，也就是“后进先出”。项的排序基于它在集合中存在的时间长度。越新的项越靠近“顶”，越老的项越靠近“底”。如下图所示，堆栈是一种LIFO的数据结构。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.4iakphln4ws0.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.4iakphln4ws0.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%><p><strong>小结：</strong> 栈Stack ：栈顶和栈底，栈的特性：反转次序，后进先出（主要应用：网页、word编辑）</p><h2 id="2-栈的抽象数据类型"><a href="#2-栈的抽象数据类型" class="headerlink" title="2 栈的抽象数据类型"></a>2 栈的抽象数据类型</h2><p>栈的抽象数据类型是由以下结构和操作定义的。抽象数据类型“栈”定义为如下的操作：（默认左端为栈底，右端为栈顶）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack( )：创建一个空栈，不包含任何数据项</span><br><span class="line">push(item)：将item加入栈顶，无返回值，append()</span><br><span class="line">pop( )：将栈顶数据项移除，并返回，栈被修改pop()</span><br><span class="line">peek( )：“窥视” 栈顶数据项，返回栈顶的数据项但不移除，栈不被修改。</span><br><span class="line">isEmpty( )：返回栈是否为空栈</span><br><span class="line">size( )：返回栈中有多少个数据项。不需要参数，返回一个整数。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化栈为空列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 出栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;pop from an empty stack&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 是否为空栈，返回布尔值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回栈顶元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回元素数目</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化一个栈对象</span></span><br><span class="line">    my_stack = Stack()</span><br><span class="line">    my_stack.push(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    my_stack.push(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(my_stack.size())</span><br><span class="line">    <span class="built_in">print</span>(my_stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(my_stack.peek())</span><br></pre></td></tr></table></figure><h2 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3 栈的应用"></a>3 栈的应用</h2><h3 id="3-1-括号匹配"><a href="#3-1-括号匹配" class="headerlink" title="3.1 括号匹配"></a>3.1 括号匹配</h3><p>问题描述：括号的使用必须遵循“平衡”规则，即每个开括号要恰好对应一个闭括号，其次每对开闭括号要正确的嵌套。如下：</p><ul><li>正确的括号：(()()()())，(((())))，(()((())()))</li><li>错误的括号：((((((())，()))，(()()(()</li></ul><p>思考：从左到右扫描括号串，最新打开的左括号，应该匹配最先遇到的右括号，这样，第一个左括号（最早打开），就应该匹配最后一个右括号（最后遇到），体现了次序反转的识别，正好符合栈的特性。</p><p>实现流程如下：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.2lczj1z4wg80.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.2lczj1z4wg80.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">算法流程图</div> </center><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">par_checker</span>(<span class="params">symbol_string</span>):</span><br><span class="line">    new_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> symbol_string:</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            new_stack.push(item)</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> new_stack.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            new_stack.pop()</span><br><span class="line">    <span class="keyword">return</span> new_stack.is_empty()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;((()))&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;((())&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;(()))&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;())&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在实际的应用里，我们会碰到更多种括号，如python中列表所用的方括号“[]”，字典所用的花括号“{}”，元组和表达式所用的圆括号“()”。这些不同的括号有可能混合在一起使用，要注意各自的开闭匹配问题。</p><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">par_checker</span>(<span class="params">symbol_string</span>):</span><br><span class="line">    par_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> symbol_string:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> <span class="string">&#x27;([&#123;&#x27;</span>:</span><br><span class="line">            par_stack.push(item)</span><br><span class="line">        <span class="keyword">elif</span> item <span class="keyword">in</span> <span class="string">&#x27;)]&#125;&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> par_stack.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                close = par_stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matches(close, item):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> par_stack.is_empty()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matches</span>(<span class="params"><span class="built_in">open</span>, close</span>):</span><br><span class="line">    opens = <span class="string">&#x27;([&#123;&#x27;</span></span><br><span class="line">    closers = <span class="string">&#x27;)]&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> opens.index(<span class="built_in">open</span>) == closers.index(close)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;&#123;&#123;([][])&#125;()&#125;&#x27;</span>))          <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;[&#123;()]&#x27;</span>))                 <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="3-2-进制转换"><a href="#3-2-进制转换" class="headerlink" title="3.2 进制转换"></a>3.2 进制转换</h3><p>十进制转换为二进制，采用的是“除以2求余数”的算法，将整数不断除以2，每次得到的余数就是由低到高的二进制位，“除以2”的过程，得到的余数是从低到高的次序，而输出则是从高到低，所以需要一个栈来反转次序。<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.5fau748xve40.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.5fau748xve40.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%></p><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_by_2</span>(<span class="params">dec_number</span>):</span><br><span class="line">    number_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">while</span> dec_number:</span><br><span class="line">        number_stack.push(dec_number % <span class="number">2</span>)</span><br><span class="line">        dec_number = dec_number // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    output_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> number_stack.is_empty():</span><br><span class="line">        output_string += <span class="built_in">str</span>(number_stack.pop())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(divide_by_2(<span class="number">42</span>))          <span class="comment"># 101010</span></span><br><span class="line">    <span class="built_in">print</span>(divide_by_2(<span class="number">156</span>))         <span class="comment"># 10011100</span></span><br><span class="line">    <span class="built_in">print</span>(divide_by_2(<span class="number">463</span>))         <span class="comment"># 111001111</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>十进制转换为二进制的算法，很容易可以扩展为转换到任意N进制，只需要将“除以2求余数”算法改为“除以N求余数”算法就可以。</p><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">base_converter</span>(<span class="params">dec_number, base</span>):</span><br><span class="line">    digits = <span class="string">&#x27;0123456789ABCDEF&#x27;</span></span><br><span class="line">    number_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">while</span> dec_number:</span><br><span class="line">        number_stack.push(dec_number % base)</span><br><span class="line">        dec_number = dec_number // base</span><br><span class="line"></span><br><span class="line">    output_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> number_stack.is_empty():</span><br><span class="line">        output_string += digits[number_stack.pop()]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(base_converter(<span class="number">152</span>, <span class="number">2</span>))       <span class="comment"># 10011000</span></span><br><span class="line">    <span class="built_in">print</span>(base_converter(<span class="number">152</span>, <span class="number">8</span>))       <span class="comment"># 230</span></span><br><span class="line">    <span class="built_in">print</span>(base_converter(<span class="number">152</span>, <span class="number">16</span>))      <span class="comment"># 98</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要学习栈的抽象数据类型，主要包括出栈、进栈、栈的大小、栈顶元素、栈是否为空，最后实现括号匹配和十进制转换为二进制来理解栈的反转次序、先进后出的特性。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="栈" scheme="https://qxienote.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（六）-- 哈希表</title>
    <link href="https://qxienote.com/article/83d55e57.html"/>
    <id>https://qxienote.com/article/83d55e57.html</id>
    <published>2023-06-11T03:08:30.000Z</published>
    <updated>2023-06-11T08:39:05.902Z</updated>
    
    <content type="html"><![CDATA[<p>散列表（hash table），又名‘hash表’，它用的是数组支持按照下标随机访问数据（时间复杂度O(1)）的特性，散列表其实就是基于数组结构的一种扩展。散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据，所以我们常常会将散列表和链表（或者跳表）结合在一起使用。</p><span id="more"></span><h2 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1 哈希表"></a>1 哈希表</h2><p>散列表（hash table），又名‘hash表’，它用的是数组支持按照下标随机访问数据（时间复杂度O(1)）的特性，所以散列表其实就是基于数组结构的一种扩展。简单的来说，就是把键值通过散列函数求得hash值之后，对数组容量进行取模运算，得到存放在数组位置的下标值，当我们按照键值查询元素时，我们用同样的方法将键值转化数组下标，从对应的数组下标的位置取数据。散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们常常会将散列表和链表（或者跳表）结合在一起使用。</p><h3 id="1-1-什么是哈希表"><a href="#1-1-什么是哈希表" class="headerlink" title="1.1 什么是哈希表"></a>1.1 什么是哈希表</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key和value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><ul><li>哈希函数（Hash Function）：将哈希表中元素的关键键值映射为元素存储位置的函数。</li><li>哈希冲突（Hash Collision）：不同的关键字通过同一个哈希函数可能得到同一哈希地址。</li></ul><p>哈希表的两个核心问题是：「哈希函数的构建」 和 「哈希冲突的解决方法」。</p><p>常用的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。</p><p>常用的哈希冲突的解决方法有两种：开放地址法和链地址法。</p><p>有两种不同类型的哈希表：哈希集合和哈希映射。</p><ul><li>哈希集合是集合数据结构的实现之一，用于存储非重复值。</li><li>哈希映射是映射数据结构的实现之一，用于存储(key, value)键值对。</li></ul><p>在标准模板库的帮助下，哈希表是易于使用的。大多数常见语言（如Java，C ++ 和 Python）都支持哈希集合和哈希映射。通过选择合适的哈希函数，哈希表可以在插入和搜索方面实现出色的性能。</p><blockquote><p>Python 将哈希表用于字典和集合。 哈希表是键值对的无序集合，其中每个键都是唯一的。 哈希表提供了有效的查找，插入和删除操作的组合。 这些是数组和链接列表的最佳属性。<font color=#9900CC><strong>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。</font></strong></p></blockquote><h3 id="1-2-哈希表的原理"><a href="#1-2-哈希表的原理" class="headerlink" title="1.2 哈希表的原理"></a>1.2 哈希表的原理</h3><p>哈希表是一种数据结构，它使用哈希函数组织数据，以支持快速插入和搜索。哈希表的核心思想就是使用哈希函数将键映射到存储桶。更确切地说：</p><ul><li>当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；</li><li>当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</li></ul><p>下面举一个简单的例子，我们来理解下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6c1crf69aic0.webp#pic_center" width = 48%><p>在示例中，我们使用 $y &#x3D; x ％ 5$ 作为哈希函数。让我们使用这个例子来完成插入和搜索策略：</p><ul><li>插入：我们通过哈希函数解析键，将它们映射到相应的桶中。 例如，1987 分配给桶 2，而 24 分配给桶 4。</li><li>搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索。 例如，如果我们搜索 23，将映射 23 到 3，并在桶 3 中搜索。我们发现 23 不在桶 3 中，这意味着 23 不在哈希表中。</li></ul><h3 id="1-2-设计哈希函数"><a href="#1-2-设计哈希函数" class="headerlink" title="1.2 设计哈希函数"></a>1.2 设计哈希函数</h3><p>哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。在之前的示例中，我们使用 $y &#x3D; x % 5$ 作为散列函数，其中 $x$ 是键值，$y$ 是分配的桶的索引。</p><p>散列函数将取决于键值的范围和桶的数量。下面是一些哈希函数的示例：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.577abu1923s0.webp#pic_center" width = 48%><p>哈希函数的设计是一个开放的问题。其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射。然而，在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。</p><p>当然，我们也可以自定义一些哈希函数。一般的方法有：</p><ul><li>直接定制法。哈希函数为关键字到地址的线性函数。如，$H(key) &#x3D; a * key + b$。这里，a 和 b 是设置好的常数。</li><li>数字分析法。假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。</li><li>平方取中法。如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li><li>折叠法。如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li><li>除留余数法。预先设置一个数 p，然后对关键字进行取余运算。即地址为 key % p。</li></ul><h3 id="1-3-解决哈希冲突"><a href="#1-3-解决哈希冲突" class="headerlink" title="1.3 解决哈希冲突"></a>1.3 解决哈希冲突</h3><p>理想情况下，如果我们的哈希函数是完美的一对一映射，我们将不需要处理冲突。不幸的是，在大多数情况下，冲突几乎是不可避免的。例如，在我们之前的哈希函数（y &#x3D; x ％ 5）中，1987 和 2 都分配给了桶 2，这就是一个哈希冲突。</p><p>解决哈希冲突应该要思考以下几个问题：</p><ul><li>如何组织在同一个桶中的值？</li><li>如果为同一个桶分配了太多的值，该怎么办？</li><li>如何在特定的桶中搜索目标值？</li></ul><p>那么一旦发生冲突，我们该如何解决呢？常用的方法有两种：开放定址法和链地址法。</p><p><strong>1. 开放定址法</strong><br>即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。</p><p>常用的探测方法是线性探测法。 比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key % 11。当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 % 11 &#x3D; 1。</p><p>然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.tk0bq8gxag.gif#pic_center" width = 48%><p><strong>2. 链地址法</strong></p><p>将哈希地址相同的记录存储在一张线性链表中。例如，有一组关键字 {12,13,25,23,38,84,6,91,34}，采用的哈希函数为 key % 11。如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.ze52i3l6k5s.gif#pic_center" width = 48%><h3 id="1-4-哈希表的应用"><a href="#1-4-哈希表的应用" class="headerlink" title="1.4 哈希表的应用"></a>1.4 哈希表的应用</h3><p><strong>1. 哈希表的基本操作</strong></p><p>在很多高级语言中，哈希函数、哈希冲突都已经在底层完成了黑盒化处理，是不需要开发者自己设计的。也就是说，哈希表完成了关键字到地址的映射，可以在常数级时间复杂度内通过关键字查找到数据。</p><p>至于实现细节，比如用了哪个哈希函数，用了什么冲突处理，甚至某个数据记录的哈希地址是多少，都是不需要开发者关注的。接下来，我们从实际的开发角度，来看一下哈希表对数据的增删查操作。</p><p>哈希表中的增加和删除数据操作，不涉及增删后对数据的挪移问题（数组需要考虑），因此处理就可以了。</p><p>哈希表查找的细节过程是：对于给定的 key，通过哈希函数计算哈希地址 H (key)。</p><p>如果哈希地址对应的值为空，则查找不成功。反之，则查找成功。虽然哈希表查找的细节过程还比较麻烦，但因为一些高级语言的黑盒化处理，开发者并不需要实际去开发底层代码，只要调用相关的函数就可以了。</p><p><strong>2. 哈希表的优缺点</strong></p><p>优势：它可以提供非常快速的插入-删除-查找操作，无论多少数据，<font color=#9900CC><strong>插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</font></strong></p><p>不足：哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。<font color=#9900CC><strong>在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。</font></strong></p><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/design-hashset/" target="_blank">705. 设计哈希集合</a></p></li><li><p><a href="https://leetcode.cn/problems/design-hashmap/" target="_blank">706. 设计哈希映射</a></p></li><li><p><a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字</a></p></li><li><p><a href="https://leetcode.cn/problems/single-number-ii/" target="_blank">137. 只出现一次的数字 II</a></p></li><li><p><a href="https://leetcode.cn/problems/single-number-iii/" target="_blank">260. 只出现一次的数字 III</a></p></li><li><p><a href="https://leetcode.cn/problems/contains-duplicate/description/" target="_blank">217. 存在重复元素</a></p></li><li><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/" target="_blank">219. 存在重复元素 II</a></p></li><li><p><a href="https://leetcode.cn/problems/contains-duplicate-iii/" target="_blank">220. 存在重复元素 III</a></p></li><li><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank">349. 两个数组的交集</a></p></li><li><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/" target="_blank">350. 两个数组的交集 II</a></p></li><li><p><a href="https://leetcode.cn/problems/valid-sudoku/" target="_blank">36. 有效的数独</a></p></li><li><p><a href="https://leetcode.cn/problems/find-the-difference/description/" target="_blank">389. 找不同</a></p></li><li><p><a href="https://leetcode.cn/problems/next-greater-element-i/description/" target="_blank">496. 下一个更大元素 I</a></p></li></ul></blockquote> <p><strong>705. 设计哈希集合</strong></p><p><strong>题目描述</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.200knowlms2o.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个一维长度为 buckets 的二维数组 table。第一维度用于计算哈希函数，为 key 分桶。</span></span><br><span class="line"><span class="comment"># 第二个维度用于寻找 key 存放的具体位置。第二维度的数组会根据 key 值动态增长，模拟真正的链表。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.buckets = <span class="number">1009</span></span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.buckets)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> key % self.buckets           <span class="comment"># 用取余数的方法实现集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key</span>):<span class="comment"># 向哈希集合中插入一个值</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.table[hashkey].append(key)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key</span>):<span class="comment"># 将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.table[hashkey].remove(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, key</span>):<span class="comment"># 返回哈希集合中是否存在这个值</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.table[hashkey]</span><br></pre></td></tr></table></figure><p><strong>706. 设计哈希映射</strong></p><p><strong>题目描述</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.l7i8ezupap8.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单的思路就是用模运算作为哈希方法，为了降低哈希碰撞的概率，通常取素数的模，例如 模 1009或2069</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.buckets = <span class="number">1009</span></span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.buckets)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>):                <span class="comment"># 哈希映射关系</span></span><br><span class="line">        <span class="keyword">return</span> key % self.buckets</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:<span class="comment"># 向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">                item[<span class="number">1</span>] = value</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        self.table[hashkey].append([key, value])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:<span class="comment"># 返回给定的键所对应的值，如果映射中不包含这个键，返回-1</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">                <span class="keyword">return</span> item[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:<span class="comment"># 如果映射中存在这个键，删除这个数值对</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.table[hashkey]):</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">                self.table[hashkey].pop(i)</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>136. 只出现一次的数字</strong></p><p>题目描述：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#一、用字典统计元素个数</span></span><br><span class="line">        <span class="comment"># hash_map = Counter(nums)</span></span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#方法一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hash_map[i] = hash_map.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">#方法二</span></span><br><span class="line">        <span class="comment"># for i in nums:</span></span><br><span class="line">        <span class="comment">#     if i not in hash_map:</span></span><br><span class="line">        <span class="comment">#         hash_map[i] = 1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         hash_map[i] += 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#二、找出只出现一次的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#方法一</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(hash_map.keys())[<span class="built_in">list</span>(hash_map.values()).index(<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#方法二</span></span><br><span class="line">        <span class="comment"># new_hash_map = &#123;v:k for k,v in hash_map.items()&#125;</span></span><br><span class="line">        <span class="comment"># return new_hash_map[1]</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#方法三</span></span><br><span class="line">        <span class="comment"># return [key for key, value in hash_map.items() if value == 1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 或</span></span><br><span class="line">        <span class="comment"># for key,value in hash_map.items():</span></span><br><span class="line">        <span class="comment">#     if value == 1:</span></span><br><span class="line">        <span class="comment">#         return key</span></span><br></pre></td></tr></table></figure><p><strong>137. 只出现一次的数字 II</strong></p><p>题目描述：给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        hash_map = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(hash_map.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>260. 只出现一次的数字 III</strong></p><p>题目描述：给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = collections.Counter(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> hash_map.items():</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>217. 存在重复元素</strong></p><p>题目描述：给你一个整数数组 nums。如果任一值在数组中出现 至少两次，返回 true；如果数组中每个元素互不相同，返回 false。</p><p><strong>1. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> hash_map:</span><br><span class="line">            <span class="keyword">if</span> hash_map[index] &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>2. 哈希集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hash_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_set.add(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>3. 集合的性质</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return sum(nums) != sum(set(nums)) or nums.count(0) &gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums) != <span class="built_in">len</span>(<span class="built_in">set</span>(nums))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.61ov593ay3k0.gif#pic_center" width = 48%><p><strong>219. 存在重复元素 II</strong></p><p>题目描述：给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个不同的索引 i 和 j ，满足 nums[i] &#x3D;&#x3D; nums[j] 且 $abs(i - j) &lt;&#x3D; k$。如果存在，返回 true；否则，返回 false 。</p><p><strong>1. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到重复元素和其索引</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 已经存在重复的情况</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> hash_map <span class="keyword">and</span> <span class="built_in">abs</span>(i - hash_map[nums[i]]) &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>2. 哈希集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 维护一个长度为 k 的集合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 存在重复元素</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> hash_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            hash_set.add(nums[i])</span><br><span class="line">            <span class="comment"># 及时删除超出数组长度的元素</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hash_set) &gt; k:</span><br><span class="line">                hash_set.remove(nums[i - k])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.1ezhfejilodc.gif#pic_center" width = 64%><p><strong>220. 存在重复元素 III</strong></p><p>题目描述：给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 $abs(nums[i] - nums[j]) &lt;&#x3D; t$，同时又满足 $abs(i - j) &lt;&#x3D; k$。如果存在则返回 true，不存在返回 false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        bucket_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 将nums[i]划分到大小为 t + 1 的不同桶中，分桶操作</span></span><br><span class="line">            num = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># print(num)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果桶中已经有元素，有相同的分桶结果，表示存在相同元素</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> bucket_dict:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 将 nums[i] 放入桶中</span></span><br><span class="line">            bucket_dict[num] = nums[i]</span><br><span class="line">            <span class="comment"># print(bucket_dict)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num - <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 将 i - k 之前的旧桶清除，因为之前的桶已经不满足条件了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                bucket_dict.pop(nums[i-k] // (t + <span class="number">1</span>))  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>349. 两个数组的交集</strong></p><p>题目描述：给定两个数组 nums1 和 nums2，返回它们的交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序。<br><strong>1. 集合的交集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        l2 = <span class="built_in">set</span>(nums2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(l1 &amp; l2)</span><br></pre></td></tr></table></figure><p><strong>2. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> num1 <span class="keyword">not</span> <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[num1] = <span class="number">1</span>         <span class="comment"># 只做一次计数</span></span><br><span class="line">        <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> num2 <span class="keyword">in</span> hash_map <span class="keyword">and</span> hash_map[num2] != <span class="number">0</span>:</span><br><span class="line">                hash_map[num2] -= <span class="number">1</span>        <span class="comment"># 及时对结果进行处理  </span></span><br><span class="line">                result.append(num2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>350. 两个数组的交集 II</strong></p><p>题目描述：给你两个整数数组 nums1 和 nums2，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> num1 <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[num1] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[num1] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> num2 <span class="keyword">in</span> hash_map <span class="keyword">and</span> hash_map[num2] != <span class="number">0</span>:</span><br><span class="line">                hash_map[num2] -= <span class="number">1</span></span><br><span class="line">                result.append(num2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>36. 有效的数独</strong></p><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 记录行数据、列数据、3x3格子数据，用于标记 1-9 共10个数字</span></span><br><span class="line">        rows = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        columns = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        boxes = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 1-9数字是否重复出现</span></span><br><span class="line">                    num = <span class="built_in">int</span>(board[i][j])</span><br><span class="line">                    board_index = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>  <span class="comment"># 方格角标的计算用 box[(i/3)*3+(j/3)][n] 来表示</span></span><br><span class="line">                    <span class="keyword">if</span> rows[i][num] &gt; <span class="number">0</span> <span class="keyword">or</span> columns[j][num] &gt; <span class="number">0</span> <span class="keyword">or</span> boxes[board_index][num] &gt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    rows[i][num] = <span class="number">1</span></span><br><span class="line">                    columns[j][num] = <span class="number">1</span></span><br><span class="line">                    boxes[board_index][num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>389. 找不同</strong></p><p>题目描述：给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。</p><p><strong>1. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(Counter(t) - Counter(s))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 异或运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(reduce(xor, <span class="built_in">map</span>(<span class="built_in">ord</span>, s + t)))</span><br></pre></td></tr></table></figure><p><strong>496. 下一个更大元素 I</strong></p><p><strong>题目描述</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.xl93xw5xua8.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = &#123;&#125;                       <span class="comment"># 字典存储结果</span></span><br><span class="line">        stack = []                          <span class="comment"># 列表模拟栈，单调栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):         <span class="comment"># 遍历每个字符串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:                   <span class="comment"># 如果当前栈为空，则直接入栈</span></span><br><span class="line">                stack.append(nums2[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums2[i] &lt; stack[-<span class="number">1</span>]:    <span class="comment"># 当前值小于栈顶元素，则入栈</span></span><br><span class="line">                    stack.append(nums2[i])</span><br><span class="line">                <span class="keyword">elif</span> nums2[i] &gt; stack[-<span class="number">1</span>]:  <span class="comment"># 当前值大于栈顶元素，不停出栈，把所有栈顶key值的value赋值为当前值</span></span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; nums2[i]:</span><br><span class="line">                        hash_map[stack[-<span class="number">1</span>]] = nums2[i]</span><br><span class="line">                        stack.pop()</span><br><span class="line">                    stack.append(nums2[i])  <span class="comment"># 当前值入队列</span></span><br><span class="line">        <span class="keyword">while</span> stack:                        <span class="comment"># 如果栈中还有元素，则全部赋值为-1，表示右边没有更大值</span></span><br><span class="line">            hash_map[stack[-<span class="number">1</span>]] = -<span class="number">1</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:                     <span class="comment"># 返回每个key值对应的value</span></span><br><span class="line">            result.append(hash_map[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>哈希表暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.29t68rsqty80.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>哈希表：<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8">https://www.programmercarl.com/哈希表理论基础.html#哈希表</a></li><li>Python数据结构-哈希表（Hash Table）：<a href="https://www.jianshu.com/p/093346ca7f38">https://www.jianshu.com/p/093346ca7f38</a></li><li>数据结构（Python实现）—— 哈希表：<a href="https://blog.csdn.net/Avery123123/article/details/103583115">https://blog.csdn.net/Avery123123/article/details/103583115</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;散列表（hash table），又名‘hash表’，它用的是数组支持按照下标随机访问数据（时间复杂度O(1)）的特性，散列表其实就是基于数组结构的一种扩展。散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据，所以我们常常会将散列表和链表（或者跳表）结合在一起使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希表" scheme="https://qxienote.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="哈希算法" scheme="https://qxienote.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希冲突" scheme="https://qxienote.com/tags/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（五）-- 二分查找与二分答案</title>
    <link href="https://qxienote.com/article/25d31d17.html"/>
    <id>https://qxienote.com/article/25d31d17.html</id>
    <published>2023-06-11T03:08:16.000Z</published>
    <updated>2023-06-11T08:28:04.494Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码和常见的解题技巧，带大家学透二分算法</p><span id="more"></span><h2 id="1-二分法介绍"><a href="#1-二分法介绍" class="headerlink" title="1 二分法介绍"></a>1 二分法介绍</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>二分查找又称折半查找、二分搜索、折半搜索等，是一种在静态查找表中查找特定元素的算法。</p><blockquote><p>所谓静态查找表，即只能对表内的元素做查找和读取操作，不允许插入或删除元素。</p></blockquote><p>使用二分查找算法，必须保证查找表中存放的是有序序列（升序或者降序）。换句话说，存储无序序列的静态查找表，除非先对数据进行排序，否则不能使用二分查找算法。它针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。下图对比了顺序查找和二分查找的不同：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.39e6uepbps80.gif#pic_center" width = 48%><p>二分查找的最基本问题是在有序数组里查找一个特定的元素，还可以应用在：</p><ol><li>在半有序（旋转有序或者是山脉）数组里查找元素；</li><li>确定一个有范围的整数；</li><li>需要查找的目标元素满足某个特定的性质。</li></ol><p>二分查找算法的时间复杂度可以用  $O(log_2n)$ 表示（$n$ 为查找表中的元素数量，底数 2 可以省略）。和顺序查找算法的 $O(n)$ 相比，显然二分查找算法的效率更高，且查找表中的元素越多，二分查找算法效率高的优势就越明显。</p><h3 id="1-2-二分法的三种写法"><a href="#1-2-二分法的三种写法" class="headerlink" title="1.2 二分法的三种写法"></a>1.2 二分法的三种写法</h3><p><strong>1. 模板一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 特殊用例判断</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 在 [left, right] 区间里查找target</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 为了防止 left + right 整形溢出，写成如下形式</span></span><br><span class="line">            <span class="comment"># Python 使用 BigInteger，所以不用担心溢出，但还是推荐使用如下方式</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                <span class="comment"># 下一轮搜索区间：[left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 此时：nums[mid] &lt; target</span></span><br><span class="line">                <span class="comment"># 下一轮搜索区间：[mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>许多刚刚写的朋友，经常在写 <code>left = mid + 1</code>；还是写 <code>right = mid - 1</code>; 感到困惑，一个行之有效的思考策略是：<font color=#9900CC><strong>永远去想下一轮目标元素应该在哪个区间里：</font></strong><ul><li>如果目标元素在区间 <code>[left, mid - 1]</code> 里，就需要设置设置 <code>right = mid - 1</code>；</li><li>如果目标元素在区间 <code>[mid + 1, right]</code> 里，就需要设置设置 <code>left = mid + 1</code>；</li></ul></li></ul><p>考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义。</p><ul><li>二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的；</li><li>循环可以继续的条件是 <code>while (left &lt;= right)</code>，特别地，当 <code>left == right</code> 即当待搜索区间里只有一个元素的时候，查找也必须进行下去；</li><li><code>mid = (left + right) // 2</code>；在 <code>left + right</code> 整形溢出的时候，mid 会变成负数，回避这个问题的办法是写成 <code>mid = left + (right - left) // 2</code>。</li></ul><p><strong>2. 模板二</strong></p><p><strong>版本一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid]</span></span><br><span class="line">            right = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br></pre></td></tr></table></figure><p><strong>版本二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时上取整</span></span><br><span class="line">        mid = left + (right - left + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid, right]</span></span><br><span class="line">            left = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br></pre></td></tr></table></figure><p>理解模板代码的要点：</p><ul><li>核心思想：虽然模板有两个，但是核心思想只有一个，那就是：<font color=#9900CC><strong>把待搜索的目标元素放在最后判断，每一次循环排除掉不存在目标元素的区间，目的依然是确定下一轮搜索的区间；</font></strong></li><li>特征：<code>while (left &lt; right):</code>，这里使用严格小于 <code>&lt;</code> 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 <code>left == right</code>成立，这一点在定位元素下标的时候极其有用；</li><li>在循环体中，先考虑 <code>nums[mid]</code> 在满足什么条件下不是目标元素，进而考虑两个区间 <code>[left, mid - 1]</code> 以及 <code>[mid + 1, right]</code> 里元素的性质，目的依然是确定下一轮搜索的区间； <strong>注意 1：</strong> 先考虑什么时候不是解，是一个经验，在绝大多数情况下不易出错，重点还是确定下一轮搜索的区间，由于这一步不容易出错，它的反面（也就是 <code>else</code> 语句的部分），就不用去考虑对应的区间是什么，直接从上一个分支的反面区间得到，进而确定边界如何设置；</li><li>根据边界情况，看取中间数的时候是否需要上取整； <strong>注意 2：</strong> 这一步也依然是根据经验，建议先不要记住结论，在使用这个思想解决问题的过程中，去思考可能产生死循环的原因，进而理解什么时候需要在括号里加 1 ，什么时候不需要；</li><li>在退出循环以后，根据情况看是否需要对下标为 <code>left</code> 或者 <code>right</code> 的元素进行单独判断，这一步叫「后处理」。在有些问题中，排除掉所有不符合要求的元素以后，剩下的那 1 个元素就一定是目标元素。如果根据问题的场景，目标元素一定在搜索区间里，那么退出循环以后，可以直接返回 left（或者 right）。</li></ul><p>以上是这两个模板写法的所有要点，并且是高度概括的。请读者一定先抓住这个模板的核心思想，在具体使用的过程中，不断地去体会这个模板使用的细节和好处。只要把中间最难理解的部分吃透，几乎所有的二分问题就都可以使用这个模板来解决，因为「减治思想」是通用的。好处在这一小节的开篇介绍过了，需要考虑的细节最少。</p><p>学习建议：一定需要多做练习，体会这（两）个模板的使用。</p><p><strong>注意事项：</strong></p><ul><li>先写分支，再决定中间数是否上取整；</li><li>在使用多了以后，就很容易记住，只要看到 left &#x3D; mid ，它对应的取中位数的取法一定是 <code>mid = left + (right - left + 1) // 2</code>。</li></ul><p><strong>3. 模板三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>这一版代码和模板二没有本质区别，一个显著的标志是：循环可以继续的条件是 <code>while (left + 1 &lt; right):</code>，这说明在退出循环的时候，一定有 <code>left + 1 == right</code> 成立，也就是退出循环以后，区间有 2 个元素，即 <code>[left, right]</code>；</li><li>这种写法的优点是：不用理解上一个版本在分支出现 left &#x3D; mid 的时候中间数上取整的行为；</li><li>缺点是显而易见的：<ul><li><code>while (left + 1 &lt; right):</code> 写法相对于 <code>while (left &lt; right):</code> 和 <code>while (left &lt;= right):</code> 来说并不自然；</li><li>由于退出循环以后，区间一定有两个元素，需要思考哪一个元素才是需要找的，即「后处理」一定要做，有些时候还会有先考虑 <code>left</code> 还是 <code>right</code> 的区别。</li></ul></li></ul><p><strong>小结：</strong></p><ul><li>模板一：最好理解的版本，但是在刷题的过程中，需要处理一些边界的问题，一不小心容易出错；</li><li>模板二：强烈推荐掌握的版本，应先理解思想，再通过实际应用去体会这个模板的细节，熟练使用以后就会觉得非常自然；</li><li>模板三：可以认为是模板二的避免踩坑版本，只要深刻理解了模板二，模板三就不在话下。</li></ul><p> &#x3D;&#x3D;实际应用中，选择最好理解的版本即可。&#x3D;&#x3D;</p><p>这里有一个提示：模板二考虑的细节最少，可以用于解决一些相对复杂的问题。缺点是：学习成本较高，初学的时候比较容易陷入死循环，建议大家通过多多使用，并且尝试 debug，找到死循环的原因，进而掌握。</p><p>题解核心内容：所有模板都一样，不可以套模板，而应该<font color=#9900CC><strong>仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。一定要分析清楚题目的意思，分析清楚要找的答案需要满足什么性质。应该清楚模板具体的用法，明白需要根据题意灵活处理、需要变通的地方，不可以认为每一行代码都是模板规定死的写法，不可以盲目套用、死记硬背。</font></strong></p><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-二分求下标（在数组中查找符合条件的元素的下标）"><a href="#2-1-二分求下标（在数组中查找符合条件的元素的下标）" class="headerlink" title="2.1 二分求下标（在数组中查找符合条件的元素的下标）"></a>2.1 二分求下标（在数组中查找符合条件的元素的下标）</h3><p><strong>题库列表</strong></p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>704</td><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank">二分查找</a>（简单）</td></tr><tr><td>35</td><td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank">搜索插入位置</a>（简单）</td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank">最长上升子序列</a>（中等）</td></tr><tr><td>34</td><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank">在排序数组中查找元素的第一个和最后一个位置</a>（简单）</td></tr><tr><td>611</td><td><a href="https://leetcode-cn.com/problems/valid-triangle-number/" target="_blank">有效三角形的个数</a></td></tr><tr><td>436</td><td><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank">寻找右区间</a>（中等）</td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank">寻找两个有序数组的中位数</a>（困难）</td></tr></tbody></table><h3 id="2-2-完全有序"><a href="#2-2-完全有序" class="headerlink" title="2.2 完全有序"></a>2.2 完全有序</h3><p><strong>704. 二分查找</strong><br>题目描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lower_bound 返回最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class="line"><span class="comment"># 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span></span><br><span class="line"><span class="comment"># 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 闭区间 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left-1] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right+1] &gt;= target</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>      <span class="comment"># 范围缩小到 [mid+1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span>     <span class="comment"># 范围缩小到 [left, mid-1]</span></span><br><span class="line">    <span class="keyword">return</span> left                 <span class="comment"># 或者 right+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左闭右开区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound2</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 左闭右开区间 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left-1] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right] &gt;= target</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 范围缩小到 [mid+1, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 范围缩小到 [left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 或者 right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound3</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 开区间 (left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right] &gt;= target</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid  <span class="comment"># 范围缩小到 (mid, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 范围缩小到 (left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> right  <span class="comment"># 或者 left+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = lower_bound(nums, target)  <span class="comment"># 选择其中一种写法即可</span></span><br><span class="line">        <span class="keyword">return</span> i <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.47omstlu8nc0.gif#pic_center" width = 64%><p><strong>35. 搜索插入位置</strong></p><p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.3nhyvtn9ruw0.gif#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)          <span class="comment"># 采用左闭右开区间[left,right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:                 <span class="comment"># 右开所以不能有=,区间不存在</span></span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span>  <span class="comment"># 防止溢出, //表示整除</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:          <span class="comment"># 中点小于目标值,在右侧,可以得到相等位置</span></span><br><span class="line">                left = mid + <span class="number">1</span>              <span class="comment"># 左闭, 所以要+1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid                 <span class="comment"># 右开, 真正右端点为mid-1</span></span><br><span class="line">        <span class="keyword">return</span> left                         <span class="comment"># 此算法结束时保证left = right, 返回谁都一样</span></span><br></pre></td></tr></table></figure><p><strong>300. 最长上升子序列</strong><br>题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>1. 动态规划 + 二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dynamic programming + Dichotomy.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tails, res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            i, j = <span class="number">0</span>, res</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tails[m] &lt; num: </span><br><span class="line">                    i = m + <span class="number">1</span>           <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    j = m</span><br><span class="line">            tails[i] = num</span><br><span class="line">            <span class="keyword">if</span> j == res: </span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.1xoae36xmhc0.gif#pic_center" width = 48%><p><strong>2. 动态规划</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]: <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.e4s3129neio.gif#pic_center" width = 48%><p><strong>34. 在排序数组中查找元素的第一个和最后一个位置</strong></p><p>题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> target <span class="keyword">not</span> <span class="keyword">in</span> nums:          <span class="comment"># 特例，二分查找失败</span></span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [self.lower_bound(nums, target), self.upper_bound(nums, target)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">upper_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):    <span class="comment"># 寻找上边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:     <span class="comment"># 移动左指针</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 移动右指针</span></span><br><span class="line">                right = mid -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):    <span class="comment"># 寻找下边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:         <span class="comment"># 当nums[mid]大于等于目标值时，继续在左区间检索，找到第一个数</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:           <span class="comment"># nums[mid]小于目标值时，则在右区间继续检索，找到第一个等于目标值的数</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.7fkctqmkt4w0.gif#pic_center" width = 48%><p><strong>611. 有效三角形的个数</strong><br>题目描述：给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。</p><p>将数组 nums 进行升序排序，随后使用二重循环枚举 a 和 b。设 $a&#x3D;nums[i], b&#x3D;nums[j]$，为了防止重复统计答案，我们需要保证 $i&lt;j$。剩余的边 c 需要满足 $c&lt;nums[i]+nums[j]$，我们可以在 $[j+1,n−1]$ 的下标范围内使用二分查找（其中 $n$ 是数组 nums 的长度），找出最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标 $k$，这样一来，在 $[j+1, k]$ 范围内的下标都可以作为边 $c$ 的下标，我们将该范围的长度 $k−j$ 累加入答案。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.1j77tet7j800.webp#pic_center" width = 45%><p><strong>1. 排序+二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                left, right = j+<span class="number">1</span>, length              </span><br><span class="line">                <span class="keyword">while</span> left &lt; right:             <span class="comment"># 找边界，</span></span><br><span class="line">                    mid = (left + right)//<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> nums[mid] &lt; nums[i] + nums[j]:</span><br><span class="line">                        left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right = mid</span><br><span class="line">                ans += left - <span class="number">1</span> - j</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>2. 排序+双指针</strong></p><p>我们将当 $a&#x3D;nums[i], b&#x3D;nums[j]$ 时，最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标 $k$ 记为 $k_{i,j}$。可以发现，如果我们固定 $i$，那么随着 $j$ 的递增，不等式右侧 $nums[i]+nums[j]$ 也是递增的，因此 $k_{i,j}$ 也是递增的。</p><p>这样一来，我们就可以将 $j$ 和 $k$ 看成两个同向（递增）移动的指针，将方法一进行如下的优化：</p><ul><li>我们使用一重循环枚举 $i$。当 $i$ 固定时，我们使用双指针同时维护 $j$ 和 $k$，它们的初始值均为 $i$；</li><li>我们每一次将 $j$ 向右移动一个位置，即 $j←j+1$，并尝试不断向右移动 $k$，使得 $k$ 是最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标。我们将 $max(k−j, 0)$ 累加入答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            k = i + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                <span class="keyword">while</span> k+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[i] + nums[j] &gt; nums[k+<span class="number">1</span>]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ans += <span class="built_in">max</span>(k-j, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>436. 寻找右区间</strong><br>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4vfedl22glc0.webp#pic_center" width = 64%></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.24c1qurj96ww.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRightInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start_map = &#123;interval[<span class="number">0</span>] : i <span class="keyword">for</span> i, interval <span class="keyword">in</span> <span class="built_in">enumerate</span>(intervals)&#125;       <span class="comment"># 以区间左侧构建索引字典</span></span><br><span class="line">        starts = [interval[<span class="number">0</span>] <span class="keyword">for</span> interval <span class="keyword">in</span> intervals]                            <span class="comment"># 取出区间的左侧</span></span><br><span class="line">        res = []</span><br><span class="line">        starts.sort()</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            pos = self.higher_find(starts, interval[<span class="number">1</span>])                             <span class="comment"># 遍历每个区间的右侧，在所有区间的左侧进行二分查找</span></span><br><span class="line">            res.append(start_map[starts[pos]] <span class="keyword">if</span> pos != -<span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">higher_find</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)              <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[left] &gt;= target:    <span class="comment"># 最后判断一下，是否满足条件</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.3zi4l9anjzo0.gif#pic_center" width = 48%><p><strong>4. 寻找两个正序数组的中位数</strong></p><p>题目描述：给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 $O(log (m+n))$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getKthElement</span>(<span class="params">k</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            - 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="string">            - 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="string">            - nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="string">            - nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="string">            - 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="string">            - 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="string">            - 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="string">            - 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="string">            - 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            </span><br><span class="line">            index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> index1 == m:</span><br><span class="line">                    <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> index2 == n:</span><br><span class="line">                    <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 正常情况</span></span><br><span class="line">                newIndex1 = <span class="built_in">min</span>(index1 + k // <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>)</span><br><span class="line">                newIndex2 = <span class="built_in">min</span>(index2 + k // <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">                <span class="keyword">if</span> pivot1 &lt;= pivot2:</span><br><span class="line">                    k -= newIndex1 - index1 + <span class="number">1</span></span><br><span class="line">                    index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= newIndex2 - index2 + <span class="number">1</span></span><br><span class="line">                    index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        totalLength = m + n</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> getKthElement((totalLength + <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(totalLength // <span class="number">2</span>) + getKthElement(totalLength // <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.2oxogh32hg80.webp#pic_center" width = 48%><h3 id="2-3-不完全有序"><a href="#2-3-不完全有序" class="headerlink" title="2.3 不完全有序"></a>2.3 不完全有序</h3><p><strong>题库列表：</strong></p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>33</td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank">搜索旋转排序数组</a>（中等）</td></tr><tr><td>81</td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank">搜索旋转排序数组 II</a>（中等）</td></tr><tr><td>153</td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank">寻找旋转排序数组中的最小值</a>（中等）</td></tr><tr><td>154</td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank">寻找旋转排序数组中的最小值 II</a>（困难）</td></tr><tr><td>852</td><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank">山脉数组的峰顶索引</a>（简单）</td></tr><tr><td>1095</td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank">山脉数组中查找目标值</a>（中等）</td></tr></tbody></table><p><strong>33. 搜索旋转排序数组</strong></p><p>题目描述：整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 $k(0 &lt;&#x3D; k &lt; nums.length)$ 上进行了旋转，使数组变为 $[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]$（下标从0开始计数）。例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:                        <span class="comment"># 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:           <span class="comment"># target 在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                                           <span class="comment"># 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]: <span class="comment"># target 在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.qtcvkzfq8u8.webp#pic_center" width = 48%><p><strong>81. 搜索旋转排序数组 II</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.7guqdqr87o80.webp#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[left]:         <span class="comment"># 去重</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:        <span class="comment"># 左半部分有序，在左侧二分查找</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment"># 右半部分有序，在右侧二分查找</span></span><br><span class="line">                <span class="keyword">if</span>  nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>153. 寻找旋转排序数组中的最小值</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.4356lavtjeq0.webp#pic_center" width = 75%><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.2auzerg0b7fo.webp#pic_left" width = "45%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.3bntek4m9bu0.webp#pic_left"  width = "45%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:    </span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[pivot] &lt; nums[high]:</span><br><span class="line">                high = pivot </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure><p><strong>154. 寻找旋转排序数组中的最小值 II</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.5nj47nf02sw0.webp#pic_center" width = 75%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left+right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span>              <span class="comment"># 去重</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.zrj5dh2d3rk.gif#pic_center" width = 36%><p><strong>852. 山脉数组的峰顶索引（简单）</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.728jhdo84ho0.webp#pic_center" width = 75%><p><strong>1. 顺序查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peakIndexInMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 顺序查找最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p><strong>2. 二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peakIndexInMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 二分查找最大值</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &gt; arr[mid + <span class="number">1</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>1095. 山脉数组中查找目标值</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.309t987j7680.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findInMountainArray</span>(<span class="params">self, target: <span class="built_in">int</span>, mountain_arr: <span class="string">&#x27;MountainArray&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        先使用二分法找到数组的峰值。</span></span><br><span class="line"><span class="string">        在峰值左边使用二分法寻找目标值。</span></span><br><span class="line"><span class="string">        如果峰值左边没有目标值，那么使用二分法在峰值右边寻找目标值。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        head, tail = <span class="number">0</span>, mountain_arr.length()-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:             <span class="comment"># 找峰值，注意越界处理</span></span><br><span class="line">            mid = (head+tail)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; mountain_arr.get(mid+<span class="number">1</span>):</span><br><span class="line">                head = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tail = mid</span><br><span class="line">        peak = head</span><br><span class="line">        ans = self.binarySearch(mountain_arr, target, <span class="number">0</span>, peak)                                              <span class="comment"># 在左半边搜索</span></span><br><span class="line">        <span class="keyword">if</span> ans != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(mountain_arr, target, peak+<span class="number">1</span>, mountain_arr.length()-<span class="number">1</span>, <span class="keyword">lambda</span> x:-x)        <span class="comment"># 在右半边搜索</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">self, mountain, target, left, right, key=<span class="keyword">lambda</span> x: x</span>): </span><br><span class="line">        target = key(target)                            <span class="comment"># 这里的key相当于把两边全部转为升序部分，也可以用target*reverse，根据reverse的正负来判断</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            curr = key(mountain.get(mid))</span><br><span class="line">            <span class="keyword">if</span> curr == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> curr &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-4-二分答案（在一个有范围的区间里搜索一个整数）"><a href="#2-4-二分答案（在一个有范围的区间里搜索一个整数）" class="headerlink" title="2.4 二分答案（在一个有范围的区间里搜索一个整数）"></a>2.4 二分答案（在一个有范围的区间里搜索一个整数）</h3><p>如果题目要我们找一个整数，这个整数有确定的范围，可以通过二分查找逐渐缩小范围，最后逼近到一个数。</p><p>定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。</p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>69</td><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank">x 的平方根</a>（简单）</td></tr><tr><td>287</td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank">寻找重复数</a>（中等）</td></tr><tr><td>374</td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank">猜数字大小</a>（简单）</td></tr></tbody></table><p><strong>69. x 的平方根</strong></p><p>题目描述：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right= <span class="number">0</span>, x//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> left-<span class="number">1</span>          </span><br></pre></td></tr></table></figure><p><strong>287. 寻找重复数</strong></p><p>题目描述：给定一个包含 $n+1$ 个整数的数组 nums ，其数字都在 $[1, n]$ 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数。你设计的解决方案必须 不修改 数组 nums 且只用常量级 $O(1)$ 的额外空间。</p><p><strong>1. 二分法</strong></p><p>设数组长度为nnn，则数组中元素 $\in[1, n-1]$，且只有一个重复元素。一个直观的想法，设一个数字 $k\in[1,n-1]$，统计数组中小于等于 $k$ 的数字的个数 count：</p><ul><li>若 $count&lt;&#x3D;k$，说明重复数字一定在 $(k,n−1]$ 的范围内。</li><li>若 $count&gt;k$，说明重复数字一定在 $[0,k]$ 的范围内。<br>利用这个性质，我们使用二分查找逐渐缩小重复数字所在的范围。</li></ul><ol><li>初试化左右 数字 边界 $left&#x3D;1, right&#x3D;n-1$</li><li>循环条件 $left&lt;right:$<ul><li>$mid&#x3D;(left+right)&#x2F;&#x2F;2$</li><li>按照性质，统计数组中小于等于 $mid$ 的元素个数 $count$</li><li>若 $count&lt;&#x3D;mid$，说明重复数字一定在 $(mid,right]$ 的范围内。令 $left&#x3D;mid+1$</li><li>若 $count&gt;mid$，说明重复数字一定在 $[left,mid]$ 的范围内。令 $right&#x3D;mid$。</li></ul></li><li>返回 $left$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=mid):</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(count&lt;=mid):</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>2. 快慢指针</strong></p><p>分为两步：</p><ol><li>找到环</li><li>找到环的入口（即重复元素）</li></ol><p>找环：</p><ol><li>定义快慢指针 $slow&#x3D;0, fast&#x3D;0$</li><li>进入循环：<br> - $slow$ 每次走一步，即 $slow&#x3D;nums[slow]$<br> - $fast$ 每次走两步，即 $fast&#x3D;nums[nums[fast]]$<br> - 当 $slow&#x3D;&#x3D;fast$时，退出循环。 当快慢指针相遇时，一定在环内。此时假设slow 走了 $k$ 步，则 fast 走了 $2k$ 步。设环的周长为 $c$，则 $k%c&#x3D;&#x3D;0$。</li></ol><p>找环的入口：</p><ol><li>定义新的指针 $find&#x3D;0$</li><li>进入循环：<ul><li>find 每次走一步，即 $find&#x3D;nums[find]$</li><li>slow每次走一步，即 $slow&#x3D;nums[slow]$</li><li>当两指针相遇时，即 $find&#x3D;&#x3D;slow$，返回 find</li></ul></li></ol><p>为何相遇时，找到的就是入口： 假设起点到环的入口(重复元素)，需要 $m$ 步。此时 slow 走了 $n+m$ 步，其中 $n$ 是环的周长 $c$ 的整数倍，所以相当于 slow走了 $m$ 步到达入口，再走了 $n$ 步。所以相遇时一定是环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow=<span class="number">0</span></span><br><span class="line">        fast=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            slow=nums[slow]</span><br><span class="line">            fast=nums[nums[fast]]</span><br><span class="line">            <span class="keyword">if</span>(slow==fast):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        find=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            find=nums[find]</span><br><span class="line">            slow=nums[slow]</span><br><span class="line">            <span class="keyword">if</span>(find==slow):</span><br><span class="line">                <span class="keyword">return</span> find</span><br></pre></td></tr></table></figure><p><strong>374. 猜数字大小</strong></p><p>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.6x7yhtzgw4g0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The guess API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param num, your guess</span></span><br><span class="line"><span class="comment"># @return -1 if num is higher than the picked number</span></span><br><span class="line"><span class="comment">#          1 if num is lower than the picked number</span></span><br><span class="line"><span class="comment">#          otherwise return 0</span></span><br><span class="line"><span class="comment"># def guess(num: int) -&gt; int:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">guessNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + ((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            temp = guess(mid)</span><br><span class="line">            <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> temp == <span class="number">1</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.p6o8es6da34.webp#pic_center" width = 64%><hr><blockquote><p><font color=#9900CC><strong>二分法暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.6rf3tza12s0.gif#pic_center" width = 48%><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>二分查找算法：<a href="https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README">https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README</a></li><li>二分算法：<a href="https://oi-wiki.org/basic/binary/">https://oi-wiki.org/basic/binary/</a></li><li>二分查找：<a href="https://www.cnblogs.com/jasonbourne3/p/17141780.html">https://www.cnblogs.com/jasonbourne3/p/17141780.html</a></li><li>算法与数据结构（七）：二分查找法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/94332149">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;94332149</a></li><li>一文带你搞定二分查找及其多个变种：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/</a></li><li>写对二分查找不是套模板并往里面填空，需要仔细分析题意：<a href="https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></li><li>二分查找（折半查找）算法详解：<a href="http://data.biancheng.net/view/336.html">http://data.biancheng.net/view/336.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码和常见的解题技巧，带大家学透二分算法&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="二分答案" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="有序数组" scheme="https://qxienote.com/tags/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    
    <category term="旋转数组" scheme="https://qxienote.com/tags/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    
    <category term="山脉数组" scheme="https://qxienote.com/tags/%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（四）-- 滑动窗口算法</title>
    <link href="https://qxienote.com/article/f08fb2ff.html"/>
    <id>https://qxienote.com/article/f08fb2ff.html</id>
    <published>2023-06-11T03:07:57.000Z</published>
    <updated>2023-06-11T03:43:10.309Z</updated>
    
    <content type="html"><![CDATA[<p>本篇带你走进滑动窗口算法，进一步强化双指针的使用，  滑动窗口算法常用于字符串匹配问题和子数组问题，本篇就总结出来Python的编写模板，从此刷题不心慌！</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。</p><h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1 滑动窗口"></a>1 滑动窗口</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>在计算机网络里经常用到滑动窗口协议（Sliding Window Protocol），该协议是 TCP协议 的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。</p><p>滑动窗口算法其实和这个是一样的，只是用的地方场景不一样，可以根据需要调整窗口的大小，有时也可以是固定窗口大小。</p><p>滑动窗口使用双指针解决问题，所以一般也叫双指针算法，因为两个指针间形成一个窗口。双指针也并不局限在数组问题，像链表场景的 “快慢指针” 也属于双指针的场景，其快慢指针滑动过程中本身就会产生一个窗口，比如当窗口收缩到某种程度，可以得到一些结论。</p><p><font color=#9900CC><strong>什么情况适合用滑动窗口算法呢？</font></strong></p><ul><li>需要输出或比较的结果在原数据结构中是连续排列的，特别是数组或链表问题；</li><li>每次窗口滑动时，只需观察窗口两端元素的变化，无论窗口多长，每次只操作两个头尾元素，当用到的窗口比较长时，可以显著减少操作次数；</li><li>窗口内元素的整体性比较强，窗口滑动可以只通过操作头尾两个位置的变化实现，但对比结果时往往要用到窗口中所有元素。</li></ul><p>滑动窗口算法常用于字符串匹配问题和子数组问题。</p><blockquote><p>滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来<font color=#9900CC><strong>滑动窗口主要应用在数组和字符串上。</strong></font></p></blockquote><h3 id="1-2-滑动窗口法的大体框架"><a href="#1-2-滑动窗口法的大体框架" class="headerlink" title="1.2 滑动窗口法的大体框架"></a>1.2 滑动窗口法的大体框架</h3><p>在介绍滑动窗口的框架时候，大家先从字面理解下：</p><ul><li>滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。</li><li>窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</li></ul><p>为了便于理解，这里采用的是字符串来讲解。但是对于数组其实也是一样的。<strong>滑动窗口算法的思路是这样：</strong></p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left &#x3D; right &#x3D; 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</li><li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol><p>这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><h3 id="1-3-滑动窗口模板"><a href="#1-3-滑动窗口模板" class="headerlink" title="1.3 滑动窗口模板"></a>1.3 滑动窗口模板</h3><p><strong>滑窗模板 Python 伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">problemName</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line">        x, y = ..., ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">            x = new_x</span><br><span class="line">            <span class="keyword">if</span> condition:</span><br><span class="line">                y = new_y</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            ------------- 下面是两种情况，读者请根据题意二选1 -------------</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># Step 4 - 情况1</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 </span></span><br><span class="line">            <span class="comment"># 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, </span></span><br><span class="line">            <span class="comment"># 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span> 窗口长度达到了限定长度:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 - 情况2</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span> 不合法:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针(end)作为驱动，拖着左指针(start)向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote><ul><li><p><a href="https://leetcode.cn/problems/maximum-average-subarray-i/" target="_blank">643. 子数组最大平均数 I</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-erasure-value/" target="_blank">1695. 删除子数组的最大得分</a></p></li><li><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank">438. 找到字符串中所有字母异位词</a></p></li><li><p><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></p></li><li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-ii/" target="_blank">487. 最大连续1的个数 II</a></p></li><li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/" target="_blank">1004. 最大连续1的个数 III</a></p></li><li><p><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/" target="_blank">1208. 尽可能使字符串相等</a></p></li><li><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/" target="_blank">1052. 爱生气的书店老板</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/" target="_blank">1151. 最少交换次数来组合所有的1 Π</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></p></li><li><p><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></p></li></ul></blockquote> <h3 id="2-2-真题演练"><a href="#2-2-真题演练" class="headerlink" title="2.2 真题演练"></a>2.2 真题演练</h3><p><strong>643. 子数组最大平均数 I</strong><br>题目描述：给你一个由 n 个元素组成的整数数组 nums 和一个整数 k。请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本题求最大平均值 (其实就是求最大和)，所以需要定义sum_sub_array, 同时定义一个max_value (初始值为负无穷)</span></span><br><span class="line">        sum_sub_array, max_value = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (sum_sub_array, max_value), 不断把当前值积累到sum_sub_array上</span></span><br><span class="line">            sum_sub_array += num</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_value = <span class="built_in">max</span>(max_value, sum_sub_array)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口首指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= k - <span class="number">1</span>:</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_value/k</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.25s1cl9rnrxc.gif#pic_center" width = 48%><p><strong>3. 无重复字符的最长子串</strong></p><p>题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hash_map = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度</span></span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hash_map) == end - start + <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hash_map):</span><br><span class="line">                head = s[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hash_map[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hash_map[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.1zysuq1eegbk.gif#pic_center" width = 48%><p><strong>159. 至多包含两个不同字符的最长子串</strong></p><p>题目描述：给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringTwoDistinct</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题求最大长度，所以需要定义max_len,</span></span><br><span class="line">        <span class="comment"># 该题又涉及计算不重复元素个数，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># 首先，把当前元素的计数加一</span></span><br><span class="line">            <span class="comment"># 一旦哈希表长度小于等于2(之多包含2个不同元素)，尝试更新最大长度</span></span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) &lt;= <span class="number">2</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表长度大于2的时候 (说明存在至少3个重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(hashmap) &gt; <span class="number">2</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><strong>209. 长度最小的子数组</strong></p><p>题目描述：给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 $[nums_l, nums_{l+1}, …, nums_{r-1}, nums_r]$，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量</span></span><br><span class="line">        min_len, sum_sub_array = math.inf, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (min_len, sum_sub_array)</span></span><br><span class="line">            sum_sub_array += num</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这一段可以删除，因为下面的while已经handle了这一块儿逻辑，不过写在这也没影响</span></span><br><span class="line">            <span class="keyword">if</span> sum_sub_array &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 这一题这里稍微有一点特别: sum_sub_array &gt;= target其实是合法的，但由于我们要求的是最小长度，</span></span><br><span class="line">            <span class="comment"># 所以当sum_sub_array已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案</span></span><br><span class="line">            <span class="comment"># 由于左指针的移动可能影响min_len和sum_sub_array的值，因此需要在移动前将它们更新</span></span><br><span class="line">            <span class="keyword">while</span> sum_sub_array &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5：返回答案 (最小长度)</span></span><br><span class="line">        <span class="keyword">if</span> min_len == math.inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.7089o47r9v00.gif#pic_center" width = 48%><p><strong>1695. 删除子数组的最大得分</strong></p><p>题目描述：给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和。返回 只删除一个 子数组可获得的 最大得分。如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumUniqueSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题最大得分，所以需要定义当前得分sum_sub_array和最大得分max_sum</span></span><br><span class="line">        <span class="comment"># 本题又涉及去重 (题目规定子数组不能有重复)，因此还需要一个哈希表</span></span><br><span class="line">        sum_sub_array, max_sum, hashmap = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array, hashmap)</span></span><br><span class="line">            <span class="comment"># sum和hashmap需要更新就不说了，max_sum当且仅当哈希表里面没有重复元素时 (end - start + 1 == len(hashmap)) 更新</span></span><br><span class="line">            sum_sub_array += tail</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == <span class="built_in">len</span>(hashmap):</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, sum_sub_array)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表里面有重复元素时 (end - start + 1 &gt; len(hashmap)) 窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap， sum_sub_array)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hashmap):</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><p><strong>438. 找到字符串中所有字母异位词</strong></p><p>题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本文需要对比两组字符串是否为异位词，所以用哈希表 (abc和bac是异位词是因为他们对应的哈希表相等)</span></span><br><span class="line">        <span class="comment"># 同时我们需要找到所有合法解，所以还需要一个ans数组</span></span><br><span class="line">        ans, hashmap_s = [], &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1： 同时把p的哈希表也建立了 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hashmap_p = Counter(p)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hashmap)， 如果hashmap == hashmap_p，代表找到了一个解，加入到ans</span></span><br><span class="line">            hashmap_s[tail] = hashmap_s.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap_s == hashmap_p:</span><br><span class="line">                ans.append(start)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(p) - <span class="number">1</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap_s[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap_s[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap_s[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.13gnl7q09urg.webp#pic_center" width = 36%><p><strong>567. 字符串的排列</strong></p><p>题目描述：给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为和排列相关 (元素相同，顺序可以不同)，使用哈希表</span></span><br><span class="line">        hash_map_s2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1: 同时建立s1的哈希表 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hash_map_s1 = Counter(s1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s2):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hash_map_s2)， 如果hash_map_s1 == hash_map_s2，代表s2包含s1的排列，直接return</span></span><br><span class="line">            hash_map_s2[tail] = hash_map_s2.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map_s1 == hash_map_s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hash_map_s2)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(s1) - <span class="number">1</span>:</span><br><span class="line">                head = s2[start]</span><br><span class="line">                hash_map_s2[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hash_map_s2[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hash_map_s2[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5： 没有在s2中找到s1的排列，返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.6alyfc9r05s0.gif#pic_center" width = 48%><p><strong>487. 最大连续1的个数 II</strong></p><p>题目描述：给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计数 (0的个数不能超过1个)，所以还要一个哈希表</span></span><br><span class="line">        max_len, hash_map = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hash_map， max_len)</span></span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当hash_map里面0的个数大于1的时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hash_map)</span></span><br><span class="line">            <span class="keyword">while</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">1</span>:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><strong>1004. 最大连续1的个数 III</strong><br>题目描述：给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len, start = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= k:     <span class="comment"># 相比较于上一题，只需要把1改成k</span></span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end-start+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &gt; k:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.351qb5gxbne0.gif#pic_center" width = 48%><p><strong>1208. 尽可能使字符串相等</strong><br>题目描述：给你两个长度相同的字符串，s 和 t。将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, max_cost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计算开销 (和求和一个道理)， 所以还要一个cur_cost</span></span><br><span class="line">        cur_cost, max_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (cur_cost)</span></span><br><span class="line">            <span class="comment"># 每一对字符的order差值就是当前时间点的开销，直接累积在cur_cost上即可</span></span><br><span class="line">            <span class="comment"># cur_cost只要不超过最大开销，就更新max_len</span></span><br><span class="line">            cur_cost += <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[end]) - <span class="built_in">ord</span>(t[end]))</span><br><span class="line">            <span class="keyword">if</span> cur_cost &lt;= max_cost:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当cur_cost大于最大开销时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法 (cur_cost &lt;= max_cost)</span></span><br><span class="line">            <span class="keyword">while</span> cur_cost &gt; max_cost:</span><br><span class="line">                cur_cost -= <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[start])-  <span class="built_in">ord</span>(t[start]))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.3j0vqxe6f6g0.gif#pic_center" width = 48%><p><strong>1052. 爱生气的书店老板</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.6xm4xkuf5qg0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量,</span></span><br><span class="line">        <span class="comment"># 因为涉及求和所以定义sum_sub_array和max_sum, 同时需要知道老板什么时候&#x27;发动技能&#x27;，再定义一个max_start</span></span><br><span class="line">        sum_sub_array, max_sum, max_start = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(customers):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            <span class="comment"># 注意：这里只要当老板在当前时间点会发脾气的时候才维护</span></span><br><span class="line">            <span class="comment"># sum_sub_array就不说了，和前面N道题的维护方法一样，新多出来的max_start也就是记录一样时间点而已，没什么fancy的</span></span><br><span class="line">            <span class="keyword">if</span> grumpy[end] == <span class="number">1</span>:</span><br><span class="line">                sum_sub_array += tail</span><br><span class="line">            <span class="keyword">if</span> sum_sub_array &gt; max_sum:</span><br><span class="line">                max_sum = sum_sub_array</span><br><span class="line">                max_start = start</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (老板技能持续时间固定)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_sub_array, max_avg)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= minutes - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> grumpy[start]:</span><br><span class="line">                    sum_sub_array -= customers[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里对比其他题目多了一小步: 在找到老板发动技能的最大收益时间点(max_start)后</span></span><br><span class="line">        <span class="comment"># 需要把受技能影响时间段中的grumpy全部置0 - 代表老板成功压制了自己的怒火</span></span><br><span class="line">        grumpy[max_start:max_start+minutes] = [<span class="number">0</span>] * minutes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 再遍历一遍数组求customer总数量并且返回结果   </span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> customer, grum <span class="keyword">in</span> <span class="built_in">zip</span>(customers, grumpy):</span><br><span class="line">            <span class="keyword">if</span> grum == <span class="number">0</span>:</span><br><span class="line">                res += customer</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.3wf994p63sc0.gif#pic_center" width = 48%><p><strong>1423. 可获得的最大点数</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.3wwhkrlmfzo0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 这题相比前面的题目加了一丢丢小的变通: 题目要求首尾串最大点数，其实就是求非首尾串的连续序列的最小点数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxScore</span>(<span class="params">self, cardPoints: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，因为涉及求和所以定义sum_sub_array和min_sum</span></span><br><span class="line">        sum_sub_array, min_sum = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(cardPoints):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            sum_sub_array += tail</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cardPoints)-k == end - start + <span class="number">1</span>:</span><br><span class="line">                min_sum = <span class="built_in">min</span>(min_sum, sum_sub_array)</span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (min_sum， sum_sub_array)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(cardPoints) - k - <span class="number">1</span>:</span><br><span class="line">                sum_sub_array -= cardPoints[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (总点数减去非首尾串的连续序列的最小点数就可以得到首尾串的最大点数)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cardPoints) - min_sum <span class="keyword">if</span> min_sum != inf <span class="keyword">else</span> <span class="built_in">sum</span>(cardPoints)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.6ahf0vp2uk4.gif#pic_center" width = 36%><p><strong>1151. 最少交换次数来组合所有的1 Π</strong></p><p>题目描述：给出一个二进制数组data，你需要通过交换位置，将数组中任何位置上的1组合到一起，并返回所有可能中所需最少的交换次数。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.7k6gqpmoa5s0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSwaps</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先数出一共有多少个1，输出来的个数就是窗口的长度</span></span><br><span class="line">        num_ones = data.count(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，求最小swap次数其实就是求窗口中0个数的最小值，因此定义num_zeros, min_num_zeros</span></span><br><span class="line">        num_zeros, min_num_zeros = <span class="number">0</span>, math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (num_zeros， min_num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> data[end] == <span class="number">0</span>:</span><br><span class="line">                num_zeros += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == num_ones:</span><br><span class="line">                min_num_zeros = <span class="built_in">min</span>(min_num_zeros, num_zeros)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (数组1的总个数)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= num_ones - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> data[start] == <span class="number">0</span>:</span><br><span class="line">                    num_zeros -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (如果min_num_zeros依旧是math.inf说明数组没有1存在，不能swap，返回0即可)</span></span><br><span class="line">        <span class="keyword">return</span> min_num_zeros <span class="keyword">if</span> min_num_zeros != math.inf <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>76. 最小覆盖子串</strong></p><p>题目描述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        need_dict = Counter(t)                      <span class="comment"># 哈希表：记录需要匹配到的各个元素的数目</span></span><br><span class="line">        need_count = <span class="built_in">len</span>(t)                         <span class="comment"># 记录需要匹配到的字符总数(need=0表示匹配到了)</span></span><br><span class="line">        left = <span class="number">0</span>                                    <span class="comment"># 窗口的左边界</span></span><br><span class="line">        res = (<span class="number">0</span>, inf)                              <span class="comment"># 记录目标子串 s[res[0], res[1]+1] 的起始和结尾</span></span><br><span class="line">        <span class="keyword">for</span> right, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):             <span class="comment"># 窗口右边界右移一位，窗口中增加的字符 tail</span></span><br><span class="line">            <span class="keyword">if</span> tail <span class="keyword">in</span> need_dict:                    <span class="comment"># 窗口新加入的字符位于t中</span></span><br><span class="line">                <span class="keyword">if</span> need_dict[tail] &gt; <span class="number">0</span>:              <span class="comment"># 对当前字符还有需求</span></span><br><span class="line">                    need_count -= <span class="number">1</span>                 <span class="comment"># 此时新加入窗口中的 tail 对 need_count 有影响</span></span><br><span class="line">                need_dict[tail] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> need_count == <span class="number">0</span>:                  <span class="comment"># 窗口左边界持续右移，need_count=0，当前窗口完全覆盖了 t</span></span><br><span class="line">                <span class="keyword">if</span> res[<span class="number">1</span>] - res[<span class="number">0</span>] &gt; right - left:  <span class="comment"># 出现了更短的字符串</span></span><br><span class="line">                    res = (left, right)</span><br><span class="line">                head = s[left]                       <span class="comment"># 窗口中要滑出的字符 head</span></span><br><span class="line">                <span class="keyword">if</span> head <span class="keyword">in</span> need_dict:                <span class="comment"># 刚滑出的字符 head 位于 t 中</span></span><br><span class="line">                    <span class="keyword">if</span> need_dict[head] &gt;= <span class="number">0</span>:         <span class="comment"># 对当前字符ch还有需求，或刚好无需求(其实此时只有=0的情况)</span></span><br><span class="line">                        need_count += <span class="number">1</span>             <span class="comment"># 此时滑出窗口的 head 会对 need_count 有影响</span></span><br><span class="line">                    need_dict[head] += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span>                           <span class="comment"># 窗口左边界+1</span></span><br><span class="line">        <span class="keyword">return</span> s[res[<span class="number">0</span>]:res[<span class="number">1</span>]+<span class="number">1</span>] <span class="keyword">if</span> res[<span class="number">1</span>] &lt; <span class="built_in">len</span>(s) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.1kdghtlgzc5c.gif#pic_center" width = 48%><p><strong>239. 滑动窗口最大值</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.bz3b93ddmio.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 用双端队列来存储数组的下标，为什么要存下标而不是存数值？</span></span><br><span class="line">        <span class="comment"># 因为存下标可以更方便的来确定元素是否需要移出滑动窗口</span></span><br><span class="line">        <span class="comment"># 判断下标是否合法来确定是否要移出</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">if</span> k == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">max</span>(nums)]</span><br><span class="line">        result, queue = [], deque()             <span class="comment"># 使用collections内置的双端队列，加快运行速度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前队列最左侧存储的下标等于 i-k 的值，代表目前队列已满。</span></span><br><span class="line">            <span class="comment"># 但是新元素需要进来，所以列表最左侧的下标出队列</span></span><br><span class="line">            <span class="keyword">if</span> queue <span class="keyword">and</span> queue[<span class="number">0</span>] == i - k:           </span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[queue[-<span class="number">1</span>]] &lt; nums[i]:      <span class="comment"># 对于新进入的元素，如果队列前面的数比它小，那么前面的都出队列</span></span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)         <span class="comment"># 新元素入队列</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:            <span class="comment"># 当前的大值加入到结果数组中</span></span><br><span class="line">                result.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>滑动窗口暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.4ql491awvt00.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>双指针套路总结：<a href="https://zhuanlan.zhihu.com/p/95747836">https://zhuanlan.zhihu.com/p/95747836</a></li><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>算法与数据结构（一）：滑动窗口法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/89066140">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;89066140</a></li><li>滑动窗口法python模板写法：<a href="https://blog.csdn.net/weixin_44414948/article/details/113862173">https://blog.csdn.net/weixin_44414948&#x2F;article&#x2F;details&#x2F;113862173</a></li><li>滑动窗口的应用：<a href="https://leetcode.cn/problems/minimum-window-substring/solutions/1503454/by-flix-1kac/">https://leetcode.cn/problems/minimum-window-substring/solutions/1503454/by-flix-1kac/</a></li><li>秒杀12道中档题————滑动窗口：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇带你走进滑动窗口算法，进一步强化双指针的使用，  滑动窗口算法常用于字符串匹配问题和子数组问题，本篇就总结出来Python的编写模板，从此刷题不心慌！&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="https://qxienote.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="最小覆盖子串" scheme="https://qxienote.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    
    <category term="最小/最大数组" scheme="https://qxienote.com/tags/%E6%9C%80%E5%B0%8F-%E6%9C%80%E5%A4%A7%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python 文章汇总</title>
    <link href="https://qxienote.com/article/212a3cab.html"/>
    <id>https://qxienote.com/article/212a3cab.html</id>
    <published>2023-06-11T02:51:09.000Z</published>
    <updated>2023-06-11T03:05:04.479Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是对Python专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1 基础篇"></a>1 基础篇</h2><ul><li><a href="https://qxienote.com/article/175d115.html">Python基础篇（一）– 十分钟学会基础语法</a></li><li><a href="https://qxienote.com/article/8a42c3c2.html">Python基础篇（二）– 数据类型和运算符</a></li><li><a href="">Python基础篇（三）– 列表、元组、字典、集合、字符串</a></li><li><a href="">Python基础篇（四）– 流程控制</a></li><li><a href="">Python基础篇（五）– 函数和表达式</a></li><li><a href="">Python基础篇（六）– 类和对象</a></li><li><a href="">Python基础篇（七）– 迭代器和生成器</a></li><li><a href="">Python基础篇（八）– 文件操作</a></li><li><a href="">Python基础篇（九）– 正则表达式</a></li><li><a href="">Python基础篇（十）– 异常处理</a></li><li><a href="">Python基础篇（十一）– 模块和包</a></li><li><a href="">Python基础篇（十二）– 常用模块</a></li><li><a href="">Python基础篇（十三）– 进程和线程</a></li><li><a href="">Python基础篇（十四）– 数据类dataclass使用指南</a></li><li><a href="">Python基础篇（十五）– Pygame游戏编程</a></li><li><a href="">Python基础篇（十六）– Python标准库模块之heapq与bisect</a></li></ul><h2 id="2-进阶篇"><a href="#2-进阶篇" class="headerlink" title="2 进阶篇"></a>2 进阶篇</h2><ul><li><a href="">Python进阶篇（一）– Django快速上手</a></li><li><a href="">Python进阶篇（二）– Django 深入模型</a></li><li><a href=""></a></li></ul><h2 id="3-数据结构与算法"><a href="#3-数据结构与算法" class="headerlink" title="3 数据结构与算法"></a>3 数据结构与算法</h2><ul><li><a href="https://qxienote.com/article/d46e4964.html">Python数据结构与算法篇（一）– 算法分析基础</a></li><li><a href="https://qxienote.com/article/319c8c73.html">Python数据结构与算法篇（二）– 前缀和与差分数组</a></li><li><a href="https://qxienote.com/article/37ba44a4.html">Python数据结构与算法篇（三）– 快慢指针与碰撞指针</a></li><li><a href="">Python数据结构与算法篇（四）– 滑动窗口算法</a></li><li><a href="">Python数据结构与算法篇（五）– 二分查找与二分答案</a></li><li><a href="">Python数据结构与算法篇（六）– 哈希表</a></li><li><a href="">Python数据结构与算法篇（七）– 栈的实现与应用</a></li><li><a href="">Python数据结构与算法篇（八）– 队列的实现与应用</a></li><li><a href="">Python数据结构与算法篇（九）–单调栈与单调队列</a></li><li><a href="">Python数据结构与算法篇（十）– 链表的实现</a></li><li><a href="">Python数据结构与算法篇（十一）– 链表的应用与常见题型</a></li><li><a href="">Python数据结构与算法篇（十二）– 树和二叉树</a></li><li><a href="">Python数据结构与算法篇（十三）– 位运算与使用技巧</a></li><li><a href="">Python数据结构与算法篇（十四）– 冒泡排序算法</a></li><li><a href="">Python数据结构与算法篇（十五）– 二叉树的遍历：深度优先搜索与广度优先搜索</a></li></ul><h2 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4 数据分析"></a>4 数据分析</h2><ul><li><a href="">Python数据分析（一）– NumPy 学习笔记</a></li><li><a href="">Python数据分析（二）– Matplotlib 学习笔记</a></li><li><a href="">Python数据分析（三）– Matplotlib绘图进阶</a></li><li><a href=""></a></li></ul><h2 id="5-网络爬虫"><a href="#5-网络爬虫" class="headerlink" title="5 网络爬虫"></a>5 网络爬虫</h2><h2 id="6-PyQt5"><a href="#6-PyQt5" class="headerlink" title="6 PyQt5"></a>6 PyQt5</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章是对Python专栏下的文章进行汇总，方便系统地学习和复习。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（三）-- 快慢指针与碰撞指针</title>
    <link href="https://qxienote.com/article/37ba44a4.html"/>
    <id>https://qxienote.com/article/37ba44a4.html</id>
    <published>2023-06-11T02:08:00.000Z</published>
    <updated>2023-06-11T02:50:05.416Z</updated>
    
    <content type="html"><![CDATA[<p>数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。本篇主要分析双指针在字符串数组中常用解题套路。</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。</p><p>双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。</p><p>双指针是一种思想，一种技巧或一种方法，并不是什么特别具体的算法，在二分查找等算法中经常用到这个技巧。具体就是用两个变量动态存储两个或多个结点，来方便我们进行一些操作。通常用在线性的数据结构中，比如链表和数组，有时候也会用在图算法中。</p><p>在我们遇到像数组，链表这类数据结构的算法题目的时候，应该要想得到双指针的套路来解决问题。特别是链表类的题目，经常需要用到两个或多个指针配合来记忆链表上的节点，完成某些操作。链表这种数据结构也是树形结构和图的原型，所以有时候在关于图和树形结构的算法题目中也会用到双指针。</p><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1 双指针"></a>1 双指针</h2><p>双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（碰撞指针或者叫左右指针）的指针进行扫描，从而达到相应的目的。</p><p>换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。</p><h3 id="1-1-快慢指针"><a href="#1-1-快慢指针" class="headerlink" title="1.1 快慢指针"></a>1.1 快慢指针</h3><p>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和 慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。</p><p>利用快慢指针可以用来解决某些算法问题，比如：</p><ul><li>计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。</li><li>判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。</li><li>判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</li><li>求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了</li><li>求链表倒数第 k 个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第 k 个元素。（严格来说应该叫先后指针而非快慢指针）</li></ul><p>快慢指针在链表的详细使用，可以阅读下一篇文章——<a href="https://blog.csdn.net/xq151750111/article/details/129303127?spm=1001.2014.3001.5501">Python数据结构与算法篇（六）– 链表的应用</a></p><h3 id="1-2-碰撞指针"><a href="#1-2-碰撞指针" class="headerlink" title="1.2 碰撞指针"></a>1.2 碰撞指针</h3><p>对撞指针（或者称作左右指针）是指在数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。一般都是排好序的数组或链表，否则无序的话这两个指针的位置也没有什么意义。特别注意两个指针的循环条件在循环体中的变化，小心右指针跑到左指针左边去了。常用来解决的问题有：</p><ul><li>二分查找问题</li><li>n 数之和问题：比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数。如果是三数问题就转化为一个数和另外两个数的两数问题。以此类推。</li></ul><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-快慢指针"><a href="#2-1-快慢指针" class="headerlink" title="2.1 快慢指针"></a>2.1 快慢指针</h3><ul><li>掌握数组删除元素的直接覆盖操作</li><li>双指针法</li></ul><p><strong>题库列表：</strong></p><blockquote> <ul><li><p>26. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank">删除有序数组中的重复项</a> （快慢指针）</p><li><p>27. <a href="https://leetcode-cn.com/problems/remove-element" target="_blank">移除元素</a> （快慢指针）</p><li><p>80. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank">删除有序数组中的重复项 II</a> (快慢指针） </p></li><li><p>283. <a href="https://leetcode.cn/problems/move-zeroes/description/" target="_blank">移动零</a>（快慢指针）</p></li></ul></blockquote> <p><strong>26. 删除有序数组中的重复项</strong></p><p>题目描述：给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow += <span class="number">1</span>                   <span class="comment"># 每个元素只出现一次，先 slow+1 再覆盖</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.3ltlzaihk9e0.gif#pic_center" width = 48%><p><strong>27. 移除元素</strong></p><p>题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>1. 快慢指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 快慢指针</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:               <span class="comment"># 删除指定元素，直接覆盖掉</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.4140vjzuc040.gif#pic_center" width = 48%><p>这里和有序数组去重的解法有一个细节差异，我们这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><p><strong>2. 单指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;拷贝覆盖&#x27;&#x27;&#x27;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num!= val:</span><br><span class="line">                nums[ans] = num</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.3p3rmieqqso0.gif#pic_center" width = 48%><p><strong>80. 删除有序数组中的重复项 II</strong></p><p>题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">1</span>, <span class="number">2</span>       <span class="comment"># 使得出现次数超过两次的元素只出现两次</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow-<span class="number">1</span>]:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>  slow + <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.6iyyl4e6wp80.gif#pic_center" width = 48%><p><strong>通用解法：</strong></p><p>为了让解法更具有一般性，我们将原问题的 <strong>「最多保留 1 位」修改为「最多保留 k 位</strong>。</p><p>对于此类问题，我们应该进行如下考虑：</p><p>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。</p><p>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。</p><p>此时，初始化时指针 slow 指向数组的起始位置（nums[k-1]），指针 fast 指向指针 slow 的后一个位置（nums[k]）。随着指针 fast 不断向后移动，将指针 fast 指向的元素与指 slow 指向的元素进行比较：</p><ul><li>如果nums[fast] ≠ nums[slow-k+1]，那么nums[slow + 1] &#x3D; nums[fast]；</li><li>如果nums[fast] &#x3D; nums[slow]，那么指针q继续向后查找；</li></ul><p><strong>283. 移动零</strong><br>题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>1. 快慢指针</strong><br><strong>写法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:                 <span class="comment"># 把前面为0的项覆盖掉</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        nums[slow:] = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)-slow)    <span class="comment"># 把后面填充为 0</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.2v3f4q957060.gif#pic_center" width = 48%><p><strong>写法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast]:</span><br><span class="line">                <span class="keyword">if</span> nums[slow] == <span class="number">0</span>:             <span class="comment"># 快指针不为零，慢指针为零，进行交换</span></span><br><span class="line">                    nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.79i27t7x4iw0.gif#pic_center" width = 48%><h3 id="2-2-左右指针"><a href="#2-2-左右指针" class="headerlink" title="2.2 左右指针"></a>2.2 左右指针</h3><p><strong>题库列表：</strong></p><blockquote> <ul><li><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank">88. 合并两个有序数组</a>：<mark>如何将数组所有元素整体后移，防止数组覆盖？</mark></p></li><li><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. 两数之和 II - 输入有序数组</a>（有序数列的首尾双指针）</p></li><li><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank">125. 验证回文串</a></p></li><li><p><a href="https://leetcode.cn/problems/reverse-string/" target="_blank">344. 反转字符串</a></p></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/" target="_blank">151. 反转字符串中的单词</a></p></li><li><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank">345. 反转字符串中的元音字母</a></p></li><li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank">11. 盛最多水的容器</a>：<strong>经典题目</strong></p></li><li><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/" target="_blank">42. 接雨水</a>：<strong>经典题目</strong></p></li><li><p> <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank">75. 颜色分类</a>（左右指针，三色旗）</p></li><li><p><a href="https://leetcode.cn/problems/backspace-string-compare/" target="_blank">844. 比较含退格的字符串</a>（左右指针）</p></li></ul></blockquote> <p><strong>88. 合并两个有序数组</strong></p><p>题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p><strong>1. 左右指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        nums1[m:] = nums2               # 直接合并后排序</span></span><br><span class="line"><span class="string">        nums1.sort()           </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p0, p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span>, m+n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0 &gt;= <span class="number">0</span> <span class="keyword">or</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> p0 == -<span class="number">1</span>:                <span class="comment"># num1 已经循环结束</span></span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p1 == -<span class="number">1</span>:              <span class="comment"># # num2 已经循环结束</span></span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p0] &gt; nums2[p1]:</span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.465vy0ux2co0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        p0, p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span>, m+n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0 &gt;= <span class="number">0</span> <span class="keyword">and</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p0] &gt; nums2[p1]:   <span class="comment"># num1 更大</span></span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                      </span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后拼接没有遍历完的数组，由于直接在 nums1 上操作，只需要在nums2没遍历完，拼接起来就可以了</span></span><br><span class="line">        <span class="keyword">if</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[:p2+<span class="number">1</span>] = nums2 [:p1+<span class="number">1</span>]  </span><br></pre></td></tr></table></figure><p><strong>167. 两数之和 II - 输入有序数组</strong></p><p>题目描述：给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            two_sum = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> two_sum == target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]    <span class="comment"># 题目要求下标从1开始</span></span><br><span class="line">            <span class="keyword">elif</span> two_sum &gt; target:          <span class="comment"># 两数之和大于目标值，右边的值太大了，right--</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                           <span class="comment"># 两数之和小于目标值，左边值太小，left++</span></span><br><span class="line">                left += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.3gtipsibd9q0.gif#pic_center" width = 48%><p><strong>125. 验证回文串</strong></p><p>题目描述：如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串。字母和数字都属于字母数字字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 思路一：正则表达式</span></span><br><span class="line"><span class="string">        if not s:</span></span><br><span class="line"><span class="string">            return True</span></span><br><span class="line"><span class="string">        s = s.lower()</span></span><br><span class="line"><span class="string">        pattern = re.compile(r&#x27;[^a-z0-9]&#x27;)   # 正则表达式，把数字和字母都剔除掉</span></span><br><span class="line"><span class="string">        new_str = pattern.sub(&#x27;&#x27;, s)</span></span><br><span class="line"><span class="string">        return new_str == new_str[::-1]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 字符串预处理</span></span><br><span class="line"><span class="string">        new_str = &#x27;&#x27;.join(ch.lower() for ch in s if ch.isalnum())</span></span><br><span class="line"><span class="string">        return new_str == new_str[::-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 左右指针</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 两个循环找到左侧和右侧为字母或者数字的位置</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:                   <span class="comment"># 判断移动过后的left，right是否满足left在左，right在右的相对位置</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[left] != s[right]:         <span class="comment"># 如果左右指针所指不同，则肯定不构成回文</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:                           <span class="comment"># 左右指针各前进一步</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这里使用了正则表达式移除所有非字母数字字符，然后判断新的字符串是否是回文，也可以使用双指针，直接一次遍历，遇到字母数字字符就进行判断。</p><p><strong>151. 反转字符串中的单词</strong></p><p>题目描述：给你一个字符串 s，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.strip() <span class="comment"># 删除首尾空格</span></span><br><span class="line">        i = j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">&#x27; &#x27;</span>: i -= <span class="number">1</span>    <span class="comment"># 搜索首个空格</span></span><br><span class="line">            res.append(s[i + <span class="number">1</span>: j + <span class="number">1</span>])             <span class="comment"># 添加单词</span></span><br><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">&#x27; &#x27;</span>: i -= <span class="number">1</span>               <span class="comment"># 跳过单词间空格</span></span><br><span class="line">            j = i                                   <span class="comment"># j 指向下个单词的尾字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)                        <span class="comment"># 拼接并返回</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.21eld8of51fk.gif#pic_center" width = 48%><p><strong>2. 分割 + 倒序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.strip().split()[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.736ly7pxg8s0.webp#pic_center" width = 48%><p><strong>344. 反转字符串</strong></p><p>题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 $O(1)$ 的额外空间解决这一问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        return s.reverse()</span></span><br><span class="line"><span class="string">        s[:] = s[::-1]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 左右指针法</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.ituca5t9lds.gif#pic_center" width = 48%><p><strong>345. 反转字符串中的元音字母</strong></p><p>题目描述：给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现不止一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        str_set = <span class="built_in">set</span>(<span class="string">&quot;aeiouAEIOU&quot;</span>)</span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        str_list = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">if</span> str_list[head] <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">in</span> str_set:</span><br><span class="line">                str_list[head], str_list[tail] = str_list[tail], str_list[head]</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str_list[head] <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">not</span> <span class="keyword">in</span> str_set:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str_list[head] <span class="keyword">not</span> <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">in</span> str_set:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br></pre></td></tr></table></figure><p><strong>11. 盛最多水的容器</strong></p><p>题目描述：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 双指针，移动小的那一边</span></span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">if</span> height[head] &lt; height[tail]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[head]*(tail-head))</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[tail]*(tail-head))</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.63a65w667xw0.gif#pic_center" width = 48%><p><strong>42. 接雨水</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.rx8hdafpg8w.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        leftMax = rightMax = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left])</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right])</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                ans += leftMax - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += rightMax - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.2ziftttwjuk0.gif#pic_center" width = 48%><p><strong>75. 颜色分类</strong></p><p>题目描述：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>1. 单指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">            <span class="keyword">if</span> nums[k] == <span class="number">1</span>:</span><br><span class="line">                nums[k], nums[i] = nums[i], nums[k]</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.6ht435cinmw0.gif#pic_center" width = 48%><p><strong>2. 左右指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 定义三个变量，p0 表示数组最左边0的区域，p1是数组最右边2的区域</span></span><br><span class="line">        i, p0, p1 = <span class="number">0</span>, <span class="number">0</span> , <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p1:</span><br><span class="line">            <span class="comment"># 如果当前指向的是 0，就把这个元素交换到数组左边</span></span><br><span class="line"><span class="comment"># 也就是跟 p0 指针交换，之后cur，p0 就往前一动一位</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前指向的是2，就把这个元素交换到数组右边</span></span><br><span class="line"><span class="comment"># 也就是跟p2指针交换，注意此时cur指针就不用移动了</span></span><br><span class="line"><span class="comment"># 因为右边的一片区域都是2，只要把元素交换过去就可以了，cur不用移动</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果是1的话，就不用交换</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.27435ybjphus.gif#pic_center" width = 48%><p><strong>844. 比较含退格的字符串</strong></p><p>题目描述：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。如果对空文本输入退格字符，文本继续为空。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s_skip_num = <span class="number">0</span>                              <span class="comment"># 记录s的#数量</span></span><br><span class="line">        t_skip_num = <span class="number">0</span>                              <span class="comment"># 记录t的#数量</span></span><br><span class="line">        i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        j = <span class="built_in">len</span>(t) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>):                         <span class="comment"># 从后向前，消除S的#</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>): </span><br><span class="line">                    s_skip_num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (s_skip_num &gt; <span class="number">0</span>): </span><br><span class="line">                        s_skip_num -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>):                         <span class="comment"># 从后向前，消除T的#</span></span><br><span class="line">                <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>):</span><br><span class="line">                    t_skip_num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (t_skip_num &gt; <span class="number">0</span>):</span><br><span class="line">                        t_skip_num -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 后半部分</span></span><br><span class="line">            <span class="comment"># 消除完了，接下来比较s[i] != t[j]</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span>                              <span class="comment"># s 或者 t 遍历到头了</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[j]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 说明S和T同时遍历完毕</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> <span class="keyword">and</span> j == -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.bbd1edjnceg.gif#pic_center" width = 48%><p><strong>2. 栈模拟法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.back_strip(s) == self.back_strip(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">back_strip</span>(<span class="params">self, s</span>):</span><br><span class="line">        s_list = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> item == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> s_list:</span><br><span class="line">                    s_list.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_list.append(item)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p><strong>3. 移除元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        list_s, list_t = <span class="built_in">list</span>(s), <span class="built_in">list</span>(t)</span><br><span class="line">        idx_s, idx_t = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_s)):</span><br><span class="line">            <span class="keyword">if</span> list_s[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                list_s[idx_s] = list_s[i]</span><br><span class="line">                idx_s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx_s -= <span class="number">1</span> <span class="keyword">if</span> idx_s &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_t)):</span><br><span class="line">            <span class="keyword">if</span> list_t[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                list_t[idx_t] = list_t[i]</span><br><span class="line">                idx_t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx_t -= <span class="number">1</span> <span class="keyword">if</span> idx_t &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> list_s[:idx_s] == list_t[:idx_t]</span><br></pre></td></tr></table></figure><p><strong>977. 有序数组的平方</strong></p><p>题目描述：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;先平方后排序，每次利用已排序的先验信息，最大值必定在两端出现&quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, length-<span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[left] ** <span class="number">2</span> &lt; nums[right] ** <span class="number">2</span>:</span><br><span class="line">                result.append(nums[right] ** <span class="number">2</span>)</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(nums[left] ** <span class="number">2</span>)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.5si4hg3y9m00.gif#pic_center" width = 48%><hr><h3 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h3><p>题库列表：</p><blockquote> <ul><li><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/" target="_blank">5. 最长回文子串</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum/" target="_blank">15. 三数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum-closest/" target="_blank">16. 最接近的三数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/4sum/" target="_blank">18. 四数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank">56. 合并区间</a>：<strong>数组类操作</strong></p></li></ul></blockquote> <p><strong>5. 最长回文子串</strong></p><p>题目描述：给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>思路分析：找回⽂串的难点在于，回⽂串的的⻓度可能是奇数也可能是偶数，解决该问题的核⼼是<font color=#9900CC><strong>从中⼼向两端扩散的双指针技巧</strong></font>。如果回⽂串的⻓度为奇数，则它有⼀个中⼼字符；如果回⽂串的⻓度为偶数，则可以认为它有两个中⼼字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找到以i和i+1为中心的回文字符串&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            s1 = self.palindrome(s, i, i)</span><br><span class="line">            s2 = self.palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            res = s1 <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(res) <span class="keyword">else</span> res</span><br><span class="line">            res = s2 <span class="keyword">if</span> <span class="built_in">len</span>(s2) &gt; <span class="built_in">len</span>(res) <span class="keyword">else</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">self, s, l, r</span>):</span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure><p><strong>15. 三数之和</strong><br>题目描述：给你一个整数数组 nums ，判断是否存在三元组 $[nums[i], nums[j], nums[k]]$ 满足 $i !&#x3D; j、i !&#x3D; k$ 且 $j !&#x3D; k$ ，同时还满足 $nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0$。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums_sorted)):</span><br><span class="line">            <span class="keyword">if</span> nums_sorted[i] &gt; <span class="number">0</span>:                              <span class="comment"># 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            # 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line"><span class="string">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="string">                continue;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:      <span class="comment"># 去重</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums_sorted)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                # 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0, 0, 0 这种三元组</span></span><br><span class="line"><span class="string">                while left &lt; right and nums_sorted[left] == nums_sorted[left+1]:    left += 1</span></span><br><span class="line"><span class="string">                while left &lt; right and nums_sorted[right] == nums_sorted[right-1]:  right -= 1</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> nums_sorted[i]+nums_sorted[left]+nums_sorted[right] == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums_sorted[i], nums_sorted[left], nums_sorted[right]])</span><br><span class="line">                    <span class="comment"># 在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], </span></span><br><span class="line">                    <span class="comment"># i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[left] == nums_sorted[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[right] == nums_sorted[right-<span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 找到答案时双指针同时收缩</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums_sorted[i]+nums_sorted[left]+nums_sorted[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.2k1miygya7c0.gif#pic_center" width = 48%><p><strong>16. 最接近的三数之和</strong><br>题目描述：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)         <span class="comment"># 初始化，因为找最小值，因此把初始值设置成实数的最大值</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)          <span class="comment"># 排序是前提</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:    <span class="comment"># 常见的剪枝操作</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i+<span class="number">1</span>                                          <span class="comment"># 双指针：指针对撞</span></span><br><span class="line">            right = length-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                temp = nums_sorted[left] + nums_sorted[right] + nums_sorted[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(temp-target) &lt; diff:     </span><br><span class="line">                    diff = <span class="built_in">abs</span>(temp-target)</span><br><span class="line">                    ans = temp</span><br><span class="line">                <span class="comment"># 不管是变小还是变大，尝试的作用是让 temp 与 target 更接近，即 temp 与 target 的绝对值之差越来越小</span></span><br><span class="line">                <span class="keyword">if</span> temp &gt; target:        <span class="comment"># 如果大了，尝试右边界收缩一格，让 temp 变小</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> temp &lt; target:     <span class="comment"># 如果小了，尝试左边界收缩一格，让 target 变大</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 如果已经等于 target 的话, 肯定是最接近的，根据题目要求，返回这三个数的和</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.2na0d7iaxdo0.gif#pic_center" width = 48%><p><strong>18. 四数之和</strong></p><p>题目描述：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li>0 &lt;&#x3D; a, b, c, d &lt; n</li><li>a、b、c 和 d 互不相同</li><li>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</li></ul><p>你可以按 任意顺序 返回答案 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length): </span><br><span class="line">            <span class="comment"># 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> nums_sorted[i] &gt; target <span class="keyword">and</span> nums_sorted[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 对 nums_sorted[i] 去重</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):        <span class="comment"># 比原来多一层循环</span></span><br><span class="line">                <span class="comment"># 二级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> nums_sorted[i] + nums_sorted[j] &gt; target <span class="keyword">and</span> nums_sorted[i] + nums_sorted[j] &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 对 nums_sorted[j] 去重</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums_sorted[j] == nums_sorted[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="keyword">if</span> nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] == target:</span><br><span class="line">                        result.append([nums_sorted[i], nums_sorted[j], nums_sorted[left], nums_sorted[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[left] == nums_sorted[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[right] == nums_sorted[right-<span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>56. 合并区间</strong></p><p>题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] &#x3D; [starti, endi]$。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result= []</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 如果列表为空，或者当前区间与上一区间不重合，直接添加</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">or</span> result[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                result.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则的话，我们就可以与上一区间进行合并</span></span><br><span class="line">                result[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(result[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>左右指针与快慢指针暂时告一段落，但还有很多自己不满意的地方，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.3nvcyp0fhrq0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>双指针套路总结：<a href="https://zhuanlan.zhihu.com/p/95747836">https://zhuanlan.zhihu.com/p/95747836</a></li><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>算法与数据结构（一）：滑动窗口法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/89066140">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;89066140</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。本篇主要分析双指针在字符串数组中常用解题套路。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快慢指针" scheme="https://qxienote.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
    <category term="碰撞指针" scheme="https://qxienote.com/tags/%E7%A2%B0%E6%92%9E%E6%8C%87%E9%92%88/"/>
    
    <category term="连续区间" scheme="https://qxienote.com/tags/%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（二）-- 前缀和与差分数组</title>
    <link href="https://qxienote.com/article/319c8c73.html"/>
    <id>https://qxienote.com/article/319c8c73.html</id>
    <published>2023-06-11T02:07:48.000Z</published>
    <updated>2023-06-11T02:29:05.042Z</updated>
    
    <content type="html"><![CDATA[<p>前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。本节主要学习算法的原理，结合LeetCode题目分析如何使用这些技巧。</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。</p><p>数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。</p><p>此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。本节主要讲解这两种算法。</p><h2 id="1-前缀和与差分数组"><a href="#1-前缀和与差分数组" class="headerlink" title="1 前缀和与差分数组"></a>1 前缀和与差分数组</h2><p>前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和，差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。合理的使用前缀和与差分，可以将某些复杂的问题简单化。</p><h3 id="1-1-前缀和"><a href="#1-1-前缀和" class="headerlink" title="1.1 前缀和"></a>1.1 前缀和</h3><p>假设有一个序列 A，前缀和为 S。根据概念很容易知到公式</p><p>$$S[i]&#x3D;\displaystyle \sum_{j&#x3D;1}^iA[j]$$</p><p>如何求区间 $[l,r]$ 的和呢？</p><p>$$sum[l,r]&#x3D;s[r]-s[l-1]$$</p><h3 id="1-2-差分数组"><a href="#1-2-差分数组" class="headerlink" title="1.2 差分数组"></a>1.2 差分数组</h3><p>设原数组为 A[i],差分数组为 diff[i]，则：</p><p>$$diff[i]&#x3D;\begin{cases} A[i]&amp;i&#x3D;1\ A[i]-A[i-1]&amp;i\geq2 \end{cases}$$</p><p>差分数组的性质是：</p><ul><li>如果对区间 $[l,r]$ 进行修改，只需修改 $diff[l], diff[r+1]$（diff[l]加上修改值，diff[r+1] 减去修改值）</li><li>$A[i]&#x3D;\displaystyle \sum_{j&#x3D;1}^{i}B[j]$（通过 $B[i]&#x3D;A[i]-A[i-1]$ 证明）</li><li>$S[x]&#x3D;\displaystyle \sum_{i&#x3D;1}^{x}A[i]&#x3D;\displaystyle \sum_{i&#x3D;1}^{x} \displaystyle \sum_{j&#x3D;1}^{i}diff[j]&#x3D;\displaystyle \sum _{i&#x3D;1}^{x}(x-i+1)*diff[i]$$</li></ul><blockquote><p>当我们希望对原数组的某一个区间 $[i, j]$ 施加一个增量 inc 时，差分数组 $d$ 对应的变化是：$d[i] 4$ 增加 inc，$d[j+1]$ 减少inc，并且这种操作是可以叠加的。</p></blockquote><p>下面举个例子：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.6lmgy6vjiyc0.webp#pic_center" width = 64%><p>差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。</p><p>还是上面那个表里的例子，我们需要进行以下操作：</p><ol><li>将区间[1，4]的数值全部加上3</li><li>将区间[3，5]的数值全部减去5</li></ol><p>很简单对吧，你可以进行枚举。但是如果给你的数据量是 $1\times e^5$，操作量 $1\times e^5$，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。</p><p>其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。</p><p>利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.125vurueqzr4.webp#pic_center" width = 64%><p>进行下一个操作，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.71279cxlwrs0.webp#pic_center" width = 64%><p>这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。</p><p>本部分参考自：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分详解+例题</a></p><p>也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，<font color=#9900CC><strong>差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。</font></strong></p><p>有 $n$ 个数，$m$ 个操作，每一次操作，将 $x<del>y$ 区间的所有数增加 $z$；最后有 $q$ 个询问，每一次询问求出 $x</del>y$ 的区间和。设原数组为 $A[i]$。其步骤为：</p><ul><li>先求出差分数组 $B[i]&#x3D;A[i]−A[i−1]$</li><li>在根据 $m$ 个造作修改 $B[i]$</li><li>求修改后的 $A[i]&#x3D;A[i−1]+B[i]$</li><li>求前缀和 $S[i]&#x3D;S[i−1]+A[i]$</li><li>最后输出区间和 $sum[x,y]&#x3D;S[y]−S[x−1]$</li></ul><blockquote><p><font color=#9900CC><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</font></strong></p></blockquote><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote> <ul><li><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/" target="_blank">303. 区域和检索 - 数组不可变</a>：<strong>一维前缀和</strong></p></li><li><p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/" target="_blank">304. 二维区域和检索 - 矩阵不可变</a>：<strong>二维前缀和</strong></p></li><li><p><a href="https://leetcode.cn/problems/range-addition/" target="_blank">370. 区间加法</a>：<strong>差分数组</strong></p></li><li><p><a href="https://leetcode.cn/problems/corporate-flight-bookings/" target="_blank">1109. 航班预订统计</a>：<strong>差分数组</strong></p></li><li><p><a href="https://leetcode.cn/problems/car-pooling/" target="_blank">1094. 拼车</a>：<strong>差分数组</strong></p></li></ul></blockquote> <p><strong>303. 区域和检索 - 数组不可变</strong></p><p>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4jq9oeam7mw0.webp#pic_center" width = 80%></p><p><strong>一维前缀和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.nums_array = [<span class="number">0</span>]            <span class="comment"># 便于计算累加和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.nums_array.append(self.nums_array[i] + nums[i])  <span class="comment"># 计算nums累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.nums_array[right+<span class="number">1</span>] - self.nums_array[left]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.xrjyxto1ocw.gif#pic_center" width = 64%><p><strong>304. 二维区域和检索 - 矩阵不可变</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/048.6ey4bron1sg0.webp#pic_center" width = 80%><p><strong>二维前缀和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])                  <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.pre_sum[i+<span class="number">1</span>][j] + self.pre_sum[i][j+<span class="number">1</span>] - self.pre_sum[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.pre_sum[row1][col2+<span class="number">1</span>] - self.pre_sum[row2+<span class="number">1</span>][col1] + self.pre_sum[row1][col1])</span><br></pre></td></tr></table></figure><p><strong>370. 区间加法</strong></p><p>题目描述：假设你有一个长度为n的数组，初始情况下所有的数字均为0，你将会被给出k个更新的操作。其中，每个操作会被表示为一个三元组: [startIndex, endIndex, inc]，你需要将子数组 A[startIndex, endIndex]（包括startlndex和endIndex）增加 inc。<br>请你返回 k 次操作后的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (length+<span class="number">1</span>)  <span class="comment"># 末尾多个0，防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end + <span class="number">1</span>] -= inc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            diff[i] += diff[i - <span class="number">1</span>]            <span class="comment"># 对差分数组求前缀和便可得到原数组</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> diff[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>1109. 航班预订统计</strong></p><p>题目描述：这里有 n 个航班，它们分别从 1 到 n 进行编号。有一份航班预订表 bookings ，表中第 $i$ 条预订记录 $bookings[i] &#x3D; [first_i, last_i, seats_i]$ 意味着在从 $first_i$ 到 $last_i$（包含 $first_i$ 和 $last_i$）的 每个航班 上预订了 $seats_i$ 个座位。请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            start, end, inc = booking[<span class="number">0</span>], booking[<span class="number">1</span>], booking[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            <span class="keyword">if</span> end &lt; n:             <span class="comment"># 没在末尾添加0，要判断一下边界</span></span><br><span class="line">                diff[end+<span class="number">1</span>] -= inc</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/052.6gnyefuumd80.gif#pic_left" width = "40%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/052.6gnyefuumd80.gif#pic_left"  width = "48%"></center></p><p><strong>1094. 拼车</strong></p><p>题目描述：车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向），给定整数 capacity 和一个数组 trips ,  $trip[i] &#x3D; [numPassengers_i, from_i, to_i]$ 表示第 $i$ 次旅行有 $numPassengers_i$ 乘客，接他们和放他们的位置分别是 $from_i$ 和 $to_i$。这些位置是从汽车的初始位置向东的公里数。当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="number">1001</span>)      <span class="comment"># 题目中最多有1001个车站</span></span><br><span class="line">        max_station = <span class="number">0</span>          <span class="comment"># 找到车站数</span></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            inc, start, end = trip[<span class="number">0</span>], trip[<span class="number">1</span>], trip[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end] -= inc      <span class="comment"># 第end站乘客已经下车，这里就不用end+1</span></span><br><span class="line">            max_station = <span class="built_in">max</span>(max_station, end)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_station+<span class="number">1</span>): <span class="comment"># 进行区间求和</span></span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(diff[:max_station]) &gt; capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/050.qso2bf25fv4.webp#pic_center" width = 80%><hr><blockquote><p><font color=#9900CC><strong>欢迎各位大佬一起来学习前缀和与差分数组，希望本篇可以让你对前缀和和差分的概念及使用技巧有更清晰的理解，欢迎继续补充！</font></strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/051.4lt77415u1s0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>差分详解+例题：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">https://blog.csdn.net/qq_44786250&#x2F;article&#x2F;details&#x2F;100056975</a></li><li>数组（三）– LC[370]&amp;[1109]&amp;[1094] 区间加法：<a href="https://blog.csdn.net/xq151750111/article/details/129243272?spm=1001.2014.3001.5502">https://blog.csdn.net/xq151750111/article/details/129243272?spm=1001.2014.3001.5502</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。本节主要学习算法的原理，结合LeetCode题目分析如何使用这些技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前缀和" scheme="https://qxienote.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="差分数组" scheme="https://qxienote.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数学（一）-- LC[12]&amp;[13] 整数转罗马数字</title>
    <link href="https://qxienote.com/article/b86971b3.html"/>
    <id>https://qxienote.com/article/b86971b3.html</id>
    <published>2023-06-10T12:10:57.000Z</published>
    <updated>2023-06-10T12:19:29.508Z</updated>
    
    <content type="html"><![CDATA[<p>本篇以LeetCode[12]——整数转罗马数字为例，分析如何使用数学方法进行解题</p><span id="more"></span><h2 id="1-整数转罗马数字"><a href="#1-整数转罗马数字" class="headerlink" title="1 整数转罗马数字"></a>1 整数转罗马数字</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><blockquote><p>示例 1:<br>输入: num &#x3D; 3<br>输出: “III”</p></blockquote><blockquote><p>示例 2:<br>输入: num &#x3D; 4<br>输出: “IV”</p></blockquote><blockquote><p>示例 3:<br>输入: num &#x3D; 9<br>输出: “IX”</p></blockquote><blockquote><p>示例 4:<br>输入: num &#x3D; 58<br>输出: “LVIII”<br>解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</p></blockquote><blockquote><p>示例 5:<br>输入: num &#x3D; 1994<br>输出: “MCMXCIV”<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p></blockquote><p>提示：1 &lt;&#x3D; num &lt;&#x3D; 3999</p><p>题目链接：<a href="https://leetcode.cn/problems/integer-to-roman/">https://leetcode.cn/problems/integer-to-roman/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>根据题目分析，我们知道罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。这给了我们总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/040.lngh4orwxww.webp#pic_center" width = 48%><p>考虑 140140 的罗马数字表示，我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为 C&#x3D;100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL&#x3D;40。因此，140 的对应的罗马数字为 <code>C+XL=CXL</code>。这说明罗马数字是唯一表示的。(这不就是贪心策略，和找零钱的问题有点类似)</p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>1. 思路一: 模拟</strong><br>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 整除该符号值，并将整除的值乘以该符号，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。设计算法的思想如下：每一步都使用当前对应阿拉伯数字较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。(贪心算法)</p><p>编程时，可以建立一个数值-符号对的列表 value_symbol，按数值从大到小排列。遍历 value_symbol 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        value_symbol = [(<span class="number">1000</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="number">900</span>, <span class="string">&#x27;CM&#x27;</span>), (<span class="number">500</span>, <span class="string">&#x27;D&#x27;</span>), (<span class="number">400</span>, <span class="string">&#x27;CD&#x27;</span>), (<span class="number">100</span>, <span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        (<span class="number">90</span>, <span class="string">&#x27;XC&#x27;</span>), (<span class="number">50</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="number">40</span>, <span class="string">&#x27;XL&#x27;</span>), (<span class="number">10</span>, <span class="string">&#x27;X&#x27;</span>), (<span class="number">9</span>, <span class="string">&#x27;IX&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;V&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;IV&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;I&#x27;</span>)]</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> value, symbol <span class="keyword">in</span> value_symbol:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= value:</span><br><span class="line">                result += symbol * (num // value)</span><br><span class="line">                num = num % value</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。由于 value_symbol 长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3(超过3就要进位了)，因此循环次数有一个确定的上限。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>2. 思路二：硬编码数字</strong></p><p>我们可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 0 对应的是空字符串。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/041.4cvm6z500240.webp#pic_center" width = 48%><p>利用模运算和除法运算，我们可以得到 num 每个位上的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thousands_digit = num // <span class="number">1000</span></span><br><span class="line">hundreds_digit = (num % <span class="number">1000</span>) // <span class="number">100</span></span><br><span class="line">tens_digit = (num % <span class="number">100</span>) // <span class="number">10</span></span><br><span class="line">ones_digit = num % <span class="number">10</span></span><br></pre></td></tr></table></figure><p>最后，根据 num 每个位上的数字，在硬编码表中查找对应的罗马字符，并将结果拼接在一起，即为 num 对应的罗马数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    thousands = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;MMM&#x27;</span>]</span><br><span class="line">    hundreds = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;CD&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;DC&#x27;</span>, <span class="string">&#x27;DCC&#x27;</span>, <span class="string">&#x27;DCCC&#x27;</span>, <span class="string">&#x27;CM&#x27;</span>]</span><br><span class="line">    tens = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;XX&#x27;</span>, <span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XL&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;LX&#x27;</span>, <span class="string">&#x27;LXX&#x27;</span>, <span class="string">&#x27;LXXX&#x27;</span>, <span class="string">&#x27;XC&#x27;</span>]</span><br><span class="line">    ones = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>, <span class="string">&#x27;VII&#x27;</span>, <span class="string">&#x27;VIII&#x27;</span>, <span class="string">&#x27;IX&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> Solution.thousands[num//<span class="number">1000</span>] + Solution.hundreds[num%<span class="number">1000</span>//<span class="number">100</span>] + Solution.tens[num%<span class="number">100</span>//<span class="number">10</span>] + Solution.ones[num%<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。计算量与输入数字的大小无关。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="2-罗马数转整数"><a href="#2-罗马数转整数" class="headerlink" title="2 罗马数转整数"></a>2 罗马数转整数</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><blockquote><p>示例 1:<br>输入: s &#x3D; “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:<br>输入: s &#x3D; “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:<br>输入: s &#x3D; “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:<br>输入: s &#x3D; “LVIII”<br>输出: 58<br>解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</p></blockquote><blockquote><p>示例 5:<br>输入: s &#x3D; “MCMXCIV”<br>输出: 1994<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/roman-to-integer/">https://leetcode.cn/problems/roman-to-integer/</a></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>思路一：观察下图，我们可以发现罗马数字最多为两位，所以可以利用这个来判断和下一个字母组合是否是构成一个整数，示例代码如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/042.141x8tzxsjhc.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        symbol_value = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;CM&#x27;</span>: <span class="number">900</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;CD&#x27;</span>: <span class="number">400</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;XC&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;XL&#x27;</span>: <span class="number">40</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;IX&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;IV&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[index:index+<span class="number">2</span>] <span class="keyword">in</span> symbol_value.keys():</span><br><span class="line">                result += symbol_value[s[index:index+<span class="number">2</span>]]</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += symbol_value[s[index]]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>思路二：我们由上面的定义可以知道，对于罗马数字<code>AB</code>，A代表的整数小于B是，要用B代表的整数减去A代表的整数，否则两个代表的整数相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        symbol_value = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> symbol_value[s[i]] &lt; symbol_value[s[i+<span class="number">1</span>]]:</span><br><span class="line">                result -= symbol_value[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += symbol_value[s[i]]</span><br><span class="line">        <span class="keyword">return</span> result + symbol_value[s[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇以LeetCode[12]——整数转罗马数字为例，分析如何使用数学方法进行解题&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="LeetCode" scheme="https://qxienote.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础文章汇总</title>
    <link href="https://qxienote.com/article/a0d5b4a3.html"/>
    <id>https://qxienote.com/article/a0d5b4a3.html</id>
    <published>2023-06-10T08:29:05.000Z</published>
    <updated>2023-06-11T02:53:03.837Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是对计算机基础专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1 计算机网络"></a>1 计算机网络</h2><h3 id="1-1-网络篇"><a href="#1-1-网络篇" class="headerlink" title="1.1  网络篇"></a>1.1  网络篇</h3><ul><li><a href="https://qxienote.com/article/54ebc735.html">计算机网络篇（一）– 网络协议入门</a></li><li><a href="https://qxienote.com/article/279b4884.html">计算机网络篇（二）– HTTP 协议入门</a></li><li><a href="https://qxienote.com/article/ae7157b3.html">计算机网络篇（三）– SSL&#x2F;TLS 协议入门</a></li><li><a href="https://qxienote.com/article/1ee3e5d0.html">计算机网络篇（四）– TCP&#x2F;IP 协议族详解</a></li><li><a href="https://qxienote.com/article/84fa558.html">计算机网络篇（五）– TCP 套接字编程</a></li><li><a href="https://qxienote.com/article/929e2127.html">计算机网络篇（六）– UDP 套接字编程</a></li><li><a href="https://qxienote.com/article/24fe53d6.html">计算机网络篇（七）– ICMP-Ping 服务程序框架</a></li><li><a href="https://qxienote.com/article/ba7802fc.html">计算机网络篇（八）-邮件客户端实现与电子邮件发送</a></li></ul><h3 id="1-2-《计算机网络—自顶向下方法》-Wireshark实验"><a href="#1-2-《计算机网络—自顶向下方法》-Wireshark实验" class="headerlink" title="1.2 《计算机网络—自顶向下方法》 Wireshark实验"></a>1.2 《计算机网络—自顶向下方法》 Wireshark实验</h3><ul><li><a href="https://blog.csdn.net/xq151750111/article/details/130515236">《计算机网络—自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130536991">《计算机网络—自顶向下方法》 Wireshark实验（二）：HTTP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130576182">《计算机网络—自顶向下方法》 Wireshark实验（三）：DNS协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130648866">《计算机网络—自顶向下方法》 Wireshark实验（四）：TCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130660079">《计算机网络—自顶向下方法》 Wireshark实验（五）：UDP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130675220">《计算机网络—自顶向下方法》 Wireshark实验（六）：IP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130663286">《计算机网络—自顶向下方法》 Wireshark实验（七）：以太网与ARP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775056">《计算机网络—自顶向下方法》 Wireshark实验（八）：ICMP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130769488">《计算机网络—自顶向下方法》 Wireshark实验（九）：DHCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775356">《计算机网络—自顶向下方法》 Wireshark实验（十）：NAT 协议分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章是对计算机基础专栏下的文章进行汇总，方便系统地学习和复习。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络篇（八）-- 邮件客户端实现与电子邮件发送</title>
    <link href="https://qxienote.com/article/ba7802fc.html"/>
    <id>https://qxienote.com/article/ba7802fc.html</id>
    <published>2023-06-10T08:11:24.000Z</published>
    <updated>2023-06-11T02:06:40.115Z</updated>
    
    <content type="html"><![CDATA[<p>通过完成本实验，我们将更加了解SMTP协议。还将学到使用Python实现标准协议的经验。主要任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><span id="more"></span><h2 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1 SMTP"></a>1 SMTP</h2><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><p>这里采用qq邮箱来完成。本文将实现一个SMTP客户端，使用qq邮箱作为发件人，向指定的163邮箱发送一封邮件。</p><p>SMTP协议即简单邮件传输协议，允许用户按照标准发送&#x2F;接收邮件。</p><p>在本文中，SMTP邮件客户端程序的基本流程如下：</p><ol><li>与qq邮件服务器建立TCP连接，域名”smtp.qq.com”，SMTP默认端口号25。建立连接后服务器将返回状态码220，代表服务就绪（类似HTTP，SMTP也使用状态码通知客户端状态信息）。</li><li>发送”HELO”命令，开始与服务器的交互，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”AUTH LOGIN”命令，开始验证身份，服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的用户名（本例中是163邮箱的账号），服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的密码（本例中是163邮箱的密码），服务器将返回状态码235（用户验证成功）。</li><li>发送”MAIL FROM”命令，并包含发件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”RCPT TO”命令，并包含收件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”DATA”命令，表示即将发送邮件内容，服务器将返回状态码354（开始邮件输入，以”.”结束）。</li><li>发送邮件内容，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”QUIT”命令，断开与邮件服务器的连接。</li></ol><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230504</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 实现邮件客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mail content</span></span><br><span class="line">subject = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">contenttype = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">msg = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sender and reciever</span></span><br><span class="line">fromaddress = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">toaddress = <span class="string">&quot;xxxxx@163.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth information (Encode with base64)</span></span><br><span class="line">username = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">username = base64.b64encode(username.encode()).decode()</span><br><span class="line">password = base64.b64encode(password.encode()).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line">clientSocket.connect((mailserver, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO CarpeDiem\r\n&#x27;</span></span><br><span class="line">clientSocket.send(heloCommand.encode())</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv1)</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;AUTH LOGIN\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((username + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((password + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;235&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;235 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send MAIL FROM command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;MAIL FROM: &lt;&#x27;</span> + fromaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send RCPT TO command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;RCPT TO: &lt;&#x27;</span> + toaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send DATA command and print server response.</span></span><br><span class="line">clientSocket.send(<span class="string">&#x27;DATA\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;354&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;354 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send message data.</span></span><br><span class="line">message = <span class="string">&#x27;from:&#x27;</span> + fromaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;to:&#x27;</span> + toaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;subject:&#x27;</span> + subject + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;Content-Type:&#x27;</span> + contenttype + <span class="string">&#x27;\t\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;\r\n&#x27;</span> + msg</span><br><span class="line">clientSocket.sendall(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Message ends with a single period.</span></span><br><span class="line">clientSocket.sendall(endmsg.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send QUIT command and get server response.</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;QUIT\r\n&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close connection</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 有些邮箱默认关闭SMTP服务，比如本文使用的qq邮箱。需要在设置中打开SMTP服务。另外，qq邮箱在打开SMTP服务后，会设置一个授权码，在程序使用这个授权码作为密码登录，而不是平时使用的密码。</p><p>一切正常的话，运行效果如下图所示，将会看到服务器返回的每条消息，其中包含每次操作后返回的状态码。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.euksoeo322w.webp#pic_center" width = 36%><p>同时，我们还可以登陆发件人邮箱和收件人邮箱，在发件人的已发送文件夹中和收件人的收件箱中都能看到这封被发送的邮件。左图为qq邮箱，右图为网易163邮箱。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.56cyk5j0h1g0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.60g5ulueg0o0.webp#pic_left"  width = "45%"></center></p><hr><h2 id="2-网络应用开发"><a href="#2-网络应用开发" class="headerlink" title="2 网络应用开发"></a>2 网络应用开发</h2><h3 id="2-1-发送电子邮件"><a href="#2-1-发送电子邮件" class="headerlink" title="2.1 发送电子邮件"></a>2.1 发送电子邮件</h3><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p><p>smtplib和email，这俩模块是Python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。</p><ul><li>smtplib模块主要负责发送邮件：是一个发送邮件的动作，连接邮箱服务器，登录邮箱，发送邮件（有发件人，收信人，邮件内容）。</li><li>email模块主要负责构造邮件：指的是邮箱页面显示的一些构造，如发件人，收件人，主题，正文，附件等。</li></ul><p><strong>代码说明：</strong></p><ol><li>smtplib模块</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">smtplib.SMTP()              <span class="comment"># 实例化SMTP()</span></span><br><span class="line"></span><br><span class="line">login(user, password)</span><br><span class="line"><span class="comment"># user：登录邮箱的用户名。</span></span><br><span class="line"><span class="comment"># password：登录邮箱的密码，像笔者用的是网易邮箱，网易邮箱一般是网页版，需要用到客户端密码，需要在网页版的网易邮箱中设置授权码，该授权码即为客户端密码。</span></span><br><span class="line"></span><br><span class="line">sendmail(from_addr, to_addrs, msg,…)</span><br><span class="line"><span class="comment"># from_addr：邮件发送者地址</span></span><br><span class="line"><span class="comment"># to_addrs：邮件接收者地址。字符串列表[‘接收地址1’,‘接收地址2’,‘接收地址3’,…]</span></span><br><span class="line"><span class="comment"># msg：发送消息：邮件内容。一般是msg.as_string():as_string()是将msg(MIMEText对象或者MIMEMultipart对象)变为str。</span></span><br><span class="line"></span><br><span class="line">quit()      <span class="comment"># 用于结束SMTP会话。</span></span><br></pre></td></tr></table></figure><p><strong>2) email模块</strong></p><p>email模块下有mime包，mime英文全称为<code>“Multipurpose Internet Mail Extensions”</code>，即多用途互联网邮件扩展，是目前互联网电子邮件普遍遵循的邮件技术规范。</p><p>该mime包下常用的有三个模块：text, image, multpart。</p><p>导入方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br></pre></td></tr></table></figure><p>构造一个邮件对象就是一个Message对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure><p>下面的代码演示了如何在Python发送普通的文字邮件。</p><p><strong>1. 发送普通文字邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230428</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header </span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 设定邮件发送者和接受者</span></span><br><span class="line">    host_server = <span class="string">&#x27;smtp.qq.com&#x27;</span>             <span class="comment"># qq 邮箱smtp服务器</span></span><br><span class="line">    sender = <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>              <span class="comment"># 发件人邮箱</span></span><br><span class="line">    pwd = <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span></span><br><span class="line">    receivers = [<span class="string">&#x27;xxxxxxx@gmail.com&#x27;</span>, <span class="string">&#x27;xxxxxx@163.com&#x27;</span>]              <span class="comment"># 收件人邮箱</span></span><br><span class="line">    mail_title = <span class="string">&quot;Python自动发送的邮件&quot;</span>                               <span class="comment"># 邮件标题  </span></span><br><span class="line">    mail_content = <span class="string">&quot;您好，这是使用python登录QQ邮箱发送邮件的测试——xq&quot;</span>   <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()               <span class="comment"># 初始化一个邮件主体</span></span><br><span class="line">    message[<span class="string">&#x27;Subject&#x27;</span>] = Header(mail_title, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    message[<span class="string">&#x27;From&#x27;</span>] = sender</span><br><span class="line">    message[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;;&quot;</span>.join(receivers)</span><br><span class="line">    message.attach(MIMEText(mail_content, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    smtper = SMTP_SSL(host_server)      <span class="comment"># ssl登录</span></span><br><span class="line">    <span class="comment"># login(user,password):</span></span><br><span class="line">    <span class="comment"># user:登录邮箱的用户名。</span></span><br><span class="line">    <span class="comment"># password：登录邮箱的密码，这里用的是QQ邮箱，</span></span><br><span class="line">    <span class="comment"># 需要用到客户端密码，需要在QQ邮箱中设置授权码，该授权码即为客户端密码</span></span><br><span class="line">    smtper.login(sender, pwd)</span><br><span class="line">    smtper.sendmail(sender, receivers, message.as_bytes())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送完成!&quot;</span>)</span><br><span class="line">    <span class="comment"># quit(): 用于结束SMTP会话</span></span><br><span class="line">    smtper.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.6alnsifgg2o0.webp#pic_center" width = 64%><p><strong>2. 发送html格式邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.6yb1qqrncyo0.webp#pic_center" width = 36%><p><strong>3. 发送带附件的邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件以及附件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication  <span class="comment"># 用于添加附件</span></span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line">attachment = MIMEApplication(<span class="built_in">open</span>(<span class="string">&quot;H:\\毕业设计\\LassoNet\\脑区选择.xlsx&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">attachment[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给附件重命名</span></span><br><span class="line">basename = <span class="string">&quot;test.xlsx&quot;</span></span><br><span class="line">attachment.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;&#x27;</span>, basename))</span><br><span class="line">msg.attach(attachment)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.6g3dk32y7kg0.webp#pic_center" width = 36%><h3 id="2-2-发送短信"><a href="#2-2-发送短信" class="headerlink" title="2.2 发送短信"></a>2.2 发送短信</h3><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a href="https://www.ihuyi.com/duanxin.html?e=591">互亿无线短信平台</a>（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    host  = <span class="string">&quot;106.ihuyi.com&quot;</span></span><br><span class="line">    sms_send_uri = <span class="string">&quot;/webservice/sms.php?method=Submit&quot;</span></span><br><span class="line">    <span class="comment"># 下面的参数需要填入自己注册的账号和对应的密码</span></span><br><span class="line">    params = urllib.parse.urlencode(&#123;<span class="string">&#x27;account&#x27;</span>: <span class="string">&#x27;API ID&#x27;</span>, <span class="string">&#x27;password&#x27;</span> : <span class="string">&#x27;API KEY&#x27;</span>, <span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;您的验证码是：666888。请不要把验证码泄露给其他人。&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>: <span class="string">&#x27;xxxxxxxxx&#x27;</span>, <span class="string">&#x27;format&#x27;</span>:<span class="string">&#x27;json&#x27;</span> &#125;)</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=<span class="number">80</span>, timeout=<span class="number">30</span>)</span><br><span class="line">    conn.request(<span class="string">&#x27;POST&#x27;</span>, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    jsonstr = response_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(json.loads(jsonstr))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>详细了解，请阅读：<a href="https://www.ihuyi.com/api/sms.html">短信验证码&#x2F;通知 - API文档</a></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python实现自动发送邮件（详解）：<a href="https://blog.csdn.net/weixin_44827418/article/details/111255414">https://blog.csdn.net/weixin_44827418&#x2F;article&#x2F;details&#x2F;111255414</a></li><li>Python网络应用开发：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过完成本实验，我们将更加了解SMTP协议。还将学到使用Python实现标准协议的经验。主要任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="邮件客户端" scheme="https://qxienote.com/tags/%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（七）-- ICMP Ping服务程序框架</title>
    <link href="https://qxienote.com/article/24fe53d6.html"/>
    <id>https://qxienote.com/article/24fe53d6.html</id>
    <published>2023-06-10T08:11:03.000Z</published>
    <updated>2023-06-10T08:29:23.393Z</updated>
    
    <content type="html"><![CDATA[<p>Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。</p><span id="more"></span><p>Ping的实现通常使用ICMP协议。ICMP协议在协议族中的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.ziro52u46eo.webp#pic_center" width = 48%><p>通过本文，你将更好地理解因特网控制报文协议（<code>ICMP</code>），学习使用<code>ICMP</code>请求和响应消息实现<code>Ping</code>程序。通过向目标主机发送<code>ICMP</code>回显包并监听<code>ICMP</code>回显应答来工作。回显有时称为<code>pong</code>。<code>ping</code>程序测量往返时间，记录数据包丢失，并输出接收到的回显包的统计摘要（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差）。</p><p>主要任务：用<code>python</code>开发自己的简单<code>Ping</code>程序。程序将使用<code>ICMP</code>协议，但为了保持简单，将不完全遵循<code>RFC 1739</code>中的正式规范。在本实训中只需要编写程序的客户端，因为服务器端所需的功能几乎内置于所有操作系统中。Ping程序的基本功能如下： Ping 程序能将 ping 请求发送到指定的主机，间隔大约一秒钟。每个消息包含一个带有时间戳的数据包。 每个数据包发送完后，程序最多等待一秒，用于接收响应。如果一秒后服务器没有响应，那么客户端应假设 ping 数据包或 pong 数据包在网络中丢失（或者服务器已关闭）。 统计摘要信息（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差） 本实训将使用原始套接字来使用ICMP协议。</p><p>下面将为为Ping客户端创建一个原始类型的套接字。</p><h2 id="1-Ping客户端创建原始套接字"><a href="#1-Ping客户端创建原始套接字" class="headerlink" title="1 Ping客户端创建原始套接字"></a>1 Ping客户端创建原始套接字</h2><h3 id="1-1-原始套接字"><a href="#1-1-原始套接字" class="headerlink" title="1.1 原始套接字"></a>1.1 原始套接字</h3><p>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。使用原始套接字进行网络通信的基本步骤为：</p><ul><li>（1）创建原始套接字、设置套接字选项和创建并填充相应协议头；</li><li>（2）用 <code>sendto()</code> 函数将组装好的数据发送出去；</li><li>（3）使用 <code>recvfrom()</code> 函数接收数据并解析；</li><li>（4）关闭套接字。</li></ul><p>在Python中使用套接字编程，需要先引入套接字（import socket）；使用 <code>socket()</code> 函数来创建套接字。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket(socket_family,socket_type,protocol=<span class="number">0</span>)</span><br><span class="line">socket_family可以是如下参数之一：</span><br><span class="line">  　　AF_INET IPv4（默认）</span><br><span class="line">　　  AF_INET6 IPv6</span><br><span class="line">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span><br><span class="line">socket_type可以是如下参数之一:</span><br><span class="line">　　  SOCK_STREAM　　流式socket , <span class="keyword">for</span> TCP （默认）</span><br><span class="line">　  　SOCK_DGRAM　　 数据报式socket , <span class="keyword">for</span> UDP</span><br><span class="line">　  　SOCK_RAW 原始套接字</span><br></pre></td></tr></table></figure><p>普通的套接字无法处理ICMP、IGMP等网络报文，而原始套接字 <code>SOCK_RAW</code> 可以；<code>SOCK_RAM</code> 用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。<code>SOCK_RAM</code> 通常仅限于高级用户或管理员运行的程序使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol参数：</span><br><span class="line">　　<span class="number">0</span>　（默认）与特定的地址家族相关的协议。如果是 <span class="number">0</span> ，则系统就会根据地址格式和套接类别，自动选择一个合适的协议。也可以使用</span><br><span class="line">  getprotobyname()指定要使用的协议名称如“ICMP”、“UDP”等。</span><br></pre></td></tr></table></figure><p>在本实验中，要创建一个使用IPV4地址族的的原始套接字，并指定使用ICMP协议，可以使用如下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmp = getprotobyname(<span class="string">&quot;icmp&quot;</span>)   /*指定ICMP协议</span><br><span class="line">rawsocket=socket(AF_INET, SOCK_RAW, icmp)</span><br></pre></td></tr></table></figure><h2 id="2-封装并发送ICMP报文"><a href="#2-封装并发送ICMP报文" class="headerlink" title="2 封装并发送ICMP报文"></a>2 封装并发送ICMP报文</h2><h3 id="2-1-ICMP协议"><a href="#2-1-ICMP协议" class="headerlink" title="2.1 ICMP协议"></a>2.1 ICMP协议</h3><p>ICMP协议：<code>Internet Control Message Protocol</code>（Internet控制报文协议）；由于IP协议并不是一个可靠的协议，它不保证数据被成功送达。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的，经常供IP层或更高层协议（TCP或UDP）使用。所以它经常被认为是IP层的一个组成部分。</p><p>制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着<font color=#9900CC><strong>“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议”</font></strong>。即，ICMP 是为了分担IP 一部分功能而被制定出来的。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.ed8xfkhqoh4.webp#pic_center" width = 48%><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p><p>在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.39oq4lvlrna0.webp#pic_center" width = 48%><ul><li>[1]给送信者的错误通知；[2]送信者的信息查询。</li><li>[1]是到IP 数据包被对方的计算机处理的过程中，发生了什么错误时被使用。不仅传送发生了错误这个事实，也传送错误原因等消息。</li><li>[2]的信息询问是在送信方的计算机向对方计算机询问信息时被使用。被询问内容的种类非常丰富，他们有目标IP 地址的机器是否存在这种基本确认，调查自己网络的子网掩码，取得对方机器的时间信息等。</li></ul><p>ICMP是TCP&#x2F;IP模型中网络层的重要成员，与IP协议、ARP协议、RARP 协议及 IGMP协议共同构成 TCP&#x2F;IP模型中的网络层。<code>ping</code> 和 <code>tracert</code> 是两个常用网络管理命令，<code>ping</code> 用来测试网络可达性，<code>tracert</code> 用来显示到达目的主机的路径。<code>ping</code> 和 <code>tracert</code> 都利用ICMP 协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。</p><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。但RFC认为ICMP是分担了IP的一部分功能。所以，ICMP也被认为是与IP同层的协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。看一下RFC 规定的数据包格式和报文内容吧。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.4xn5l5nbahs0.webp#pic_center" width = 48%><p>当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP的数据报文格式如下所示。所有报文的前4个字节都是一样的，其他的因报文类型不同而不一样。类型字段可以有15个不同的值，用以描述不同的ICMP报文。校验和字段覆盖整个ICMP报文，使用了和IP首部检验和一样的算法，详细请搜索TCP&#x2F;IP检验和算法。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.52nce9l7ak40.webp#pic_center" width = 48%><p><strong>字段说明：</strong></p><ul><li>类型：标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。    </li><li>代码：标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。    </li><li>校验和：对包括ICMP报文数据部分在内的整个ICMP&#96;数据报的校验和，以检验报文在传输过程中是否出现了差错。</li></ul><p><font color=#9900CC><strong>不同类型的报文是由类型字段和代码字段来共同决定。</font></strong>下表是各种类型的ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.5ol4guwagpk0.webp#pic_center" width = 48%><p>根据上表可知，ICMP协议大致分为两类，一种是查询报文，一种是差错报文。查询报文是用一对请求和应答定义的，它通常有以下几种用途:</p><ol><li>ping查询</li><li>子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）</li><li>时间戳查询（可以用来同步时间）</li></ol><p>而差错报文通常包含了引起错误的IP数据报的第一个分片的IP首部（和选项），加上该分片数据部分的前8个字节。RFC 792规范中定义的这8个字节中包含了该分组运输层首部的所有分用信息，这样运输层协议就可以向正确的进程提交ICMP差错报文。</p><p>当传送IP数据包发生错误时，比如主机不可达，端口不可达等，ICMP协议就会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。由上面可知，ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成，而前 16bit就组成了ICMP所要传递的信息。由数据链路层所能发送的最大数据帧，即MTU（Maximum Transmission Unit）为1500，计算易知ICMP协议在实际传输中数据包为：20字节IP首部 + 8字节ICMP首部+ 1472字节（数据大小）。</p><p>尽管在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的。如下</p><ol><li>ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）</li><li>目的地址是广播地址或多播地址的IP数据报。</li><li>作为链路层广播的数据报。</li><li>不是IP分片的第一片。</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。</li></ol><h3 id="2-2-ping程序原理分析"><a href="#2-2-ping程序原理分析" class="headerlink" title="2.2 ping程序原理分析"></a>2.2 ping程序原理分析</h3><p>ping程序是由Mike Muuss编写，目的是为了测试另一 台主机是否可达，现在已经成为一个常用的网络状态检查工具。该程序发送一份 ICMP回显请求报文给远程主机，并等待返回 ICMP回显应答。利用ping这种原理，已经出现了许多基于ping的网络扫描器，比如nmap、arping、fping、hping3等。所以随着Internet安全意识的增强，现在有些提供访问控制策略的路由器和防火墙已经可以设置过滤特定ICMP报文请求。因此并不能通过简单的ping命令判断远程主机是否在线。</p><p>ping 使用的是ICMP协议，它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。大多数的 TCP&#x2F;IP 实现都在内核中直接支持Ping服务器，ICMP回显请求和回显应答报文如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.klquqyz6p2o.webp#pic_center" width = 48%><p>ping的原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。通过计算ICMP应答报文数量和与接受与发送报文之间的时间差，判断当前的网络状态。这个往返时间的计算方法是：ping命令在发送ICMP报文时将当前的时间值存储在ICMP报文中发出，当应答报文返回时，使用当前时间值减去存放在ICMP报文数据中存放发送请求的时间值来计算往返时间。ping返回接受到的数据报文字节大小、TTL值以及往返时间。</p><p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的 ID号。这样 即使在同一台主机上同时运行了多个 ping程序实例，ping程序也可以识别出返回的信息。</p><p><code>ping</code> 操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.3qwubtumq28.webp#pic_center" width = 48%><p>过程如下：</p><ol><li><p>向目标服务器发送回送请求。<br>首先，向目标服务器发出回送请求（类型是8，代码是0）报文（同2）。在这个回送请求报文里，除了类型和代码字段，还被追加了标识符和序号字段。标识符和序号字段分别是16 位的字段。ping 命令在发送回送请求报文时，在这两个字段里填入任意的值。对于标识符，应用程序执行期间送出的所有报文里填入相同的值。对于序号，每送出一个报文数值就增加1。而且，回送请求的选项数据部分用来装任意数据。这个任意数据用来调整ping 的交流数据包的大小。</p></li><li><p>鹦鹉学舌一样返回回送回答。<br>计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求（类型是0，代码是0）（同3）。这个ICMP 回送回答报文在IP 层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP 地址字段被交换了，类型字段里填入了表示回送回答的0。也就是，从送信方来看，自己送出的ICMP 报文从目标服务器那里象鹦鹉学舌那样原样返回了。<br>送信方的计算机可以通过收到回送回答报文，来确认目标服务器在工作着。进一步，记住发送回送请求报文的时间，与接收到回送回答报文的时间一比较，就能计算出报文一去一回往复所需要的时间（同4）。但是，收到的回送回答报文里写的只是类型和代码的话，发送方计算机将无法判断它是否是自己发出去请求的回答。因此，前面说到的标识符和序号字段就有它的意义了。将这两个值与回送回答报文中的相同字段值一比较，送行方计算机就能够简单地检测回送回答是否正确了。执行ping 命令而调查的结果没什么问题的话，就将目标服务器的IP 地址，数据大小，往复花费的时间打印到屏幕上。</p></li><li><p>用ping 命令不能确定与对方连通的原因大致有三个。<br>1）目标服务器不存在；2)花在数据包交流上的时间太长ping 命令认为超时；3）目标服务器不回答ping 命令。如果是原因2），通过ping 命令的选项来延长到超时的等待时间，就能正确显示结果了。如果原因是1）或3）的话，仅凭ping 命令的结果就不能判断是哪方了。正如这样，ping 命令不一定一定能判断对方是否存在。</p></li></ol><p>一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。</p><p>时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。</p><h3 id="2-3-协议数据包的封装"><a href="#2-3-协议数据包的封装" class="headerlink" title="2.3 协议数据包的封装"></a>2.3 协议数据包的封装</h3><p>Python中处理二进制数据如存取文件、socket操作时，可以使用 Python 的 struct 模块来完成。使用该模块可以方便地来实现协议数据的封装与解封。</p><p>struct模块中最重要的三个函数是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pack(fmt, v1, v2, ...)     <span class="comment"># 按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</span></span><br><span class="line">unpack(fmt, string)        <span class="comment"># 按照给定的格式(fmt)解析字节流string，返回解析出来的数组</span></span><br><span class="line">calcsize(fmt)              <span class="comment"># 计算给定的格式(fmt)占用多少字节的内存</span></span><br></pre></td></tr></table></figure><p>其中fmt支持的格式如下表描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5mgm8e69x380.webp#pic_center" width = 48%><p>在完成封装后，将封装后的数据data，使用原始套接字的 <code>sendto()</code> 方法进行发送。<code>sendto()</code> 主要参数：</p><ul><li>packet：发送的数据</li><li>Addr：形式为 <code>(ipaddr，port)</code> 的元组</li></ul><h2 id="3-解析IP包ICMP头信息"><a href="#3-解析IP包ICMP头信息" class="headerlink" title="3 解析IP包ICMP头信息"></a>3 解析IP包ICMP头信息</h2><h3 id="3-1-接收ICMP报文"><a href="#3-1-接收ICMP报文" class="headerlink" title="3.1 接收ICMP报文"></a>3.1 接收ICMP报文</h3><p>使用原始套接字的 <code>recvfrom()</code> 函数接收报文，输入参数指定为报文最大长度，如1024；函数返回值为报文发送方的地址、报文内容。接收代码示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfpacket, addr = mysocket.recvfrom(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-解析ICMP报文"><a href="#3-2-解析ICMP报文" class="headerlink" title="3.2 解析ICMP报文"></a>3.2 解析ICMP报文</h3><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议类型字段值为1时，就说明这是一个ICMP报文。</p><p>ICMP报头如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.5fd06it998c0.webp#pic_center" width = 48%><p>解析ICMP报文可以使用Python中struct模块的 <code>upack()</code> 函数来实现。其参数：</p><ul><li>fmtstr: 格式化字符串</li><li>packet: 需要解析的字符数组</li></ul><p>函数的返回值可以是多个，根据格式串中指定的类型返回到相应变量中。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d=struct.unpack(<span class="string">&#x27;5s6sif&#x27;</span>,<span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><p>则从bytes这个数组中解析出a：5个字符的字符串（5s），b:6个字符的字符串(6s)，c为整型(i)，d为浮点型数据(f)。</p><p>对于Ping命令的ICMP报文，我们需从IP包中取出ICMP报头，位于20到28字节；从中可以取出报文类型type,代码code，校验和checksum，报文ID及报文序号字段；</p><p>对于类型为1的报文且其ID为需要接收的报文，从28字节后面开始解析发送的数据为发送时间，数据类型及长度根据发送的数据来确定。</p><ul><li>响应时间：计算收到报文的时间与发送报文（ICMP报文的数据部分）的时间差；</li><li>TTL：TTL指Time To Live生成周期，指定IP包被路由器丢弃之前允许通过的最大网段数量。在IPv4包头中TTL是一个8 bit字段，它位于IPv4包的第9个字节。因此只需从接收报文中解析出第9字节即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chesksum</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    校验</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(data)</span><br><span class="line">    m = n % <span class="number">2</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - m ,<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">sum</span> += (data[i]) + ((data[i+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>)   <span class="comment"># 传入data以每两个字节（十六进制）通过ord转十进制，第一字节在低位，第二个字节在高位</span></span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        <span class="built_in">sum</span> += (data[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 将高于16位与低16位相加</span></span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>) + (<span class="built_in">sum</span> &amp; <span class="number">0xffff</span>)</span><br><span class="line">    <span class="built_in">sum</span> += (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>)      <span class="comment"># 如果还有高于16位，将继续与低16位相加</span></span><br><span class="line">    answer = ~<span class="built_in">sum</span> &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="comment"># 主机字节序转网络字节序列（参考小端序转大端序）</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一次Ping的返回消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiveOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr, timeout</span>):</span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        </span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        <span class="built_in">type</span>, code, checksum, packetID, sequence = struct.unpack(<span class="string">&quot;!bbHHh&quot;</span>, header)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">and</span> packetID == ID:  <span class="comment"># type should be 0</span></span><br><span class="line">            byte_in_double =  struct.calcsize(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">            timeSent = struct.unpack(<span class="string">&quot;d&quot;</span>, recPacket[<span class="number">28</span>:<span class="number">28</span>+byte_in_double])[<span class="number">0</span>]</span><br><span class="line">            delay = timeReceived - startedSelect</span><br><span class="line">            ttl = struct.unpack(<span class="string">&quot;!b&quot;</span>, recPacket[<span class="number">8</span>:<span class="number">9</span>])[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> (delay, ttl, byte_in_double)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送一次Ping数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr</span>):</span><br><span class="line">    <span class="comment"># 头部构成： type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;!d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># 计算头部和数据的校验和</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向指定地址发送Ping消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doOnePing</span>(<span class="params">destAddr, ID, sequence, timeout</span>):</span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建原始套接字</span></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"> </span><br><span class="line">    sendOnePing(mySocket, ID, sequence, destAddr)</span><br><span class="line">    delay = receiveOnePing(mySocket, ID, sequence, destAddr, timeout)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数Ping</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># timeout=1指: 如果1秒内没从服务器返回，客户端认为Ping或Pong丢失。</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pinging &quot;</span> + dest + <span class="string">&quot; using Python:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每秒向服务器发送一次Ping请求</span></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># 返回进程ID</span></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        result = doOnePing(dest, myID, i, timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Request timed out.&quot;</span>)</span><br><span class="line">            loss += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delay = <span class="built_in">int</span>(result[<span class="number">0</span>]*<span class="number">1000</span>)</span><br><span class="line">            ttl = result[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">bytes</span> = result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Received from &quot;</span> + dest + <span class="string">&quot;: byte(s)=&quot;</span> + <span class="built_in">str</span>(<span class="built_in">bytes</span>) + <span class="string">&quot; delay=&quot;</span> + <span class="built_in">str</span>(delay) + <span class="string">&quot;ms TTL=&quot;</span> + <span class="built_in">str</span>(ttl))</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Packet: sent = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>) + <span class="string">&quot; received = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>-loss) + <span class="string">&quot; lost = &quot;</span> + <span class="built_in">str</span>(loss))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6tiqidr3ru00.webp#pic_center" width = 36%><h2 id="4-ICMP-的应用–Traceroute"><a href="#4-ICMP-的应用–Traceroute" class="headerlink" title="4 ICMP 的应用–Traceroute"></a>4 ICMP 的应用–Traceroute</h2><h3 id="4-1-原理介绍"><a href="#4-1-原理介绍" class="headerlink" title="4.1 原理介绍"></a>4.1 原理介绍</h3><p>Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管 ping 工具也可以进行侦测，但是，因为 ip 头的限制，ping 不能完全的记录下所经过的路由器。所以 Traceroute 正好就填补了这个缺憾。</p><p>Traceroute 的原理是非常非常的有意思，它受到目的主机的 IP 后，首先给目的主机发送一个 TTL&#x3D;1(还记得 TTL 是什么吗?)的  UDP(后面就 知道 UDP 是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减1，而 TTL 变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL&#x3D;2的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 ip。从而避开了 ip 头只能记录有限路由 IP 的问题。</p><p>有人要问，我怎么知道 UDP 到没到达目的主机呢？这就涉及一个技巧的问题，TCP 和 UDP 协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较小的端口，比如说80，比如说23，等等。而 traceroute 发送的是端口号&gt;30000(真变态)的  UDP 报，所以到 达目的主机的时候，目的主机只能发送一个端口不可达的 ICMP 数据报给主机。主机接到这个报告以后就知道，主机到了，所以，说  Traceroute 是一个骗子一点也不为过。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.62nfc4shenk0.webp#pic_center" width = 48%><p><strong>过程如下：</strong></p><ol><li>执行tracert命令。<br>在Windows 上执行tracert 命令后，首先计算机向目的服务器发送IP 数据包。Windows 上使用的是与ping 同样的ICMP 回送请求报文。但是，有一点和通常的回送请求不一样。那是，最初将IP 首部的TTL(生存时间)字段设为1 这一点。</li></ol><p>路由器每转送一次数据包就将TTL 的值减1。当TTL 变为0 的时候，按规定将丢弃这个数据包。正如这样，与其说TTL 是时间，还不如说TTL 是经过路由器的个数。对于计算机发送出去的数据包，只要它与目标服务器不在同一局域网内，一定会被哪儿的路由器中继。这时如果TTL 的值是1，由于路由器的处理会变为0，则该数据包将会被丢弃（同2）。</p><ol start="2"><li>用超时报文来通知送信方。<br>路由器丢弃数据包的同时，用ICMP 报文来通知错误。这时使用的ICMP 报文是，类型为11，代码为0 的ICMP 超时报文。而且在选项数据字段里，将填入原先数据包的IP 首部和ICMP 的开始8 字节。正如ping 命令的时候看到的，ICMP 回送请求的先头8 字节里包含了标识符和序号字段。因此，送信方的计算机看了超时报文后，就知道是针对自己发出的回送请求的错误通知。</li></ol><p>计算机接到针对第一个数据包的ICMP 超时报文后，接下来将TTL 加1（TTL&#x3D;2）并同样地送出（同3）。这次通过第一个路由器，TTL 变为1，到达第二个路由器。但是第二个路由器象前面一样，由于TTL变为0，将不能转发该包。因此，同第一个路由器一样，将该包丢弃，并返回ICMP 超时报文。以后，收到错误的发送方计算机将TTL 加1，重复同样的工作（同4）。</p><ol start="3"><li>只有目标服务器的反应不同。<br>如此一个一个增加TTL，某个时候ICMP 回送请求报文将到达最终的目标服务器。这时，只有目标服务器与途中的路由器不同，不返回ICMP 超时报文。为什么呢？因为即使目标服务器收到TTL 为1 的数据包也不会发生错误。</li></ol><p>作为代替处理，服务器针对送信方计算机发出的ICMP 回送请求报文，返回ICMP 回送回答报文。也就是，送信方计算机与服务器之间，与ping 命令的执行一样了（同5）。得到了ICMP 回送回答报文的送信方知道了路经调查已经到了目标服务器，就结束了tracert 命令的执行（同6）。像这样，通过列出中途路由器返回的错误，就能知道构成到目标服务器路径的所有路由器的信息了。</p><ol start="4"><li>操作系统不同则实现方法略微不同。<br>到这里，以Windows 上的tracert 命令为例看了原理，有些别的操作系统的traceroute 命令的原理略微不同。</li></ol><p>具体来说，也有用向目标发送UDP 数据包代替ICMP 回送请求报文来实现的。虽说是用UDP，但途中的路由器的处理与図 8完全相同。只是UDP 数据包到达目标后的处理不同。目标计算机突然收到与通信无关的数据包，就返回ICMP 错误，因此根据返回数据包的内容来判断命令的中止。</p><h3 id="4-2-Python-实现"><a href="#4-2-Python-实现" class="headerlink" title="4.2 Python 实现"></a>4.2 Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230423</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 基于ICMP协议Traceroute实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kamene.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tracert_one</span>(<span class="params">dst,dport,ttl_no</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;发一个Traceroute包，参数需要目的地址，目的端口，TTL&#x27;&#x27;&#x27;</span></span><br><span class="line">    send_time = time.time()         <span class="comment"># 记录发送时间</span></span><br><span class="line">    Tracert_one_reply = sr1(IP(dst=dst, ttl=ttl_no)/UDP(sport=<span class="number">6600</span>, dport=dport)/<span class="string">b&#x27;my traceroute!!!&#x27;</span>, timeout = <span class="number">1</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Scapy中UDP默认源目端口53，需要将源端口也改掉，否则中间设备将不回应</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">11</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果收到TTL超时</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>, hop_ip, time_to_passed        <span class="comment"># 返回1表示并未抵达目的地</span></span><br><span class="line">        <span class="keyword">elif</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">3</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">3</span>:</span><br><span class="line">            <span class="comment"># 如果收到端口不可达</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>, hop_ip, time_to_passed    <span class="comment"># 返回2表示抵达目的地</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">&#x27;.*NoneType.*&#x27;</span>,<span class="built_in">str</span>(e)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>     <span class="comment"># 测试失败返回None,没有回包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MY_Tracert</span>(<span class="params">dst,hops</span>):</span><br><span class="line">    dport = <span class="number">33434</span>           <span class="comment"># Traceroute的目的端口从33434开始计算</span></span><br><span class="line">    hop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> hop &lt; hops:</span><br><span class="line">        dport = dport + hop</span><br><span class="line">        hop += <span class="number">1</span></span><br><span class="line">        Result = Tracert_one(dst,dport,hop)</span><br><span class="line">        <span class="keyword">if</span> Result == <span class="literal">None</span>:      <span class="comment"># 如果测试失败就打印‘*’</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; *&#x27;</span>,flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">1</span>:    <span class="comment"># 如果未抵达目的，就打印这一跳和消耗的时间</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">2</span>:    <span class="comment"># 如果抵达目的，就打印这一跳和消耗的时间，并且跳出循环！</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conf.route.add(net=<span class="string">&#x27;172.16.10.0/24&#x27;</span>,gw=<span class="string">&#x27;192.168.10.115&#x27;</span>)    <span class="comment"># 为Scapy添加路由</span></span><br><span class="line">    destIP=<span class="built_in">input</span>(<span class="string">&quot;目标IP&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    hops=<span class="built_in">input</span>(<span class="string">&quot;最大跳数&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    MY_Tracert(destIP, <span class="built_in">int</span>(hops))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.40tookmha7w0.webp#pic_center" width = 64%><blockquote><p>了解更多，请阅读：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">ICMP实现之端口扫描、ICMP实现之改变路由、ICMP实现之源点抑制、ICMP实现之MTU探索</a></p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>python实现ping工具：<a href="https://blog.csdn.net/jia666666/article/details/85254450">https://blog.csdn.net/jia666666/article/details/85254450</a></li><li>ICMP协议与ping原理以及用Python实现ping：<a href="https://cloud.tencent.com/developer/article/1156671">https://cloud.tencent.com/developer/article/1156671</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li><li>完全理解icmp协议：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">https://www.cnblogs.com/iiiiher/p/8513748.html</a></li><li>Python网络编程2–实现Ping程序与Traceroute程序：<a href="https://www.jianshu.com/p/0c52955515c7">https://www.jianshu.com/p/0c52955515c7</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="ICMP 协议" scheme="https://qxienote.com/tags/ICMP-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
