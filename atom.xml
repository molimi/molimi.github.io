<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CarpeDiem&#39;s Blog</title>
  
  <subtitle>虽不能至，心向往之</subtitle>
  <link href="https://qxienote.com/atom.xml" rel="self"/>
  
  <link href="https://qxienote.com/"/>
  <updated>2023-06-11T03:43:49.329Z</updated>
  <id>https://qxienote.com/</id>
  
  <author>
    <name>Carpe Diem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《计算机网络-自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</title>
    <link href="https://qxienote.com/article/396f3774.html"/>
    <id>https://qxienote.com/article/396f3774.html</id>
    <published>2023-06-11T03:09:59.000Z</published>
    <updated>2023-06-11T03:43:49.329Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。</p><span id="more"></span><p>要深入理解网络协议，需要仔细观察协议实体之间交换的报文序列。为探究协议操作细节，可使协议实体执行某些动作，观察这些动作及其影响。这些任务可以在仿真环境下或在如因特网这样的真实网络环境中完成。观察在正在运行协议实体间交换报文的基本工具被称为分组嗅探器(<code>packet sniffer</code>)。顾名思义，一个分组嗅探器捕获（嗅探）计算机发送和接收的报文。一般情况下，分组嗅探器将存储和显示出被捕获报文的各协议头部字段内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.6gwpvo7pots0.webp#pic_center" width = 48%><p>上图右边是计算机上正常运行的协议（在这里是因特网协议）和应用程序（如：<code>Web</code> 浏览器和 <code>ftp</code> 客户端）。分组嗅探器（虚线框中的部分）是附加在计算机普通软件上的，主要由两部分组成。分组捕获库接收计算机发送和接收的每一个链路层帧的拷贝。高层协议（如：<code>HTTP</code>、 <code>FTP</code>、 <code>TCP</code>、 <code>UDP</code>、 <code>DNS</code>、 <code>IP</code> 等）交换的报文都被封装在链路层帧(Frame)中，并沿着物理介质（如以太网的电缆）传输。上图假设所使用的物理媒体是以太网，上层协议的报文最终封装在以太网帧中。</p><p>分组嗅探器的第二个组成部分是分析器。分析器用来显示协议报文所有字段的内容。为此，分析器必须能够理解协议所交换的所有报文的结构。例如：我们要显示上图中 HTTP 协议所交换的报文的各个字段。分组分析器理解以太网帧格式，能够识别包含在帧中的 IP 数据报。分组分析器也要理解 IP 数据报的格式，并能从 IP 数据报中提取出 TCP 报文段。然后，它需要理解 TCP 报文段，并能够从中提取出 HTTP 消息。最后，它需要理解 HTTP 消息。</p><p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和Linux&#x2F;Unix计算机上运行，是进行网络实验的理想分组分析器。该软件具有庞大的用户基础，文档支持包括用户指南、手册和常见问题(详见<a href="http://www.wireshark.org/docs">http://www.wireshark.org/docs</a>)，丰富的功能包括分析数百种协议，以及精心设计的用户界面。可以运行在使用以太网、串行(PPP和SLIP)、802.11无线局域网和许多其他链路层技术的计算机上。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.6fvhzc6qeb40.webp#pic_center" width = 48%><p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark。</p><h2 id="1-下载并安装Wireshark软件"><a href="#1-下载并安装Wireshark软件" class="headerlink" title="1 下载并安装Wireshark软件"></a>1 下载并安装Wireshark软件</h2><p>WireShark 是一种可以运行在 Windows，UNIX，Linux 等操作系统上的分组分析器。运行Wireshark，需要有一台支持Wireshark和libpcap或WinPCap分组捕获库的计算机。安装Wireshark时，如果操作系统中未安装libpcap软件，它将会自动安装。支持的操作系统和下载站点的列表，请访问[<a href="http://www.wireshark.org/download.html]">http://www.wireshark.org/download.html]</a>(<a href="http://www.wireshark.org/download.html%E3%80%82%E6%8C%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E6%8C%89%E7%85%A7%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E4%B8%80%E8%B7%AFNext%E5%AE%89%E8%A3%85%E3%80%82">http://www.wireshark.org/download.html。按照系统版本选择下载，下载完成后，按照软件提示一路Next安装。</a></p><p> <strong>温馨提示：</strong> 当您在安装或运行Wireshark时遇到问题时，可以查看Wireshark FAQ，它包含一些有用的提示和信息。如果你是Win10系统，安装完成后，选择抓包但是不显示网卡，下载win10pcap兼容性安装包。下载路径：<a href="http://www.win10pcap.org/download/">下载路径：win10pcap兼容性安装包</a></p><h2 id="2-Wireshark-开始抓包示例"><a href="#2-Wireshark-开始抓包示例" class="headerlink" title="2 Wireshark 开始抓包示例"></a>2 Wireshark 开始抓包示例</h2><p>1、双击桌面上的图标，可启动Wireshark。启动后的用户界面如下图所示，中间列表部分列出了所有网络接口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.38sj0cnbnum0.webp#pic_center" width = 48%><p>2、选择菜单栏上捕获 -&gt; 选项，勾选WLAN网卡（这里需要根据各自电脑网卡使用情况选择，简单的办法可以看使用的IP对应的网卡）。点击Start。启动抓包。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4qe115vaeae0.webp#pic_center" width = 48%><p>3、wireshark启动后，wireshark处于抓包状态中。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.3la44n2lec40.webp#pic_center" width = 48%><p>4、执行需要抓包的操作，如在cmd窗口下执行<code>ping www.baidu.com</code>。</p><p>5、抓取分组操作</p><p>A.单击中间网络接口列表中，某一网络接口如<code>eth0</code>，选中网络接口，通过菜单“捕获”-“开始”或工具栏中的<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 按钮，开始捕获选定接口中的网络分组；B．也可以双击中间网络接口列表中，某一网络接口如<code>eth0</code>，可以开始抓取分组；C．通过菜单“捕获”-“停止”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 停止抓取分组。D．通过菜单“捕获”-“重新开始”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 重新开始抓取。</p><p>6、Wireshark窗口功能</p><p><strong>A．命令菜单和工具栏</strong><br>命令菜单位于窗口的最顶部，是标准的下拉式菜单。最常用菜单命令有两个： 文件、 捕获。 文件 菜单允许你保存捕获的分组数据，或打开一个已被保存的捕获分组数据文件，或退出 WireShark 程序。 捕获 菜单允许你开始捕获分组。</p><p>工具栏位于命令菜单的下方，提供常用功能的快捷方式。如<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：开始捕获、<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：停止捕获、<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：重新抓取分组。</p><p><strong>B．显示过滤规则</strong></p><p>在该字段中，可以填写协议的名称或其他信息，根据此内容可以对分组列表窗口中的分组进行过滤。</p><p><strong>C．捕获分组列表</strong></p><p>按行显示已被捕获的分组内容，其中包括： WireShark 赋予的分组序号、捕获时间、分组的源地址和目的地址、协议类型、分组中所包含的协议说明信息。单击某一列的列名，可以使分组按指定列进行排序。 在该列表中，所显示的协议类型是发送或接收分组的最高层协议的类型。</p><p><strong>D．分组头部明细</strong></p><p>显示捕获分组列表窗口中被选中分组的头部详细信息。包括：与以太网帧有关的信息，与包含在该分组中的 IP 数据报有关的信息。</p><p>单击以太网帧或 IP 数据报所在行左边的向右或向下的箭头可以展开或最小化相关信息。如果利用 TCP 或 UDP 承载分组， WireShark 也会显示 TCP 或 UDP 协议头部信息。分组最高层协议的头部字段也会显示在此窗口中。</p><p><strong>E．分组内容窗口</strong></p><p>以 ASCII 码和十六进制两种格式显示被捕获帧的完整内容。</p><p>7、通常，分组列表窗口中会显示许多类型的分组。即使仅仅是下载了一个网页，但是还有许多其他协议在您的计算机上运行，只是用户所看不见。可以在中间过滤窗口中输入过滤的分组协议如http， 选择应用按钮，就可以只让HTTP分组消息显示在分组列表窗口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.4x7p2hmwhiw0.webp#pic_center" width = 48%><p>8、操作完成后相关数据包就抓取到了。为避免其他无用的数据包影响分析，可以通过在过滤栏设置过滤条件进行数据包列表过滤，获取结果如下。说明：<code>ip.addr == 119.75.217.26 and icmp</code> 表示只显示ICPM协议且源主机IP或者目的主机IP为<code>119.75.217.26</code>的数据包。说明：协议名称icmp要小写。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.sm5aj8usjww.webp#pic_center" width = 48%><h2 id="3-Wireshakr抓包界面介绍"><a href="#3-Wireshakr抓包界面介绍" class="headerlink" title="3 Wireshakr抓包界面介绍"></a>3 Wireshakr抓包界面介绍</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.61b2vxymuhg0.webp#pic_center" width = 36%><p>说明：数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏 视图(View) –&gt; 着色规则(Coloring Rules)。如下所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.4owrci6ggh00.webp#pic_center" width = 48%><ol><li>显示过滤器(Display Filter)，用于设置过滤条件进行数据包列表过滤。菜单路径：分析(Analyze) –&gt; 显示过滤器(Display Filters)。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.726v80qr0vg0.webp#pic_center" width = 48%><ol><li>数据包列表(Packet List Pane)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。</li></ol><p>Time:时间；Source:发送主机IP地址；Destination: 接收主机IP地址；Protocol：分组协议；Length：分组长度；Info：分组内容</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.7829pakw1us0.webp#pic_center" width = 48%><ol><li>数据包详细信息(Packet Details Pane), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为<br>（1）Frame:   物理层的数据帧概况<br>（2）Ethernet II: 数据链路层以太网帧头部信息<br>（3）Internet Protocol Version 4: 互联网层IP包头部信息<br>（4）Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP<br>（5）Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.4xs9wudqaak0.webp#pic_center" width = 48%><p>TCP包的具体内容</p><p>从下图可以看到wireshark捕获到的TCP包中的每个字段。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.2sybmlwvjy00.webp#pic_center" width = 48%><ol><li>数据包字节区(Dissector Pane)。</li></ol><p>在分组内容窗口中，可以显示出该分组内容的16进制和ASCII两种格式的内容。鼠标指向内容窗口，可以将分组中某一字段的内容突出显示。在分组头部信息窗口中，展开选择某一头部信息时，分组内容中相应内容同步突出显示。</p><h2 id="4-Wireshark过滤器设置"><a href="#4-Wireshark过滤器设置" class="headerlink" title="4 Wireshark过滤器设置"></a>4 Wireshark过滤器设置</h2><p>初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己需要抓取的数据包部分。wireshark工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p><p><strong>1) 抓包过滤器</strong></p><p>捕获过滤器的菜单栏路径为Capture –&gt; Capture Filters。用于在抓取数据包前设置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.6uzm0lq7h800.webp#pic_center" width = 48%><p>如何使用？可以在抓取数据包前设置如下。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.5zbhvy2gomw0.webp#pic_center" width = 48%><p><code>ip host 60.207.246.216 and icmp</code> 表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.2k7fnwqaoo20.webp#pic_center" width = 48%><p><strong>（2）显示过滤器</strong></p><p>显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛或者没有设置导致抓取的数据包内容较多时使用显示过滤器设置条件过滤以方便分析。同样上述场景，在捕获时未设置抓包过滤规则直接通过网卡进行抓取所有数据包，如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.1p43gtotb00w.webp#pic_center" width = 48%><p>执行 <code>ping www.baidu.com</code> 获取的数据包列表如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.2hu9htl72eo0.webp#pic_center" width = 48%><p>观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。<code>ip.addr == 14.119.104.254 and icmp</code>。并进行过滤。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.4q6cjmtdeei0.webp#pic_center" width = 48%><p>上述介绍了抓包过滤器和显示过滤器的基本使用方法。在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。下面介绍一下两者间的语法以及它们的区别。</p><h2 id="5-wireshark过滤器表达式的规则"><a href="#5-wireshark过滤器表达式的规则" class="headerlink" title="5 wireshark过滤器表达式的规则"></a>5 wireshark过滤器表达式的规则</h2><p>1、抓包过滤器语法和实例</p><p>抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）</p><p>(1) 协议过滤</p><p>比较简单，直接在抓包过滤框中直接输入协议名即可。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><p>(2) IP过滤</p><ul><li>host 192.168.1.104</li><li>src host 192.168.1.104</li><li>dst host 192.168.1.104</li></ul><p>(3) 端口过滤</p><ul><li>port 80</li><li>src port 80</li><li>dst port 80</li></ul><p>(4) 逻辑运算符 &amp;&amp; 与、|| 或、！非</p><ul><li><code>src host 192.168.1.104 &amp;&amp; dst port 80</code> 抓取主机地址为192.168.1.80、目的端口为80的数据包</li><li><code>host 192.168.1.104 || host 192.168.1.102</code> 抓取主机为192.168.1.104或者192.168.1.102的数据包</li><li><code>!broadcast</code> 不抓取广播数据包</li></ul><p>2、显示过滤器语法和实例<br>(1) 比较操作符</p><p>比较操作符有&#x3D;&#x3D; 等于、！&#x3D; 不等于、&gt; 大于、&lt; 小于、&gt;&#x3D; 大于等于、&lt;&#x3D;小于等于。</p><p>(2) 协议过滤</p><p>比较简单，直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(3) ip过滤</p><ul><li><code>ip.src ==192.168.1.104</code>，显示源地址为192.168.1.104的数据包列表</li><li><code>ip.dst==192.168.1.104</code>，显示目标地址为192.168.1.104的数据包列表</li><li><code>ip.addr == 192.168.1.104</code>，显示源IP地址或目标IP地址为192.168.1.104的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(4) 端口过滤</p><ul><li>tcp.port &#x3D;&#x3D;80,  显示源主机或者目的主机端口为80的数据包列表。</li><li>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的源主机端口为80的数据包列表。</li><li>tcp.dstport &#x3D;&#x3D; 80，只显示TCP协议的目的主机端口为80的数据包列表。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/042.4ni1tou9im80.webp#pic_center" width = 48%><p>(5) Http模式过滤</p><p><code>http.request.method==&quot;GET&quot;</code>, 只显示HTTP GET方法的。</p><p>(6) 逻辑运算符为 and&#x2F;or&#x2F;not</p><p>过滤多个条件组合时，使用and&#x2F;or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为 <code>ip.addr == 14.119.104.254 and icmp</code></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.oe0q389yzmo.webp#pic_center" width = 48%><p>(7) 按照数据包内容过滤。假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.2eq42rto5h34.webp#pic_center" width = 48%><p>右键单击选中后出现如下界面</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.9tlmp06f5y8.webp#pic_center" width = 48%><p>选中Select后在过滤器中显示如下，后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含”abcd”内容的数据流。包含的关键词是contains 后面跟上内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4v5jwne3bpq0.webp#pic_center" width = 48%><p>调整数据包列表中时间戳显示格式。调整方法为View –&gt;Time Display Format –&gt; Date and Time of Day。调整后格式如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.3f70teoime8.webp#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>wireshark 基本使用：<a href="https://www.educoder.net/shixuns/5kuyi2hn/challenges">https://www.educoder.net/shixuns/5kuyi2hn/challenges</a></li><li>wireshark抓包新手使用教程：<a href="https://www.cnblogs.com/linyfeng/p/9496126.html">https://www.cnblogs.com/linyfeng/p/9496126.html</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络-自顶向下方法" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Wireshark" scheme="https://qxienote.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十）-- 链表的实现</title>
    <link href="https://qxienote.com/article/4e528de2.html"/>
    <id>https://qxienote.com/article/4e528de2.html</id>
    <published>2023-06-11T03:09:20.000Z</published>
    <updated>2023-06-11T03:31:42.672Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（九）--单调栈与单调队列</title>
    <link href="https://qxienote.com/article/933f1d8e.html"/>
    <id>https://qxienote.com/article/933f1d8e.html</id>
    <published>2023-06-11T03:09:10.000Z</published>
    <updated>2023-06-11T03:31:42.668Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（八）-- 队列的实现与应用</title>
    <link href="https://qxienote.com/article/1515a7fd.html"/>
    <id>https://qxienote.com/article/1515a7fd.html</id>
    <published>2023-06-11T03:08:58.000Z</published>
    <updated>2023-06-11T03:31:42.670Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（七）-- 栈的实现与应用</title>
    <link href="https://qxienote.com/article/fa4199ab.html"/>
    <id>https://qxienote.com/article/fa4199ab.html</id>
    <published>2023-06-11T03:08:46.000Z</published>
    <updated>2023-06-11T03:31:42.666Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（六）-- 哈希表</title>
    <link href="https://qxienote.com/article/83d55e57.html"/>
    <id>https://qxienote.com/article/83d55e57.html</id>
    <published>2023-06-11T03:08:30.000Z</published>
    <updated>2023-06-11T03:31:42.671Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（五）-- 二分查找与二分答案</title>
    <link href="https://qxienote.com/article/25d31d17.html"/>
    <id>https://qxienote.com/article/25d31d17.html</id>
    <published>2023-06-11T03:08:16.000Z</published>
    <updated>2023-06-11T08:28:04.494Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码和常见的解题技巧，带大家学透二分算法</p><span id="more"></span><h2 id="1-二分法介绍"><a href="#1-二分法介绍" class="headerlink" title="1 二分法介绍"></a>1 二分法介绍</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>二分查找又称折半查找、二分搜索、折半搜索等，是一种在静态查找表中查找特定元素的算法。</p><blockquote><p>所谓静态查找表，即只能对表内的元素做查找和读取操作，不允许插入或删除元素。</p></blockquote><p>使用二分查找算法，必须保证查找表中存放的是有序序列（升序或者降序）。换句话说，存储无序序列的静态查找表，除非先对数据进行排序，否则不能使用二分查找算法。它针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。下图对比了顺序查找和二分查找的不同：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.39e6uepbps80.gif#pic_center" width = 48%><p>二分查找的最基本问题是在有序数组里查找一个特定的元素，还可以应用在：</p><ol><li>在半有序（旋转有序或者是山脉）数组里查找元素；</li><li>确定一个有范围的整数；</li><li>需要查找的目标元素满足某个特定的性质。</li></ol><p>二分查找算法的时间复杂度可以用  $O(log_2n)$ 表示（$n$ 为查找表中的元素数量，底数 2 可以省略）。和顺序查找算法的 $O(n)$ 相比，显然二分查找算法的效率更高，且查找表中的元素越多，二分查找算法效率高的优势就越明显。</p><h3 id="1-2-二分法的三种写法"><a href="#1-2-二分法的三种写法" class="headerlink" title="1.2 二分法的三种写法"></a>1.2 二分法的三种写法</h3><p><strong>1. 模板一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 特殊用例判断</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 在 [left, right] 区间里查找target</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 为了防止 left + right 整形溢出，写成如下形式</span></span><br><span class="line">            <span class="comment"># Python 使用 BigInteger，所以不用担心溢出，但还是推荐使用如下方式</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                <span class="comment"># 下一轮搜索区间：[left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 此时：nums[mid] &lt; target</span></span><br><span class="line">                <span class="comment"># 下一轮搜索区间：[mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>许多刚刚写的朋友，经常在写 <code>left = mid + 1</code>；还是写 <code>right = mid - 1</code>; 感到困惑，一个行之有效的思考策略是：<font color=#9900CC><strong>永远去想下一轮目标元素应该在哪个区间里：</font></strong><ul><li>如果目标元素在区间 <code>[left, mid - 1]</code> 里，就需要设置设置 <code>right = mid - 1</code>；</li><li>如果目标元素在区间 <code>[mid + 1, right]</code> 里，就需要设置设置 <code>left = mid + 1</code>；</li></ul></li></ul><p>考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义。</p><ul><li>二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的；</li><li>循环可以继续的条件是 <code>while (left &lt;= right)</code>，特别地，当 <code>left == right</code> 即当待搜索区间里只有一个元素的时候，查找也必须进行下去；</li><li><code>mid = (left + right) // 2</code>；在 <code>left + right</code> 整形溢出的时候，mid 会变成负数，回避这个问题的办法是写成 <code>mid = left + (right - left) // 2</code>。</li></ul><p><strong>2. 模板二</strong></p><p><strong>版本一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid]</span></span><br><span class="line">            right = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br></pre></td></tr></table></figure><p><strong>版本二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时上取整</span></span><br><span class="line">        mid = left + (right - left + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid, right]</span></span><br><span class="line">            left = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br></pre></td></tr></table></figure><p>理解模板代码的要点：</p><ul><li>核心思想：虽然模板有两个，但是核心思想只有一个，那就是：<font color=#9900CC><strong>把待搜索的目标元素放在最后判断，每一次循环排除掉不存在目标元素的区间，目的依然是确定下一轮搜索的区间；</font></strong></li><li>特征：<code>while (left &lt; right):</code>，这里使用严格小于 <code>&lt;</code> 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 <code>left == right</code>成立，这一点在定位元素下标的时候极其有用；</li><li>在循环体中，先考虑 <code>nums[mid]</code> 在满足什么条件下不是目标元素，进而考虑两个区间 <code>[left, mid - 1]</code> 以及 <code>[mid + 1, right]</code> 里元素的性质，目的依然是确定下一轮搜索的区间； <strong>注意 1：</strong> 先考虑什么时候不是解，是一个经验，在绝大多数情况下不易出错，重点还是确定下一轮搜索的区间，由于这一步不容易出错，它的反面（也就是 <code>else</code> 语句的部分），就不用去考虑对应的区间是什么，直接从上一个分支的反面区间得到，进而确定边界如何设置；</li><li>根据边界情况，看取中间数的时候是否需要上取整； <strong>注意 2：</strong> 这一步也依然是根据经验，建议先不要记住结论，在使用这个思想解决问题的过程中，去思考可能产生死循环的原因，进而理解什么时候需要在括号里加 1 ，什么时候不需要；</li><li>在退出循环以后，根据情况看是否需要对下标为 <code>left</code> 或者 <code>right</code> 的元素进行单独判断，这一步叫「后处理」。在有些问题中，排除掉所有不符合要求的元素以后，剩下的那 1 个元素就一定是目标元素。如果根据问题的场景，目标元素一定在搜索区间里，那么退出循环以后，可以直接返回 left（或者 right）。</li></ul><p>以上是这两个模板写法的所有要点，并且是高度概括的。请读者一定先抓住这个模板的核心思想，在具体使用的过程中，不断地去体会这个模板使用的细节和好处。只要把中间最难理解的部分吃透，几乎所有的二分问题就都可以使用这个模板来解决，因为「减治思想」是通用的。好处在这一小节的开篇介绍过了，需要考虑的细节最少。</p><p>学习建议：一定需要多做练习，体会这（两）个模板的使用。</p><p><strong>注意事项：</strong></p><ul><li>先写分支，再决定中间数是否上取整；</li><li>在使用多了以后，就很容易记住，只要看到 left &#x3D; mid ，它对应的取中位数的取法一定是 <code>mid = left + (right - left + 1) // 2</code>。</li></ul><p><strong>3. 模板三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>这一版代码和模板二没有本质区别，一个显著的标志是：循环可以继续的条件是 <code>while (left + 1 &lt; right):</code>，这说明在退出循环的时候，一定有 <code>left + 1 == right</code> 成立，也就是退出循环以后，区间有 2 个元素，即 <code>[left, right]</code>；</li><li>这种写法的优点是：不用理解上一个版本在分支出现 left &#x3D; mid 的时候中间数上取整的行为；</li><li>缺点是显而易见的：<ul><li><code>while (left + 1 &lt; right):</code> 写法相对于 <code>while (left &lt; right):</code> 和 <code>while (left &lt;= right):</code> 来说并不自然；</li><li>由于退出循环以后，区间一定有两个元素，需要思考哪一个元素才是需要找的，即「后处理」一定要做，有些时候还会有先考虑 <code>left</code> 还是 <code>right</code> 的区别。</li></ul></li></ul><p><strong>小结：</strong></p><ul><li>模板一：最好理解的版本，但是在刷题的过程中，需要处理一些边界的问题，一不小心容易出错；</li><li>模板二：强烈推荐掌握的版本，应先理解思想，再通过实际应用去体会这个模板的细节，熟练使用以后就会觉得非常自然；</li><li>模板三：可以认为是模板二的避免踩坑版本，只要深刻理解了模板二，模板三就不在话下。</li></ul><p> &#x3D;&#x3D;实际应用中，选择最好理解的版本即可。&#x3D;&#x3D;</p><p>这里有一个提示：模板二考虑的细节最少，可以用于解决一些相对复杂的问题。缺点是：学习成本较高，初学的时候比较容易陷入死循环，建议大家通过多多使用，并且尝试 debug，找到死循环的原因，进而掌握。</p><p>题解核心内容：所有模板都一样，不可以套模板，而应该<font color=#9900CC><strong>仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。一定要分析清楚题目的意思，分析清楚要找的答案需要满足什么性质。应该清楚模板具体的用法，明白需要根据题意灵活处理、需要变通的地方，不可以认为每一行代码都是模板规定死的写法，不可以盲目套用、死记硬背。</font></strong></p><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-二分求下标（在数组中查找符合条件的元素的下标）"><a href="#2-1-二分求下标（在数组中查找符合条件的元素的下标）" class="headerlink" title="2.1 二分求下标（在数组中查找符合条件的元素的下标）"></a>2.1 二分求下标（在数组中查找符合条件的元素的下标）</h3><p><strong>题库列表</strong></p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>704</td><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank">二分查找</a>（简单）</td></tr><tr><td>35</td><td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank">搜索插入位置</a>（简单）</td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank">最长上升子序列</a>（中等）</td></tr><tr><td>34</td><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank">在排序数组中查找元素的第一个和最后一个位置</a>（简单）</td></tr><tr><td>611</td><td><a href="https://leetcode-cn.com/problems/valid-triangle-number/" target="_blank">有效三角形的个数</a></td></tr><tr><td>436</td><td><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank">寻找右区间</a>（中等）</td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank">寻找两个有序数组的中位数</a>（困难）</td></tr></tbody></table><h3 id="2-2-完全有序"><a href="#2-2-完全有序" class="headerlink" title="2.2 完全有序"></a>2.2 完全有序</h3><p><strong>704. 二分查找</strong><br>题目描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lower_bound 返回最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class="line"><span class="comment"># 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span></span><br><span class="line"><span class="comment"># 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 闭区间 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left-1] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right+1] &gt;= target</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>      <span class="comment"># 范围缩小到 [mid+1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span>     <span class="comment"># 范围缩小到 [left, mid-1]</span></span><br><span class="line">    <span class="keyword">return</span> left                 <span class="comment"># 或者 right+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左闭右开区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound2</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 左闭右开区间 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left-1] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right] &gt;= target</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 范围缩小到 [mid+1, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 范围缩小到 [left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 或者 right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound3</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 开区间 (left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right] &gt;= target</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid  <span class="comment"># 范围缩小到 (mid, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 范围缩小到 (left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> right  <span class="comment"># 或者 left+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = lower_bound(nums, target)  <span class="comment"># 选择其中一种写法即可</span></span><br><span class="line">        <span class="keyword">return</span> i <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.47omstlu8nc0.gif#pic_center" width = 64%><p><strong>35. 搜索插入位置</strong></p><p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.3nhyvtn9ruw0.gif#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)          <span class="comment"># 采用左闭右开区间[left,right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:                 <span class="comment"># 右开所以不能有=,区间不存在</span></span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span>  <span class="comment"># 防止溢出, //表示整除</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:          <span class="comment"># 中点小于目标值,在右侧,可以得到相等位置</span></span><br><span class="line">                left = mid + <span class="number">1</span>              <span class="comment"># 左闭, 所以要+1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid                 <span class="comment"># 右开, 真正右端点为mid-1</span></span><br><span class="line">        <span class="keyword">return</span> left                         <span class="comment"># 此算法结束时保证left = right, 返回谁都一样</span></span><br></pre></td></tr></table></figure><p><strong>300. 最长上升子序列</strong><br>题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>1. 动态规划 + 二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dynamic programming + Dichotomy.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tails, res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            i, j = <span class="number">0</span>, res</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tails[m] &lt; num: </span><br><span class="line">                    i = m + <span class="number">1</span>           <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    j = m</span><br><span class="line">            tails[i] = num</span><br><span class="line">            <span class="keyword">if</span> j == res: </span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.1xoae36xmhc0.gif#pic_center" width = 48%><p><strong>2. 动态规划</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]: <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.e4s3129neio.gif#pic_center" width = 48%><p><strong>34. 在排序数组中查找元素的第一个和最后一个位置</strong></p><p>题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> target <span class="keyword">not</span> <span class="keyword">in</span> nums:          <span class="comment"># 特例，二分查找失败</span></span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [self.lower_bound(nums, target), self.upper_bound(nums, target)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">upper_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):    <span class="comment"># 寻找上边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:     <span class="comment"># 移动左指针</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 移动右指针</span></span><br><span class="line">                right = mid -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):    <span class="comment"># 寻找下边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:         <span class="comment"># 当nums[mid]大于等于目标值时，继续在左区间检索，找到第一个数</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:           <span class="comment"># nums[mid]小于目标值时，则在右区间继续检索，找到第一个等于目标值的数</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.7fkctqmkt4w0.gif#pic_center" width = 48%><p><strong>611. 有效三角形的个数</strong><br>题目描述：给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。</p><p>将数组 nums 进行升序排序，随后使用二重循环枚举 a 和 b。设 $a&#x3D;nums[i], b&#x3D;nums[j]$，为了防止重复统计答案，我们需要保证 $i&lt;j$。剩余的边 c 需要满足 $c&lt;nums[i]+nums[j]$，我们可以在 $[j+1,n−1]$ 的下标范围内使用二分查找（其中 $n$ 是数组 nums 的长度），找出最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标 $k$，这样一来，在 $[j+1, k]$ 范围内的下标都可以作为边 $c$ 的下标，我们将该范围的长度 $k−j$ 累加入答案。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.1j77tet7j800.webp#pic_center" width = 45%><p><strong>1. 排序+二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                left, right = j+<span class="number">1</span>, length              </span><br><span class="line">                <span class="keyword">while</span> left &lt; right:             <span class="comment"># 找边界，</span></span><br><span class="line">                    mid = (left + right)//<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> nums[mid] &lt; nums[i] + nums[j]:</span><br><span class="line">                        left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right = mid</span><br><span class="line">                ans += left - <span class="number">1</span> - j</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>2. 排序+双指针</strong></p><p>我们将当 $a&#x3D;nums[i], b&#x3D;nums[j]$ 时，最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标 $k$ 记为 $k_{i,j}$。可以发现，如果我们固定 $i$，那么随着 $j$ 的递增，不等式右侧 $nums[i]+nums[j]$ 也是递增的，因此 $k_{i,j}$ 也是递增的。</p><p>这样一来，我们就可以将 $j$ 和 $k$ 看成两个同向（递增）移动的指针，将方法一进行如下的优化：</p><ul><li>我们使用一重循环枚举 $i$。当 $i$ 固定时，我们使用双指针同时维护 $j$ 和 $k$，它们的初始值均为 $i$；</li><li>我们每一次将 $j$ 向右移动一个位置，即 $j←j+1$，并尝试不断向右移动 $k$，使得 $k$ 是最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标。我们将 $max(k−j, 0)$ 累加入答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            k = i + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                <span class="keyword">while</span> k+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[i] + nums[j] &gt; nums[k+<span class="number">1</span>]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ans += <span class="built_in">max</span>(k-j, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>436. 寻找右区间</strong><br>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4vfedl22glc0.webp#pic_center" width = 64%></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.24c1qurj96ww.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRightInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start_map = &#123;interval[<span class="number">0</span>] : i <span class="keyword">for</span> i, interval <span class="keyword">in</span> <span class="built_in">enumerate</span>(intervals)&#125;       <span class="comment"># 以区间左侧构建索引字典</span></span><br><span class="line">        starts = [interval[<span class="number">0</span>] <span class="keyword">for</span> interval <span class="keyword">in</span> intervals]                            <span class="comment"># 取出区间的左侧</span></span><br><span class="line">        res = []</span><br><span class="line">        starts.sort()</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            pos = self.higher_find(starts, interval[<span class="number">1</span>])                             <span class="comment"># 遍历每个区间的右侧，在所有区间的左侧进行二分查找</span></span><br><span class="line">            res.append(start_map[starts[pos]] <span class="keyword">if</span> pos != -<span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">higher_find</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)              <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[left] &gt;= target:    <span class="comment"># 最后判断一下，是否满足条件</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.3zi4l9anjzo0.gif#pic_center" width = 48%><p><strong>4. 寻找两个正序数组的中位数</strong></p><p>题目描述：给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 $O(log (m+n))$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getKthElement</span>(<span class="params">k</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            - 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="string">            - 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="string">            - nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="string">            - nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="string">            - 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="string">            - 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="string">            - 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="string">            - 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="string">            - 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            </span><br><span class="line">            index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> index1 == m:</span><br><span class="line">                    <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> index2 == n:</span><br><span class="line">                    <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 正常情况</span></span><br><span class="line">                newIndex1 = <span class="built_in">min</span>(index1 + k // <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>)</span><br><span class="line">                newIndex2 = <span class="built_in">min</span>(index2 + k // <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">                <span class="keyword">if</span> pivot1 &lt;= pivot2:</span><br><span class="line">                    k -= newIndex1 - index1 + <span class="number">1</span></span><br><span class="line">                    index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= newIndex2 - index2 + <span class="number">1</span></span><br><span class="line">                    index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        totalLength = m + n</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> getKthElement((totalLength + <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(totalLength // <span class="number">2</span>) + getKthElement(totalLength // <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.2oxogh32hg80.webp#pic_center" width = 48%><h3 id="2-3-不完全有序"><a href="#2-3-不完全有序" class="headerlink" title="2.3 不完全有序"></a>2.3 不完全有序</h3><p><strong>题库列表：</strong></p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>33</td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank">搜索旋转排序数组</a>（中等）</td></tr><tr><td>81</td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank">搜索旋转排序数组 II</a>（中等）</td></tr><tr><td>153</td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank">寻找旋转排序数组中的最小值</a>（中等）</td></tr><tr><td>154</td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank">寻找旋转排序数组中的最小值 II</a>（困难）</td></tr><tr><td>852</td><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank">山脉数组的峰顶索引</a>（简单）</td></tr><tr><td>1095</td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank">山脉数组中查找目标值</a>（中等）</td></tr></tbody></table><p><strong>33. 搜索旋转排序数组</strong></p><p>题目描述：整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 $k(0 &lt;&#x3D; k &lt; nums.length)$ 上进行了旋转，使数组变为 $[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]$（下标从0开始计数）。例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:                        <span class="comment"># 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:           <span class="comment"># target 在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                                           <span class="comment"># 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]: <span class="comment"># target 在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.qtcvkzfq8u8.webp#pic_center" width = 48%><p><strong>81. 搜索旋转排序数组 II</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.7guqdqr87o80.webp#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[left]:         <span class="comment"># 去重</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:        <span class="comment"># 左半部分有序，在左侧二分查找</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment"># 右半部分有序，在右侧二分查找</span></span><br><span class="line">                <span class="keyword">if</span>  nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>153. 寻找旋转排序数组中的最小值</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.4356lavtjeq0.webp#pic_center" width = 75%><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.2auzerg0b7fo.webp#pic_left" width = "45%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.3bntek4m9bu0.webp#pic_left"  width = "45%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:    </span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[pivot] &lt; nums[high]:</span><br><span class="line">                high = pivot </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure><p><strong>154. 寻找旋转排序数组中的最小值 II</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.5nj47nf02sw0.webp#pic_center" width = 75%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left+right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span>              <span class="comment"># 去重</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.zrj5dh2d3rk.gif#pic_center" width = 36%><p><strong>852. 山脉数组的峰顶索引（简单）</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.728jhdo84ho0.webp#pic_center" width = 75%><p><strong>1. 顺序查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peakIndexInMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 顺序查找最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p><strong>2. 二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peakIndexInMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 二分查找最大值</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &gt; arr[mid + <span class="number">1</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>1095. 山脉数组中查找目标值</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.309t987j7680.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findInMountainArray</span>(<span class="params">self, target: <span class="built_in">int</span>, mountain_arr: <span class="string">&#x27;MountainArray&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        先使用二分法找到数组的峰值。</span></span><br><span class="line"><span class="string">        在峰值左边使用二分法寻找目标值。</span></span><br><span class="line"><span class="string">        如果峰值左边没有目标值，那么使用二分法在峰值右边寻找目标值。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        head, tail = <span class="number">0</span>, mountain_arr.length()-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:             <span class="comment"># 找峰值，注意越界处理</span></span><br><span class="line">            mid = (head+tail)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; mountain_arr.get(mid+<span class="number">1</span>):</span><br><span class="line">                head = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tail = mid</span><br><span class="line">        peak = head</span><br><span class="line">        ans = self.binarySearch(mountain_arr, target, <span class="number">0</span>, peak)                                              <span class="comment"># 在左半边搜索</span></span><br><span class="line">        <span class="keyword">if</span> ans != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(mountain_arr, target, peak+<span class="number">1</span>, mountain_arr.length()-<span class="number">1</span>, <span class="keyword">lambda</span> x:-x)        <span class="comment"># 在右半边搜索</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">self, mountain, target, left, right, key=<span class="keyword">lambda</span> x: x</span>): </span><br><span class="line">        target = key(target)                            <span class="comment"># 这里的key相当于把两边全部转为升序部分，也可以用target*reverse，根据reverse的正负来判断</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            curr = key(mountain.get(mid))</span><br><span class="line">            <span class="keyword">if</span> curr == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> curr &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-4-二分答案（在一个有范围的区间里搜索一个整数）"><a href="#2-4-二分答案（在一个有范围的区间里搜索一个整数）" class="headerlink" title="2.4 二分答案（在一个有范围的区间里搜索一个整数）"></a>2.4 二分答案（在一个有范围的区间里搜索一个整数）</h3><p>如果题目要我们找一个整数，这个整数有确定的范围，可以通过二分查找逐渐缩小范围，最后逼近到一个数。</p><p>定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。</p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>69</td><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank">x 的平方根</a>（简单）</td></tr><tr><td>287</td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank">寻找重复数</a>（中等）</td></tr><tr><td>374</td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank">猜数字大小</a>（简单）</td></tr></tbody></table><p><strong>69. x 的平方根</strong></p><p>题目描述：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right= <span class="number">0</span>, x//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> left-<span class="number">1</span>          </span><br></pre></td></tr></table></figure><p><strong>287. 寻找重复数</strong></p><p>题目描述：给定一个包含 $n+1$ 个整数的数组 nums ，其数字都在 $[1, n]$ 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数。你设计的解决方案必须 不修改 数组 nums 且只用常量级 $O(1)$ 的额外空间。</p><p><strong>1. 二分法</strong></p><p>设数组长度为nnn，则数组中元素 $\in[1, n-1]$，且只有一个重复元素。一个直观的想法，设一个数字 $k\in[1,n-1]$，统计数组中小于等于 $k$ 的数字的个数 count：</p><ul><li>若 $count&lt;&#x3D;k$，说明重复数字一定在 $(k,n−1]$ 的范围内。</li><li>若 $count&gt;k$，说明重复数字一定在 $[0,k]$ 的范围内。<br>利用这个性质，我们使用二分查找逐渐缩小重复数字所在的范围。</li></ul><ol><li>初试化左右 数字 边界 $left&#x3D;1, right&#x3D;n-1$</li><li>循环条件 $left&lt;right:$<ul><li>$mid&#x3D;(left+right)&#x2F;&#x2F;2$</li><li>按照性质，统计数组中小于等于 $mid$ 的元素个数 $count$</li><li>若 $count&lt;&#x3D;mid$，说明重复数字一定在 $(mid,right]$ 的范围内。令 $left&#x3D;mid+1$</li><li>若 $count&gt;mid$，说明重复数字一定在 $[left,mid]$ 的范围内。令 $right&#x3D;mid$。</li></ul></li><li>返回 $left$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=mid):</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(count&lt;=mid):</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>2. 快慢指针</strong></p><p>分为两步：</p><ol><li>找到环</li><li>找到环的入口（即重复元素）</li></ol><p>找环：</p><ol><li>定义快慢指针 $slow&#x3D;0, fast&#x3D;0$</li><li>进入循环：<br> - $slow$ 每次走一步，即 $slow&#x3D;nums[slow]$<br> - $fast$ 每次走两步，即 $fast&#x3D;nums[nums[fast]]$<br> - 当 $slow&#x3D;&#x3D;fast$时，退出循环。 当快慢指针相遇时，一定在环内。此时假设slow 走了 $k$ 步，则 fast 走了 $2k$ 步。设环的周长为 $c$，则 $k%c&#x3D;&#x3D;0$。</li></ol><p>找环的入口：</p><ol><li>定义新的指针 $find&#x3D;0$</li><li>进入循环：<ul><li>find 每次走一步，即 $find&#x3D;nums[find]$</li><li>slow每次走一步，即 $slow&#x3D;nums[slow]$</li><li>当两指针相遇时，即 $find&#x3D;&#x3D;slow$，返回 find</li></ul></li></ol><p>为何相遇时，找到的就是入口： 假设起点到环的入口(重复元素)，需要 $m$ 步。此时 slow 走了 $n+m$ 步，其中 $n$ 是环的周长 $c$ 的整数倍，所以相当于 slow走了 $m$ 步到达入口，再走了 $n$ 步。所以相遇时一定是环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow=<span class="number">0</span></span><br><span class="line">        fast=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            slow=nums[slow]</span><br><span class="line">            fast=nums[nums[fast]]</span><br><span class="line">            <span class="keyword">if</span>(slow==fast):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        find=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            find=nums[find]</span><br><span class="line">            slow=nums[slow]</span><br><span class="line">            <span class="keyword">if</span>(find==slow):</span><br><span class="line">                <span class="keyword">return</span> find</span><br></pre></td></tr></table></figure><p><strong>374. 猜数字大小</strong></p><p>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.6x7yhtzgw4g0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The guess API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param num, your guess</span></span><br><span class="line"><span class="comment"># @return -1 if num is higher than the picked number</span></span><br><span class="line"><span class="comment">#          1 if num is lower than the picked number</span></span><br><span class="line"><span class="comment">#          otherwise return 0</span></span><br><span class="line"><span class="comment"># def guess(num: int) -&gt; int:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">guessNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + ((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            temp = guess(mid)</span><br><span class="line">            <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> temp == <span class="number">1</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.p6o8es6da34.webp#pic_center" width = 64%><hr><blockquote><p><font color=#9900CC><strong>二分法暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.6rf3tza12s0.gif#pic_center" width = 48%><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>二分查找算法：<a href="https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README">https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README</a></li><li>二分算法：<a href="https://oi-wiki.org/basic/binary/">https://oi-wiki.org/basic/binary/</a></li><li>二分查找：<a href="https://www.cnblogs.com/jasonbourne3/p/17141780.html">https://www.cnblogs.com/jasonbourne3/p/17141780.html</a></li><li>算法与数据结构（七）：二分查找法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/94332149">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;94332149</a></li><li>一文带你搞定二分查找及其多个变种：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/</a></li><li>写对二分查找不是套模板并往里面填空，需要仔细分析题意：<a href="https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></li><li>二分查找（折半查找）算法详解：<a href="http://data.biancheng.net/view/336.html">http://data.biancheng.net/view/336.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码和常见的解题技巧，带大家学透二分算法&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="二分答案" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
    <category term="有序数组" scheme="https://qxienote.com/tags/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    
    <category term="旋转数组" scheme="https://qxienote.com/tags/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    
    <category term="山脉数组" scheme="https://qxienote.com/tags/%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（四）-- 滑动窗口算法</title>
    <link href="https://qxienote.com/article/f08fb2ff.html"/>
    <id>https://qxienote.com/article/f08fb2ff.html</id>
    <published>2023-06-11T03:07:57.000Z</published>
    <updated>2023-06-11T03:43:10.309Z</updated>
    
    <content type="html"><![CDATA[<p>本篇带你走进滑动窗口算法，进一步强化双指针的使用，  滑动窗口算法常用于字符串匹配问题和子数组问题，本篇就总结出来Python的编写模板，从此刷题不心慌！</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。</p><h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1 滑动窗口"></a>1 滑动窗口</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>在计算机网络里经常用到滑动窗口协议（Sliding Window Protocol），该协议是 TCP协议 的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。</p><p>滑动窗口算法其实和这个是一样的，只是用的地方场景不一样，可以根据需要调整窗口的大小，有时也可以是固定窗口大小。</p><p>滑动窗口使用双指针解决问题，所以一般也叫双指针算法，因为两个指针间形成一个窗口。双指针也并不局限在数组问题，像链表场景的 “快慢指针” 也属于双指针的场景，其快慢指针滑动过程中本身就会产生一个窗口，比如当窗口收缩到某种程度，可以得到一些结论。</p><p><font color=#9900CC><strong>什么情况适合用滑动窗口算法呢？</font></strong></p><ul><li>需要输出或比较的结果在原数据结构中是连续排列的，特别是数组或链表问题；</li><li>每次窗口滑动时，只需观察窗口两端元素的变化，无论窗口多长，每次只操作两个头尾元素，当用到的窗口比较长时，可以显著减少操作次数；</li><li>窗口内元素的整体性比较强，窗口滑动可以只通过操作头尾两个位置的变化实现，但对比结果时往往要用到窗口中所有元素。</li></ul><p>滑动窗口算法常用于字符串匹配问题和子数组问题。</p><blockquote><p>滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来<font color=#9900CC><strong>滑动窗口主要应用在数组和字符串上。</strong></font></p></blockquote><h3 id="1-2-滑动窗口法的大体框架"><a href="#1-2-滑动窗口法的大体框架" class="headerlink" title="1.2 滑动窗口法的大体框架"></a>1.2 滑动窗口法的大体框架</h3><p>在介绍滑动窗口的框架时候，大家先从字面理解下：</p><ul><li>滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。</li><li>窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</li></ul><p>为了便于理解，这里采用的是字符串来讲解。但是对于数组其实也是一样的。<strong>滑动窗口算法的思路是这样：</strong></p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left &#x3D; right &#x3D; 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</li><li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol><p>这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><h3 id="1-3-滑动窗口模板"><a href="#1-3-滑动窗口模板" class="headerlink" title="1.3 滑动窗口模板"></a>1.3 滑动窗口模板</h3><p><strong>滑窗模板 Python 伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">problemName</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line">        x, y = ..., ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">            x = new_x</span><br><span class="line">            <span class="keyword">if</span> condition:</span><br><span class="line">                y = new_y</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            ------------- 下面是两种情况，读者请根据题意二选1 -------------</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># Step 4 - 情况1</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 </span></span><br><span class="line">            <span class="comment"># 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, </span></span><br><span class="line">            <span class="comment"># 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span> 窗口长度达到了限定长度:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 - 情况2</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span> 不合法:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针(end)作为驱动，拖着左指针(start)向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote><ul><li><p><a href="https://leetcode.cn/problems/maximum-average-subarray-i/" target="_blank">643. 子数组最大平均数 I</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-erasure-value/" target="_blank">1695. 删除子数组的最大得分</a></p></li><li><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank">438. 找到字符串中所有字母异位词</a></p></li><li><p><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></p></li><li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-ii/" target="_blank">487. 最大连续1的个数 II</a></p></li><li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/" target="_blank">1004. 最大连续1的个数 III</a></p></li><li><p><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/" target="_blank">1208. 尽可能使字符串相等</a></p></li><li><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/" target="_blank">1052. 爱生气的书店老板</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/" target="_blank">1151. 最少交换次数来组合所有的1 Π</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></p></li><li><p><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></p></li></ul></blockquote> <h3 id="2-2-真题演练"><a href="#2-2-真题演练" class="headerlink" title="2.2 真题演练"></a>2.2 真题演练</h3><p><strong>643. 子数组最大平均数 I</strong><br>题目描述：给你一个由 n 个元素组成的整数数组 nums 和一个整数 k。请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本题求最大平均值 (其实就是求最大和)，所以需要定义sum_sub_array, 同时定义一个max_value (初始值为负无穷)</span></span><br><span class="line">        sum_sub_array, max_value = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (sum_sub_array, max_value), 不断把当前值积累到sum_sub_array上</span></span><br><span class="line">            sum_sub_array += num</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_value = <span class="built_in">max</span>(max_value, sum_sub_array)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口首指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= k - <span class="number">1</span>:</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_value/k</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.25s1cl9rnrxc.gif#pic_center" width = 48%><p><strong>3. 无重复字符的最长子串</strong></p><p>题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hash_map = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度</span></span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hash_map) == end - start + <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hash_map):</span><br><span class="line">                head = s[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hash_map[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hash_map[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.1zysuq1eegbk.gif#pic_center" width = 48%><p><strong>159. 至多包含两个不同字符的最长子串</strong></p><p>题目描述：给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringTwoDistinct</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题求最大长度，所以需要定义max_len,</span></span><br><span class="line">        <span class="comment"># 该题又涉及计算不重复元素个数，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># 首先，把当前元素的计数加一</span></span><br><span class="line">            <span class="comment"># 一旦哈希表长度小于等于2(之多包含2个不同元素)，尝试更新最大长度</span></span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) &lt;= <span class="number">2</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表长度大于2的时候 (说明存在至少3个重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(hashmap) &gt; <span class="number">2</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><strong>209. 长度最小的子数组</strong></p><p>题目描述：给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 $[nums_l, nums_{l+1}, …, nums_{r-1}, nums_r]$，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量</span></span><br><span class="line">        min_len, sum_sub_array = math.inf, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (min_len, sum_sub_array)</span></span><br><span class="line">            sum_sub_array += num</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这一段可以删除，因为下面的while已经handle了这一块儿逻辑，不过写在这也没影响</span></span><br><span class="line">            <span class="keyword">if</span> sum_sub_array &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 这一题这里稍微有一点特别: sum_sub_array &gt;= target其实是合法的，但由于我们要求的是最小长度，</span></span><br><span class="line">            <span class="comment"># 所以当sum_sub_array已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案</span></span><br><span class="line">            <span class="comment"># 由于左指针的移动可能影响min_len和sum_sub_array的值，因此需要在移动前将它们更新</span></span><br><span class="line">            <span class="keyword">while</span> sum_sub_array &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5：返回答案 (最小长度)</span></span><br><span class="line">        <span class="keyword">if</span> min_len == math.inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.7089o47r9v00.gif#pic_center" width = 48%><p><strong>1695. 删除子数组的最大得分</strong></p><p>题目描述：给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和。返回 只删除一个 子数组可获得的 最大得分。如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumUniqueSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题最大得分，所以需要定义当前得分sum_sub_array和最大得分max_sum</span></span><br><span class="line">        <span class="comment"># 本题又涉及去重 (题目规定子数组不能有重复)，因此还需要一个哈希表</span></span><br><span class="line">        sum_sub_array, max_sum, hashmap = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array, hashmap)</span></span><br><span class="line">            <span class="comment"># sum和hashmap需要更新就不说了，max_sum当且仅当哈希表里面没有重复元素时 (end - start + 1 == len(hashmap)) 更新</span></span><br><span class="line">            sum_sub_array += tail</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == <span class="built_in">len</span>(hashmap):</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, sum_sub_array)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表里面有重复元素时 (end - start + 1 &gt; len(hashmap)) 窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap， sum_sub_array)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hashmap):</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><p><strong>438. 找到字符串中所有字母异位词</strong></p><p>题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本文需要对比两组字符串是否为异位词，所以用哈希表 (abc和bac是异位词是因为他们对应的哈希表相等)</span></span><br><span class="line">        <span class="comment"># 同时我们需要找到所有合法解，所以还需要一个ans数组</span></span><br><span class="line">        ans, hashmap_s = [], &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1： 同时把p的哈希表也建立了 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hashmap_p = Counter(p)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hashmap)， 如果hashmap == hashmap_p，代表找到了一个解，加入到ans</span></span><br><span class="line">            hashmap_s[tail] = hashmap_s.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap_s == hashmap_p:</span><br><span class="line">                ans.append(start)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(p) - <span class="number">1</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap_s[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap_s[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap_s[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.13gnl7q09urg.webp#pic_center" width = 36%><p><strong>567. 字符串的排列</strong></p><p>题目描述：给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为和排列相关 (元素相同，顺序可以不同)，使用哈希表</span></span><br><span class="line">        hash_map_s2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1: 同时建立s1的哈希表 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hash_map_s1 = Counter(s1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s2):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hash_map_s2)， 如果hash_map_s1 == hash_map_s2，代表s2包含s1的排列，直接return</span></span><br><span class="line">            hash_map_s2[tail] = hash_map_s2.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map_s1 == hash_map_s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hash_map_s2)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(s1) - <span class="number">1</span>:</span><br><span class="line">                head = s2[start]</span><br><span class="line">                hash_map_s2[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hash_map_s2[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hash_map_s2[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5： 没有在s2中找到s1的排列，返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.6alyfc9r05s0.gif#pic_center" width = 48%><p><strong>487. 最大连续1的个数 II</strong></p><p>题目描述：给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计数 (0的个数不能超过1个)，所以还要一个哈希表</span></span><br><span class="line">        max_len, hash_map = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hash_map， max_len)</span></span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当hash_map里面0的个数大于1的时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hash_map)</span></span><br><span class="line">            <span class="keyword">while</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">1</span>:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><strong>1004. 最大连续1的个数 III</strong><br>题目描述：给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len, start = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= k:     <span class="comment"># 相比较于上一题，只需要把1改成k</span></span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end-start+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &gt; k:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.351qb5gxbne0.gif#pic_center" width = 48%><p><strong>1208. 尽可能使字符串相等</strong><br>题目描述：给你两个长度相同的字符串，s 和 t。将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, max_cost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计算开销 (和求和一个道理)， 所以还要一个cur_cost</span></span><br><span class="line">        cur_cost, max_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (cur_cost)</span></span><br><span class="line">            <span class="comment"># 每一对字符的order差值就是当前时间点的开销，直接累积在cur_cost上即可</span></span><br><span class="line">            <span class="comment"># cur_cost只要不超过最大开销，就更新max_len</span></span><br><span class="line">            cur_cost += <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[end]) - <span class="built_in">ord</span>(t[end]))</span><br><span class="line">            <span class="keyword">if</span> cur_cost &lt;= max_cost:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当cur_cost大于最大开销时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法 (cur_cost &lt;= max_cost)</span></span><br><span class="line">            <span class="keyword">while</span> cur_cost &gt; max_cost:</span><br><span class="line">                cur_cost -= <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[start])-  <span class="built_in">ord</span>(t[start]))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.3j0vqxe6f6g0.gif#pic_center" width = 48%><p><strong>1052. 爱生气的书店老板</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.6xm4xkuf5qg0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量,</span></span><br><span class="line">        <span class="comment"># 因为涉及求和所以定义sum_sub_array和max_sum, 同时需要知道老板什么时候&#x27;发动技能&#x27;，再定义一个max_start</span></span><br><span class="line">        sum_sub_array, max_sum, max_start = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(customers):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            <span class="comment"># 注意：这里只要当老板在当前时间点会发脾气的时候才维护</span></span><br><span class="line">            <span class="comment"># sum_sub_array就不说了，和前面N道题的维护方法一样，新多出来的max_start也就是记录一样时间点而已，没什么fancy的</span></span><br><span class="line">            <span class="keyword">if</span> grumpy[end] == <span class="number">1</span>:</span><br><span class="line">                sum_sub_array += tail</span><br><span class="line">            <span class="keyword">if</span> sum_sub_array &gt; max_sum:</span><br><span class="line">                max_sum = sum_sub_array</span><br><span class="line">                max_start = start</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (老板技能持续时间固定)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_sub_array, max_avg)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= minutes - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> grumpy[start]:</span><br><span class="line">                    sum_sub_array -= customers[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里对比其他题目多了一小步: 在找到老板发动技能的最大收益时间点(max_start)后</span></span><br><span class="line">        <span class="comment"># 需要把受技能影响时间段中的grumpy全部置0 - 代表老板成功压制了自己的怒火</span></span><br><span class="line">        grumpy[max_start:max_start+minutes] = [<span class="number">0</span>] * minutes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 再遍历一遍数组求customer总数量并且返回结果   </span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> customer, grum <span class="keyword">in</span> <span class="built_in">zip</span>(customers, grumpy):</span><br><span class="line">            <span class="keyword">if</span> grum == <span class="number">0</span>:</span><br><span class="line">                res += customer</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.3wf994p63sc0.gif#pic_center" width = 48%><p><strong>1423. 可获得的最大点数</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.3wwhkrlmfzo0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 这题相比前面的题目加了一丢丢小的变通: 题目要求首尾串最大点数，其实就是求非首尾串的连续序列的最小点数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxScore</span>(<span class="params">self, cardPoints: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，因为涉及求和所以定义sum_sub_array和min_sum</span></span><br><span class="line">        sum_sub_array, min_sum = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(cardPoints):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            sum_sub_array += tail</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cardPoints)-k == end - start + <span class="number">1</span>:</span><br><span class="line">                min_sum = <span class="built_in">min</span>(min_sum, sum_sub_array)</span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (min_sum， sum_sub_array)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(cardPoints) - k - <span class="number">1</span>:</span><br><span class="line">                sum_sub_array -= cardPoints[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (总点数减去非首尾串的连续序列的最小点数就可以得到首尾串的最大点数)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cardPoints) - min_sum <span class="keyword">if</span> min_sum != inf <span class="keyword">else</span> <span class="built_in">sum</span>(cardPoints)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.6ahf0vp2uk4.gif#pic_center" width = 36%><p><strong>1151. 最少交换次数来组合所有的1 Π</strong></p><p>题目描述：给出一个二进制数组data，你需要通过交换位置，将数组中任何位置上的1组合到一起，并返回所有可能中所需最少的交换次数。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.7k6gqpmoa5s0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSwaps</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先数出一共有多少个1，输出来的个数就是窗口的长度</span></span><br><span class="line">        num_ones = data.count(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，求最小swap次数其实就是求窗口中0个数的最小值，因此定义num_zeros, min_num_zeros</span></span><br><span class="line">        num_zeros, min_num_zeros = <span class="number">0</span>, math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (num_zeros， min_num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> data[end] == <span class="number">0</span>:</span><br><span class="line">                num_zeros += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == num_ones:</span><br><span class="line">                min_num_zeros = <span class="built_in">min</span>(min_num_zeros, num_zeros)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (数组1的总个数)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= num_ones - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> data[start] == <span class="number">0</span>:</span><br><span class="line">                    num_zeros -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (如果min_num_zeros依旧是math.inf说明数组没有1存在，不能swap，返回0即可)</span></span><br><span class="line">        <span class="keyword">return</span> min_num_zeros <span class="keyword">if</span> min_num_zeros != math.inf <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>76. 最小覆盖子串</strong></p><p>题目描述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        need_dict = Counter(t)                      <span class="comment"># 哈希表：记录需要匹配到的各个元素的数目</span></span><br><span class="line">        need_count = <span class="built_in">len</span>(t)                         <span class="comment"># 记录需要匹配到的字符总数(need=0表示匹配到了)</span></span><br><span class="line">        left = <span class="number">0</span>                                    <span class="comment"># 窗口的左边界</span></span><br><span class="line">        res = (<span class="number">0</span>, inf)                              <span class="comment"># 记录目标子串 s[res[0], res[1]+1] 的起始和结尾</span></span><br><span class="line">        <span class="keyword">for</span> right, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):             <span class="comment"># 窗口右边界右移一位，窗口中增加的字符 tail</span></span><br><span class="line">            <span class="keyword">if</span> tail <span class="keyword">in</span> need_dict:                    <span class="comment"># 窗口新加入的字符位于t中</span></span><br><span class="line">                <span class="keyword">if</span> need_dict[tail] &gt; <span class="number">0</span>:              <span class="comment"># 对当前字符还有需求</span></span><br><span class="line">                    need_count -= <span class="number">1</span>                 <span class="comment"># 此时新加入窗口中的 tail 对 need_count 有影响</span></span><br><span class="line">                need_dict[tail] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> need_count == <span class="number">0</span>:                  <span class="comment"># 窗口左边界持续右移，need_count=0，当前窗口完全覆盖了 t</span></span><br><span class="line">                <span class="keyword">if</span> res[<span class="number">1</span>] - res[<span class="number">0</span>] &gt; right - left:  <span class="comment"># 出现了更短的字符串</span></span><br><span class="line">                    res = (left, right)</span><br><span class="line">                head = s[left]                       <span class="comment"># 窗口中要滑出的字符 head</span></span><br><span class="line">                <span class="keyword">if</span> head <span class="keyword">in</span> need_dict:                <span class="comment"># 刚滑出的字符 head 位于 t 中</span></span><br><span class="line">                    <span class="keyword">if</span> need_dict[head] &gt;= <span class="number">0</span>:         <span class="comment"># 对当前字符ch还有需求，或刚好无需求(其实此时只有=0的情况)</span></span><br><span class="line">                        need_count += <span class="number">1</span>             <span class="comment"># 此时滑出窗口的 head 会对 need_count 有影响</span></span><br><span class="line">                    need_dict[head] += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span>                           <span class="comment"># 窗口左边界+1</span></span><br><span class="line">        <span class="keyword">return</span> s[res[<span class="number">0</span>]:res[<span class="number">1</span>]+<span class="number">1</span>] <span class="keyword">if</span> res[<span class="number">1</span>] &lt; <span class="built_in">len</span>(s) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.1kdghtlgzc5c.gif#pic_center" width = 48%><p><strong>239. 滑动窗口最大值</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.bz3b93ddmio.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 用双端队列来存储数组的下标，为什么要存下标而不是存数值？</span></span><br><span class="line">        <span class="comment"># 因为存下标可以更方便的来确定元素是否需要移出滑动窗口</span></span><br><span class="line">        <span class="comment"># 判断下标是否合法来确定是否要移出</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">if</span> k == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">max</span>(nums)]</span><br><span class="line">        result, queue = [], deque()             <span class="comment"># 使用collections内置的双端队列，加快运行速度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前队列最左侧存储的下标等于 i-k 的值，代表目前队列已满。</span></span><br><span class="line">            <span class="comment"># 但是新元素需要进来，所以列表最左侧的下标出队列</span></span><br><span class="line">            <span class="keyword">if</span> queue <span class="keyword">and</span> queue[<span class="number">0</span>] == i - k:           </span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[queue[-<span class="number">1</span>]] &lt; nums[i]:      <span class="comment"># 对于新进入的元素，如果队列前面的数比它小，那么前面的都出队列</span></span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)         <span class="comment"># 新元素入队列</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:            <span class="comment"># 当前的大值加入到结果数组中</span></span><br><span class="line">                result.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>滑动窗口暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.4ql491awvt00.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>双指针套路总结：<a href="https://zhuanlan.zhihu.com/p/95747836">https://zhuanlan.zhihu.com/p/95747836</a></li><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>算法与数据结构（一）：滑动窗口法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/89066140">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;89066140</a></li><li>滑动窗口法python模板写法：<a href="https://blog.csdn.net/weixin_44414948/article/details/113862173">https://blog.csdn.net/weixin_44414948&#x2F;article&#x2F;details&#x2F;113862173</a></li><li>滑动窗口的应用：<a href="https://leetcode.cn/problems/minimum-window-substring/solutions/1503454/by-flix-1kac/">https://leetcode.cn/problems/minimum-window-substring/solutions/1503454/by-flix-1kac/</a></li><li>秒杀12道中档题————滑动窗口：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇带你走进滑动窗口算法，进一步强化双指针的使用，  滑动窗口算法常用于字符串匹配问题和子数组问题，本篇就总结出来Python的编写模板，从此刷题不心慌！&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="https://qxienote.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="最小覆盖子串" scheme="https://qxienote.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    
    <category term="最小/最大数组" scheme="https://qxienote.com/tags/%E6%9C%80%E5%B0%8F-%E6%9C%80%E5%A4%A7%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python 文章汇总</title>
    <link href="https://qxienote.com/article/212a3cab.html"/>
    <id>https://qxienote.com/article/212a3cab.html</id>
    <published>2023-06-11T02:51:09.000Z</published>
    <updated>2023-06-11T03:05:04.479Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是对Python专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1 基础篇"></a>1 基础篇</h2><ul><li><a href="https://qxienote.com/article/175d115.html">Python基础篇（一）– 十分钟学会基础语法</a></li><li><a href="https://qxienote.com/article/8a42c3c2.html">Python基础篇（二）– 数据类型和运算符</a></li><li><a href="">Python基础篇（三）– 列表、元组、字典、集合、字符串</a></li><li><a href="">Python基础篇（四）– 流程控制</a></li><li><a href="">Python基础篇（五）– 函数和表达式</a></li><li><a href="">Python基础篇（六）– 类和对象</a></li><li><a href="">Python基础篇（七）– 迭代器和生成器</a></li><li><a href="">Python基础篇（八）– 文件操作</a></li><li><a href="">Python基础篇（九）– 正则表达式</a></li><li><a href="">Python基础篇（十）– 异常处理</a></li><li><a href="">Python基础篇（十一）– 模块和包</a></li><li><a href="">Python基础篇（十二）– 常用模块</a></li><li><a href="">Python基础篇（十三）– 进程和线程</a></li><li><a href="">Python基础篇（十四）– 数据类dataclass使用指南</a></li><li><a href="">Python基础篇（十五）– Pygame游戏编程</a></li><li><a href="">Python基础篇（十六）– Python标准库模块之heapq与bisect</a></li></ul><h2 id="2-进阶篇"><a href="#2-进阶篇" class="headerlink" title="2 进阶篇"></a>2 进阶篇</h2><ul><li><a href="">Python进阶篇（一）– Django快速上手</a></li><li><a href="">Python进阶篇（二）– Django 深入模型</a></li><li><a href=""></a></li></ul><h2 id="3-数据结构与算法"><a href="#3-数据结构与算法" class="headerlink" title="3 数据结构与算法"></a>3 数据结构与算法</h2><ul><li><a href="https://qxienote.com/article/d46e4964.html">Python数据结构与算法篇（一）– 算法分析基础</a></li><li><a href="https://qxienote.com/article/319c8c73.html">Python数据结构与算法篇（二）– 前缀和与差分数组</a></li><li><a href="https://qxienote.com/article/37ba44a4.html">Python数据结构与算法篇（三）– 快慢指针与碰撞指针</a></li><li><a href="">Python数据结构与算法篇（四）– 滑动窗口算法</a></li><li><a href="">Python数据结构与算法篇（五）– 二分查找与二分答案</a></li><li><a href="">Python数据结构与算法篇（六）– 哈希表</a></li><li><a href="">Python数据结构与算法篇（七）– 栈的实现与应用</a></li><li><a href="">Python数据结构与算法篇（八）– 队列的实现与应用</a></li><li><a href="">Python数据结构与算法篇（九）–单调栈与单调队列</a></li><li><a href="">Python数据结构与算法篇（十）– 链表的实现</a></li><li><a href="">Python数据结构与算法篇（十一）– 链表的应用与常见题型</a></li><li><a href="">Python数据结构与算法篇（十二）– 树和二叉树</a></li><li><a href="">Python数据结构与算法篇（十三）– 位运算与使用技巧</a></li><li><a href="">Python数据结构与算法篇（十四）– 冒泡排序算法</a></li><li><a href="">Python数据结构与算法篇（十五）– 二叉树的遍历：深度优先搜索与广度优先搜索</a></li></ul><h2 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4 数据分析"></a>4 数据分析</h2><ul><li><a href="">Python数据分析（一）– NumPy 学习笔记</a></li><li><a href="">Python数据分析（二）– Matplotlib 学习笔记</a></li><li><a href="">Python数据分析（三）– Matplotlib绘图进阶</a></li><li><a href=""></a></li></ul><h2 id="5-网络爬虫"><a href="#5-网络爬虫" class="headerlink" title="5 网络爬虫"></a>5 网络爬虫</h2><h2 id="6-PyQt5"><a href="#6-PyQt5" class="headerlink" title="6 PyQt5"></a>6 PyQt5</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章是对Python专栏下的文章进行汇总，方便系统地学习和复习。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（三）-- 快慢指针与碰撞指针</title>
    <link href="https://qxienote.com/article/37ba44a4.html"/>
    <id>https://qxienote.com/article/37ba44a4.html</id>
    <published>2023-06-11T02:08:00.000Z</published>
    <updated>2023-06-11T02:50:05.416Z</updated>
    
    <content type="html"><![CDATA[<p>数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。本篇主要分析双指针在字符串数组中常用解题套路。</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。</p><p>双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。</p><p>双指针是一种思想，一种技巧或一种方法，并不是什么特别具体的算法，在二分查找等算法中经常用到这个技巧。具体就是用两个变量动态存储两个或多个结点，来方便我们进行一些操作。通常用在线性的数据结构中，比如链表和数组，有时候也会用在图算法中。</p><p>在我们遇到像数组，链表这类数据结构的算法题目的时候，应该要想得到双指针的套路来解决问题。特别是链表类的题目，经常需要用到两个或多个指针配合来记忆链表上的节点，完成某些操作。链表这种数据结构也是树形结构和图的原型，所以有时候在关于图和树形结构的算法题目中也会用到双指针。</p><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1 双指针"></a>1 双指针</h2><p>双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（碰撞指针或者叫左右指针）的指针进行扫描，从而达到相应的目的。</p><p>换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。</p><h3 id="1-1-快慢指针"><a href="#1-1-快慢指针" class="headerlink" title="1.1 快慢指针"></a>1.1 快慢指针</h3><p>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和 慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。</p><p>利用快慢指针可以用来解决某些算法问题，比如：</p><ul><li>计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。</li><li>判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。</li><li>判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</li><li>求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了</li><li>求链表倒数第 k 个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第 k 个元素。（严格来说应该叫先后指针而非快慢指针）</li></ul><p>快慢指针在链表的详细使用，可以阅读下一篇文章——<a href="https://blog.csdn.net/xq151750111/article/details/129303127?spm=1001.2014.3001.5501">Python数据结构与算法篇（六）– 链表的应用</a></p><h3 id="1-2-碰撞指针"><a href="#1-2-碰撞指针" class="headerlink" title="1.2 碰撞指针"></a>1.2 碰撞指针</h3><p>对撞指针（或者称作左右指针）是指在数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。一般都是排好序的数组或链表，否则无序的话这两个指针的位置也没有什么意义。特别注意两个指针的循环条件在循环体中的变化，小心右指针跑到左指针左边去了。常用来解决的问题有：</p><ul><li>二分查找问题</li><li>n 数之和问题：比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数。如果是三数问题就转化为一个数和另外两个数的两数问题。以此类推。</li></ul><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-快慢指针"><a href="#2-1-快慢指针" class="headerlink" title="2.1 快慢指针"></a>2.1 快慢指针</h3><ul><li>掌握数组删除元素的直接覆盖操作</li><li>双指针法</li></ul><p><strong>题库列表：</strong></p><blockquote> <ul><li><p>26. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank">删除有序数组中的重复项</a> （快慢指针）</p><li><p>27. <a href="https://leetcode-cn.com/problems/remove-element" target="_blank">移除元素</a> （快慢指针）</p><li><p>80. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank">删除有序数组中的重复项 II</a> (快慢指针） </p></li><li><p>283. <a href="https://leetcode.cn/problems/move-zeroes/description/" target="_blank">移动零</a>（快慢指针）</p></li></ul></blockquote> <p><strong>26. 删除有序数组中的重复项</strong></p><p>题目描述：给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow += <span class="number">1</span>                   <span class="comment"># 每个元素只出现一次，先 slow+1 再覆盖</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.3ltlzaihk9e0.gif#pic_center" width = 48%><p><strong>27. 移除元素</strong></p><p>题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>1. 快慢指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 快慢指针</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:               <span class="comment"># 删除指定元素，直接覆盖掉</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.4140vjzuc040.gif#pic_center" width = 48%><p>这里和有序数组去重的解法有一个细节差异，我们这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><p><strong>2. 单指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;拷贝覆盖&#x27;&#x27;&#x27;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num!= val:</span><br><span class="line">                nums[ans] = num</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.3p3rmieqqso0.gif#pic_center" width = 48%><p><strong>80. 删除有序数组中的重复项 II</strong></p><p>题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">1</span>, <span class="number">2</span>       <span class="comment"># 使得出现次数超过两次的元素只出现两次</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow-<span class="number">1</span>]:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>  slow + <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.6iyyl4e6wp80.gif#pic_center" width = 48%><p><strong>通用解法：</strong></p><p>为了让解法更具有一般性，我们将原问题的 <strong>「最多保留 1 位」修改为「最多保留 k 位</strong>。</p><p>对于此类问题，我们应该进行如下考虑：</p><p>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。</p><p>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。</p><p>此时，初始化时指针 slow 指向数组的起始位置（nums[k-1]），指针 fast 指向指针 slow 的后一个位置（nums[k]）。随着指针 fast 不断向后移动，将指针 fast 指向的元素与指 slow 指向的元素进行比较：</p><ul><li>如果nums[fast] ≠ nums[slow-k+1]，那么nums[slow + 1] &#x3D; nums[fast]；</li><li>如果nums[fast] &#x3D; nums[slow]，那么指针q继续向后查找；</li></ul><p><strong>283. 移动零</strong><br>题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>1. 快慢指针</strong><br><strong>写法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:                 <span class="comment"># 把前面为0的项覆盖掉</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        nums[slow:] = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)-slow)    <span class="comment"># 把后面填充为 0</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.2v3f4q957060.gif#pic_center" width = 48%><p><strong>写法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast]:</span><br><span class="line">                <span class="keyword">if</span> nums[slow] == <span class="number">0</span>:             <span class="comment"># 快指针不为零，慢指针为零，进行交换</span></span><br><span class="line">                    nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.79i27t7x4iw0.gif#pic_center" width = 48%><h3 id="2-2-左右指针"><a href="#2-2-左右指针" class="headerlink" title="2.2 左右指针"></a>2.2 左右指针</h3><p><strong>题库列表：</strong></p><blockquote> <ul><li><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank">88. 合并两个有序数组</a>：<mark>如何将数组所有元素整体后移，防止数组覆盖？</mark></p></li><li><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. 两数之和 II - 输入有序数组</a>（有序数列的首尾双指针）</p></li><li><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank">125. 验证回文串</a></p></li><li><p><a href="https://leetcode.cn/problems/reverse-string/" target="_blank">344. 反转字符串</a></p></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/" target="_blank">151. 反转字符串中的单词</a></p></li><li><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank">345. 反转字符串中的元音字母</a></p></li><li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank">11. 盛最多水的容器</a>：<strong>经典题目</strong></p></li><li><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/" target="_blank">42. 接雨水</a>：<strong>经典题目</strong></p></li><li><p> <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank">75. 颜色分类</a>（左右指针，三色旗）</p></li><li><p><a href="https://leetcode.cn/problems/backspace-string-compare/" target="_blank">844. 比较含退格的字符串</a>（左右指针）</p></li></ul></blockquote> <p><strong>88. 合并两个有序数组</strong></p><p>题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p><strong>1. 左右指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        nums1[m:] = nums2               # 直接合并后排序</span></span><br><span class="line"><span class="string">        nums1.sort()           </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p0, p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span>, m+n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0 &gt;= <span class="number">0</span> <span class="keyword">or</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> p0 == -<span class="number">1</span>:                <span class="comment"># num1 已经循环结束</span></span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p1 == -<span class="number">1</span>:              <span class="comment"># # num2 已经循环结束</span></span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p0] &gt; nums2[p1]:</span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.465vy0ux2co0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        p0, p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span>, m+n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0 &gt;= <span class="number">0</span> <span class="keyword">and</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p0] &gt; nums2[p1]:   <span class="comment"># num1 更大</span></span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                      </span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后拼接没有遍历完的数组，由于直接在 nums1 上操作，只需要在nums2没遍历完，拼接起来就可以了</span></span><br><span class="line">        <span class="keyword">if</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[:p2+<span class="number">1</span>] = nums2 [:p1+<span class="number">1</span>]  </span><br></pre></td></tr></table></figure><p><strong>167. 两数之和 II - 输入有序数组</strong></p><p>题目描述：给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            two_sum = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> two_sum == target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]    <span class="comment"># 题目要求下标从1开始</span></span><br><span class="line">            <span class="keyword">elif</span> two_sum &gt; target:          <span class="comment"># 两数之和大于目标值，右边的值太大了，right--</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                           <span class="comment"># 两数之和小于目标值，左边值太小，left++</span></span><br><span class="line">                left += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.3gtipsibd9q0.gif#pic_center" width = 48%><p><strong>125. 验证回文串</strong></p><p>题目描述：如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串。字母和数字都属于字母数字字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 思路一：正则表达式</span></span><br><span class="line"><span class="string">        if not s:</span></span><br><span class="line"><span class="string">            return True</span></span><br><span class="line"><span class="string">        s = s.lower()</span></span><br><span class="line"><span class="string">        pattern = re.compile(r&#x27;[^a-z0-9]&#x27;)   # 正则表达式，把数字和字母都剔除掉</span></span><br><span class="line"><span class="string">        new_str = pattern.sub(&#x27;&#x27;, s)</span></span><br><span class="line"><span class="string">        return new_str == new_str[::-1]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 字符串预处理</span></span><br><span class="line"><span class="string">        new_str = &#x27;&#x27;.join(ch.lower() for ch in s if ch.isalnum())</span></span><br><span class="line"><span class="string">        return new_str == new_str[::-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 左右指针</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 两个循环找到左侧和右侧为字母或者数字的位置</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:                   <span class="comment"># 判断移动过后的left，right是否满足left在左，right在右的相对位置</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[left] != s[right]:         <span class="comment"># 如果左右指针所指不同，则肯定不构成回文</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:                           <span class="comment"># 左右指针各前进一步</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这里使用了正则表达式移除所有非字母数字字符，然后判断新的字符串是否是回文，也可以使用双指针，直接一次遍历，遇到字母数字字符就进行判断。</p><p><strong>151. 反转字符串中的单词</strong></p><p>题目描述：给你一个字符串 s，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.strip() <span class="comment"># 删除首尾空格</span></span><br><span class="line">        i = j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">&#x27; &#x27;</span>: i -= <span class="number">1</span>    <span class="comment"># 搜索首个空格</span></span><br><span class="line">            res.append(s[i + <span class="number">1</span>: j + <span class="number">1</span>])             <span class="comment"># 添加单词</span></span><br><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">&#x27; &#x27;</span>: i -= <span class="number">1</span>               <span class="comment"># 跳过单词间空格</span></span><br><span class="line">            j = i                                   <span class="comment"># j 指向下个单词的尾字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)                        <span class="comment"># 拼接并返回</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.21eld8of51fk.gif#pic_center" width = 48%><p><strong>2. 分割 + 倒序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.strip().split()[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.736ly7pxg8s0.webp#pic_center" width = 48%><p><strong>344. 反转字符串</strong></p><p>题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 $O(1)$ 的额外空间解决这一问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        return s.reverse()</span></span><br><span class="line"><span class="string">        s[:] = s[::-1]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 左右指针法</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.ituca5t9lds.gif#pic_center" width = 48%><p><strong>345. 反转字符串中的元音字母</strong></p><p>题目描述：给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现不止一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        str_set = <span class="built_in">set</span>(<span class="string">&quot;aeiouAEIOU&quot;</span>)</span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        str_list = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">if</span> str_list[head] <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">in</span> str_set:</span><br><span class="line">                str_list[head], str_list[tail] = str_list[tail], str_list[head]</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str_list[head] <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">not</span> <span class="keyword">in</span> str_set:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str_list[head] <span class="keyword">not</span> <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">in</span> str_set:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br></pre></td></tr></table></figure><p><strong>11. 盛最多水的容器</strong></p><p>题目描述：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 双指针，移动小的那一边</span></span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">if</span> height[head] &lt; height[tail]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[head]*(tail-head))</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[tail]*(tail-head))</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.63a65w667xw0.gif#pic_center" width = 48%><p><strong>42. 接雨水</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.rx8hdafpg8w.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        leftMax = rightMax = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left])</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right])</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                ans += leftMax - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += rightMax - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.2ziftttwjuk0.gif#pic_center" width = 48%><p><strong>75. 颜色分类</strong></p><p>题目描述：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>1. 单指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">            <span class="keyword">if</span> nums[k] == <span class="number">1</span>:</span><br><span class="line">                nums[k], nums[i] = nums[i], nums[k]</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.6ht435cinmw0.gif#pic_center" width = 48%><p><strong>2. 左右指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 定义三个变量，p0 表示数组最左边0的区域，p1是数组最右边2的区域</span></span><br><span class="line">        i, p0, p1 = <span class="number">0</span>, <span class="number">0</span> , <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p1:</span><br><span class="line">            <span class="comment"># 如果当前指向的是 0，就把这个元素交换到数组左边</span></span><br><span class="line"><span class="comment"># 也就是跟 p0 指针交换，之后cur，p0 就往前一动一位</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前指向的是2，就把这个元素交换到数组右边</span></span><br><span class="line"><span class="comment"># 也就是跟p2指针交换，注意此时cur指针就不用移动了</span></span><br><span class="line"><span class="comment"># 因为右边的一片区域都是2，只要把元素交换过去就可以了，cur不用移动</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果是1的话，就不用交换</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.27435ybjphus.gif#pic_center" width = 48%><p><strong>844. 比较含退格的字符串</strong></p><p>题目描述：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。如果对空文本输入退格字符，文本继续为空。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s_skip_num = <span class="number">0</span>                              <span class="comment"># 记录s的#数量</span></span><br><span class="line">        t_skip_num = <span class="number">0</span>                              <span class="comment"># 记录t的#数量</span></span><br><span class="line">        i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        j = <span class="built_in">len</span>(t) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>):                         <span class="comment"># 从后向前，消除S的#</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>): </span><br><span class="line">                    s_skip_num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (s_skip_num &gt; <span class="number">0</span>): </span><br><span class="line">                        s_skip_num -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>):                         <span class="comment"># 从后向前，消除T的#</span></span><br><span class="line">                <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>):</span><br><span class="line">                    t_skip_num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (t_skip_num &gt; <span class="number">0</span>):</span><br><span class="line">                        t_skip_num -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 后半部分</span></span><br><span class="line">            <span class="comment"># 消除完了，接下来比较s[i] != t[j]</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span>                              <span class="comment"># s 或者 t 遍历到头了</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[j]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 说明S和T同时遍历完毕</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> <span class="keyword">and</span> j == -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.bbd1edjnceg.gif#pic_center" width = 48%><p><strong>2. 栈模拟法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.back_strip(s) == self.back_strip(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">back_strip</span>(<span class="params">self, s</span>):</span><br><span class="line">        s_list = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> item == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> s_list:</span><br><span class="line">                    s_list.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_list.append(item)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p><strong>3. 移除元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        list_s, list_t = <span class="built_in">list</span>(s), <span class="built_in">list</span>(t)</span><br><span class="line">        idx_s, idx_t = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_s)):</span><br><span class="line">            <span class="keyword">if</span> list_s[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                list_s[idx_s] = list_s[i]</span><br><span class="line">                idx_s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx_s -= <span class="number">1</span> <span class="keyword">if</span> idx_s &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_t)):</span><br><span class="line">            <span class="keyword">if</span> list_t[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                list_t[idx_t] = list_t[i]</span><br><span class="line">                idx_t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx_t -= <span class="number">1</span> <span class="keyword">if</span> idx_t &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> list_s[:idx_s] == list_t[:idx_t]</span><br></pre></td></tr></table></figure><p><strong>977. 有序数组的平方</strong></p><p>题目描述：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;先平方后排序，每次利用已排序的先验信息，最大值必定在两端出现&quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, length-<span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[left] ** <span class="number">2</span> &lt; nums[right] ** <span class="number">2</span>:</span><br><span class="line">                result.append(nums[right] ** <span class="number">2</span>)</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(nums[left] ** <span class="number">2</span>)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.5si4hg3y9m00.gif#pic_center" width = 48%><hr><h3 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h3><p>题库列表：</p><blockquote> <ul><li><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/" target="_blank">5. 最长回文子串</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum/" target="_blank">15. 三数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum-closest/" target="_blank">16. 最接近的三数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/4sum/" target="_blank">18. 四数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank">56. 合并区间</a>：<strong>数组类操作</strong></p></li></ul></blockquote> <p><strong>5. 最长回文子串</strong></p><p>题目描述：给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>思路分析：找回⽂串的难点在于，回⽂串的的⻓度可能是奇数也可能是偶数，解决该问题的核⼼是<font color=#9900CC><strong>从中⼼向两端扩散的双指针技巧</strong></font>。如果回⽂串的⻓度为奇数，则它有⼀个中⼼字符；如果回⽂串的⻓度为偶数，则可以认为它有两个中⼼字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找到以i和i+1为中心的回文字符串&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            s1 = self.palindrome(s, i, i)</span><br><span class="line">            s2 = self.palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            res = s1 <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(res) <span class="keyword">else</span> res</span><br><span class="line">            res = s2 <span class="keyword">if</span> <span class="built_in">len</span>(s2) &gt; <span class="built_in">len</span>(res) <span class="keyword">else</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">self, s, l, r</span>):</span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure><p><strong>15. 三数之和</strong><br>题目描述：给你一个整数数组 nums ，判断是否存在三元组 $[nums[i], nums[j], nums[k]]$ 满足 $i !&#x3D; j、i !&#x3D; k$ 且 $j !&#x3D; k$ ，同时还满足 $nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0$。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums_sorted)):</span><br><span class="line">            <span class="keyword">if</span> nums_sorted[i] &gt; <span class="number">0</span>:                              <span class="comment"># 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            # 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line"><span class="string">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="string">                continue;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:      <span class="comment"># 去重</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums_sorted)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                # 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0, 0, 0 这种三元组</span></span><br><span class="line"><span class="string">                while left &lt; right and nums_sorted[left] == nums_sorted[left+1]:    left += 1</span></span><br><span class="line"><span class="string">                while left &lt; right and nums_sorted[right] == nums_sorted[right-1]:  right -= 1</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> nums_sorted[i]+nums_sorted[left]+nums_sorted[right] == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums_sorted[i], nums_sorted[left], nums_sorted[right]])</span><br><span class="line">                    <span class="comment"># 在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], </span></span><br><span class="line">                    <span class="comment"># i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[left] == nums_sorted[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[right] == nums_sorted[right-<span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 找到答案时双指针同时收缩</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums_sorted[i]+nums_sorted[left]+nums_sorted[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.2k1miygya7c0.gif#pic_center" width = 48%><p><strong>16. 最接近的三数之和</strong><br>题目描述：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)         <span class="comment"># 初始化，因为找最小值，因此把初始值设置成实数的最大值</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)          <span class="comment"># 排序是前提</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:    <span class="comment"># 常见的剪枝操作</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i+<span class="number">1</span>                                          <span class="comment"># 双指针：指针对撞</span></span><br><span class="line">            right = length-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                temp = nums_sorted[left] + nums_sorted[right] + nums_sorted[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(temp-target) &lt; diff:     </span><br><span class="line">                    diff = <span class="built_in">abs</span>(temp-target)</span><br><span class="line">                    ans = temp</span><br><span class="line">                <span class="comment"># 不管是变小还是变大，尝试的作用是让 temp 与 target 更接近，即 temp 与 target 的绝对值之差越来越小</span></span><br><span class="line">                <span class="keyword">if</span> temp &gt; target:        <span class="comment"># 如果大了，尝试右边界收缩一格，让 temp 变小</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> temp &lt; target:     <span class="comment"># 如果小了，尝试左边界收缩一格，让 target 变大</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 如果已经等于 target 的话, 肯定是最接近的，根据题目要求，返回这三个数的和</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.2na0d7iaxdo0.gif#pic_center" width = 48%><p><strong>18. 四数之和</strong></p><p>题目描述：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li>0 &lt;&#x3D; a, b, c, d &lt; n</li><li>a、b、c 和 d 互不相同</li><li>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</li></ul><p>你可以按 任意顺序 返回答案 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length): </span><br><span class="line">            <span class="comment"># 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> nums_sorted[i] &gt; target <span class="keyword">and</span> nums_sorted[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 对 nums_sorted[i] 去重</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):        <span class="comment"># 比原来多一层循环</span></span><br><span class="line">                <span class="comment"># 二级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> nums_sorted[i] + nums_sorted[j] &gt; target <span class="keyword">and</span> nums_sorted[i] + nums_sorted[j] &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 对 nums_sorted[j] 去重</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums_sorted[j] == nums_sorted[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="keyword">if</span> nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] == target:</span><br><span class="line">                        result.append([nums_sorted[i], nums_sorted[j], nums_sorted[left], nums_sorted[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[left] == nums_sorted[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[right] == nums_sorted[right-<span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>56. 合并区间</strong></p><p>题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] &#x3D; [starti, endi]$。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result= []</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 如果列表为空，或者当前区间与上一区间不重合，直接添加</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">or</span> result[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                result.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则的话，我们就可以与上一区间进行合并</span></span><br><span class="line">                result[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(result[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>左右指针与快慢指针暂时告一段落，但还有很多自己不满意的地方，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.3nvcyp0fhrq0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>双指针套路总结：<a href="https://zhuanlan.zhihu.com/p/95747836">https://zhuanlan.zhihu.com/p/95747836</a></li><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>算法与数据结构（一）：滑动窗口法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/89066140">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;89066140</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。本篇主要分析双指针在字符串数组中常用解题套路。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快慢指针" scheme="https://qxienote.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
    <category term="碰撞指针" scheme="https://qxienote.com/tags/%E7%A2%B0%E6%92%9E%E6%8C%87%E9%92%88/"/>
    
    <category term="连续区间" scheme="https://qxienote.com/tags/%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（二）-- 前缀和与差分数组</title>
    <link href="https://qxienote.com/article/319c8c73.html"/>
    <id>https://qxienote.com/article/319c8c73.html</id>
    <published>2023-06-11T02:07:48.000Z</published>
    <updated>2023-06-11T02:29:05.042Z</updated>
    
    <content type="html"><![CDATA[<p>前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。本节主要学习算法的原理，结合LeetCode题目分析如何使用这些技巧。</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。</p><p>数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。</p><p>此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。本节主要讲解这两种算法。</p><h2 id="1-前缀和与差分数组"><a href="#1-前缀和与差分数组" class="headerlink" title="1 前缀和与差分数组"></a>1 前缀和与差分数组</h2><p>前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和，差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。合理的使用前缀和与差分，可以将某些复杂的问题简单化。</p><h3 id="1-1-前缀和"><a href="#1-1-前缀和" class="headerlink" title="1.1 前缀和"></a>1.1 前缀和</h3><p>假设有一个序列 A，前缀和为 S。根据概念很容易知到公式</p><p>$$S[i]&#x3D;\displaystyle \sum_{j&#x3D;1}^iA[j]$$</p><p>如何求区间 $[l,r]$ 的和呢？</p><p>$$sum[l,r]&#x3D;s[r]-s[l-1]$$</p><h3 id="1-2-差分数组"><a href="#1-2-差分数组" class="headerlink" title="1.2 差分数组"></a>1.2 差分数组</h3><p>设原数组为 A[i],差分数组为 diff[i]，则：</p><p>$$diff[i]&#x3D;\begin{cases} A[i]&amp;i&#x3D;1\ A[i]-A[i-1]&amp;i\geq2 \end{cases}$$</p><p>差分数组的性质是：</p><ul><li>如果对区间 $[l,r]$ 进行修改，只需修改 $diff[l], diff[r+1]$（diff[l]加上修改值，diff[r+1] 减去修改值）</li><li>$A[i]&#x3D;\displaystyle \sum_{j&#x3D;1}^{i}B[j]$（通过 $B[i]&#x3D;A[i]-A[i-1]$ 证明）</li><li>$S[x]&#x3D;\displaystyle \sum_{i&#x3D;1}^{x}A[i]&#x3D;\displaystyle \sum_{i&#x3D;1}^{x} \displaystyle \sum_{j&#x3D;1}^{i}diff[j]&#x3D;\displaystyle \sum _{i&#x3D;1}^{x}(x-i+1)*diff[i]$$</li></ul><blockquote><p>当我们希望对原数组的某一个区间 $[i, j]$ 施加一个增量 inc 时，差分数组 $d$ 对应的变化是：$d[i] 4$ 增加 inc，$d[j+1]$ 减少inc，并且这种操作是可以叠加的。</p></blockquote><p>下面举个例子：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.6lmgy6vjiyc0.webp#pic_center" width = 64%><p>差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。</p><p>还是上面那个表里的例子，我们需要进行以下操作：</p><ol><li>将区间[1，4]的数值全部加上3</li><li>将区间[3，5]的数值全部减去5</li></ol><p>很简单对吧，你可以进行枚举。但是如果给你的数据量是 $1\times e^5$，操作量 $1\times e^5$，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。</p><p>其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。</p><p>利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.125vurueqzr4.webp#pic_center" width = 64%><p>进行下一个操作，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.71279cxlwrs0.webp#pic_center" width = 64%><p>这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。</p><p>本部分参考自：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分详解+例题</a></p><p>也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，<font color=#9900CC><strong>差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。</font></strong></p><p>有 $n$ 个数，$m$ 个操作，每一次操作，将 $x<del>y$ 区间的所有数增加 $z$；最后有 $q$ 个询问，每一次询问求出 $x</del>y$ 的区间和。设原数组为 $A[i]$。其步骤为：</p><ul><li>先求出差分数组 $B[i]&#x3D;A[i]−A[i−1]$</li><li>在根据 $m$ 个造作修改 $B[i]$</li><li>求修改后的 $A[i]&#x3D;A[i−1]+B[i]$</li><li>求前缀和 $S[i]&#x3D;S[i−1]+A[i]$</li><li>最后输出区间和 $sum[x,y]&#x3D;S[y]−S[x−1]$</li></ul><blockquote><p><font color=#9900CC><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</font></strong></p></blockquote><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote> <ul><li><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/" target="_blank">303. 区域和检索 - 数组不可变</a>：<strong>一维前缀和</strong></p></li><li><p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/" target="_blank">304. 二维区域和检索 - 矩阵不可变</a>：<strong>二维前缀和</strong></p></li><li><p><a href="https://leetcode.cn/problems/range-addition/" target="_blank">370. 区间加法</a>：<strong>差分数组</strong></p></li><li><p><a href="https://leetcode.cn/problems/corporate-flight-bookings/" target="_blank">1109. 航班预订统计</a>：<strong>差分数组</strong></p></li><li><p><a href="https://leetcode.cn/problems/car-pooling/" target="_blank">1094. 拼车</a>：<strong>差分数组</strong></p></li></ul></blockquote> <p><strong>303. 区域和检索 - 数组不可变</strong></p><p>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4jq9oeam7mw0.webp#pic_center" width = 80%></p><p><strong>一维前缀和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.nums_array = [<span class="number">0</span>]            <span class="comment"># 便于计算累加和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.nums_array.append(self.nums_array[i] + nums[i])  <span class="comment"># 计算nums累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.nums_array[right+<span class="number">1</span>] - self.nums_array[left]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.xrjyxto1ocw.gif#pic_center" width = 64%><p><strong>304. 二维区域和检索 - 矩阵不可变</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/048.6ey4bron1sg0.webp#pic_center" width = 80%><p><strong>二维前缀和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])                  <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.pre_sum[i+<span class="number">1</span>][j] + self.pre_sum[i][j+<span class="number">1</span>] - self.pre_sum[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.pre_sum[row1][col2+<span class="number">1</span>] - self.pre_sum[row2+<span class="number">1</span>][col1] + self.pre_sum[row1][col1])</span><br></pre></td></tr></table></figure><p><strong>370. 区间加法</strong></p><p>题目描述：假设你有一个长度为n的数组，初始情况下所有的数字均为0，你将会被给出k个更新的操作。其中，每个操作会被表示为一个三元组: [startIndex, endIndex, inc]，你需要将子数组 A[startIndex, endIndex]（包括startlndex和endIndex）增加 inc。<br>请你返回 k 次操作后的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (length+<span class="number">1</span>)  <span class="comment"># 末尾多个0，防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end + <span class="number">1</span>] -= inc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            diff[i] += diff[i - <span class="number">1</span>]            <span class="comment"># 对差分数组求前缀和便可得到原数组</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> diff[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>1109. 航班预订统计</strong></p><p>题目描述：这里有 n 个航班，它们分别从 1 到 n 进行编号。有一份航班预订表 bookings ，表中第 $i$ 条预订记录 $bookings[i] &#x3D; [first_i, last_i, seats_i]$ 意味着在从 $first_i$ 到 $last_i$（包含 $first_i$ 和 $last_i$）的 每个航班 上预订了 $seats_i$ 个座位。请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            start, end, inc = booking[<span class="number">0</span>], booking[<span class="number">1</span>], booking[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            <span class="keyword">if</span> end &lt; n:             <span class="comment"># 没在末尾添加0，要判断一下边界</span></span><br><span class="line">                diff[end+<span class="number">1</span>] -= inc</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/052.6gnyefuumd80.gif#pic_left" width = "40%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/052.6gnyefuumd80.gif#pic_left"  width = "48%"></center></p><p><strong>1094. 拼车</strong></p><p>题目描述：车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向），给定整数 capacity 和一个数组 trips ,  $trip[i] &#x3D; [numPassengers_i, from_i, to_i]$ 表示第 $i$ 次旅行有 $numPassengers_i$ 乘客，接他们和放他们的位置分别是 $from_i$ 和 $to_i$。这些位置是从汽车的初始位置向东的公里数。当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="number">1001</span>)      <span class="comment"># 题目中最多有1001个车站</span></span><br><span class="line">        max_station = <span class="number">0</span>          <span class="comment"># 找到车站数</span></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            inc, start, end = trip[<span class="number">0</span>], trip[<span class="number">1</span>], trip[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end] -= inc      <span class="comment"># 第end站乘客已经下车，这里就不用end+1</span></span><br><span class="line">            max_station = <span class="built_in">max</span>(max_station, end)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_station+<span class="number">1</span>): <span class="comment"># 进行区间求和</span></span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(diff[:max_station]) &gt; capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/050.qso2bf25fv4.webp#pic_center" width = 80%><hr><blockquote><p><font color=#9900CC><strong>欢迎各位大佬一起来学习前缀和与差分数组，希望本篇可以让你对前缀和和差分的概念及使用技巧有更清晰的理解，欢迎继续补充！</font></strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/051.4lt77415u1s0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>差分详解+例题：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">https://blog.csdn.net/qq_44786250&#x2F;article&#x2F;details&#x2F;100056975</a></li><li>数组（三）– LC[370]&amp;[1109]&amp;[1094] 区间加法：<a href="https://blog.csdn.net/xq151750111/article/details/129243272?spm=1001.2014.3001.5502">https://blog.csdn.net/xq151750111/article/details/129243272?spm=1001.2014.3001.5502</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。本节主要学习算法的原理，结合LeetCode题目分析如何使用这些技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前缀和" scheme="https://qxienote.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="差分数组" scheme="https://qxienote.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数学（一）-- LC[12]&amp;[13] 整数转罗马数字</title>
    <link href="https://qxienote.com/article/b86971b3.html"/>
    <id>https://qxienote.com/article/b86971b3.html</id>
    <published>2023-06-10T12:10:57.000Z</published>
    <updated>2023-06-10T12:19:29.508Z</updated>
    
    <content type="html"><![CDATA[<p>本篇以LeetCode[12]——整数转罗马数字为例，分析如何使用数学方法进行解题</p><span id="more"></span><h2 id="1-整数转罗马数字"><a href="#1-整数转罗马数字" class="headerlink" title="1 整数转罗马数字"></a>1 整数转罗马数字</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><blockquote><p>示例 1:<br>输入: num &#x3D; 3<br>输出: “III”</p></blockquote><blockquote><p>示例 2:<br>输入: num &#x3D; 4<br>输出: “IV”</p></blockquote><blockquote><p>示例 3:<br>输入: num &#x3D; 9<br>输出: “IX”</p></blockquote><blockquote><p>示例 4:<br>输入: num &#x3D; 58<br>输出: “LVIII”<br>解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</p></blockquote><blockquote><p>示例 5:<br>输入: num &#x3D; 1994<br>输出: “MCMXCIV”<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p></blockquote><p>提示：1 &lt;&#x3D; num &lt;&#x3D; 3999</p><p>题目链接：<a href="https://leetcode.cn/problems/integer-to-roman/">https://leetcode.cn/problems/integer-to-roman/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>根据题目分析，我们知道罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。这给了我们总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/040.lngh4orwxww.webp#pic_center" width = 48%><p>考虑 140140 的罗马数字表示，我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为 C&#x3D;100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL&#x3D;40。因此，140 的对应的罗马数字为 <code>C+XL=CXL</code>。这说明罗马数字是唯一表示的。(这不就是贪心策略，和找零钱的问题有点类似)</p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>1. 思路一: 模拟</strong><br>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 整除该符号值，并将整除的值乘以该符号，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。设计算法的思想如下：每一步都使用当前对应阿拉伯数字较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。(贪心算法)</p><p>编程时，可以建立一个数值-符号对的列表 value_symbol，按数值从大到小排列。遍历 value_symbol 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        value_symbol = [(<span class="number">1000</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="number">900</span>, <span class="string">&#x27;CM&#x27;</span>), (<span class="number">500</span>, <span class="string">&#x27;D&#x27;</span>), (<span class="number">400</span>, <span class="string">&#x27;CD&#x27;</span>), (<span class="number">100</span>, <span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        (<span class="number">90</span>, <span class="string">&#x27;XC&#x27;</span>), (<span class="number">50</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="number">40</span>, <span class="string">&#x27;XL&#x27;</span>), (<span class="number">10</span>, <span class="string">&#x27;X&#x27;</span>), (<span class="number">9</span>, <span class="string">&#x27;IX&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;V&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;IV&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;I&#x27;</span>)]</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> value, symbol <span class="keyword">in</span> value_symbol:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= value:</span><br><span class="line">                result += symbol * (num // value)</span><br><span class="line">                num = num % value</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。由于 value_symbol 长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3(超过3就要进位了)，因此循环次数有一个确定的上限。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>2. 思路二：硬编码数字</strong></p><p>我们可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 0 对应的是空字符串。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/041.4cvm6z500240.webp#pic_center" width = 48%><p>利用模运算和除法运算，我们可以得到 num 每个位上的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thousands_digit = num // <span class="number">1000</span></span><br><span class="line">hundreds_digit = (num % <span class="number">1000</span>) // <span class="number">100</span></span><br><span class="line">tens_digit = (num % <span class="number">100</span>) // <span class="number">10</span></span><br><span class="line">ones_digit = num % <span class="number">10</span></span><br></pre></td></tr></table></figure><p>最后，根据 num 每个位上的数字，在硬编码表中查找对应的罗马字符，并将结果拼接在一起，即为 num 对应的罗马数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    thousands = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;MMM&#x27;</span>]</span><br><span class="line">    hundreds = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;CD&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;DC&#x27;</span>, <span class="string">&#x27;DCC&#x27;</span>, <span class="string">&#x27;DCCC&#x27;</span>, <span class="string">&#x27;CM&#x27;</span>]</span><br><span class="line">    tens = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;XX&#x27;</span>, <span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XL&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;LX&#x27;</span>, <span class="string">&#x27;LXX&#x27;</span>, <span class="string">&#x27;LXXX&#x27;</span>, <span class="string">&#x27;XC&#x27;</span>]</span><br><span class="line">    ones = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>, <span class="string">&#x27;VII&#x27;</span>, <span class="string">&#x27;VIII&#x27;</span>, <span class="string">&#x27;IX&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> Solution.thousands[num//<span class="number">1000</span>] + Solution.hundreds[num%<span class="number">1000</span>//<span class="number">100</span>] + Solution.tens[num%<span class="number">100</span>//<span class="number">10</span>] + Solution.ones[num%<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。计算量与输入数字的大小无关。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="2-罗马数转整数"><a href="#2-罗马数转整数" class="headerlink" title="2 罗马数转整数"></a>2 罗马数转整数</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><blockquote><p>示例 1:<br>输入: s &#x3D; “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:<br>输入: s &#x3D; “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:<br>输入: s &#x3D; “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:<br>输入: s &#x3D; “LVIII”<br>输出: 58<br>解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</p></blockquote><blockquote><p>示例 5:<br>输入: s &#x3D; “MCMXCIV”<br>输出: 1994<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/roman-to-integer/">https://leetcode.cn/problems/roman-to-integer/</a></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>思路一：观察下图，我们可以发现罗马数字最多为两位，所以可以利用这个来判断和下一个字母组合是否是构成一个整数，示例代码如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/042.141x8tzxsjhc.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        symbol_value = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;CM&#x27;</span>: <span class="number">900</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;CD&#x27;</span>: <span class="number">400</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;XC&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;XL&#x27;</span>: <span class="number">40</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;IX&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;IV&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[index:index+<span class="number">2</span>] <span class="keyword">in</span> symbol_value.keys():</span><br><span class="line">                result += symbol_value[s[index:index+<span class="number">2</span>]]</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += symbol_value[s[index]]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>思路二：我们由上面的定义可以知道，对于罗马数字<code>AB</code>，A代表的整数小于B是，要用B代表的整数减去A代表的整数，否则两个代表的整数相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        symbol_value = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> symbol_value[s[i]] &lt; symbol_value[s[i+<span class="number">1</span>]]:</span><br><span class="line">                result -= symbol_value[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += symbol_value[s[i]]</span><br><span class="line">        <span class="keyword">return</span> result + symbol_value[s[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇以LeetCode[12]——整数转罗马数字为例，分析如何使用数学方法进行解题&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="LeetCode" scheme="https://qxienote.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础文章汇总</title>
    <link href="https://qxienote.com/article/a0d5b4a3.html"/>
    <id>https://qxienote.com/article/a0d5b4a3.html</id>
    <published>2023-06-10T08:29:05.000Z</published>
    <updated>2023-06-11T02:53:03.837Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是对计算机基础专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1 计算机网络"></a>1 计算机网络</h2><h3 id="1-1-网络篇"><a href="#1-1-网络篇" class="headerlink" title="1.1  网络篇"></a>1.1  网络篇</h3><ul><li><a href="https://qxienote.com/article/54ebc735.html">计算机网络篇（一）– 网络协议入门</a></li><li><a href="https://qxienote.com/article/279b4884.html">计算机网络篇（二）– HTTP 协议入门</a></li><li><a href="https://qxienote.com/article/ae7157b3.html">计算机网络篇（三）– SSL&#x2F;TLS 协议入门</a></li><li><a href="https://qxienote.com/article/1ee3e5d0.html">计算机网络篇（四）– TCP&#x2F;IP 协议族详解</a></li><li><a href="https://qxienote.com/article/84fa558.html">计算机网络篇（五）– TCP 套接字编程</a></li><li><a href="https://qxienote.com/article/929e2127.html">计算机网络篇（六）– UDP 套接字编程</a></li><li><a href="https://qxienote.com/article/24fe53d6.html">计算机网络篇（七）– ICMP-Ping 服务程序框架</a></li><li><a href="https://qxienote.com/article/ba7802fc.html">计算机网络篇（八）-邮件客户端实现与电子邮件发送</a></li></ul><h3 id="1-2-《计算机网络—自顶向下方法》-Wireshark实验"><a href="#1-2-《计算机网络—自顶向下方法》-Wireshark实验" class="headerlink" title="1.2 《计算机网络—自顶向下方法》 Wireshark实验"></a>1.2 《计算机网络—自顶向下方法》 Wireshark实验</h3><ul><li><a href="https://blog.csdn.net/xq151750111/article/details/130515236">《计算机网络—自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130536991">《计算机网络—自顶向下方法》 Wireshark实验（二）：HTTP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130576182">《计算机网络—自顶向下方法》 Wireshark实验（三）：DNS协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130648866">《计算机网络—自顶向下方法》 Wireshark实验（四）：TCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130660079">《计算机网络—自顶向下方法》 Wireshark实验（五）：UDP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130675220">《计算机网络—自顶向下方法》 Wireshark实验（六）：IP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130663286">《计算机网络—自顶向下方法》 Wireshark实验（七）：以太网与ARP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775056">《计算机网络—自顶向下方法》 Wireshark实验（八）：ICMP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130769488">《计算机网络—自顶向下方法》 Wireshark实验（九）：DHCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775356">《计算机网络—自顶向下方法》 Wireshark实验（十）：NAT 协议分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章是对计算机基础专栏下的文章进行汇总，方便系统地学习和复习。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络篇（八）-- 邮件客户端实现与电子邮件发送</title>
    <link href="https://qxienote.com/article/ba7802fc.html"/>
    <id>https://qxienote.com/article/ba7802fc.html</id>
    <published>2023-06-10T08:11:24.000Z</published>
    <updated>2023-06-11T02:06:40.115Z</updated>
    
    <content type="html"><![CDATA[<p>通过完成本实验，我们将更加了解SMTP协议。还将学到使用Python实现标准协议的经验。主要任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><span id="more"></span><h2 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1 SMTP"></a>1 SMTP</h2><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><p>这里采用qq邮箱来完成。本文将实现一个SMTP客户端，使用qq邮箱作为发件人，向指定的163邮箱发送一封邮件。</p><p>SMTP协议即简单邮件传输协议，允许用户按照标准发送&#x2F;接收邮件。</p><p>在本文中，SMTP邮件客户端程序的基本流程如下：</p><ol><li>与qq邮件服务器建立TCP连接，域名”smtp.qq.com”，SMTP默认端口号25。建立连接后服务器将返回状态码220，代表服务就绪（类似HTTP，SMTP也使用状态码通知客户端状态信息）。</li><li>发送”HELO”命令，开始与服务器的交互，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”AUTH LOGIN”命令，开始验证身份，服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的用户名（本例中是163邮箱的账号），服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的密码（本例中是163邮箱的密码），服务器将返回状态码235（用户验证成功）。</li><li>发送”MAIL FROM”命令，并包含发件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”RCPT TO”命令，并包含收件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”DATA”命令，表示即将发送邮件内容，服务器将返回状态码354（开始邮件输入，以”.”结束）。</li><li>发送邮件内容，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”QUIT”命令，断开与邮件服务器的连接。</li></ol><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230504</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 实现邮件客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mail content</span></span><br><span class="line">subject = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">contenttype = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">msg = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sender and reciever</span></span><br><span class="line">fromaddress = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">toaddress = <span class="string">&quot;xxxxx@163.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth information (Encode with base64)</span></span><br><span class="line">username = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">username = base64.b64encode(username.encode()).decode()</span><br><span class="line">password = base64.b64encode(password.encode()).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line">clientSocket.connect((mailserver, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO CarpeDiem\r\n&#x27;</span></span><br><span class="line">clientSocket.send(heloCommand.encode())</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv1)</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;AUTH LOGIN\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((username + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((password + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;235&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;235 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send MAIL FROM command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;MAIL FROM: &lt;&#x27;</span> + fromaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send RCPT TO command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;RCPT TO: &lt;&#x27;</span> + toaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send DATA command and print server response.</span></span><br><span class="line">clientSocket.send(<span class="string">&#x27;DATA\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;354&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;354 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send message data.</span></span><br><span class="line">message = <span class="string">&#x27;from:&#x27;</span> + fromaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;to:&#x27;</span> + toaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;subject:&#x27;</span> + subject + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;Content-Type:&#x27;</span> + contenttype + <span class="string">&#x27;\t\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;\r\n&#x27;</span> + msg</span><br><span class="line">clientSocket.sendall(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Message ends with a single period.</span></span><br><span class="line">clientSocket.sendall(endmsg.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send QUIT command and get server response.</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;QUIT\r\n&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close connection</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 有些邮箱默认关闭SMTP服务，比如本文使用的qq邮箱。需要在设置中打开SMTP服务。另外，qq邮箱在打开SMTP服务后，会设置一个授权码，在程序使用这个授权码作为密码登录，而不是平时使用的密码。</p><p>一切正常的话，运行效果如下图所示，将会看到服务器返回的每条消息，其中包含每次操作后返回的状态码。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.euksoeo322w.webp#pic_center" width = 36%><p>同时，我们还可以登陆发件人邮箱和收件人邮箱，在发件人的已发送文件夹中和收件人的收件箱中都能看到这封被发送的邮件。左图为qq邮箱，右图为网易163邮箱。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.56cyk5j0h1g0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.60g5ulueg0o0.webp#pic_left"  width = "45%"></center></p><hr><h2 id="2-网络应用开发"><a href="#2-网络应用开发" class="headerlink" title="2 网络应用开发"></a>2 网络应用开发</h2><h3 id="2-1-发送电子邮件"><a href="#2-1-发送电子邮件" class="headerlink" title="2.1 发送电子邮件"></a>2.1 发送电子邮件</h3><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p><p>smtplib和email，这俩模块是Python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。</p><ul><li>smtplib模块主要负责发送邮件：是一个发送邮件的动作，连接邮箱服务器，登录邮箱，发送邮件（有发件人，收信人，邮件内容）。</li><li>email模块主要负责构造邮件：指的是邮箱页面显示的一些构造，如发件人，收件人，主题，正文，附件等。</li></ul><p><strong>代码说明：</strong></p><ol><li>smtplib模块</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">smtplib.SMTP()              <span class="comment"># 实例化SMTP()</span></span><br><span class="line"></span><br><span class="line">login(user, password)</span><br><span class="line"><span class="comment"># user：登录邮箱的用户名。</span></span><br><span class="line"><span class="comment"># password：登录邮箱的密码，像笔者用的是网易邮箱，网易邮箱一般是网页版，需要用到客户端密码，需要在网页版的网易邮箱中设置授权码，该授权码即为客户端密码。</span></span><br><span class="line"></span><br><span class="line">sendmail(from_addr, to_addrs, msg,…)</span><br><span class="line"><span class="comment"># from_addr：邮件发送者地址</span></span><br><span class="line"><span class="comment"># to_addrs：邮件接收者地址。字符串列表[‘接收地址1’,‘接收地址2’,‘接收地址3’,…]</span></span><br><span class="line"><span class="comment"># msg：发送消息：邮件内容。一般是msg.as_string():as_string()是将msg(MIMEText对象或者MIMEMultipart对象)变为str。</span></span><br><span class="line"></span><br><span class="line">quit()      <span class="comment"># 用于结束SMTP会话。</span></span><br></pre></td></tr></table></figure><p><strong>2) email模块</strong></p><p>email模块下有mime包，mime英文全称为<code>“Multipurpose Internet Mail Extensions”</code>，即多用途互联网邮件扩展，是目前互联网电子邮件普遍遵循的邮件技术规范。</p><p>该mime包下常用的有三个模块：text, image, multpart。</p><p>导入方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br></pre></td></tr></table></figure><p>构造一个邮件对象就是一个Message对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure><p>下面的代码演示了如何在Python发送普通的文字邮件。</p><p><strong>1. 发送普通文字邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230428</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header </span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 设定邮件发送者和接受者</span></span><br><span class="line">    host_server = <span class="string">&#x27;smtp.qq.com&#x27;</span>             <span class="comment"># qq 邮箱smtp服务器</span></span><br><span class="line">    sender = <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>              <span class="comment"># 发件人邮箱</span></span><br><span class="line">    pwd = <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span></span><br><span class="line">    receivers = [<span class="string">&#x27;xxxxxxx@gmail.com&#x27;</span>, <span class="string">&#x27;xxxxxx@163.com&#x27;</span>]              <span class="comment"># 收件人邮箱</span></span><br><span class="line">    mail_title = <span class="string">&quot;Python自动发送的邮件&quot;</span>                               <span class="comment"># 邮件标题  </span></span><br><span class="line">    mail_content = <span class="string">&quot;您好，这是使用python登录QQ邮箱发送邮件的测试——xq&quot;</span>   <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()               <span class="comment"># 初始化一个邮件主体</span></span><br><span class="line">    message[<span class="string">&#x27;Subject&#x27;</span>] = Header(mail_title, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    message[<span class="string">&#x27;From&#x27;</span>] = sender</span><br><span class="line">    message[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;;&quot;</span>.join(receivers)</span><br><span class="line">    message.attach(MIMEText(mail_content, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    smtper = SMTP_SSL(host_server)      <span class="comment"># ssl登录</span></span><br><span class="line">    <span class="comment"># login(user,password):</span></span><br><span class="line">    <span class="comment"># user:登录邮箱的用户名。</span></span><br><span class="line">    <span class="comment"># password：登录邮箱的密码，这里用的是QQ邮箱，</span></span><br><span class="line">    <span class="comment"># 需要用到客户端密码，需要在QQ邮箱中设置授权码，该授权码即为客户端密码</span></span><br><span class="line">    smtper.login(sender, pwd)</span><br><span class="line">    smtper.sendmail(sender, receivers, message.as_bytes())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送完成!&quot;</span>)</span><br><span class="line">    <span class="comment"># quit(): 用于结束SMTP会话</span></span><br><span class="line">    smtper.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.6alnsifgg2o0.webp#pic_center" width = 64%><p><strong>2. 发送html格式邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.6yb1qqrncyo0.webp#pic_center" width = 36%><p><strong>3. 发送带附件的邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件以及附件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication  <span class="comment"># 用于添加附件</span></span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line">attachment = MIMEApplication(<span class="built_in">open</span>(<span class="string">&quot;H:\\毕业设计\\LassoNet\\脑区选择.xlsx&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">attachment[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给附件重命名</span></span><br><span class="line">basename = <span class="string">&quot;test.xlsx&quot;</span></span><br><span class="line">attachment.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;&#x27;</span>, basename))</span><br><span class="line">msg.attach(attachment)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.6g3dk32y7kg0.webp#pic_center" width = 36%><h3 id="2-2-发送短信"><a href="#2-2-发送短信" class="headerlink" title="2.2 发送短信"></a>2.2 发送短信</h3><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a href="https://www.ihuyi.com/duanxin.html?e=591">互亿无线短信平台</a>（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    host  = <span class="string">&quot;106.ihuyi.com&quot;</span></span><br><span class="line">    sms_send_uri = <span class="string">&quot;/webservice/sms.php?method=Submit&quot;</span></span><br><span class="line">    <span class="comment"># 下面的参数需要填入自己注册的账号和对应的密码</span></span><br><span class="line">    params = urllib.parse.urlencode(&#123;<span class="string">&#x27;account&#x27;</span>: <span class="string">&#x27;API ID&#x27;</span>, <span class="string">&#x27;password&#x27;</span> : <span class="string">&#x27;API KEY&#x27;</span>, <span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;您的验证码是：666888。请不要把验证码泄露给其他人。&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>: <span class="string">&#x27;xxxxxxxxx&#x27;</span>, <span class="string">&#x27;format&#x27;</span>:<span class="string">&#x27;json&#x27;</span> &#125;)</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=<span class="number">80</span>, timeout=<span class="number">30</span>)</span><br><span class="line">    conn.request(<span class="string">&#x27;POST&#x27;</span>, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    jsonstr = response_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(json.loads(jsonstr))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>详细了解，请阅读：<a href="https://www.ihuyi.com/api/sms.html">短信验证码&#x2F;通知 - API文档</a></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python实现自动发送邮件（详解）：<a href="https://blog.csdn.net/weixin_44827418/article/details/111255414">https://blog.csdn.net/weixin_44827418&#x2F;article&#x2F;details&#x2F;111255414</a></li><li>Python网络应用开发：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过完成本实验，我们将更加了解SMTP协议。还将学到使用Python实现标准协议的经验。主要任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="邮件客户端" scheme="https://qxienote.com/tags/%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（七）-- ICMP Ping服务程序框架</title>
    <link href="https://qxienote.com/article/24fe53d6.html"/>
    <id>https://qxienote.com/article/24fe53d6.html</id>
    <published>2023-06-10T08:11:03.000Z</published>
    <updated>2023-06-10T08:29:23.393Z</updated>
    
    <content type="html"><![CDATA[<p>Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。</p><span id="more"></span><p>Ping的实现通常使用ICMP协议。ICMP协议在协议族中的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.ziro52u46eo.webp#pic_center" width = 48%><p>通过本文，你将更好地理解因特网控制报文协议（<code>ICMP</code>），学习使用<code>ICMP</code>请求和响应消息实现<code>Ping</code>程序。通过向目标主机发送<code>ICMP</code>回显包并监听<code>ICMP</code>回显应答来工作。回显有时称为<code>pong</code>。<code>ping</code>程序测量往返时间，记录数据包丢失，并输出接收到的回显包的统计摘要（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差）。</p><p>主要任务：用<code>python</code>开发自己的简单<code>Ping</code>程序。程序将使用<code>ICMP</code>协议，但为了保持简单，将不完全遵循<code>RFC 1739</code>中的正式规范。在本实训中只需要编写程序的客户端，因为服务器端所需的功能几乎内置于所有操作系统中。Ping程序的基本功能如下： Ping 程序能将 ping 请求发送到指定的主机，间隔大约一秒钟。每个消息包含一个带有时间戳的数据包。 每个数据包发送完后，程序最多等待一秒，用于接收响应。如果一秒后服务器没有响应，那么客户端应假设 ping 数据包或 pong 数据包在网络中丢失（或者服务器已关闭）。 统计摘要信息（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差） 本实训将使用原始套接字来使用ICMP协议。</p><p>下面将为为Ping客户端创建一个原始类型的套接字。</p><h2 id="1-Ping客户端创建原始套接字"><a href="#1-Ping客户端创建原始套接字" class="headerlink" title="1 Ping客户端创建原始套接字"></a>1 Ping客户端创建原始套接字</h2><h3 id="1-1-原始套接字"><a href="#1-1-原始套接字" class="headerlink" title="1.1 原始套接字"></a>1.1 原始套接字</h3><p>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。使用原始套接字进行网络通信的基本步骤为：</p><ul><li>（1）创建原始套接字、设置套接字选项和创建并填充相应协议头；</li><li>（2）用 <code>sendto()</code> 函数将组装好的数据发送出去；</li><li>（3）使用 <code>recvfrom()</code> 函数接收数据并解析；</li><li>（4）关闭套接字。</li></ul><p>在Python中使用套接字编程，需要先引入套接字（import socket）；使用 <code>socket()</code> 函数来创建套接字。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket(socket_family,socket_type,protocol=<span class="number">0</span>)</span><br><span class="line">socket_family可以是如下参数之一：</span><br><span class="line">  　　AF_INET IPv4（默认）</span><br><span class="line">　　  AF_INET6 IPv6</span><br><span class="line">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span><br><span class="line">socket_type可以是如下参数之一:</span><br><span class="line">　　  SOCK_STREAM　　流式socket , <span class="keyword">for</span> TCP （默认）</span><br><span class="line">　  　SOCK_DGRAM　　 数据报式socket , <span class="keyword">for</span> UDP</span><br><span class="line">　  　SOCK_RAW 原始套接字</span><br></pre></td></tr></table></figure><p>普通的套接字无法处理ICMP、IGMP等网络报文，而原始套接字 <code>SOCK_RAW</code> 可以；<code>SOCK_RAM</code> 用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。<code>SOCK_RAM</code> 通常仅限于高级用户或管理员运行的程序使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol参数：</span><br><span class="line">　　<span class="number">0</span>　（默认）与特定的地址家族相关的协议。如果是 <span class="number">0</span> ，则系统就会根据地址格式和套接类别，自动选择一个合适的协议。也可以使用</span><br><span class="line">  getprotobyname()指定要使用的协议名称如“ICMP”、“UDP”等。</span><br></pre></td></tr></table></figure><p>在本实验中，要创建一个使用IPV4地址族的的原始套接字，并指定使用ICMP协议，可以使用如下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmp = getprotobyname(<span class="string">&quot;icmp&quot;</span>)   /*指定ICMP协议</span><br><span class="line">rawsocket=socket(AF_INET, SOCK_RAW, icmp)</span><br></pre></td></tr></table></figure><h2 id="2-封装并发送ICMP报文"><a href="#2-封装并发送ICMP报文" class="headerlink" title="2 封装并发送ICMP报文"></a>2 封装并发送ICMP报文</h2><h3 id="2-1-ICMP协议"><a href="#2-1-ICMP协议" class="headerlink" title="2.1 ICMP协议"></a>2.1 ICMP协议</h3><p>ICMP协议：<code>Internet Control Message Protocol</code>（Internet控制报文协议）；由于IP协议并不是一个可靠的协议，它不保证数据被成功送达。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的，经常供IP层或更高层协议（TCP或UDP）使用。所以它经常被认为是IP层的一个组成部分。</p><p>制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着<font color=#9900CC><strong>“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议”</font></strong>。即，ICMP 是为了分担IP 一部分功能而被制定出来的。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.ed8xfkhqoh4.webp#pic_center" width = 48%><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p><p>在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.39oq4lvlrna0.webp#pic_center" width = 48%><ul><li>[1]给送信者的错误通知；[2]送信者的信息查询。</li><li>[1]是到IP 数据包被对方的计算机处理的过程中，发生了什么错误时被使用。不仅传送发生了错误这个事实，也传送错误原因等消息。</li><li>[2]的信息询问是在送信方的计算机向对方计算机询问信息时被使用。被询问内容的种类非常丰富，他们有目标IP 地址的机器是否存在这种基本确认，调查自己网络的子网掩码，取得对方机器的时间信息等。</li></ul><p>ICMP是TCP&#x2F;IP模型中网络层的重要成员，与IP协议、ARP协议、RARP 协议及 IGMP协议共同构成 TCP&#x2F;IP模型中的网络层。<code>ping</code> 和 <code>tracert</code> 是两个常用网络管理命令，<code>ping</code> 用来测试网络可达性，<code>tracert</code> 用来显示到达目的主机的路径。<code>ping</code> 和 <code>tracert</code> 都利用ICMP 协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。</p><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。但RFC认为ICMP是分担了IP的一部分功能。所以，ICMP也被认为是与IP同层的协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。看一下RFC 规定的数据包格式和报文内容吧。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.4xn5l5nbahs0.webp#pic_center" width = 48%><p>当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP的数据报文格式如下所示。所有报文的前4个字节都是一样的，其他的因报文类型不同而不一样。类型字段可以有15个不同的值，用以描述不同的ICMP报文。校验和字段覆盖整个ICMP报文，使用了和IP首部检验和一样的算法，详细请搜索TCP&#x2F;IP检验和算法。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.52nce9l7ak40.webp#pic_center" width = 48%><p><strong>字段说明：</strong></p><ul><li>类型：标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。    </li><li>代码：标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。    </li><li>校验和：对包括ICMP报文数据部分在内的整个ICMP&#96;数据报的校验和，以检验报文在传输过程中是否出现了差错。</li></ul><p><font color=#9900CC><strong>不同类型的报文是由类型字段和代码字段来共同决定。</font></strong>下表是各种类型的ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.5ol4guwagpk0.webp#pic_center" width = 48%><p>根据上表可知，ICMP协议大致分为两类，一种是查询报文，一种是差错报文。查询报文是用一对请求和应答定义的，它通常有以下几种用途:</p><ol><li>ping查询</li><li>子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）</li><li>时间戳查询（可以用来同步时间）</li></ol><p>而差错报文通常包含了引起错误的IP数据报的第一个分片的IP首部（和选项），加上该分片数据部分的前8个字节。RFC 792规范中定义的这8个字节中包含了该分组运输层首部的所有分用信息，这样运输层协议就可以向正确的进程提交ICMP差错报文。</p><p>当传送IP数据包发生错误时，比如主机不可达，端口不可达等，ICMP协议就会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。由上面可知，ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成，而前 16bit就组成了ICMP所要传递的信息。由数据链路层所能发送的最大数据帧，即MTU（Maximum Transmission Unit）为1500，计算易知ICMP协议在实际传输中数据包为：20字节IP首部 + 8字节ICMP首部+ 1472字节（数据大小）。</p><p>尽管在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的。如下</p><ol><li>ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）</li><li>目的地址是广播地址或多播地址的IP数据报。</li><li>作为链路层广播的数据报。</li><li>不是IP分片的第一片。</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。</li></ol><h3 id="2-2-ping程序原理分析"><a href="#2-2-ping程序原理分析" class="headerlink" title="2.2 ping程序原理分析"></a>2.2 ping程序原理分析</h3><p>ping程序是由Mike Muuss编写，目的是为了测试另一 台主机是否可达，现在已经成为一个常用的网络状态检查工具。该程序发送一份 ICMP回显请求报文给远程主机，并等待返回 ICMP回显应答。利用ping这种原理，已经出现了许多基于ping的网络扫描器，比如nmap、arping、fping、hping3等。所以随着Internet安全意识的增强，现在有些提供访问控制策略的路由器和防火墙已经可以设置过滤特定ICMP报文请求。因此并不能通过简单的ping命令判断远程主机是否在线。</p><p>ping 使用的是ICMP协议，它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。大多数的 TCP&#x2F;IP 实现都在内核中直接支持Ping服务器，ICMP回显请求和回显应答报文如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.klquqyz6p2o.webp#pic_center" width = 48%><p>ping的原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。通过计算ICMP应答报文数量和与接受与发送报文之间的时间差，判断当前的网络状态。这个往返时间的计算方法是：ping命令在发送ICMP报文时将当前的时间值存储在ICMP报文中发出，当应答报文返回时，使用当前时间值减去存放在ICMP报文数据中存放发送请求的时间值来计算往返时间。ping返回接受到的数据报文字节大小、TTL值以及往返时间。</p><p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的 ID号。这样 即使在同一台主机上同时运行了多个 ping程序实例，ping程序也可以识别出返回的信息。</p><p><code>ping</code> 操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.3qwubtumq28.webp#pic_center" width = 48%><p>过程如下：</p><ol><li><p>向目标服务器发送回送请求。<br>首先，向目标服务器发出回送请求（类型是8，代码是0）报文（同2）。在这个回送请求报文里，除了类型和代码字段，还被追加了标识符和序号字段。标识符和序号字段分别是16 位的字段。ping 命令在发送回送请求报文时，在这两个字段里填入任意的值。对于标识符，应用程序执行期间送出的所有报文里填入相同的值。对于序号，每送出一个报文数值就增加1。而且，回送请求的选项数据部分用来装任意数据。这个任意数据用来调整ping 的交流数据包的大小。</p></li><li><p>鹦鹉学舌一样返回回送回答。<br>计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求（类型是0，代码是0）（同3）。这个ICMP 回送回答报文在IP 层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP 地址字段被交换了，类型字段里填入了表示回送回答的0。也就是，从送信方来看，自己送出的ICMP 报文从目标服务器那里象鹦鹉学舌那样原样返回了。<br>送信方的计算机可以通过收到回送回答报文，来确认目标服务器在工作着。进一步，记住发送回送请求报文的时间，与接收到回送回答报文的时间一比较，就能计算出报文一去一回往复所需要的时间（同4）。但是，收到的回送回答报文里写的只是类型和代码的话，发送方计算机将无法判断它是否是自己发出去请求的回答。因此，前面说到的标识符和序号字段就有它的意义了。将这两个值与回送回答报文中的相同字段值一比较，送行方计算机就能够简单地检测回送回答是否正确了。执行ping 命令而调查的结果没什么问题的话，就将目标服务器的IP 地址，数据大小，往复花费的时间打印到屏幕上。</p></li><li><p>用ping 命令不能确定与对方连通的原因大致有三个。<br>1）目标服务器不存在；2)花在数据包交流上的时间太长ping 命令认为超时；3）目标服务器不回答ping 命令。如果是原因2），通过ping 命令的选项来延长到超时的等待时间，就能正确显示结果了。如果原因是1）或3）的话，仅凭ping 命令的结果就不能判断是哪方了。正如这样，ping 命令不一定一定能判断对方是否存在。</p></li></ol><p>一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。</p><p>时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。</p><h3 id="2-3-协议数据包的封装"><a href="#2-3-协议数据包的封装" class="headerlink" title="2.3 协议数据包的封装"></a>2.3 协议数据包的封装</h3><p>Python中处理二进制数据如存取文件、socket操作时，可以使用 Python 的 struct 模块来完成。使用该模块可以方便地来实现协议数据的封装与解封。</p><p>struct模块中最重要的三个函数是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pack(fmt, v1, v2, ...)     <span class="comment"># 按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</span></span><br><span class="line">unpack(fmt, string)        <span class="comment"># 按照给定的格式(fmt)解析字节流string，返回解析出来的数组</span></span><br><span class="line">calcsize(fmt)              <span class="comment"># 计算给定的格式(fmt)占用多少字节的内存</span></span><br></pre></td></tr></table></figure><p>其中fmt支持的格式如下表描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5mgm8e69x380.webp#pic_center" width = 48%><p>在完成封装后，将封装后的数据data，使用原始套接字的 <code>sendto()</code> 方法进行发送。<code>sendto()</code> 主要参数：</p><ul><li>packet：发送的数据</li><li>Addr：形式为 <code>(ipaddr，port)</code> 的元组</li></ul><h2 id="3-解析IP包ICMP头信息"><a href="#3-解析IP包ICMP头信息" class="headerlink" title="3 解析IP包ICMP头信息"></a>3 解析IP包ICMP头信息</h2><h3 id="3-1-接收ICMP报文"><a href="#3-1-接收ICMP报文" class="headerlink" title="3.1 接收ICMP报文"></a>3.1 接收ICMP报文</h3><p>使用原始套接字的 <code>recvfrom()</code> 函数接收报文，输入参数指定为报文最大长度，如1024；函数返回值为报文发送方的地址、报文内容。接收代码示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfpacket, addr = mysocket.recvfrom(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-解析ICMP报文"><a href="#3-2-解析ICMP报文" class="headerlink" title="3.2 解析ICMP报文"></a>3.2 解析ICMP报文</h3><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议类型字段值为1时，就说明这是一个ICMP报文。</p><p>ICMP报头如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.5fd06it998c0.webp#pic_center" width = 48%><p>解析ICMP报文可以使用Python中struct模块的 <code>upack()</code> 函数来实现。其参数：</p><ul><li>fmtstr: 格式化字符串</li><li>packet: 需要解析的字符数组</li></ul><p>函数的返回值可以是多个，根据格式串中指定的类型返回到相应变量中。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d=struct.unpack(<span class="string">&#x27;5s6sif&#x27;</span>,<span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><p>则从bytes这个数组中解析出a：5个字符的字符串（5s），b:6个字符的字符串(6s)，c为整型(i)，d为浮点型数据(f)。</p><p>对于Ping命令的ICMP报文，我们需从IP包中取出ICMP报头，位于20到28字节；从中可以取出报文类型type,代码code，校验和checksum，报文ID及报文序号字段；</p><p>对于类型为1的报文且其ID为需要接收的报文，从28字节后面开始解析发送的数据为发送时间，数据类型及长度根据发送的数据来确定。</p><ul><li>响应时间：计算收到报文的时间与发送报文（ICMP报文的数据部分）的时间差；</li><li>TTL：TTL指Time To Live生成周期，指定IP包被路由器丢弃之前允许通过的最大网段数量。在IPv4包头中TTL是一个8 bit字段，它位于IPv4包的第9个字节。因此只需从接收报文中解析出第9字节即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chesksum</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    校验</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(data)</span><br><span class="line">    m = n % <span class="number">2</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - m ,<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">sum</span> += (data[i]) + ((data[i+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>)   <span class="comment"># 传入data以每两个字节（十六进制）通过ord转十进制，第一字节在低位，第二个字节在高位</span></span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        <span class="built_in">sum</span> += (data[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 将高于16位与低16位相加</span></span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>) + (<span class="built_in">sum</span> &amp; <span class="number">0xffff</span>)</span><br><span class="line">    <span class="built_in">sum</span> += (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>)      <span class="comment"># 如果还有高于16位，将继续与低16位相加</span></span><br><span class="line">    answer = ~<span class="built_in">sum</span> &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="comment"># 主机字节序转网络字节序列（参考小端序转大端序）</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一次Ping的返回消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiveOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr, timeout</span>):</span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        </span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        <span class="built_in">type</span>, code, checksum, packetID, sequence = struct.unpack(<span class="string">&quot;!bbHHh&quot;</span>, header)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">and</span> packetID == ID:  <span class="comment"># type should be 0</span></span><br><span class="line">            byte_in_double =  struct.calcsize(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">            timeSent = struct.unpack(<span class="string">&quot;d&quot;</span>, recPacket[<span class="number">28</span>:<span class="number">28</span>+byte_in_double])[<span class="number">0</span>]</span><br><span class="line">            delay = timeReceived - startedSelect</span><br><span class="line">            ttl = struct.unpack(<span class="string">&quot;!b&quot;</span>, recPacket[<span class="number">8</span>:<span class="number">9</span>])[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> (delay, ttl, byte_in_double)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送一次Ping数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr</span>):</span><br><span class="line">    <span class="comment"># 头部构成： type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;!d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># 计算头部和数据的校验和</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向指定地址发送Ping消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doOnePing</span>(<span class="params">destAddr, ID, sequence, timeout</span>):</span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建原始套接字</span></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"> </span><br><span class="line">    sendOnePing(mySocket, ID, sequence, destAddr)</span><br><span class="line">    delay = receiveOnePing(mySocket, ID, sequence, destAddr, timeout)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数Ping</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># timeout=1指: 如果1秒内没从服务器返回，客户端认为Ping或Pong丢失。</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pinging &quot;</span> + dest + <span class="string">&quot; using Python:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每秒向服务器发送一次Ping请求</span></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># 返回进程ID</span></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        result = doOnePing(dest, myID, i, timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Request timed out.&quot;</span>)</span><br><span class="line">            loss += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delay = <span class="built_in">int</span>(result[<span class="number">0</span>]*<span class="number">1000</span>)</span><br><span class="line">            ttl = result[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">bytes</span> = result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Received from &quot;</span> + dest + <span class="string">&quot;: byte(s)=&quot;</span> + <span class="built_in">str</span>(<span class="built_in">bytes</span>) + <span class="string">&quot; delay=&quot;</span> + <span class="built_in">str</span>(delay) + <span class="string">&quot;ms TTL=&quot;</span> + <span class="built_in">str</span>(ttl))</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Packet: sent = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>) + <span class="string">&quot; received = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>-loss) + <span class="string">&quot; lost = &quot;</span> + <span class="built_in">str</span>(loss))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6tiqidr3ru00.webp#pic_center" width = 36%><h2 id="4-ICMP-的应用–Traceroute"><a href="#4-ICMP-的应用–Traceroute" class="headerlink" title="4 ICMP 的应用–Traceroute"></a>4 ICMP 的应用–Traceroute</h2><h3 id="4-1-原理介绍"><a href="#4-1-原理介绍" class="headerlink" title="4.1 原理介绍"></a>4.1 原理介绍</h3><p>Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管 ping 工具也可以进行侦测，但是，因为 ip 头的限制，ping 不能完全的记录下所经过的路由器。所以 Traceroute 正好就填补了这个缺憾。</p><p>Traceroute 的原理是非常非常的有意思，它受到目的主机的 IP 后，首先给目的主机发送一个 TTL&#x3D;1(还记得 TTL 是什么吗?)的  UDP(后面就 知道 UDP 是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减1，而 TTL 变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL&#x3D;2的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 ip。从而避开了 ip 头只能记录有限路由 IP 的问题。</p><p>有人要问，我怎么知道 UDP 到没到达目的主机呢？这就涉及一个技巧的问题，TCP 和 UDP 协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较小的端口，比如说80，比如说23，等等。而 traceroute 发送的是端口号&gt;30000(真变态)的  UDP 报，所以到 达目的主机的时候，目的主机只能发送一个端口不可达的 ICMP 数据报给主机。主机接到这个报告以后就知道，主机到了，所以，说  Traceroute 是一个骗子一点也不为过。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.62nfc4shenk0.webp#pic_center" width = 48%><p><strong>过程如下：</strong></p><ol><li>执行tracert命令。<br>在Windows 上执行tracert 命令后，首先计算机向目的服务器发送IP 数据包。Windows 上使用的是与ping 同样的ICMP 回送请求报文。但是，有一点和通常的回送请求不一样。那是，最初将IP 首部的TTL(生存时间)字段设为1 这一点。</li></ol><p>路由器每转送一次数据包就将TTL 的值减1。当TTL 变为0 的时候，按规定将丢弃这个数据包。正如这样，与其说TTL 是时间，还不如说TTL 是经过路由器的个数。对于计算机发送出去的数据包，只要它与目标服务器不在同一局域网内，一定会被哪儿的路由器中继。这时如果TTL 的值是1，由于路由器的处理会变为0，则该数据包将会被丢弃（同2）。</p><ol start="2"><li>用超时报文来通知送信方。<br>路由器丢弃数据包的同时，用ICMP 报文来通知错误。这时使用的ICMP 报文是，类型为11，代码为0 的ICMP 超时报文。而且在选项数据字段里，将填入原先数据包的IP 首部和ICMP 的开始8 字节。正如ping 命令的时候看到的，ICMP 回送请求的先头8 字节里包含了标识符和序号字段。因此，送信方的计算机看了超时报文后，就知道是针对自己发出的回送请求的错误通知。</li></ol><p>计算机接到针对第一个数据包的ICMP 超时报文后，接下来将TTL 加1（TTL&#x3D;2）并同样地送出（同3）。这次通过第一个路由器，TTL 变为1，到达第二个路由器。但是第二个路由器象前面一样，由于TTL变为0，将不能转发该包。因此，同第一个路由器一样，将该包丢弃，并返回ICMP 超时报文。以后，收到错误的发送方计算机将TTL 加1，重复同样的工作（同4）。</p><ol start="3"><li>只有目标服务器的反应不同。<br>如此一个一个增加TTL，某个时候ICMP 回送请求报文将到达最终的目标服务器。这时，只有目标服务器与途中的路由器不同，不返回ICMP 超时报文。为什么呢？因为即使目标服务器收到TTL 为1 的数据包也不会发生错误。</li></ol><p>作为代替处理，服务器针对送信方计算机发出的ICMP 回送请求报文，返回ICMP 回送回答报文。也就是，送信方计算机与服务器之间，与ping 命令的执行一样了（同5）。得到了ICMP 回送回答报文的送信方知道了路经调查已经到了目标服务器，就结束了tracert 命令的执行（同6）。像这样，通过列出中途路由器返回的错误，就能知道构成到目标服务器路径的所有路由器的信息了。</p><ol start="4"><li>操作系统不同则实现方法略微不同。<br>到这里，以Windows 上的tracert 命令为例看了原理，有些别的操作系统的traceroute 命令的原理略微不同。</li></ol><p>具体来说，也有用向目标发送UDP 数据包代替ICMP 回送请求报文来实现的。虽说是用UDP，但途中的路由器的处理与図 8完全相同。只是UDP 数据包到达目标后的处理不同。目标计算机突然收到与通信无关的数据包，就返回ICMP 错误，因此根据返回数据包的内容来判断命令的中止。</p><h3 id="4-2-Python-实现"><a href="#4-2-Python-实现" class="headerlink" title="4.2 Python 实现"></a>4.2 Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230423</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 基于ICMP协议Traceroute实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kamene.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tracert_one</span>(<span class="params">dst,dport,ttl_no</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;发一个Traceroute包，参数需要目的地址，目的端口，TTL&#x27;&#x27;&#x27;</span></span><br><span class="line">    send_time = time.time()         <span class="comment"># 记录发送时间</span></span><br><span class="line">    Tracert_one_reply = sr1(IP(dst=dst, ttl=ttl_no)/UDP(sport=<span class="number">6600</span>, dport=dport)/<span class="string">b&#x27;my traceroute!!!&#x27;</span>, timeout = <span class="number">1</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Scapy中UDP默认源目端口53，需要将源端口也改掉，否则中间设备将不回应</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">11</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果收到TTL超时</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>, hop_ip, time_to_passed        <span class="comment"># 返回1表示并未抵达目的地</span></span><br><span class="line">        <span class="keyword">elif</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">3</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">3</span>:</span><br><span class="line">            <span class="comment"># 如果收到端口不可达</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>, hop_ip, time_to_passed    <span class="comment"># 返回2表示抵达目的地</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">&#x27;.*NoneType.*&#x27;</span>,<span class="built_in">str</span>(e)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>     <span class="comment"># 测试失败返回None,没有回包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MY_Tracert</span>(<span class="params">dst,hops</span>):</span><br><span class="line">    dport = <span class="number">33434</span>           <span class="comment"># Traceroute的目的端口从33434开始计算</span></span><br><span class="line">    hop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> hop &lt; hops:</span><br><span class="line">        dport = dport + hop</span><br><span class="line">        hop += <span class="number">1</span></span><br><span class="line">        Result = Tracert_one(dst,dport,hop)</span><br><span class="line">        <span class="keyword">if</span> Result == <span class="literal">None</span>:      <span class="comment"># 如果测试失败就打印‘*’</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; *&#x27;</span>,flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">1</span>:    <span class="comment"># 如果未抵达目的，就打印这一跳和消耗的时间</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">2</span>:    <span class="comment"># 如果抵达目的，就打印这一跳和消耗的时间，并且跳出循环！</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conf.route.add(net=<span class="string">&#x27;172.16.10.0/24&#x27;</span>,gw=<span class="string">&#x27;192.168.10.115&#x27;</span>)    <span class="comment"># 为Scapy添加路由</span></span><br><span class="line">    destIP=<span class="built_in">input</span>(<span class="string">&quot;目标IP&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    hops=<span class="built_in">input</span>(<span class="string">&quot;最大跳数&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    MY_Tracert(destIP, <span class="built_in">int</span>(hops))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.40tookmha7w0.webp#pic_center" width = 64%><blockquote><p>了解更多，请阅读：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">ICMP实现之端口扫描、ICMP实现之改变路由、ICMP实现之源点抑制、ICMP实现之MTU探索</a></p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>python实现ping工具：<a href="https://blog.csdn.net/jia666666/article/details/85254450">https://blog.csdn.net/jia666666/article/details/85254450</a></li><li>ICMP协议与ping原理以及用Python实现ping：<a href="https://cloud.tencent.com/developer/article/1156671">https://cloud.tencent.com/developer/article/1156671</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li><li>完全理解icmp协议：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">https://www.cnblogs.com/iiiiher/p/8513748.html</a></li><li>Python网络编程2–实现Ping程序与Traceroute程序：<a href="https://www.jianshu.com/p/0c52955515c7">https://www.jianshu.com/p/0c52955515c7</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="ICMP 协议" scheme="https://qxienote.com/tags/ICMP-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（六）- UDP套接字编程</title>
    <link href="https://qxienote.com/article/929e2127.html"/>
    <id>https://qxienote.com/article/929e2127.html</id>
    <published>2023-06-10T03:23:57.000Z</published>
    <updated>2023-06-10T08:10:34.974Z</updated>
    
    <content type="html"><![CDATA[<p>本文将首先利用 Python 实现面向UDP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。</p><span id="more"></span><h2 id="1-创建UDP套接字"><a href="#1-创建UDP套接字" class="headerlink" title="1 创建UDP套接字"></a>1 创建UDP套接字</h2><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。<font color=#9900CC><strong>TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。</strong></font>可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。</p><p>数据包格式套接字（<code>Datagram Sockets</code>）也叫“无连接的套接字”，在代码中使用 <code>SOCK_DGRAM</code> 表示。可以将 <code>SOCK_DGRAM</code> 比喻成高速移动的摩托车快递，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的。</li></ul><p>数据包套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。</p><p>实际应用中，QQ 视频聊天和语音聊天主要使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。当然，SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</p><p>本部分将学习利用 UDP 套接字编程实现网络连通程序Ping。包含如何使用 UDP 套接字发送和接收数据报；如何设置适当的套接字超时；Ping 应用程序通信过程及计算网络统计信息（如丢包率）。</p><p>Ping 程序的基本原理：利用客户端发送一个数据包到远程机器，远程机器将收到的数据包返回到客户端（称为回显），客户端根据是否收到发送的消息及计算数据包的往返时间来反映网络是否连通及网络状态。</p><p>首先，要实现一个用 Python 编写的简单的 Ping 服务端程序，然后再实现对应的客户端程序。程序功能类似于现代操作系统中可用的标准 Ping 程序功能，不过这里使用简单的 UDP 协议，而不是标准互联网控制消息协议（ICMP）来进行通信的</p><h3 id="1-1-基于-UDP-协议的-Socket-套接字编程"><a href="#1-1-基于-UDP-协议的-Socket-套接字编程" class="headerlink" title="1.1 基于 UDP 协议的 Socket 套接字编程"></a>1.1 基于 UDP 协议的 Socket 套接字编程</h3><p>UDP 协议是非连接的协议，通信双方不用建立连接，而是直接把要发送的数据发送给对方。UDP 协议适用于一次传输数据量很少，对可靠性要求不高的应用场景。但由于UDP 协议没有类似于 TCP 的三次握手、可靠传输机制等，所以通信效率比较高。</p><p>UDP 协议的应用也非常广泛，比如知名的应用层协议：SNMP、DNS 都是基于 UDP的。一个常用的 UDP 通信的框架如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.2h2w2f6qok40.webp#pic_center" width = 64%><p>由图可以看出，客户端要发起一次请求，仅仅需要两个步骤（socket 和 sendto），而服务器端也仅仅需要三个步骤即可接收到来自客户端的消息（socket、bind、recvfrom）。和 TCP 通信不同的是，UDP 通信不需要监听（listen）及建立连接（accept）步骤，在创建及套接字后，可以直接使用 <code>sendto()</code> 及 <code>recvform()</code> 进行数据的发送及接收。</p><h3 id="1-2-UDP-Ping服务程序框架"><a href="#1-2-UDP-Ping服务程序框架" class="headerlink" title="1.2 UDP Ping服务程序框架"></a>1.2 UDP Ping服务程序框架</h3><p>在这个简单的 UDP Ping 服务器程序中，完成套接字创建及绑定后，当接收到消息后进行简单处理（这里是转化为大写），再将消息回传给相应的客户端。</p><h4 id="1-2-1-Ping服务端创建UDP套接字"><a href="#1-2-1-Ping服务端创建UDP套接字" class="headerlink" title="1.2.1 Ping服务端创建UDP套接字"></a>1.2.1 Ping服务端创建UDP套接字</h4><p>创建UDP套接字，绑定地址包含主机及其端口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">12000</span>))</span><br></pre></td></tr></table></figure><h4 id="1-2-2-UDP通信中发送与接收数据"><a href="#1-2-2-UDP通信中发送与接收数据" class="headerlink" title="1.2.2 UDP通信中发送与接收数据"></a>1.2.2 UDP通信中发送与接收数据</h4><p>在 UDP 通信中，使用 <code>sendto()</code> 函数发送 UDP 数据，将数据发送到套接字，输入参数 address 是形式为 <code>(host, port)</code> 的元组，指定远程地址，其中 <code>host</code> 表示服务器地址，<code>port</code> 表示服务器端口号。返回值是发送的字节数。</p><p>接收数据使用 <code>recvfrom()</code> 函数实现。输入参数为接收缓冲区大小。该函数接收 UDP 数据，与 <code>recv()</code> 类似，但返回值是 <code>(data, address)</code>。其中 <code>data</code> 是包含接收数据的字符串，<code>address</code> 是发送数据的套接字地址。</p><p><strong>示例如下：</strong></p><ul><li><p>接收数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg, addr = udp_server.recvfrom(BUFSIZE)   <span class="comment"># 使用套接字对象udp_server的recvfrom()方法接收数据</span></span><br></pre></td></tr></table></figure></li><li><p>发送数据</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp_server.sendto(msg,addr)     <span class="comment"># 使用套接字对象udp_server的sendto()方法发送数据</span></span><br></pre></td></tr></table></figure><p>完整的服务器程序一般都处于后台服务状态，通过不断循环等待客户端发送 <code>Ping</code> 消息，经过简单处理后，将消息发给相应的客户端。</p><p>在本实验中，为了避免大量资源的消耗，设置了一个接收消息计数器，当接收到消息超过设定值后，服务程序就退出（break）循环。</p><p>UDP为应用程序提供了不可靠的传输服务。消息可能因为路由器队列溢出，硬件错误或其他原因，而在网络中丢失。但由于在内网中很少丢包甚至不丢包，所以在本实验室的服务器程序添加人为损失来模拟网络丢包的影响。这里为了模拟，采用对接收到的消息计数器进行模运算，当模 3 的取值为 1 时，就不回传消息，返回接收下一条消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建UDP套接字</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定本机IP地址和端口号</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>))</span><br><span class="line"></span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接收客户端消息</span></span><br><span class="line">    message, address = serverSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将数据包消息转换为大写</span></span><br><span class="line">    message = message.upper()</span><br><span class="line">        </span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将消息传回给客户端</span></span><br><span class="line">    serverSocket.sendto(message, address)</span><br></pre></td></tr></table></figure><h3 id="1-3-客户端创建UDP套接字"><a href="#1-3-客户端创建UDP套接字" class="headerlink" title="1.3 客户端创建UDP套接字"></a>1.3 客户端创建UDP套接字</h3><p>创建 UDP 套接字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure><h4 id="1-3-1-设置套接字超时时间"><a href="#1-3-1-设置套接字超时时间" class="headerlink" title="1.3.1 设置套接字超时时间"></a>1.3.1 设置套接字超时时间</h4><p>在进行客户端向服务器发送 Ping 消息的过程中，有时候可能会因为网络原因造成一直连不上服务器（如服务器程序没有开启），这时如不手动停止，Socket 可能会一直尝试重连，造成资源的浪费。这就需要设置 <code>timeout</code> 来限制重连时间，当 Socket 尝试重连到指定的时间时，就会停止一切操作，并提示达到 <code>timeout</code> 设定阈值。设置超时时间一般在创建套接字后，在网络通信之前进行。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysocket.settimeout(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>代码作用为设定套接字的超时时间为 10 秒</p><p>客户端程序在创建完套接字后，通过循环向服务器发送消息，然后接收服务器回传的消息，通过计算收到消息及发送消息的时间差，来反映网络的状况。如果超时时间过后还没收到消息，则报出超时异常。</p><h4 id="1-3-2-客户端向服务器发送消息并接收消息"><a href="#1-3-2-客户端向服务器发送消息并接收消息" class="headerlink" title="1.3.2 客户端向服务器发送消息并接收消息"></a>1.3.2 客户端向服务器发送消息并接收消息</h4><p><strong>1. 消息编解码</strong></p><p>在网络通信中，网络线路中传输的是字节（二进制格式）流 <code>bytes</code>。但在我们发送的消息习惯用字符串 <code>string</code> 来表示，这时就需要用编码 <code>encode()</code> 和解码 <code>decode()</code> 函数来转换。</p><p><code>encode()</code> 函数：字符串类型（str）提供的方法，用于将字符串类型转换成 bytes 类型，这个过程也称为“编码”。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>注意，格式中用 [] 括起来的参数为可选参数，也就是说，在使用此方法时，可以使用 [] 中的参数，也可以不使用。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.53ukirqvzok0.webp#pic_center" width = 64%><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode()</span><br></pre></td></tr></table></figure><p>采用默认的 UTF-8 字符集将 str 编码为字节流</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode(<span class="string">&#x27;GBK&#x27;</span>)</span><br></pre></td></tr></table></figure><p>采用指定的 GBK 字符集将 str 编码为字节流</p><p><code>decode()</code> 函数：用于将 bytes 类型的二进制数据转换为 string 类型，这个过程也称为“解码”。其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>使用默认的 UTF-8 字符集进行解码为字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode()</span><br></pre></td></tr></table></figure><p>如果编码时采用的不是默认的 UTF-8 编码，则解码时要选择和编码时一样的格式，否则会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span> = <span class="built_in">str</span>.encode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line"><span class="built_in">bytes</span>.decode()  <span class="comment">#默认使用 UTF-8 编码，会抛出以下异常。</span></span><br><span class="line"><span class="built_in">bytes</span>.decode(<span class="string">&quot;GBK&quot;</span>)  <span class="comment">#不会抛出异常</span></span><br></pre></td></tr></table></figure><p>在 Ping 客户端程序中，发送消息时将发送消息的序号及发送时间发送到 Ping 服务器，然后接收消息，并将收到消息的时间与发送消息的时间差作为消息的延迟时间进行计算，并打印出来。</p><p>客户端程序为：</p><ol><li>使用UDP发送<code>ping</code>消息（注意：不同于TCP，您不需要首先建立连接，因为UDP是无连接协议。）</li><li>从服务器输出响应消息</li><li>如果从服务器受到响应，则计算并输出每个数据包的往返时延（RTT）（以秒为单位），</li><li>否则输出“请求超时”</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;127.0.0.1&#x27;</span> <span class="comment"># 服务器地址，本例中使用本机地址</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment"># 服务器指定的端口</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment"># 创建UDP套接字，使用IPv4协议</span></span><br><span class="line">clientSocket.settimeout(<span class="number">1</span>) <span class="comment"># 设置套接字超时值1秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">    sendTime = time.time()</span><br><span class="line">    message = (<span class="string">&#x27;Ping %d %s&#x27;</span> % (i+<span class="number">1</span>, sendTime)).encode()     <span class="comment"># 生成数据报，编码为bytes以便发送</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将信息发送到服务器</span></span><br><span class="line">        clientSocket.sendto(message, (serverName, serverPort))</span><br><span class="line">        <span class="comment"># 从服务器接收信息，同时也能得到服务器地址</span></span><br><span class="line">        modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">        rtt = time.time() - sendTime    <span class="comment"># 计算往返时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Reply from %s    RTT = %.3fs&#x27;</span> % (i+<span class="number">1</span>, serverName, rtt))         <span class="comment"># 显示信息</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Request timed out.&#x27;</span> % (i+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">clientSocket.close()            <span class="comment"># 关闭套接字</span></span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><p>在一台主机上运行<code>UDPPingerServer.py</code>，作为接收ping程序数据的服务器。</p><p>效果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.7g8vggsmopo0.webp#pic_center" width = 64%><p><strong>客户端：</strong></p><p>在另一台主机上运行<code>UDPPinger.py</code>，效果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.2qzffvjk6qw0.webp#pic_center" width = 48%>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将首先利用 Python 实现面向UDP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="UDP套接字" scheme="https://qxienote.com/tags/UDP%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（五）-- TCP套接字编程</title>
    <link href="https://qxienote.com/article/84fa558.html"/>
    <id>https://qxienote.com/article/84fa558.html</id>
    <published>2023-06-08T03:18:15.000Z</published>
    <updated>2023-06-10T08:01:40.126Z</updated>
    
    <content type="html"><![CDATA[<p>本文将首先利用 Python 实现面向TCP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。其次还将学习 HTTP 协议格式的相关知识。在此基础上，本篇将用 Python 语言开发一个简单的 Web 服务器，它仅能处理一个HTTP连接请求。</p><span id="more"></span><h2 id="1-Python3-网络编程"><a href="#1-Python3-网络编程" class="headerlink" title="1 Python3 网络编程"></a>1 Python3 网络编程</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Web 服务器的基本功能是接受并解析客户端的 HTTP 请求，然后从服务器的文件系统获取所请求的文件，生成一个由头部和响应文件内容所构成成的 HTTP 响应消息，并将该响应消息发送给客户端。如果请求的文件不存在于服务器中，则服务器应该向客户端发送“404 Not Found”差错报文。</p><p> &#x3D;&#x3D;具体的过程分为：&#x3D;&#x3D;</p><ul><li>当一个客户（浏览器）连接时，创建一个连接套接字；</li><li>从这个连接套接字接收 HTTP 请求；</li><li>解释该请求以确定所请求的特定文件；</li><li>从服务器的文件系统获得请求的文件；</li><li>创建一个由请求的文件组成的 HTTP 响应报文，报文前面有首部行；</li><li>经 TCP 连接向请求浏览器发送响应。</li><li>如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。</li></ul><p>要实现 Web 服务器，需使用套接字 Socket 编程接口来使用操作系统提供的网络通信功能。</p><p><font color=#9900CC><strong>Socket 是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，是一组编程接口。它把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。使用 Socket 后，无需深入理解 TCP&#x2F;UDP 协议细节（因为Socket 已经为我们封装好了），只需要遵循 Socket 的规定去编程，写出的程序自然就是遵循 TCP&#x2F;UDP 标准的。</strong></font>Socket 的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.1wujw2azhhhc.webp#pic_center" width = 36%><p><font color=#9900CC><strong>从某种意义上说，Socket 由地址IP和端口Port构成。</font></strong>IP 是用来标识互联网中的一台主机的位置，而 Port 是用来标识这台机器上的一个应用程序，IP 地址是配置到网卡上的，而 Port 是应用程序开启的，IP 与 Port 的绑定就标识了互联网中独一无二的一个应用程序。</p><p><strong>套接字类型</strong></p><ul><li>流式套接字（SOCK_STREAM）：用于提供面向连接、可靠的数据传输服务。——TCP</li><li>数据报套接字（SOCK_DGRAM）：提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。——UDP</li><li>原始套接字（SOCK_RAW）：主要用于实现自定义协议或底层网络协议。</li></ul><p>在本 WEB 服务器程序实验中，采用流式套接字进行通信。其基本模型如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.3r9nhi7ohm00.webp#pic_center" width = 48%><p>其工作过程如下：服务器首先启动，通过调用 <code>socket()</code> 建立一个套接字，然后调用绑定方法 <code>bind()</code> 将该套接字和本地网络地址联系在一起，再调用 <code>listen()</code> 使套接字做好侦听连接的准备，并设定的连接队列的长度。客户端在建立套接字后，就可调用连接方法 <code>connect()</code> 向服务器端提出连接请求。服务器端在监听到连接请求后，建立和该客户端的连接，并放入连接队列中，并通过调用 <code>accept()</code> 来返回该连接，以便后面通信使用。客户端和服务器连接一旦建立，就可以通过调用接收方法 <code>recv()/recvfrom()</code> 和发送 方法 <code>send()/sendto()</code> 来发送和接收数据。最后，待数据传送结束后，双方调用 <code>close()</code> 关闭套接字。</p><blockquote><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p></blockquote><hr><h2 id="2-创建TCP套接字"><a href="#2-创建TCP套接字" class="headerlink" title="2 创建TCP套接字"></a>2 创建TCP套接字</h2><h3 id="2-1-套接字"><a href="#2-1-套接字" class="headerlink" title="2.1 套接字"></a>2.1 套接字</h3><p><font color=#9900CC><strong>套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I&#x2F;O 插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是 IP 地址与端口 Port 的组合。</font></strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.1a0a2dxbsfr4.webp#pic_center" width = 48%><p>为了满足不同的通信程序对通信质量和性能的要求，网络系统提供了三种不同类型的套接字，以供用户在设计网络应用程序时根据不同的要求来选择。分别是：</p><ul><li>流式套接字（SOCK-STREAM）。提供一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在 TCP&#x2F;IP 协议簇中，使用 TCP 协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</li><li>数据报套接字（SOCK-DGRAM）。提供一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在 TCP&#x2F;IP 协议簇中，使用 UDP 协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</li><li>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如 IP 或 ICMP ）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</li></ul><p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建 <code>socket</code> 对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。<font color=#9900CC><strong>这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</font></strong></p><p>Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。</p><h3 id="2-2-如何创建套接字"><a href="#2-2-如何创建套接字" class="headerlink" title="2.2 如何创建套接字"></a>2.2 如何创建套接字</h3><p>套接字 Socket 实质上提供了主机间进程通信的连接点。进程通信之前，双方首先必须各自创建一个连接点。否则是没有办法建立联系并相互通信的。Python 中，我们用 <code>socket()</code> 函数来创建套接字，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my_socket = socket(socket_family, socket_type, protocol=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">socket_family可以是如下参数之一：</span></span><br><span class="line"><span class="string">  　　AF_INET IPv4（默认）</span></span><br><span class="line"><span class="string">　　  AF_INET6 IPv6</span></span><br><span class="line"><span class="string">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span></span><br><span class="line"><span class="string">socket_type可以是如下参数之一:</span></span><br><span class="line"><span class="string">　　  SOCK_STREAM　　流式socket , for TCP （默认）</span></span><br><span class="line"><span class="string">　  　SOCK_DGRAM　　 数据报式socket , for UDP</span></span><br><span class="line"><span class="string">　  　SOCK_RAW 原始套接字</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>Socket 对象(内建)方法</strong></p><table> <thead> <tr> <th align="left">函数</th> <th align="left">描述</th> </tr> </thead> <tbody><tr> <td align="left">服务器端套接字</td>  </tr> <tr> <td align="left">s.bind()</td> <td align="left">绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</td> </tr> <tr> <td align="left">s.listen()</td> <td align="left">开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td> </tr> <tr> <td align="left">s.accept()</td> <td align="left">被动接受TCP客户端连接,(阻塞式)等待连接的到来</td> </tr> <tr> <td align="left">客户端套接字</td>  </tr> <tr> <td align="left">s.connect()</td> <td align="left">主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td> </tr> <tr> <td align="left">s.connect_ex()</td> <td align="left">connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td> </tr> <tr> <td align="left">公共用途的套接字函数</td>  </tr> <tr> <td align="left">s.recv()</td> <td align="left">接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td> </tr> <tr> <td align="left">s.send()</td> <td align="left">发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td> </tr> <tr> <td align="left">s.sendall()</td> <td align="left">完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td> </tr> <tr> <td align="left">s.recvfrom()</td> <td align="left">接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td> </tr> <tr> <td align="left">s.sendto()</td> <td align="left">发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td> </tr> <tr> <td align="left">s.close()</td> <td align="left">关闭套接字</td> </tr> <tr> <td align="left">s.getpeername()</td> <td align="left">返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td> </tr> <tr> <td align="left">s.getsockname()</td> <td align="left">返回套接字自己的地址。通常是一个元组(ipaddr,port)</td> </tr> <tr> <td align="left">s.setsockopt(level,optname,value)</td> <td align="left">设置给定套接字选项的值。</td> </tr> <tr> <td align="left">s.getsockopt(level,optname[.buflen])</td> <td align="left">返回套接字选项的值。</td> </tr> <tr> <td align="left">s.settimeout(timeout)</td> <td align="left">设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td> </tr> <tr> <td align="left">s.gettimeout()</td> <td align="left">返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td> </tr> <tr> <td align="left">s.fileno()</td> <td align="left">返回套接字的文件描述符。</td> </tr> <tr> <td align="left">s.setblocking(flag)</td> <td align="left">如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td> </tr> <tr> <td align="left">s.makefile()</td> <td align="left">创建一个与该套接字相关连的文件</td> </tr> </tbody></table><h3 id="2-3-如何为套接字绑定主机及端口"><a href="#2-3-如何为套接字绑定主机及端口" class="headerlink" title="2.3 如何为套接字绑定主机及端口"></a>2.3 如何为套接字绑定主机及端口</h3><p>一个完整的 Socket 可以用一个通信双方的相关描述：<br>         $${协议,本地地址,本地端口,远程地址,远程端口}$$</p><p>实际应用中，在创建一个 Socket 时先用一个半相关描述（服务器这一半可以确定，而另一半尚不确定）:<br>         $${协议,本地地址,本地端口}$$<br>每一个 Socket 有一个本地的唯一端口号，由操作系统分配。</p><p>绑定指为套接字绑定地址包含主机及其端口。 在 AF_INET 下，以元组（host,port）的形式表示地址。</p><ul><li>host：用字符串表示主机的 IP 地址。表示本机<code>&#39;&#39;</code>，也可用 <code>127.0.0.1</code> 表示回环地址，或者主机的一般 IP 地址。</li><li>port：端口号，数字表示。1024 以下为系统约定，自定义的用 1024 以上。</li></ul><p>绑定通过套接字的绑定方法 <code>bind()</code> 来完成，输入参数为元组 <code>(host,port)</code>。<br><strong>绑定示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_socket.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1234</span>))         <span class="comment"># 绑定本地回环地址</span></span><br><span class="line">my_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">1234</span>))                  <span class="comment"># 自动获取IP地址</span></span><br></pre></td></tr></table></figure><h3 id="2-4-如何设置套接字监听"><a href="#2-4-如何设置套接字监听" class="headerlink" title="2.4 如何设置套接字监听"></a>2.4 如何设置套接字监听</h3><p>服务器程序在调用创建套接字 <code>socket()</code> 和绑定 <code>bind()</code> 之后需要处于监听状态，因为不知客户端什么时候开始进行请求连接。为此，需调用套接字的监听方法 <code>listen()</code>。</p><p>一个服务端可能同时面对多个客户端的连接请求，为此服务器程序需创建一个连接队列来保存的连接请求，并依次为连接请求建立相应连接。为此需设置队列的大小作为监听方法的参数。<br>监听示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_socket.listen(<span class="number">10</span>)    <span class="comment"># 设置连接队列大小为10，并使套接字处于监听状态。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-服务端获取连接请求"><a href="#2-5-服务端获取连接请求" class="headerlink" title="2.5 服务端获取连接请求"></a>2.5 服务端获取连接请求</h3><h4 id="2-5-1-如何获取客户端的连接请求"><a href="#2-5-1-如何获取客户端的连接请求" class="headerlink" title="2.5.1 如何获取客户端的连接请求"></a>2.5.1 如何获取客户端的连接请求</h4><p>当服务器中的套接字监听到了连接请求之后，内核和客户建立连接，并将连接放入连接队列中。典型的服务器程序是可以同时服务多个客户端的，当有客户端发起连接时，服务器就调用 <code>accept()</code> 返回并接收这个连接，如果有大量客户端发起请求，服务器来不及处理，还没有 accept 的客户端就处于连接等待状态。如果服务器调用 <code>accept()</code> 时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection_socket，addr = my_socket.accept()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">返回值： </span></span><br><span class="line"><span class="string">connectionSocket 客户端连接套接字</span></span><br><span class="line"><span class="string">addr 连接的客户端地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的 connectionSocket 称为客户端连接套接字，是 <code>accept()</code> 接收到一个客户端连接请求后返回的一个新的套接字，它代表了服务端和客户端的连接。后面可以用于读取数据以及关闭连接。</p><h4 id="2-5-2-如何获取客户端发送的报文内容"><a href="#2-5-2-如何获取客户端发送的报文内容" class="headerlink" title="2.5.2 如何获取客户端发送的报文内容"></a>2.5.2 如何获取客户端发送的报文内容</h4><p>服务器与客户端的连接建立好之后，就可以接收或发送消息操作。相应有下面几组方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recv()/send()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure><p>接收报文方法 <code>recv()</code> 用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = socket.recv(buffersize)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">　　　　　功能 ： 接收对应客户端消息</span></span><br><span class="line"><span class="string">　　　　　参数 ： 一次最多接收多少字节</span></span><br><span class="line"><span class="string">　　　　　返回值 ： 接收到的内容</span></span><br><span class="line"><span class="string">　　　    *  如果没有消息则会阻塞等待</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-服务端读取请求文件内容"><a href="#2-6-服务端读取请求文件内容" class="headerlink" title="2.6 服务端读取请求文件内容"></a>2.6 服务端读取请求文件内容</h3><h4 id="2-6-1-如何获取客户端请求的网页文件名"><a href="#2-6-1-如何获取客户端请求的网页文件名" class="headerlink" title="2.6.1 如何获取客户端请求的网页文件名"></a>2.6.1 如何获取客户端请求的网页文件名</h4><p>HTTP 请求是客户端通过发送信息向服务器请求对资源的访问。HTTP 请求由三部分组成：请求行、请求头和请求正文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /index.html HTTP/<span class="number">1.1</span>   <span class="comment"># 请求方法 url 协议及版本号</span></span><br><span class="line">Host: localhost             <span class="comment"># 主机地址</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">5.1</span>; rv:<span class="number">10.0</span><span class="number">.2</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">10.0</span><span class="number">.2</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*/*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Language: zh-cn,zh;q=<span class="number">0.5</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: &lt;a target=_blank href=<span class="string">&quot;http://localhost/&quot;</span> style=<span class="string">&quot;color: rgb(51, 102, 153); text-decoration: none;&quot;</span>&gt;http://localhost/&lt;/a&gt;</span><br><span class="line">Content-Length：<span class="number">25</span></span><br><span class="line">Content-<span class="type">Type</span>：application/x-www-form-urlencoded</span><br><span class="line">`     `</span><br><span class="line">username=aa&amp;password=<span class="number">1234</span>             <span class="comment"># 请求体</span></span><br></pre></td></tr></table></figure><p>从上方代码可以看出，请求网页文件名位于请求行（第一行）中用空格分隔的第二个部分。</p><p>在获得请求文件名后，读取文件内容使用文件操作来实现。Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。</p><h3 id="2-7-服务端响应请求头部信息"><a href="#2-7-服务端响应请求头部信息" class="headerlink" title="2.7 服务端响应请求头部信息"></a>2.7 服务端响应请求头部信息</h3><h4 id="2-7-1-WEB服务器响应消息头部定义"><a href="#2-7-1-WEB服务器响应消息头部定义" class="headerlink" title="2.7.1 WEB服务器响应消息头部定义"></a>2.7.1 WEB服务器响应消息头部定义</h4><p>WEB 服务器在接收到客户端的连接请求后，接下来就会响应该请求。HTTP 响应报文由三部分组成：响应行、响应头、响应体。如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.36a8ikrs6si0.webp#pic_center" width = 48%><ul><li>响应行：一般由协议版本、状态码及其描述组成，比如 <code>HTTP/1.1 200 OK</code> 其中协议版本 <code>HTTP/1.1</code> 或者 <code>HTTP/1.0</code>，<code>200</code> 就是它的状态码，<code>OK</code> 则为它的描述。</li><li>响应头：用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理它回送的数据。</li></ul><p>常见的响应头字段含义：</p><ul><li>Allow：服务器支持哪些请求方法(如GET、POST等)。</li><li>Content-Encoding：文档的编码(Encode)方法。</li><li>Content-Length：表示内容长度。</li><li>Content-Type：表示后面的文档属于什么MIME类型。</li><li>Date：当前的GMT时间</li><li>Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。</li><li>Last-Modified：文档的最后改动时间。</li><li>Location：用于重定向接收者到一个新URI地址。</li><li>Refresh：告诉浏览器隔多久刷新一次，以秒计。</li><li>Server：服务器通过这个头告诉浏览器服务器的类型。</li></ul><p>在这个 WEB 服务器返回的头部信息示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Connection: close</span><br><span class="line">Content-<span class="type">Type</span>: text/html</span><br><span class="line">Content-Length: <span class="number">24</span></span><br></pre></td></tr></table></figure><h4 id="2-7-2-发送响应消息头部内容"><a href="#2-7-2-发送响应消息头部内容" class="headerlink" title="2.7.2 发送响应消息头部内容"></a>2.7.2 发送响应消息头部内容</h4><p>在定义好响应消息的头部信息后，使用套接字的 send 方法发送即可。在发送前需要使用编码 <code>encode()</code> 方法，将字符串转换为字节数组后发送。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(header.encode())</span><br></pre></td></tr></table></figure><h4 id="2-7-3-如何捕获请求文件读取错误的异常"><a href="#2-7-3-如何捕获请求文件读取错误的异常" class="headerlink" title="2.7.3 如何捕获请求文件读取错误的异常"></a>2.7.3 如何捕获请求文件读取错误的异常</h4><p>在本服务器程序中，采用 <code>try...except</code> 结构来捕获异常。当请求的文件不存在（可能是文件名错误或路径错误）及其他可能导致文件访问错误（如没有相应权限）时，就会产生 IOError 异常。从而进入异常处理部分代码。</p><p><strong>发送自定义的异常信息给客户端</strong></p><p>在异常处理代码中，定义响应客户端请求文件不存在的响应消息头代码 404 及消息内容not Found。</p><p>将此响应消息头发给客户端，可以使用 socket 的发送方法 <code>send()</code> 完成，发送前需要使用编码方法 <code>encode()</code> 对响应消息进行编码。</p><p><strong>完整代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line"><span class="comment"># Prepare a sever socket </span></span><br><span class="line">serverSocket.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6789</span>))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始WEB服务...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">            connectionSocket, addr = serverSocket.accept()</span><br><span class="line">            message = connectionSocket.recv(<span class="number">1024</span>) <span class="comment"># 获取客户发送的报文</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 读取文件内容</span></span><br><span class="line">            filename = message.split()[<span class="number">1</span>]       <span class="comment"># message=[&quot;POST&quot;, &quot;/index.html&quot;, &quot;HTTP/1.1&quot;, ...]</span></span><br><span class="line">            f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">            outputdata = f.read()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 向套接字发送头部信息</span></span><br><span class="line">            header = <span class="string">&#x27; HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n&#x27;</span> % (<span class="built_in">len</span>(outputdata))</span><br><span class="line">            connectionSocket.send(header.encode())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送请求文件的内容</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">                connectionSocket.send(outputdata[i].encode())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line">            connectionSocket.close()</span><br><span class="line">    <span class="keyword">except</span> IOError:             <span class="comment"># 异常处理</span></span><br><span class="line">            <span class="comment"># 发送文件未找到的消息</span></span><br><span class="line">            header = <span class="string">&#x27; HTTP/1.1 404 not Found&#x27;</span></span><br><span class="line">            <span class="comment">#########Begin#########</span></span><br><span class="line">            connectionSocket.send(header.encode())</span><br><span class="line">            <span class="comment">#########End#########</span></span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line">            connectionSocket.close()</span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    serverSocket.close()</span><br></pre></td></tr></table></figure><p>上面建立了一个只允许一个连接的服务器，在指定端口监听客户端的请求，从客户端发送的请求中提取文件名，若该文件存在于服务器上（如下文的<code>&quot;HelloWorld.html&quot;</code>），则生成一个状态码200的POST报文，并返回该文件；若该文件不存在，则返回一个404 Not Found报文。</p><p><strong>HelloWorld.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><p>在一台主机上的同一目录下放入<code>WebServer.py</code>和<code>HelloWorld.html</code>两个文件，并运行<code>WebServer.py</code>，作为服务器。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.1q8kc9lae4sg.webp#pic_center" width = 48%><p><strong>客户端：</strong></p><p>在另一台主机上打开浏览器，并输入”<a href="http://xxx.xxx.xxx.xxx:6789/HelloWorld.html">http://XXX.XXX.XXX.XXX:6789/HelloWorld.html</a>“ （其中”XXX.XXX.XXX.XXX”是服务器IP地址），以获取服务器上的<code>HelloWorld.html</code>文件。</p><p>一切正常的话，可以看到如下页面：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1kv6ji5c5ygw.webp#pic_center" width = 48%><p>输入新地址<code>&quot;http://XXX.XXX.XXX.XXX:6789/abc.html&quot;</code>，以获取服务器上不存在的<code>abc.html</code>。将出现以下页面（注意页面中的”HTTP ERROR 404”）：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.7jp8f2p1r000.webp#pic_center" width = 48%><h3 id="2-8-示例分析"><a href="#2-8-示例分析" class="headerlink" title="2.8 示例分析"></a>2.8 示例分析</h3><p><strong>1. 服务端</strong></p><p>下面的代码实现了一个提供时间日期的服务器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230420</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 一个提供时间日期的服务器</span></span><br><span class="line"><span class="comment"># @Filename: server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET, gethostname</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1. 创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    <span class="comment"># family=AF_INET - IPv4地址</span></span><br><span class="line">    <span class="comment"># family=AF_INET6 - IPv6地址</span></span><br><span class="line">    <span class="comment"># type=SOCK_STREAM - TCP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_DGRAM - UDP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_RAW - 原始套接字</span></span><br><span class="line">    server = socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2. 绑定IP地址和端口（端口用于区分不同的服务）</span></span><br><span class="line">    <span class="comment"># 同一个时间在同一个端口只能绑定一个服务否则报错</span></span><br><span class="line">    <span class="comment"># server.bind((&#x27;192.168.1.2&#x27;, 1030))</span></span><br><span class="line">    host = gethostname()            <span class="comment"># 获取本地主机名</span></span><br><span class="line">    port = <span class="number">9999</span>                     <span class="comment"># 绑定端口号</span></span><br><span class="line">    server.bind((host, port))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    <span class="comment"># 参数512可以理解为连接队列的大小，超过后排队</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器启动开始监听……&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.通过循环接收客户端的连接并作出相应的处理(提供服务)</span></span><br><span class="line">        <span class="comment"># accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行</span></span><br><span class="line">        <span class="comment"># accept方法返回一个元组其中的第一个元素是客户端对象</span></span><br><span class="line">        <span class="comment"># 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)</span></span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(addr) + <span class="string">&quot;连接到了服务器.&quot;</span>)</span><br><span class="line">        <span class="comment"># 5. 发送数据</span></span><br><span class="line">        client.send(<span class="built_in">str</span>(datetime.now()).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># 6. 断开连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>查找自己电脑IP和端口的方法：<br>  <strong>第一步： Win+R</strong><br>  <strong>第二步： 输入：cmd  然后点击确定（Enter）进入</strong><br>  <strong>第三步： 输入：ipconfig  然后Enter</strong><br>  <strong>第四步： 输入：netstat 然后Enter</strong>  一般用第一个就行</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.1r14az76m0g0.webp#pic_center" width = 48%><p>运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.1lq3ku8fzvkw.webp#pic_left" width = "30%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.v6i83q4ig28.webp#pic_left"  width = "48%"></center></p><p>Windows开启telnet服务，见下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.72oe6hf6xfc0.gif#pic_center" width = 48%><p>当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p><p><strong>2. 客户端</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230420</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 一个接受时间日期的客户端</span></span><br><span class="line"><span class="comment"># @Filename: client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET, gethostname</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字对象默认使用IPv4和TCP协议</span></span><br><span class="line">    <span class="comment"># client = socket()</span></span><br><span class="line">    client = socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.连接到服务器（需要指定IP地址和端口）</span></span><br><span class="line">    <span class="comment"># client.connect((&#x27;10.69.164.78&#x27;, 1030))</span></span><br><span class="line">    host = gethostname()            <span class="comment"># 获取本地主机名</span></span><br><span class="line">    port = <span class="number">9999</span>                     <span class="comment"># 绑定端口号</span></span><br><span class="line">    client.connect((host, port))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.从服务器接受数据, 接收小于 1024 字节的数据</span></span><br><span class="line">    <span class="built_in">print</span>(client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>现在我们打开两个终端，第一个终端执行 <code>server.py</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 server.py</span><br></pre></td></tr></table></figure><p>第二个终端执行 <code>client.py</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 client.py</span><br><span class="line">2023-04-19 17:04:30.293444</span><br></pre></td></tr></table></figure><p>这时我们再打开第一个终端，就会看到有以下信息输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;192.168.1.2&#x27;</span>, 11046)连接到了服务器.</span><br></pre></td></tr></table></figure><p>需要注意的是，上面的服务器并没有使用多线程或者异步I&#x2F;O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p><p><strong>服务器端代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> dumps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自定义线程类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileTransferHandler</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cclient</span>):</span><br><span class="line">            <span class="built_in">super</span>().__init__()</span><br><span class="line">            self.cclient = cclient</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">            my_dict = &#123;&#125;</span><br><span class="line">            my_dict[<span class="string">&#x27;filename&#x27;</span>] = <span class="string">&#x27;guido.jpg&#x27;</span></span><br><span class="line">            <span class="comment"># JSON是纯文本不能携带二进制数据</span></span><br><span class="line">            <span class="comment"># 所以图片的二进制数据要处理成base64编码</span></span><br><span class="line">            my_dict[<span class="string">&#x27;filedata&#x27;</span>] = data</span><br><span class="line">            <span class="comment"># 通过dumps函数将字典处理成JSON字符串</span></span><br><span class="line">            json_str = dumps(my_dict)</span><br><span class="line">            <span class="comment"># 发送JSON字符串</span></span><br><span class="line">            self.cclient.send(json_str.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            self.cclient.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    server = socket()</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(区分不同的服务)</span></span><br><span class="line">    server.bind((<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;服务器启动开始监听...&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guido.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将二进制数据处理成base64再解码成字符串</span></span><br><span class="line">        data = b64encode(f.read()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 启动一个线程来处理客户端的请求</span></span><br><span class="line">        FileTransferHandler(client).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> loads</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    client = socket()</span><br><span class="line">    client.connect((<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 定义一个保存二进制数据的对象</span></span><br><span class="line">    in_data = <span class="built_in">bytes</span>()</span><br><span class="line">    <span class="comment"># 由于不知道服务器发送的数据有多大每次接收1024字节</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="comment"># 将收到的数据拼接起来</span></span><br><span class="line">        in_data += data</span><br><span class="line">        data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将收到的二进制数据解码成JSON字符串并转换成字典</span></span><br><span class="line">    <span class="comment"># loads函数的作用就是将JSON字符串转成字典对象</span></span><br><span class="line">    my_dict = loads(in_data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    filename = my_dict[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">    filedata = my_dict[<span class="string">&#x27;filedata&#x27;</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/Hao/&#x27;</span> + filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将base64格式的数据解码成二进制数据并写入文件</span></span><br><span class="line">        f.write(b64decode(filedata))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;图片已保存.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“&#x2F;”总共64个字符表示从000000到111111的64种状态。<a href="https://zh.wikipedia.org/wiki/Base64">维基百科</a>上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>网络编程入门：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.网络编程入门和网络应用开发.md</a></li><li>Python3 网络编程：<a href="https://www.nowcoder.com/tutorial/10005/99e037cb31a1486a8cf8ea61eb58dc8c">https://www.nowcoder.com/tutorial/10005/99e037cb31a1486a8cf8ea61eb58dc8c</a></li><li>WEB服务器编程实现：<a href="https://www.educoder.net/shixuns/synqujxr/challenges">https://www.educoder.net/shixuns/synqujxr/challenges</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将首先利用 Python 实现面向TCP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。其次还将学习 HTTP 协议格式的相关知识。在此基础上，本篇将用 Python 语言开发一个简单的 Web 服务器，它仅能处理一个HTTP连接请求。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP 套接字" scheme="https://qxienote.com/tags/TCP-%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（四）-- TCP/IP协议族详解</title>
    <link href="https://qxienote.com/article/1ee3e5d0.html"/>
    <id>https://qxienote.com/article/1ee3e5d0.html</id>
    <published>2023-06-08T03:17:18.000Z</published>
    <updated>2023-06-10T07:28:35.575Z</updated>
    
    <content type="html"><![CDATA[<p>TCP&#x2F;IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。TCP&#x2F;IP协议模型，包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><span id="more"></span><p>基于TCP&#x2F;IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP&#x2F;IP模型与OSI模型各层的对照关系。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5pqdp6bd4sw0.webp#pic_center" width = 48%><p><strong>1) 网络接口层</strong><br>        主要是指物理层次的一些接口，比如电缆等。</p><p><strong>2) 网络层</strong><br>        提供独立于硬件的逻辑寻址，实现物理地址与逻辑地址的转换。<br>        在 TCP &#x2F; IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）。</p><p><strong>3) 传输层</strong><br>        为网络提供了流量控制，错误控制和确认服务。<br>        在 TCP &#x2F; IP 协议族中有两个互不相同的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。</p><p><strong>4) 应用层</strong><br>        为网络排错，文件传输，远程控制和 Internet 操作提供具体的应用程序</p><p><strong><font color=#9900CC>重要协议：<ul><li>http (文本传输协议  当我们访问网页时使用的是http协议)  https 动态网页数据传输</li><li>  ftp  (文件传输协议  专门用于文件传输) </li><li>dhcp (自动ip地址分配协议   网络中要有一个dhcp服务器(路由器)) </li><li>   dns  (实现了域名到ip地址的解析)    ip地址    域名(www.qq.com) </li>实际网络之间通信用的是ip地址<br></br>dns服务器记录了常用的ip地址和域名的对应关系<li>icmp (ping 命令通过icmp协议发送出去的、装载错误报文信息) </li></ul></font> </strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">容易碰到的笔试面试题</span><br><span class="line">        1) tcp/ip有哪几层</span><br><span class="line">                应用层、传输层、网络层、网络接口层</span><br><span class="line">        2) 传输层有哪些协议</span><br><span class="line">                tcp   udp    icmp</span><br><span class="line">        3) 应用层有哪些协议</span><br><span class="line">                http  ftp  dns  dhcp</span><br><span class="line">        4) 请描述同一网段下主机A ping 主机B的全过程   (百度)</span><br><span class="line">                同一网段下   没用到dns</span><br><span class="line">                ping 192.168.1.100(不知道对方的网卡地址 MAC   MAC地址：每一个网卡有一个唯一地址(物理地址))    </span><br><span class="line">                如何得到对方MAC地址(用arp协议)</span><br><span class="line">                1) A发送一个ARP广播包，询问192.168.1.100的MAC地址是多少</span><br><span class="line">                2) B回送ARP包，包中携带自己的MAC地址(00 50 A9 90 88 07)    </span><br><span class="line">                3) A记录ip地址，ARP表中(以后不用发送广播包)（可以不写）</span><br><span class="line">                4) A 发送一个icmp报文给B</span><br><span class="line">                5) B收到回送一个icmp报文    </span><br></pre></td></tr></table></figure><hr><h2 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1 网络层"></a>1 网络层</h2><h3 id="1-1-IP协议"><a href="#1-1-IP协议" class="headerlink" title="1.1 IP协议"></a>1.1 IP协议</h3><p>IP协议是TCP&#x2F;IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><ul><li>A类IP地址: 0.0.0.0~127.255.255.255    IP 地址的前 8 位代表网络 ID ，后 24 位代表主机 ＩＤ。</li><li>B类IP地址:128.0.0.0~191.255.255.255   IP 地址的前 16 位代表网络 ID ，后 16 位代表主机 ＩＤ。</li><li>C类IP地址:192.0.0.0~239.255.255.255</li></ul><p>全是 0 的主机 ID 代表网络本身，比如说 IP 地址为 130.100.0.0 指的是网络 ID 为130.100 的 B 类地址。</p><p>全是 1 的主机 ID 代表广播，是用于向该网络中的全部主机方法消息的。 IP 地址为 130.100.255.255 就是网络 ID 为 130.100 网络的广播地址（二进制 IP 地址中全是 1 ，转换为十进制就是 255 ）</p><p>以十进制 127 开头的地址都是环回地址。目的地址是环回地址的消息，其实是由本地发送和接收的。主要是用于测试 TCP&#x2F;IP 软件是否正常工作。我们用 ping 功能的时候，一般用的环回地址是 127.0.0.1</p><h4 id="1-3-IP协议头"><a href="#1-3-IP协议头" class="headerlink" title="1.3 IP协议头"></a>1.3 IP协议头</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.2hkf0vw2kgw0.webp#pic_center" width = 48%><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64</p><h3 id="1-4-ARP及RARP协议"><a href="#1-4-ARP及RARP协议" class="headerlink" title="1.4 ARP及RARP协议"></a>1.4 ARP及RARP协议</h3><p>ARP 是根据IP地址获取MAC地址的一种协议。</p><p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p><p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p><p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>RARP协议的工作与此相反，不做赘述。</p><h3 id="1-5-ICMP协议"><a href="#1-5-ICMP协议" class="headerlink" title="1.5 ICMP协议"></a>1.5 ICMP协议</h3><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><hr><h2 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2 传输层"></a>2 传输层</h2><h3 id="2-1-TCP和UDP协议"><a href="#2-1-TCP和UDP协议" class="headerlink" title="2.1 TCP和UDP协议"></a>2.1 TCP和UDP协议</h3><p>TCP&#x2F;UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6oc8u9v1cf40.webp#pic_center" width = 48%><p><strong>面向报文(UDP)</strong></p><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文数据—大小有限制（64k）。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p><p><strong>面向字节流(TCP)</strong></p><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p><h3 id="2-2-TCP和UDP协议的一些应用"><a href="#2-2-TCP和UDP协议的一些应用" class="headerlink" title="2.2 TCP和UDP协议的一些应用"></a>2.2 TCP和UDP协议的一些应用</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.mwy4ndfwxgw.webp#pic_center" width = 48%><p><strong>什么时候应该使用TCP？</strong></p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p><strong>什么时候应该使用UDP？</strong></p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><hr><h2 id="3-TCP“三次握手”和“四次挥手”"><a href="#3-TCP“三次握手”和“四次挥手”" class="headerlink" title="3 TCP“三次握手”和“四次挥手”"></a>3 TCP“三次握手”和“四次挥手”</h2><h3 id="3-1-三次握手"><a href="#3-1-三次握手" class="headerlink" title="3.1 三次握手"></a>3.1 三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。<font color=#9900CC><strong>三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</font></strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.3ue72zpsrbs0.webp#pic_center" width = 48%><ol><li>第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ol><p><strong>为什么要三次握手？</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><h3 id="3-2-四次挥手"><a href="#3-2-四次挥手" class="headerlink" title="3.2 四次挥手"></a>3.2 四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.4cz29awk4ty0.webp#pic_center" width = 40%><ol><li>第一次挥手： 主机A（可以使客户端，也可以是服务器端），设置Sequence Number，向主机B发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机A没有数据要发送给主机B了；</li><li>第二次挥手： 主机B收到了主机A发送的FIN报文段，向主机A回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机A进入FIN_WAIT_2状态；主机B告诉主机A，我“同意”你的关闭请求；</li><li>第三次挥手： 主机B向主机A发送FIN报文段，请求关闭连接，同时主机B进入LAST_ACK状态；</li><li>第四次挥手： 主机A收到主机B发送的FIN报文段，向主机B发送ACK报文段，然后主机A进入TIME_WAIT状态；主机B收到主机A的ACK报文段以后，就关闭连接；此时，主机A等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机A也可以关闭连接了。</li></ol><p><strong>为什么要四次挥手？</strong> </p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机A发出FIN报文段时，只是表示主机A已经没有数据要发送了，主机A告诉主机B，它的数据已经全部发送完毕了；但是，这个时候主机A还是可以接受来自主机B的数据；当主机B返回ACK报文段时，表示它已经知道主机A没有数据发送了，但是主机B还是可以发送数据到主机A的；当主机B也发送了FIN报文段时，这个时候就表示主机B也没有数据要发送了，就会告诉主机A，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么在第四次挥手后会有2个MSL的延时？</strong></p><p>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。</p><p>假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。</p><hr><h2 id="4-TCP流量控制"><a href="#4-TCP流量控制" class="headerlink" title="4 TCP流量控制"></a>4 TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd &#x3D; 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。ACK表示首部中的确认位ACK，ack表示确认字段的值ack。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.1txsbpry9oxs.webp#pic_center" width = 48%><p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd &#x3D; 300 ，第二次又减到了 rwnd &#x3D; 100 ，最后减到 rwnd &#x3D; 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK &#x3D; 1 ，只有在ACK&#x3D;1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><hr><h2 id="5-TCP拥塞控制"><a href="#5-TCP拥塞控制" class="headerlink" title="5 TCP拥塞控制"></a>5 TCP拥塞控制</h2><h3 id="5-1-慢开始和拥塞避免"><a href="#5-1-慢开始和拥塞避免" class="headerlink" title="5.1 慢开始和拥塞避免"></a>5.1 慢开始和拥塞避免</h3><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p><strong>慢开始算法</strong></p><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.786waxk5a080.webp#pic_center" width = 48%><p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>另外，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li></ul><p><strong>拥塞避免</strong></p><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.vj0ehnw7ib4.webp#pic_center" width = 48%><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.5kw010mrs6s0.webp#pic_center" width = 48%><h3 id="5-2-快重传和快恢复"><a href="#5-2-快重传和快恢复" class="headerlink" title="5.2 快重传和快恢复"></a>5.2 快重传和快恢复</h3><p><strong>快重传</strong></p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/034.4np51k8fxnk0.webp#pic_center" width = 48%><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><p>应用层做为 TCP&#x2F;IP 协议的最高层级，对于我们移动开发来说，是接触最多的。</p><p><strong>运行在TCP协议上的协议：</strong></p><ul><li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 </li><li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本</li><li>FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。 </li><li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 </li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li><li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li><li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li></ul><p><strong>运行在UDP协议上的协议：</strong></p><ul><li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。 </li><li>NTP（Network Time Protocol，网络时间协议），用于网络同步。 </li><li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li></ul><p><strong>其他：</strong></p><ul><li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。</li><li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。 </li><li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。 </li><li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li></ul><hr><p>面试问题整理<br><a href="https://blog.csdn.net/u013354486/article/details/80588916">面试问题整理之TCP&#x2F;IP和网络编程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP&amp;#x2F;IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。TCP&amp;#x2F;IP协议模型，包含了一系列构成互联网基础的网络协议，是Internet的核心协议。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP 协议族" scheme="https://qxienote.com/tags/TCP-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（三）-- SSL/TLS协议运行机制的概述</title>
    <link href="https://qxienote.com/article/ae7157b3.html"/>
    <id>https://qxienote.com/article/ae7157b3.html</id>
    <published>2023-06-08T03:16:54.000Z</published>
    <updated>2023-06-10T07:49:45.596Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL&#x2F;TLS协议运行机制的概述》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --><p>互联网的通信安全，建立在SSL/TLS协议之上。</p><!-- /div --><!-- div id="more" class="asset-more" --><p>本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅<a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC文档</a>。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020501.jpg" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020501.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>一、作用</h2><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><blockquote>  <p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p><p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p><p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p></blockquote><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><blockquote>  <p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p><p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p></blockquote><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><p>——————————————————————————————————————————————————————————</p><h2>二、历史</h2><p>互联网加密通信协议的历史，几乎与互联网一样长。</p><blockquote>  <p>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</p><p>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</p><p>1996年，SSL 3.0版问世，得到大规模应用。</p><p>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer" target="_blank">TLS</a> 1.0版。</p><p>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的<a href="https://tools.ietf.org/html/rfc6176" target="_blank">修订版</a>。</p></blockquote><p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p><p>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p><p>——————————————————————————————————————————————————————————</p><h3>三、基本的运行过程</h3><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><p><strong>（1）如何保证公钥不被篡改？</strong></p><blockquote>  <p>解决方法：将公钥放在<a href="https://en.wikipedia.org/wiki/Digital_certificate" target="_blank">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p></blockquote><p><strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong></p><blockquote>  <p>解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</p></blockquote><p>因此，SSL/TLS协议的基本过程是这样的：</p><blockquote>  <p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成"对话密钥"。</p><p>（3） 双方采用"对话密钥"进行加密通信。</p></blockquote><p>上面过程的前两步，又称为"握手阶段"（handshake）。</p><p>——————————————————————————————————————————————————————————</p><h2>四、握手阶段的详细过程</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。</p><h3>4.1 客户端发出请求（ClientHello）</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p><p>在这一步，客户端主要向服务器提供以下信息。</p><blockquote>  <p>（1） 支持的协议版本，比如TLS 1.0版。</p><p>（2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。</p><p>（3） 支持的加密方法，比如RSA公钥加密。</p><p>（4） 支持的压缩方法。</p></blockquote><p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="https://tools.ietf.org/html/rfc4366" target="_blank">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p><h3>4.2 服务器回应（SeverHello）</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><blockquote>  <p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。</p><p>（3） 确认使用的加密方法，比如RSA公钥加密。</p><p>（4） 服务器证书。</p></blockquote><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><h3>4.3 客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><blockquote>  <p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</p><p>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。</p><p>至于为什么一定要用三个随机数，来生成"会话密钥"，<a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank">dog250</a>解释得很好：</p><blockquote>  <p>"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"</p></blockquote><p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><h3>4.4 服务器的最后回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。</p><blockquote>  <p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020503.gif" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020503.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>五、参考链接</h2><ul><li>MicroSoft TechNet, <a href="https://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx" target="_blank">SSL/TLS in Detail</a></li><li>Jeff Moser, <a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html" target="_blank">The First Few Milliseconds of an HTTPS Connection</a></li><li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">Transport Layer Security</a></li><li>StackExchange, <a href="https://security.stackexchange.com/questions/20803/how-does-ssl-work" target="_blank">How does SSL work?</a></li></ul><!-- /div --></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章转载自阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot;&gt;《SSL&amp;#x2F;TLS协议运行机制的概述》&lt;/a&gt;，供学习使用。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="SSL/TLS 协议" scheme="https://qxienote.com/tags/SSL-TLS-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络篇（二）-- HTTP协议入门</title>
    <link href="https://qxienote.com/article/279b4884.html"/>
    <id>https://qxienote.com/article/279b4884.html</id>
    <published>2023-06-08T03:16:31.000Z</published>
    <updated>2023-06-10T03:11:07.247Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP协议入门》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --><p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p><!-- /div --><!-- div id="more" class="asset-more" --><p>本文介绍 HTTP 协议的历史演变和设计思路。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.7dhbrewkz900.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.7dhbrewkz900.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的<a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank"><strong>应用层协议</strong></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p><pre class=" language-http"><code class=" language-http">GET /index.html</code></pre><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><pre><code class="language-html">&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>服务器发送完毕，就关闭TCP连接。</p><p>——————————————————————————————————————————————————————————</p><h2>二、HTTP/1.0</h2><h3>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><pre class=" language-http"><code class=" language-http">GET / HTTP/1.0<span class="token keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<span class="token keyword">Accept:</span> */*</code></pre><p>可以看到，这个格式与0.9版有很大变化。</p><p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p><h3>2.3 回应格式</h3><p>服务器的回应如下。</p><pre class=" language-http"><code class=" language-http">HTTP/1.0 200 OK <span class="token keyword">Content-Type:</span> text/plain<span class="token keyword">Content-Length:</span> 137582<span class="token keyword">Expires:</span> Thu, 05 Dec 1997 16:00:00 GMT<span class="token keyword">Last-Modified:</span> Wed, 5 August 1996 15:55:28 GMT<span class="token keyword">Server:</span> Apache 0.84&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>回应的格式是"头信息 + 一个空行（<code>\r\n</code>） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。</p><h3>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><blockquote>  <ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg</li><li>image/png</li><li>image/svg+xml</li><li>audio/mp4</li><li>video/mp4</li><li>application/javascript</li><li>application/pdf</li><li>application/zip</li><li>application/atom+xml</li></ul></blockquote><p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p><p>除了预定义的类型，厂商也可以自定义类型。</p><pre class=" language-http"><code class=" language-http">application/vnd.debian.binary-package</code></pre><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p><p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Type:</span> text/html; charset=utf-8</code></pre><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Accept:</span> */*</code></pre><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p><pre><code class="language-html">&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;!-- 等同于 --&gt;&lt;meta charset="utf-8" /&gt; </code></pre><h3>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Encoding:</span> gzip<span class="token keyword">Content-Encoding:</span> compress<span class="token keyword">Content-Encoding:</span> deflate</code></pre><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Accept-Encoding:</span> gzip, deflate</code></pre><h3>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> keep-alive</code></pre><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> keep-alive</code></pre><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><p>——————————————————————————————————————————————————————————</p><h2>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h3>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> close</code></pre><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p><h3>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h3>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Length:</span> 3495</code></pre><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank">"分块传输编码"</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Transfer-Encoding:</span> chunked</code></pre><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><pre class=" language-http"><code class=" language-http">HTTP/1.1 200 OK<span class="token keyword">Content-Type:</span> text/plain<span class="token keyword">Transfer-Encoding:</span> chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0</code></pre><h3>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p><p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p><blockquote><pre class=" language-http"><code class=" language-http"><span class="token keyword">Host:</span> www.example.com</code></pre></blockquote><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank">"队头堵塞"</a>（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><p>——————————————————————————————————————————————————————————</p><h2>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 </p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><p>——————————————————————————————————————————————————————————</p><h2>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><h3>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><p>——————————————————————————————————————————————————————————</p><h3>六、参考链接</h3><ul><li><a href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/" target="_blank">Journey to HTTP/2</a>, by Kamran Ahmed</li><li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">HTTP</a>, by Wikipedia</li><li><a href="https://tools.ietf.org/html/rfc1945" target="_blank">HTTP/1.0 Specification</a></li><li><a href="https://http2.github.io/http2-spec/" target="_blank">HTTP/2 Specification</a></li></ul> <!-- /div --></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章转载自阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/08/http.html&quot;&gt;《HTTP协议入门》&lt;/a&gt;，供学习使用。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP 协议" scheme="https://qxienote.com/tags/HTTP-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
