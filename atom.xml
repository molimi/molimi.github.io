<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CarpeDiem&#39;s Blog</title>
  
  <subtitle>虽不能至，心向往之</subtitle>
  <link href="https://qxienote.com/atom.xml" rel="self"/>
  
  <link href="https://qxienote.com/"/>
  <updated>2023-08-06T14:02:53.687Z</updated>
  <id>https://qxienote.com/</id>
  
  <author>
    <name>Carpe Diem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL基础篇（四）-- 数据表的基本操作</title>
    <link href="https://qxienote.com/article/636c7070.html"/>
    <id>https://qxienote.com/article/636c7070.html</id>
    <published>2023-08-06T13:26:34.000Z</published>
    <updated>2023-08-06T14:02:53.687Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要学习数据表的基本操作，包括创建数据表、修改数据表、修改字段、删除数据表、查看表结构、添加字段、复制表。</p><span id="more"></span><p>数据表是数据库的重要组成部分，每一个数据库都是由若干个数据表组成的。换句话说，没有数据表就无法在数据库中存放数据。</p><h2 id="1-创建数据表"><a href="#1-创建数据表" class="headerlink" title="1 创建数据表"></a>1 创建数据表</h2><h3 id="1-1-表创建基础"><a href="#1-1-表创建基础" class="headerlink" title="1.1 表创建基础"></a>1.1 表创建基础</h3><p>熟悉Excel的小伙伴肯定都知道，需要先新建工作簿，然后在该工作簿里新建表格，相似的过程，创建数据库后，并在该数据库中创建数据表。</p><p>可使用SQL的<code>CREATE TABLE</code>语句创建表，必须给出以下信息：</p><ul><li>新表的名字，在关键字CREATE TABLE之后给出；</li><li>表列的名字和定义，用逗号分隔。</li></ul><p>语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名<span class="number">1</span> 类型[(宽度)] [约束条件] [comment <span class="string">&#x27;字段说明&#x27;</span>],</span><br><span class="line">字段名<span class="number">2</span> 类型[(宽度)] [约束条件] [comment <span class="string">&#x27;字段说明&#x27;</span>],</span><br><span class="line">字段名<span class="number">3</span> 类型[(宽度)] [约束条件] [comment <span class="string">&#x27;字段说明&#x27;</span>]</span><br><span class="line">)[表的一些设置];</span><br></pre></td></tr></table></figure><p>CREATE TABLE 语句的主要语法及使用说明如下：</p><ul><li>CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。</li><li>&lt;表名&gt;：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，’mydb’.’mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。</li><li>&lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。</li><li>默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。</li></ul><p><strong>温馨提示：</strong> </p><ul><li>要创建的表的名称不区分大小写，不能使用SQL语言中的关键字，如DROP、ALTER、INSERT等。宽度和约束条件为可选参数，字段名和类型是必须的。每列的定义以列名（字段名，它在表中必须是唯一的）开始，后跟列的数据类型。各列之间用逗号分隔。</li><li>在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。如果你仅想在一个表不存在时创建它，应该在表名后给出<code>IF NOT EXISTS</code>。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。</li></ul><h3 id="1-2-使用NULL值"><a href="#1-2-使用NULL值" class="headerlink" title="1.2 使用NULL值"></a>1.2 使用NULL值</h3><p>允许NULL值的列也允许在插入行时不给出该列的值。不允许NULL值的列不接受该列没有值的行，换句话说，在插入或更新行时，该列必须有值。</p><p>每个表列或者是NULL列，或者是NOT NULL列，这种状态在创建时由表的定义规定。请看下面的例子：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/022.4i1f1vqaxt60.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/022.4i1f1vqaxt60.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><p><strong>温馨提示：</strong>不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定。</p><h3 id="1-3-主键和外键"><a href="#1-3-主键和外键" class="headerlink" title="1.3 主键和外键"></a>1.3 主键和外键</h3><p>主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p><p>primary key：标识该字段为该表的主键，可以唯一的标识记录，插入重复的会报错。<br>方式1：跟在列后，如下：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/023.4qa6sgkz77c0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/023.4qa6sgkz77c0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>方式2：在所有列定义之后定义，如下：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/024.44a8qgo49e40.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/024.44a8qgo49e40.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>方式3：支持多字段作为主键，多个之间用逗号隔开，语法：&#96;primary key(字段1, 字段2, 字段n)，示例：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/025.3i2pqjn24rs0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/025.3i2pqjn24rs0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>方式4：为表中的字段设置外键<br>语法：foreign key(当前表的列名) references 引用的外键表(外键表中字段名称）<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/026.7gtuhbk4vio0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/026.7gtuhbk4vio0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>注意一下几点：</p><ul><li>两张表中需要建立外键关系的字段类型需要一致</li><li>要设置外键的字段不能为主键</li><li>被引用的字段需要为主键</li><li>被插入的值在外键表必须存在，如上面向test10中插入ts9_a为2的时候报错了，原因：2的值在test9表中不存在</li></ul><p>温馨提示：主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识。每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。</p><p>unique key(uq)：标识该字段的值是唯一的。支持一个到多个字段，插入重复的值会报违反唯一约束，会插入失败。<br>方式1：跟在字段后，如下所示：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/027.2bhq8l0yt5no.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/027.2bhq8l0yt5no.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><br>方式2：所有列定义之后定义，如下：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/028.3tabh9ojp0w0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/028.3tabh9ojp0w0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>方式3：支持多字段，多个之间用逗号隔开，语法：<code>unique key(字段1,字段2,字段n)</code>，示例：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/029.6lvq5j5nauk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/029.6lvq5j5nauk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><h3 id="1-4-使用AUTO-INCREMENT"><a href="#1-4-使用AUTO-INCREMENT" class="headerlink" title="1.4 使用AUTO_INCREMENT"></a>1.4 使用AUTO_INCREMENT</h3><p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），给该列赋予下一个可用的值。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/030.3wbswm2clw4.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/030.3wbswm2clw4.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><p><strong>温馨提示：</strong>关于自动增长字段的初始值、步长可以在mysql中进行设置，比如设置初始值为1万，每次增长10。自增长列当前值存储在内存中，数据库每次重启之后，会查询当前表中自增列的最大值作为当前值，如果表数据被清空之后，数据库重启了，自增列的值将从初始值开始。</p><h3 id="1-5-指定默认值"><a href="#1-5-指定默认值" class="headerlink" title="1.5 指定默认值"></a>1.5 指定默认值</h3><p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定。<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/031.7gmgmmbdauw0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/031.7gmgmmbdauw0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>温馨提示：与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</p><h3 id="1-6-引擎类型"><a href="#1-6-引擎类型" class="headerlink" title="1.6 引擎类型"></a>1.6 引擎类型</h3><p>在创建表格时，常用的就是<code>ENGINE=InnoDB</code>；与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎。在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候，此引擎都隐藏在DBMS内，不需要过多关注它。</p><p>如果省略ENGINE&#x3D;语句，则使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE&#x3D;语句很重要的原因。</p><p>常用的引擎：</p><ul><li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）<br>中，速度很快（特别适合于临时表）；</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li></ul><p><strong>温馨提示：</strong>混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p><h2 id="2-修改数据表"><a href="#2-修改数据表" class="headerlink" title="2 修改数据表"></a>2 修改数据表</h2><p>修改数据表的前提是数据库中已经存在该表。修改表指的是修改数据库中已经存在的数据表的结构。</p><h3 id="2-1-修改表名"><a href="#2-1-修改表名" class="headerlink" title="2.1 修改表名"></a>2.1 修改表名</h3><p>MySQL 通过 ALTER TABLE 语句来实现表名的修改，语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>旧表名<span class="operator">&gt;</span> RENAME [<span class="keyword">TO</span>] <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span>；</span><br></pre></td></tr></table></figure><p>其中，TO 为可选参数，使用与否均不影响结果。</p><p><strong>温馨提示：</strong> 使用<code>ALTER TABLE</code>要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p><h3 id="2-2-修改表字符集"><a href="#2-2-修改表字符集" class="headerlink" title="2.2 修改表字符集"></a>2.2 修改表字符集</h3><p>MySQL 通过 ALTER TABLE 语句来实现表字符集的修改，语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 [<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span> [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>其中，DEFAULT 为可选参数，使用与否均不影响结果。</p><h2 id="3-修改字段"><a href="#3-修改字段" class="headerlink" title="3 修改字段"></a>3 修改字段</h2><h3 id="3-1-修改字段名称"><a href="#3-1-修改字段名称" class="headerlink" title="3.1 修改字段名称"></a>3.1 修改字段名称</h3><p>MySQL 中修改表字段名的语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> CHANGE <span class="operator">&lt;</span>旧字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新数据类型<span class="operator">&gt;</span>；</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>旧字段名：指修改前的字段名；</li><li>新字段名：指修改后的字段名；</li><li>新数据类型：指修改后的数据类型，如果不需要修改字段的数据类型，- 可以将新数据类型设置成与原来一样，但数据类型不能为空。</li></ul><p><strong>温馨提示：</strong> 由于不同类型的数据在机器中的存储方式及长度并不相同，修改数据类型可能会影响数据表中已有的数据记录，因此，当数据表中已经有数据时，不要轻易修改数据类型。</p><h3 id="3-2-修改字段数据类型"><a href="#3-2-修改字段数据类型" class="headerlink" title="3.2 修改字段数据类型"></a>3.2 修改字段数据类型</h3><p>修改字段的数据类型就是把字段的数据类型转换成另一种数据类型。在 MySQL 中修改字段数据类型的语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> MODIFY <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>表名：指要修改数据类型的字段所在表的名称；</li><li>字段名：指需要修改的字段；</li><li>数据类型：指修改后字段的新数据类型。</li></ul><h3 id="3-3-删除字段"><a href="#3-3-删除字段" class="headerlink" title="3.3 删除字段"></a>3.3 删除字段</h3><p>删除字段是将数据表中的某个字段从表中移除，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span>；</span><br></pre></td></tr></table></figure><p>其中，“字段名”指需要从表中删除的字段的名称。</p><h2 id="4-删除数据表"><a href="#4-删除数据表" class="headerlink" title="4 删除数据表"></a>4 删除数据表</h2><p>在删除表的同时，表的结构和表中所有的数据都会被删除，因此在删除数据表之前最好先备份，以免造成无法挽回的损失。删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tb_test;</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 用户必须拥有执行<code>DROP TABLE</code>命令的权限，否则数据表不会被删除。表被删除时，用户在该表上的权限不会自动删除。</p><h2 id="5-删除被其他表关联的主表"><a href="#5-删除被其他表关联的主表" class="headerlink" title="5 删除被其他表关联的主表"></a>5 删除被其他表关联的主表</h2><p>数据表之间经常存在外键关联的情况，这时如果直接删除父表，会破坏数据表的完整性，也会删除失败。</p><p>删除父表有以下两种方法：</p><ul><li>先删除与它关联的子表，再删除父表；但是这样会同时删除两个表中的数据。</li><li>将关联表的外键约束取消，再删除父表；适用于需要保留子表的数据，只删除父表的情况。</li></ul><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/032.3v5rlo8lxpe0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/032.3v5rlo8lxpe0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><h2 id="6-查看表结构命令"><a href="#6-查看表结构命令" class="headerlink" title="6 查看表结构命令"></a>6 查看表结构命令</h2><h3 id="6-1-以表格的形式展示表结构"><a href="#6-1-以表格的形式展示表结构" class="headerlink" title="6.1 以表格的形式展示表结构"></a>6.1 以表格的形式展示表结构</h3><p>DESCRIBE&#x2F;DESC 语句会以表格的形式来展示表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span>\<span class="keyword">desc</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>; </span><br></pre></td></tr></table></figure><h3 id="6-2-以SQL语句的形式展示表结构"><a href="#6-2-以SQL语句的形式展示表结构" class="headerlink" title="6.2 以SQL语句的形式展示表结构"></a>6.2 以SQL语句的形式展示表结构</h3><p>SHOW CREATE TABLE 命令会以 SQL 语句的形式来展示表信息。和 DESCRIBE 相比，SHOW CREATE TABLE 展示的内容更加丰富，它可以查看表的存储引擎和字符编码；另外，你还可以通过\g或者\G参数来控制展示格式。</p><p><code>SHOW CREATE TABLE</code>的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加\g或者\G参数可以改变展示形式。</p><h2 id="7-数据表添加字段"><a href="#7-数据表添加字段" class="headerlink" title="7 数据表添加字段"></a>7 数据表添加字段</h2><p>MySQL 数据表是由行和列构成的，通常把表的“列”称为字段（Field），把表的“行”称为记录（Record）。随着业务的变化，可能需要在已有的表中添加新的字段。MySQL 允许在开头、中间和结尾处添加字段。</p><p>一个完整的字段包括字段名、数据类型和约束条件。MySQL 添加字段的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[约束条件];</span><br></pre></td></tr></table></figure><p>这种语法格式默认在表的最后位置（最后一列的后面）添加新字段。</p><h3 id="7-1-在开头添加字段"><a href="#7-1-在开头添加字段" class="headerlink" title="7.1 在开头添加字段"></a>7.1 在开头添加字段</h3><p>MySQL 默认在表的最后位置添加新字段，如果希望在开头位置（第一列的前面）添加新字段，那么可以使用 FIRST 关键字，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [约束条件] <span class="keyword">FIRST</span>;</span><br></pre></td></tr></table></figure><h3 id="7-2-在中间位置添加字段"><a href="#7-2-在中间位置添加字段" class="headerlink" title="7.2 在中间位置添加字段"></a>7.2 在中间位置添加字段</h3><p>MySQL 除了允许在表的开头位置和末尾位置添加字段外，还允许在中间位置（指定的字段之后）添加字段，此时需要使用 AFTER 关键字，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [约束条件] AFTER <span class="operator">&lt;</span>已经存在的字段名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong>AFTER 的作用是将新字段添加到某个已有字段后面。只能在某个已有字段的后面添加新字段，不能在它的前面添加新字段。</p><h2 id="8-复制表"><a href="#8-复制表" class="headerlink" title="8 复制表"></a>8 复制表</h2><h3 id="8-1-只复制表结构"><a href="#8-1-只复制表结构" class="headerlink" title="8.1 只复制表结构"></a>8.1 只复制表结构</h3><p>语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 被复制的表名;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/033.69rtqxx0tuk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/033.69rtqxx0tuk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><h3 id="8-2-复制表结构-数据"><a href="#8-2-复制表结构-数据" class="headerlink" title="8.2 复制表结构+数据"></a>8.2 复制表结构+数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 [<span class="keyword">as</span>] <span class="keyword">select</span> 字段,... <span class="keyword">from</span> 被复制的表 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/034.nuivi0zcwr4.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/034.nuivi0zcwr4.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要学习数据表的基本操作，包括创建数据表、修改数据表、修改字段、删除数据表、查看表结构、添加字段、复制表。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="MySQL 基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MySQL-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="创建数据表" scheme="https://qxienote.com/tags/%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础篇（三）-- 数据类型</title>
    <link href="https://qxienote.com/article/ba595a63.html"/>
    <id>https://qxienote.com/article/ba595a63.html</id>
    <published>2023-08-06T13:26:19.000Z</published>
    <updated>2023-08-06T14:03:39.117Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习MySQL中的串数据类型（CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM、SET）、数值数据类型（TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT、FLOAT、DOUBLE、DECIMAL）、日期、时间类型（ YEAR、TIME、DATE、DATETIME 和 TIMESTAMP）、二进制类型（ BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB）。</p><span id="more"></span><p>数据表由多个字段组成，每个字段在进行数据定义的时候都要确定不同的数据类型。向每个字段插入的数据内容决定了该字段的数据类型。数据类型用于以下目的：</p><ul><li>数据类型允许限制可存储在列中的数据。例如，数值数据类型列只能接受数值。</li><li>数据类型允许在内部更有效地存储数据。可以用一种比文本串更简洁的格式存储数值和日期时间值。</li><li>数据类型允许变换排序顺序。如果所有数据都作为串处理，则1位于10之前，而10又位于2之前（串以字典顺序排序，从左边开始比较，一次一个字符）。作为数值数据类型，数值才能正确排序。</li></ul><p>在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失）。</p><h2 id="1-串数据类型"><a href="#1-串数据类型" class="headerlink" title="1 串数据类型"></a>1 串数据类型</h2><p>最常用的数据类型是串数据类型。它们存储串，如名字、地址、电话号码、邮政编码等。有两种基本的串类型，分别为定长串和变长串(如下表所示)</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/011.zm7qj4p8z00.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/011.zm7qj4p8z00.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">串数据类型</div> </center><p>定长串接受长度固定的字符串，其长度是在创建表时指定的。例如，名字列可允许30个字符，而社会安全号列允许11个字符（允许的字符数目中包括两个破折号）。定长列不允许多于指定的字符数目。它们分配的存储空间与指定的一样多。</p><p>变长串存储可变长度的文本。有些变长数据类型具有最大的定长，而有些则是完全变长的。不管是哪种，只有指定的数据得到保存（额外的数据不保存）TEXT属于变长串类型。</p><blockquote><p>既然变长数据类型这样灵活，为什么还要使用定长数据类型？回答是因为性能。MySQL处理定长列远比处理变长列快得多。此外，MySQL不允许对变长列（或一个列的可变部分）进行索引。这也会极大地影响性能。</p></blockquote><p>温馨提示：不管使用何种形式的串数据类型，串值都必须括在引号内（通常单引号更好）。</p><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th>说明</th></tr></thead><tbody><tr><td>char(M)</td><td>m</td><td>[0,m]，m的范围[0,2^8-1]</td><td>定长字符串</td></tr><tr><td>varchar(M)</td><td>L+1</td><td>[0,m]，m的范围[0,2^16-1]</td><td>0-65535 字节</td></tr><tr><td>tinytext</td><td>L+1</td><td>0-255(2^8-1)字节</td><td>短文本字符串</td></tr><tr><td>text</td><td>L+2</td><td>0-65535(2^16-1)字节</td><td>长文本字数据</td></tr><tr><td>mediumtext</td><td>L+3</td><td>0-16777215(2^24-1)字节</td><td>中等长度文本数据</td></tr><tr><td>longtext</td><td>L+4</td><td>0-4294967295(2^32-1)字节</td><td>极大文本数据</td></tr></tbody></table><p>注：表格中的L表示存储的数据本身占用的字节，L 以外所需的额外字节为存放该值的长度所需的字节数</p><h3 id="1-1-char和varchar类型"><a href="#1-1-char和varchar类型" class="headerlink" title="1.1 char和varchar类型"></a>1.1 char和varchar类型</h3><p>CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。</p><p>VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。</p><h3 id="1-2-text类型"><a href="#1-2-text类型" class="headerlink" title="1.2 text类型"></a>1.2 text类型</h3><p>TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。</p><h3 id="1-3-enum类型"><a href="#1-3-enum类型" class="headerlink" title="1.3 enum类型"></a>1.3 enum类型</h3><p>ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> ENUM( <span class="string">&#x27;值1&#x27;</span>, <span class="string">&#x27;值1&#x27;</span>, …, <span class="string">&#x27;值n&#x27;</span> )</span><br></pre></td></tr></table></figure><p>字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。</p><p>ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。</p><p>ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。</p><p>温馨提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。</p><h3 id="1-4-set类型"><a href="#1-4-set类型" class="headerlink" title="1.4 set类型"></a>1.4 set类型</h3><p>SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>( <span class="string">&#x27;值1&#x27;</span>, <span class="string">&#x27;值2&#x27;</span>, …, <span class="string">&#x27;值n&#x27;</span> )</span><br></pre></td></tr></table></figure><p>与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。</p><p>但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</p><p>温馨提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。</p><h2 id="2-数值数据类型"><a href="#2-数值数据类型" class="headerlink" title="2 数值数据类型"></a>2 数值数据类型</h2><p>数值数据类型存储数值。MySQL支持多种数值数据类型，每种存储的数值具有不同的取值范围。显然，支持的取值范围越大，所需存储空间越多。下表中列出了 MySQL 中的数值类型。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/012.4aa2q5ni76u0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/012.4aa2q5ni76u0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">数值数据类型</div> </center><h3 id="2-1-整数类型"><a href="#2-1-整数类型" class="headerlink" title="2.1 整数类型"></a>2.1 整数类型</h3><p>MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的整数类型。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/013.6q22x0bb5gw0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/013.6q22x0bb5gw0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><p>注：上面[]包含的内容是可选的，默认是有符号类型的，无符号的需要在类型后面跟上<code>unsigned</code>。</p><p>在开发中，会碰到有些定义整型的写法是<code>int(11)</code>，这种写法个人感觉在开发过程中没有什么用途，不过还是来说一下， <code>int(N)</code>我们只需要记住两点：</p><ul><li>无论N等于多少，int永远占4个字节</li><li>N表示的是显示宽度，不足的用0补足，超过的无视长度而直接显示整个数字，但这要整型设置了<code>unsigned zerofill</code>才有效</li></ul><p>下面用一个例子演示：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/014.3xog9vtucm00.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/014.3xog9vtucm00.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/015.4i8zzsuhp1c0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/015.4i8zzsuhp1c0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>注：<code>show create table tb_test01</code>; 输出了表tb_test01的创建语句，和原始的创建语句不一致了，原始的d字段用的是有符号的，可以看出当使用了<code>zerofill</code>自动会将有符号提升为无符号。</p><p><strong>温馨提示：</strong> 显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。</p><h3 id="2-2-小数类型"><a href="#2-2-小数类型" class="headerlink" title="2.2 小数类型"></a>2.2 小数类型</h3><p>浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。</p><p>浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。</p><p>float和double在不指定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0。<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/016.5sdasngib7c0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/016.5sdasngib7c0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>下面用实例演示：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/017.ujuy0l1h8vk.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/017.ujuy0l1h8vk.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><p>说明：<br>c是decimal类型，看一下输入和输出，发现decimal采用的是四舍五入<br>看一下a 和b 的输入和输出，尽然不是四舍五入，这里float和double采用的是四舍六入五成双。decimal插入的数据超过精度之后会触发警告。</p><p><strong>什么是四舍六入五成双？</strong><br>就是5以下舍弃5以上进位，如果需要处理数字为5的时候，需要看5后面是否还有不为0的任何数字，如果有，则直接进位，如果没有，需要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉</p><p>将浮点类型的（M,D）精度和标度都去掉，看看效果：<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/018.448gxht7agc0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/018.448gxht7agc0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>说明：a和b的数据正确插入，而c被截断了，浮点数float、double如果不写精度和标度，则会按照实际显示。decimal不写精度和标度，小数点后面的会进行四舍五入，并且插入时会有警告!<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/019.6f5emx8e8lc0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/019.6f5emx8e8lc0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>从上面sum的结果可以看出float 、double 会存在精度问题，decimal 精度正常的，比如银行对统计</p><p>结果要求比较精准的建议使用decimal 。有符号或无符号 所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号。有符号数值列可以存储正或负的数值，无符号数值列只能存储正数。默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字，这样做将允许你存储两倍大小的值。</p><p>温馨提示：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。存储货币数据类型 MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)。</p><h2 id="3-日期和时间类型"><a href="#3-日期和时间类型" class="headerlink" title="3 日期和时间类型"></a>3 日期和时间类型</h2><p>MySQL使用专门的数据类型来存储日期和时间值。下表中列出了 MySQL 中的日期与时间类型。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/020.2reaoy8lvak0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/020.2reaoy8lvak0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">日期与时间数据类型</div> </center><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。下表列出YEAR、TIME、DATE、DTAETIME、TIMESTAMP各自的字节数、取值范围和用途。</p><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th></th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01&#x2F;9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’&#x2F;‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续间</td></tr><tr><td>YEAR</td><td>1</td><td>1901&#x2F;2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00&#x2F;2038结束时间是第2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p>对于日期和时间类型的详细介绍，可以阅读：<a href="http://c.biancheng.net/view/2425.html">MySQL DTAETIME、TIMESTAMP、DATE、TIME、YEAR（日期和时间类型）</a></p><h2 id="4-二进制类型"><a href="#4-二进制类型" class="headerlink" title="4 二进制类型"></a>4 二进制类型</h2><p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、<br>多媒体、字处理文档等。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/021.5qu9b0wru140.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/021.5qu9b0wru140.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">二进制数据类型</div> </center><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。如下表所示。</p><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th>说明</th></tr></thead><tbody><tr><td>tinyblob</td><td>L+1</td><td>0-255(2^8-1)字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>blob</td><td>L+2</td><td>0-65535(2^16-1)字节</td><td>二进制形式的长文本数据</td></tr><tr><td>mediumblob</td><td>L+3</td><td>0-16777215(2^24-1)字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>longblob</td><td>L+4</td><td>0-4294967295(2^32-1)字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>bit(M)</td><td>大约 (M+7)&#x2F;8 字节</td><td>-</td><td>位字段类型</td></tr><tr><td>binary(M)</td><td>M</td><td>-</td><td>固定长度二进制字符串</td></tr><tr><td>varbinary(M)</td><td>M+1</td><td>-</td><td>可变长度二进制字符串</td></tr></tbody></table><h2 id="5-数据类型选择"><a href="#5-数据类型选择" class="headerlink" title="5 数据类型选择"></a>5 数据类型选择</h2><h3 id="5-1-字符串类型"><a href="#5-1-字符串类型" class="headerlink" title="5.1 字符串类型"></a>5.1 字符串类型</h3><p>字符串类型没有像数字类型列那样的“取值范围”，但它们都有长度的概念。如果需要存储的字符串短于 256 个字符，那么可以使用 CHAR、VARCHAR 或 TINYTEXT。如果需要存储更长一点的字符串，则可以选用 VARCHAR 或某种更长的 TEXT 类型。</p><h3 id="5-2-数值类型"><a href="#5-2-数值类型" class="headerlink" title="5.2 数值类型"></a>5.2 数值类型</h3><p>如果要存储的数字是整数（没有小数部分），则使用整数类型，根据取值范围进行具体的选择；如果要存储的数字是小数（带有小数部分），则可以选用 DECIMAL 或浮点类型，但是一般选择 FLOAT 类型（浮点类型的一种）。</p><p>当数值不是数值时 你可能会认为电话号码和邮政编码应该存储在数值字段中（数值字段只存储数值数据），但是，这样做却是不可取的。如果在数值字段中存储邮政编码01234，则保存的将是数值1234，实际上丢失了一位数字。</p><p>需要遵守的基本规则是：如果数值是计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p><h3 id="5-3-日期和时间类型"><a href="#5-3-日期和时间类型" class="headerlink" title="5.3 日期和时间类型"></a>5.3 日期和时间类型</h3><p>如果只需要记录年份，则使用 YEAR 类型即可；如果只记录时间，可以使用 TIME 类型。</p><p>如果同时需要记录日期和时间，则可以使用 TIMESTAMP 或者 DATETIME 类型。由于TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，因此存储较大的日期最好使用 DATETIME。</p><p>TIMESTAMP 也有一个 DATETIME 不具备的属性。默认情况下，当插入一条记录但并没有指定 TIMESTAMP 这个列值时，MySQL 会把 TIMESTAMP 列设为当前的时间。因此当需要插入记录和当前时间时，使用 TIMESTAMP 是方便的，另外 TIMESTAMP 在空间上比 DATETIME 更有效。</p><h3 id="5-4-二进制"><a href="#5-4-二进制" class="headerlink" title="5.4 二进制"></a>5.4 二进制</h3><p>BLOB 是二进制字符串，TEXT 是非二进制字符串，两者均可存放大容量的信息。BLOB 主要存储图片、音频信息等，而 TEXT 只能存储纯文本文件。</p><p>数据类型选择的一些建议：</p><ul><li>选小不选大：一般情况下选择可以正确存储数据的最小数据类型，越小的数据类型通常更快，占用<br>磁盘，内存和CPU缓存更小。</li><li>简单就好：简单的数据类型的操作通常需要更少的CPU周期，例如：整型比字符操作代价要小得<br>多，因为字符集和校对规则(排序规则)使字符比整型比较更加复杂。</li><li>尽量避免NULL：尽量制定列为NOT NULL，除非真的需要NULL类型的值，有NULL的列值会使得<br>索引、索引统计和值比较更加复杂。</li><li>浮点类型的建议统一选择decimal</li><li>记录时间的建议使用int或者bigint类型，将时间转换为时间戳格式，如将时间转换为秒、毫秒，<br>进行存储，方便走索引</li></ul><hr><p>在刚才新建表的过程中，我们提到了数据类型，MySQL 的数据类型和其他编程语言大同小异，下表是一些 MySQL 常用数据类型：</p><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th>格式</th></tr></thead><tbody><tr><td>INT</td><td>4</td><td>整数</td><td></td></tr><tr><td>FLOAT</td><td>4</td><td>单精度浮点数</td><td></td></tr><tr><td>DOUBLE</td><td>8</td><td>多精度浮点数</td><td></td></tr><tr><td>ENUM</td><td>—</td><td>单选，比如性别</td><td>ENUM(‘a’,’b’,’c’)</td></tr><tr><td>SET</td><td>—</td><td>多选</td><td>SET(‘1’,’2’,’3’)</td></tr><tr><td>DATE</td><td>3</td><td>日期</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3</td><td>时间点或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1</td><td>年份</td><td>YYYY</td></tr><tr><td>CHAR</td><td>0~255</td><td>定长字符串</td><td></td></tr><tr><td>VARCHAR</td><td>0~255</td><td>变长字符串</td><td></td></tr><tr><td>TEXT</td><td>0~65535</td><td>长文本数据</td><td></td></tr></tbody></table><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01&#x2F;9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’&#x2F;‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续间</td></tr><tr><td>YEAR</td><td>1</td><td>1901&#x2F;2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00&#x2F;2038结束时间是第2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨03:14:07</td><td>YYYYMMDDHHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th>说明</th></tr></thead><tbody><tr><td>char(M)</td><td>m</td><td>[0,m]，m的范围[0,2^8-1]</td><td>定长字符串</td></tr><tr><td>varchar(M)</td><td>m</td><td>[0,m]，m的范围[0,2^16-1]</td><td>0-65535 字节</td></tr><tr><td>tinytext</td><td>L+1</td><td>0-255(2^8-1)字节</td><td>短文本字符串</td></tr><tr><td>text</td><td>L+2</td><td>0-65535(2^16-1)字节</td><td>长文本字数据</td></tr><tr><td>mediumtext</td><td>L+3</td><td>0-16777215(2^24-1)字节</td><td>中等长度文本数据</td></tr><tr><td>longtext</td><td>L+4</td><td>0-4294967295(2^32-1)字节</td><td>极大文本数据</td></tr></tbody></table><table><thead><tr><th>数据类型</th><th>大小（字节）</th><th>范围</th><th>说明</th></tr></thead><tbody><tr><td>tinyblob</td><td>L+1</td><td>0-255(2^8-1)字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>blob</td><td>L+2</td><td>0-65535(2^16-1)字节</td><td>二进制形式的长文本数据</td></tr><tr><td>mediumblob</td><td>L+3</td><td>0-16777215(2^24-1)字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>longblob</td><td>L+4</td><td>0-4294967295(2^32-1)字节</td><td>二进制形式的极大文本数据</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要学习MySQL中的串数据类型（CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM、SET）、数值数据类型（TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT、FLOAT、DOUBLE、DECIMAL）、日期、时间类型（ YEAR、TIME、DATE、DATETIME 和 TIMESTAMP）、二进制类型（ BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB）。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="MySQL 基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MySQL-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据类型" scheme="https://qxienote.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础篇（二）-- MySql 基础</title>
    <link href="https://qxienote.com/article/3c6d2611.html"/>
    <id>https://qxienote.com/article/3c6d2611.html</id>
    <published>2023-08-06T13:25:55.000Z</published>
    <updated>2023-08-06T13:47:32.630Z</updated>
    
    <content type="html"><![CDATA[<p>本篇正式开始学习MySQL，主要介绍了Windows下如何启动和登陆、常用工具和终端常用的命令。</p><span id="more"></span><p>在前一节中介绍了数据库和SQL。正如所述，数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS（数据库管理系统）完成的。MySQL是一种DBMS，即它是一种数据库软件，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>MySQL在互联网公司使用率排名第一，主要有以下优点：</p><ul><li>成本——MySQL是开放源代码的，一般可以免费使用（甚至可以免费修改）。</li><li>性能——MySQL执行很快（非常快）。</li><li>可信赖——某些非常重要和声望很高的公司、站点使用MySQL，这些公司和站点都用MySQL来处理自己的重要数据。</li><li>简单——MySQL很容易安装和使用。</li></ul><p>网上有很多关于安装MySQL安装教程，可以参考下面的教程安装，MySQL安装配置教程：<a href="http://c.biancheng.net/view/7135.html">http://c.biancheng.net/view/7135.html</a>和MySQL安装：<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day36-40/36.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CMySQL%E6%A6%82%E8%BF%B0.md">https://github.com/jackfrued/Python-100-Days/blob/master/Day36-40</a></p><h2 id="1-启动和登陆"><a href="#1-启动和登陆" class="headerlink" title="1 启动和登陆"></a>1 启动和登陆</h2><h3 id="1-1-启动"><a href="#1-1-启动" class="headerlink" title="1.1 启动"></a>1.1 启动</h3><p>方式一：在cmd中运行：<code>services.msc</code>，会打开服务窗口，在服务窗口中找到mysql服务，点击右键可以启动或者停止。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/003.6wukf0ube9c0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/003.6wukf0ube9c0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><p>方式二：在cmd中运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;net stop mysql</span><br><span class="line">mysql 服务正在停止。</span><br><span class="line">mysql 服务已成功停止。</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;net start mysql</span><br><span class="line">mysql 服务正在启动。</span><br><span class="line">mysql 服务已经启动成功。</span><br></pre></td></tr></table></figure><h3 id="1-2-登陆"><a href="#1-2-登陆" class="headerlink" title="1.2 登陆"></a>1.2 登陆</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h ip <span class="operator">-</span>P 端口 <span class="operator">-</span>u 用户名 <span class="operator">-</span>p</span><br><span class="line"># mysql <span class="operator">-</span>h localhost <span class="operator">-</span>P <span class="number">3306</span> <span class="operator">-</span>u root <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-P大写的P后面跟上端口</li><li>如果登陆本地，ip和端口可以省略</li></ul><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/004.107s0z8oyyao.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/004.107s0z8oyyao.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><p>mysql命令行实用程序是使用最多的实用程序之一，它对于快速测试和执行脚本非常有价值。如下所示：</p><ul><li>命令输入在mysql&gt;之后；</li><li>命令用;或\g结束，换句话说，仅按Enter不执行命令；</li><li>输入help或\h获得帮助，也可以输入更多的文本获得特定命令的帮助（如，输入<code>help select</code>获得使用<code>SELECT</code>语句的帮助）；</li><li>输入<code>quit</code>或<code>exit</code>退出命令行实用程序。</li></ul><h3 id="1-3-常用工具"><a href="#1-3-常用工具" class="headerlink" title="1.3 常用工具"></a>1.3 常用工具</h3><p>在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接 MySQL 服务器，包括：</p><p>MySQL Workbench（官方工具）<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/005.20951rmal0yo.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/005.20951rmal0yo.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>Navicat for MySQL（界面简单友好）<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/006.4fn5w3aaulg0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/006.4fn5w3aaulg0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><h2 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2 基本命令"></a>2 基本命令</h2><h3 id="2-1-查看命令"><a href="#2-1-查看命令" class="headerlink" title="2.1 查看命令"></a>2.1 查看命令</h3><ol><li>选择数据库<br>在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用USE关键字。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use school;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><code>USE</code>语句并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是mysql命令行实用程序在数据库选择成功后显示的。</li></ol><p><strong>温馨提示：</strong> 必须先使用USE打开数据库，才能读取其中的数据。关键字(key word) 作为MySQL语言组成部分的一个保留字。决不要用关键字命名一个表或列。</p><ol start="2"><li>查看所有数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><p><code>SHOW DATABASES;</code>返回可用数据库的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库。</p><ol start="3"><li>查看数据库下所有表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><p><code>SHOW TABLES;</code>返回当前选择的数据库内可用表的列表。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/007.3p745ahso400.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/007.3p745ahso400.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><ol><li>显示表列<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> columns <span class="keyword">from</span> tb_student;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/008.6uymkklo47c0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/008.6uymkklo47c0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></li></ol><p>SHOW COLUMNS 要求给出一个表名（ 这个例子中的FROM tb_record），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段rec_id的auto_increment）。</p><blockquote><p>什么是自动增量？ 某些表列需要唯一值。例如，订单编号、雇员ID或（如上面例子中所示的）顾客ID。在每个行添加到表中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。</p></blockquote><p>MySQL支持用DESCRIBE作为<code>SHOW COLUMNS FROM</code>的一种快捷方式。换句话说，<code>DESCRIBE customers;</code>是<code>SHOW COLUMNS FROM customers;</code>的一种快捷方式。</p><ol><li>查看所有字符集</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">character</span> <span class="keyword">set</span>;</span><br></pre></td></tr></table></figure><ol start="6"><li>查看所有的排序规则</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">collation</span>;</span><br></pre></td></tr></table></figure><ol start="7"><li>查看所有的引擎</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><ol start="8"><li>查看所有日志文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs;</span><br></pre></td></tr></table></figure><h3 id="2-2-获取帮助"><a href="#2-2-获取帮助" class="headerlink" title="2.2 获取帮助"></a>2.2 获取帮助</h3><p>在 MySQL 命令行工具中，可以使用<code>help</code>命令或<code>?</code>来获取帮助，如下所示。</p><ol><li><p>查看<code>show</code>命令的帮助。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? show</span><br></pre></td></tr></table></figure></li><li><p>查看有哪些帮助内容。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? contents</span><br></pre></td></tr></table></figure></li><li><p>获取函数的帮助。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? functions</span><br></pre></td></tr></table></figure></li><li><p>获取数据类型的帮助。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? data types</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-其他命令"><a href="#2-3-其他命令" class="headerlink" title="2.3 其他命令"></a>2.3 其他命令</h3><ol><li><p>新建&#x2F;重建服务器连接 - <code>connect</code> &#x2F; <code>resetconnection</code>。</p></li><li><p>清空当前输入 - <code>\c</code>。在输入错误时，可以及时使用<code>\c</code>清空当前输入并重新开始。</p></li><li><p>修改终止符（定界符）- <code>delimiter</code>。默认的终止符是<code>;</code>，可以使用该命令修改成其他的字符，例如修改为<code>$</code>符号，可以用<code>delimiter $</code>命令。</p></li><li><p>打开系统默认编辑器 - <code>edit</code>。编辑完成保存关闭之后，命令行会自动执行编辑的内容。</p></li><li><p>查看服务器状态 - <code>status</code>。</p></li><li><p>修改默认提示符 - <code>prompt</code>。</p></li><li><p>执行系统命令 - <code>system</code>。可以将系统命令跟在<code>system</code>命令的后面执行，<code>system</code>命令也可以缩写为<code>\!</code>。</p></li><li><p>执行 SQL 文件 - <code>source</code>。<code>source</code>命令后面跟 SQL 文件路径。</p></li><li><p>重定向输出 - <code>tee</code> &#x2F; <code>notee</code>。可以将命令的输出重定向到指定的文件中。</p></li><li><p>切换数据库 - <code>use</code>。</p></li><li><p>显示警告信息 - <code>warnings</code>。</p></li><li><p>退出命令行 - <code>quit</code>或<code>exit</code>。</p></li></ol><p><strong>补充：</strong></p><ol><li>查看数据库版本<br><code>mysql --version</code>或者<code>mysql -V</code>用于在未登录情况下，查看本机mysql版本：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;mysql -V</span><br><span class="line">mysql  Ver 8.0.25 <span class="keyword">for</span> Win64 on x86_64 (MySQL Community Server - GPL)</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;mysql --version</span><br><span class="line">mysql  Ver 8.0.25 <span class="keyword">for</span> Win64 on x86_64 (MySQL Community Server - GPL)</span><br></pre></td></tr></table></figure><p><code>select version();</code>：登录情况下，查看链接的库版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> version() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8.0</span><span class="number">.25</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.10</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>查看其他库中所有的表：<code>show tables from 库名;</code></p></li><li><p>查看表的创建语句：<code>show create table 表名;</code></p></li></ol><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/009.3rqajjrmjz20.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/009.3rqajjrmjz20.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><ol><li><p>查看表结构：<code>desc 表名;</code></p></li><li><p>查看当前所在库：<code>select database();</code></p></li><li><p>查看系统变量及其值：<code>SHOW VARIABLES;</code></p></li><li><p>查看某个系统变量：show variables like ‘变量名’;</p></li></ol><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/010.5ig65jhdt0s0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230801/010.5ig65jhdt0s0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇正式开始学习MySQL，主要介绍了Windows下如何启动和登陆、常用工具和终端常用的命令。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="MySQL 基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MySQL-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL基础篇（一）-- SQL 基础</title>
    <link href="https://qxienote.com/article/f416b295.html"/>
    <id>https://qxienote.com/article/f416b295.html</id>
    <published>2023-08-06T13:25:27.000Z</published>
    <updated>2023-08-06T13:34:47.678Z</updated>
    
    <content type="html"><![CDATA[<p>什么是SQL？简单地说，SQL就是访问和处理关系数据库的计算机标准语言。也就是说，无论用什么编程语言（Java、Python、C++……）编写程序，只要涉及到操作关系数据库，比如，一个电商网站需要把用户和商品信息存入数据库，或者一个手机游戏需要把用户的道具、通关信息存入数据库，都必须通过SQL来完成。本篇主要以构建一个简单的选课系统数据库来分析数据定义、数据操作、数据查询、数据控制。</p><span id="more"></span><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，它的产生距今已有六十多年。随着信息技术和市场的发展，数据库变得无处不在：它在电子商务、银行系统等众多领域都被广泛使用，且成为其系统的重要组成部分。</p><p>数据库用于记录数据，使用数据库记录数据可以表现出各种数据间的联系，也可以很方便地对所记录的数据进行增、删、改、查等操作。</p><p>结构化查询语言(Structured Query Language)简称 SQL，是上世纪 70 年代由 IBM 公司开发，用于对数据库进行操作的语言。更详细地说，SQL 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。</p><p>本篇主要学习GitHub上<a href="https://github.com/jackfrued/Python-100-Days/tree/master/Day36-40">Python-100-Days</a>数据库部分，主用用来学习使用。</p><h2 id="1-什么是SQL"><a href="#1-什么是SQL" class="headerlink" title="1 什么是SQL"></a>1 什么是SQL</h2><p>SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。</p><p>与其他语言（如，英语以及Java和Visual Basic这样的程序设计语言）不一样，SQL由很少的词构成，这是有意而为的。设计SQL的目的是很好地完成一项任务，即提供一种从数据库中读写数据的简单有效的方法。</p><p>SQL有如下的优点。</p><ul><li>SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL，所以，学习此语言使你几乎能与所有数据库打交道。</li><li>SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。</li><li>SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li></ul><p>我们通常可以将 SQL 分为四类，分别是 DDL（数据定义语言）、DML（数据操作语言）、DQL（数据查询语言）和 DCL（数据控制语言）。DDL 主要用于创建、删除、修改数据库中的对象，比如创建、删除和修改二维表，核心的关键字包括<code>create</code>、<code>drop</code>和<code>alter</code>；DML 主要负责数据的插入、删除和更新，关键词包括<code>insert</code>、<code>delete</code>和<code>update</code>；DQL 负责数据查询，最重要的一个关键词是<code>select</code>；DCL 通常用于授予和召回权限，核心关键词是<code>grant</code>和<code>revoke</code>。</p><blockquote><p>在大多数系统中，SQL 语句都是不区分大小写的，但是出于严谨，而且便于区分保留字（保留字(reserved word)：指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名或过程名使用。）和变量名，我们把保留字大写，把变量和数据小写。这里为了便于书写和识别方便，下面的 SQL 都使用了小写字母来书写。</p></blockquote><h2 id="2-SQL详解"><a href="#2-SQL详解" class="headerlink" title="2 SQL详解"></a>2 SQL详解</h2><h3 id="2-1-DDL（数据定义语言）"><a href="#2-1-DDL（数据定义语言）" class="headerlink" title="2.1 DDL（数据定义语言）"></a>2.1 DDL（数据定义语言）</h3><p>下面我们来实现一个选课系统的数据库，如下所示的 SQL 创建了名为<code>school</code>的数据库和五张表，分别是学院表（<code>tb_college</code>）、学生表（<code>tb_student</code>）、教师表（<code>tb_teacher</code>）、课程表（<code>tb_course</code>）和选课记录表（<code>tb_record</code>），其中学生和教师跟学院之间是多对一关系，课程跟老师之间也是多对一关系，学生和课程是多对多关系，选课记录表就是维持学生跟课程多对多关系的中间表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果存在名为school的数据库就删除它</span></span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> `school`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建名为school的数据库并设置默认的字符集和排序方式</span></span><br><span class="line"><span class="keyword">create</span> database `school` <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换到school数据库上下文环境</span></span><br><span class="line">use `school`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建学院表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_college`</span><br><span class="line">(</span><br><span class="line">`col_id` <span class="type">int</span> unsigned auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">`col_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">`col_intro` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> comment <span class="string">&#x27;介绍&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key (`col_id`)</span><br><span class="line">) engine<span class="operator">=</span>innodb auto_increment<span class="operator">=</span><span class="number">1</span> comment <span class="string">&#x27;学院表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_student`</span><br><span class="line">(</span><br><span class="line">`stu_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">`stu_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`stu_sex` <span class="type">boolean</span> <span class="keyword">default</span> <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">`stu_birth` <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">`stu_addr` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> comment <span class="string">&#x27;籍贯&#x27;</span>,</span><br><span class="line">`col_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;所属学院&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key (`stu_id`),</span><br><span class="line"><span class="keyword">constraint</span> `fk_student_col_id` <span class="keyword">foreign</span> key (`col_id`) <span class="keyword">references</span> `tb_college` (`col_id`)</span><br><span class="line">) engine<span class="operator">=</span>innodb comment <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建教师表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_teacher`</span><br><span class="line">(</span><br><span class="line">`tea_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;工号&#x27;</span>,</span><br><span class="line">`tea_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`tea_title` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="string">&#x27;助教&#x27;</span> comment <span class="string">&#x27;职称&#x27;</span>,</span><br><span class="line">`col_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;所属学院&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key (`tea_id`),</span><br><span class="line"><span class="keyword">constraint</span> `fk_teacher_col_id` <span class="keyword">foreign</span> key (`col_id`) <span class="keyword">references</span> `tb_college` (`col_id`)</span><br><span class="line">) engine<span class="operator">=</span>innodb comment <span class="string">&#x27;老师表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建课程表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_course`</span><br><span class="line">(</span><br><span class="line">`cou_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">`cou_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">`cou_credit` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学分&#x27;</span>,</span><br><span class="line">`tea_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;授课老师&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key (`cou_id`),</span><br><span class="line"><span class="keyword">constraint</span> `fk_course_tea_id` <span class="keyword">foreign</span> key (`tea_id`) <span class="keyword">references</span> `tb_teacher` (`tea_id`)</span><br><span class="line">) engine<span class="operator">=</span>innodb comment <span class="string">&#x27;课程表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建选课记录表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_record`</span><br><span class="line">(</span><br><span class="line">`rec_id` <span class="type">bigint</span> unsigned auto_increment comment <span class="string">&#x27;选课记录号&#x27;</span>,</span><br><span class="line">`stu_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">`cou_id` <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程编号&#x27;</span>,</span><br><span class="line">`sel_date` <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;选课日期&#x27;</span>,</span><br><span class="line">`score` <span class="type">decimal</span>(<span class="number">4</span>,<span class="number">1</span>) comment <span class="string">&#x27;考试成绩&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key (`rec_id`),</span><br><span class="line"><span class="keyword">constraint</span> `fk_record_stu_id` <span class="keyword">foreign</span> key (`stu_id`) <span class="keyword">references</span> `tb_student` (`stu_id`),</span><br><span class="line"><span class="keyword">constraint</span> `fk_record_cou_id` <span class="keyword">foreign</span> key (`cou_id`) <span class="keyword">references</span> `tb_course` (`cou_id`),</span><br><span class="line"><span class="keyword">constraint</span> `uk_record_stu_cou` <span class="keyword">unique</span> (`stu_id`, `cou_id`)</span><br><span class="line">) engine<span class="operator">=</span>innodb comment <span class="string">&#x27;选课记录表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>知识点：</p><p>在 MySQL 中，可以使用 CREATE DATABASE 语句创建数据库，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span>] </span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p><code>[]</code>中的内容是可选的。语法说明如下：</p><ul><li>&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。</li><li>IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li>[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。</li><li>[DEFAULT] COLLATE：指定字符集的默认校对规则。</li></ul><p><strong>1. 注释</strong></p><p>单行注释可以使用<code>#</code>注释符，<code>#</code>注释符后直接加注释内容。格式如下：</p><p>单行注释也可以使用–注释符，–注释符后需要加一个空格，注释才能生效</p><p>#和–的区别就是：#后面直接加注释内容，而–的第 2 个破折号后需要跟一个空格符在加注释内容。</p><p>多行注释使用&#x2F;* *&#x2F;注释符。&#x2F;<em>用于注释内容的开头，</em>&#x2F;用于注释内容的结尾。</p><p>任何注释（单行注释和多行注释）都可以插在 SQL 语句中，且注释可以放在 SQL 语句中的任意位置。</p><p>注释可以写在任何 SQL 语句当中，且 SQL 语句中对注释的数量没有限制。</p><p>MySQL 注释能够帮助阅读者更好地理解 SQL 语句，特别是在使用复杂的 SQL 语句时，所以应该尽量多添加一些简明易懂的注释。</p><p><strong>2. 字符集</strong></p><p>创建数据库时，我们通过<code>default character set utf8mb4</code>指定了数据库默认使用的字符集为<code>utf8mb4</code>（最大<code>4</code>字节的<code>utf-8</code>编码），我们推荐使用该字符集，它也是 MySQL 8.x 默认使用的字符集，因为它能够支持国际化编码，还可以存储 Emoji 字符。可以通过下面的命令查看 MySQL 支持的字符集以及默认的排序规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">character</span> <span class="keyword">set</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 存储引擎</strong><br>在创建表的时候，可以自行选择底层的存储引擎。MySQL 支持多种存储引擎，可以通过<code>show engines</code>命令进行查看。MySQL 5.5 以后的版本默认使用的存储引擎是 InnoDB，它是我们推荐大家使用的存储引擎（因为更适合当下互联网应用对高并发、性能以及事务支持等方面的需求），为了 SQL 语句的向下兼容性，我们可以在建表语句结束处右圆括号的后面通过<code>engine=innodb</code>来指定使用 InnoDB 存储引擎。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines\G</span><br></pre></td></tr></table></figure><p>  下面的表格对MySQL几种常用的数据引擎进行了简单的对比。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MRG_MYISAM</th><th>MEMORY</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>没有</td><td>有</td><td>有</td></tr><tr><td>事务</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td></tr><tr><td>全文检索</td><td>支持（5.6+）</td><td></td><td></td><td>支持</td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中</td><td>低</td></tr><tr><td>存储空间使用</td><td>高</td><td>低</td><td></td><td>低</td></tr><tr><td>批量插入性能</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>是否支持外键</td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><p>  通过上面的比较我们可以了解到，InnoDB 是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且在较新版本的 MySQL 中，它也是默认使用的存储引擎。</p><p><strong>4. 数据类型</strong></p><p>在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过 MySQL 的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? data types</span><br></pre></td></tr></table></figure><p>在数据类型的选择上，保存字符串数据通常都使用<code>VARCHAR</code>和<code>CHAR</code>两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于 InnoDB 存储引擎，行存储格式没有区分固定长度和可变长度列，因此<code>VARCHAR</code>类型和<code>CHAR</code>类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用<code>TEXT</code>类型；如果要保存很大的字节串，可以使用<code>BLOB</code>（二进制大对象）类型。在 MySQL 中，<code>TEXT</code>和<code>BLOB</code>又分别包括<code>TEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>和<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code>三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用<code>FLOAT</code>或<code>DOUBLE</code>类型，<code>FLOAT</code>已经不推荐使用了，而且在 MySQL 后续的版本中可能会被移除掉。而保存定点数应该使用<code>DECIMAL</code>类型。如果要保存时间日期，<code>DATETIME</code>类型优于<code>TIMESTAMP</code>类型，因为前者能表示的时间日期范围更大。</p><h3 id="2-2-DML（数据操作语言）"><a href="#2-2-DML（数据操作语言）" class="headerlink" title="2.2 DML（数据操作语言）"></a>2.2 DML（数据操作语言）</h3><p><strong>1. 添加数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">use school;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入学院数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_college` </span><br><span class="line">    (`col_name`, `col_intro`) </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">    (<span class="string">&#x27;计算机学院&#x27;</span>, <span class="string">&#x27;计算机学院1958年设立计算机专业，1981年建立计算机科学系，1998年设立计算机学院，2005年5月，为了进一步整合教学和科研资源，学校决定，计算机学院和软件学院行政班子合并统一运作、实行教学和学生管理独立运行的模式。 学院下设三个系：计算机科学与技术系、物联网工程系、计算金融系；两个研究所：图象图形研究所、网络空间安全研究院（2015年成立）；三个教学实验中心：计算机基础教学实验中心、IBM技术中心和计算机专业实验中心。&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;外国语学院&#x27;</span>, <span class="string">&#x27;外国语学院设有7个教学单位，6个文理兼收的本科专业；拥有1个一级学科博士授予点，3个二级学科博士授予点，5个一级学科硕士学位授权点，5个二级学科硕士学位授权点，5个硕士专业授权领域，同时还有2个硕士专业学位（MTI）专业；有教职员工210余人，其中教授、副教授80余人，教师中获得中国国内外名校博士学位和正在职攻读博士学位的教师比例占专任教师的60%以上。&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;经济管理学院&#x27;</span>, <span class="string">&#x27;经济学院前身是创办于1905年的经济科；已故经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代学者刘诗白等曾先后在此任教或学习。&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入学生数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_student` </span><br><span class="line">    (`stu_id`, `stu_name`, `stu_sex`, `stu_birth`, `stu_addr`, `col_id`) </span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">    (<span class="number">1001</span>, <span class="string">&#x27;杨过&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1990-3-4&#x27;</span>, <span class="string">&#x27;湖南长沙&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1002</span>, <span class="string">&#x27;任我行&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1992-2-2&#x27;</span>, <span class="string">&#x27;湖南长沙&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1033</span>, <span class="string">&#x27;王语嫣&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;1989-12-3&#x27;</span>, <span class="string">&#x27;四川成都&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1572</span>, <span class="string">&#x27;岳不群&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1993-7-19&#x27;</span>, <span class="string">&#x27;陕西咸阳&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1378</span>, <span class="string">&#x27;纪嫣然&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;1995-8-12&#x27;</span>, <span class="string">&#x27;四川绵阳&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1954</span>, <span class="string">&#x27;林平之&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1994-9-20&#x27;</span>, <span class="string">&#x27;福建莆田&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">2035</span>, <span class="string">&#x27;东方不败&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1988-6-30&#x27;</span>, <span class="keyword">null</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">3011</span>, <span class="string">&#x27;林震南&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1985-12-12&#x27;</span>, <span class="string">&#x27;福建莆田&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">3755</span>, <span class="string">&#x27;项少龙&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1993-1-25&#x27;</span>, <span class="string">&#x27;四川成都&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">3923</span>, <span class="string">&#x27;杨不悔&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;1985-4-17&#x27;</span>, <span class="string">&#x27;四川成都&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入老师数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_teacher` </span><br><span class="line">    (`tea_id`, `tea_name`, `tea_title`, `col_id`) </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">    (<span class="number">1122</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="string">&#x27;教授&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1133</span>, <span class="string">&#x27;宋远桥&#x27;</span>, <span class="string">&#x27;副教授&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">1144</span>, <span class="string">&#x27;杨逍&#x27;</span>, <span class="string">&#x27;副教授&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">2255</span>, <span class="string">&#x27;范遥&#x27;</span>, <span class="string">&#x27;副教授&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">3366</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="keyword">default</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入课程数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_course` </span><br><span class="line">    (`cou_id`, `cou_name`, `cou_credit`, `tea_id`) </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">    (<span class="number">1111</span>, <span class="string">&#x27;Python程序设计&#x27;</span>, <span class="number">3</span>, <span class="number">1122</span>),</span><br><span class="line">    (<span class="number">2222</span>, <span class="string">&#x27;Web前端开发&#x27;</span>, <span class="number">2</span>, <span class="number">1122</span>),</span><br><span class="line">    (<span class="number">3333</span>, <span class="string">&#x27;操作系统&#x27;</span>, <span class="number">4</span>, <span class="number">1122</span>),</span><br><span class="line">    (<span class="number">4444</span>, <span class="string">&#x27;计算机网络&#x27;</span>, <span class="number">2</span>, <span class="number">1133</span>),</span><br><span class="line">    (<span class="number">5555</span>, <span class="string">&#x27;编译原理&#x27;</span>, <span class="number">4</span>, <span class="number">1144</span>),</span><br><span class="line">    (<span class="number">6666</span>, <span class="string">&#x27;算法和数据结构&#x27;</span>, <span class="number">3</span>, <span class="number">1144</span>),</span><br><span class="line">    (<span class="number">7777</span>, <span class="string">&#x27;经贸法语&#x27;</span>, <span class="number">3</span>, <span class="number">2255</span>),</span><br><span class="line">    (<span class="number">8888</span>, <span class="string">&#x27;成本会计&#x27;</span>, <span class="number">2</span>, <span class="number">3366</span>),</span><br><span class="line">    (<span class="number">9999</span>, <span class="string">&#x27;审计学&#x27;</span>, <span class="number">3</span>, <span class="number">3366</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入选课数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_record` </span><br><span class="line">    (`stu_id`, `cou_id`, `sel_date`, `score`) </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">    (<span class="number">1001</span>, <span class="number">1111</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">95</span>),</span><br><span class="line">    (<span class="number">1001</span>, <span class="number">2222</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">87.5</span>),</span><br><span class="line">    (<span class="number">1001</span>, <span class="number">3333</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">100</span>),</span><br><span class="line">    (<span class="number">1001</span>, <span class="number">4444</span>, <span class="string">&#x27;2018-09-03&#x27;</span>, <span class="keyword">null</span>),</span><br><span class="line">    (<span class="number">1001</span>, <span class="number">6666</span>, <span class="string">&#x27;2017-09-02&#x27;</span>, <span class="number">100</span>),</span><br><span class="line">    (<span class="number">1002</span>, <span class="number">1111</span>, <span class="string">&#x27;2017-09-03&#x27;</span>, <span class="number">65</span>),</span><br><span class="line">    (<span class="number">1002</span>, <span class="number">5555</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">42</span>),</span><br><span class="line">    (<span class="number">1033</span>, <span class="number">1111</span>, <span class="string">&#x27;2017-09-03&#x27;</span>, <span class="number">92.5</span>),</span><br><span class="line">    (<span class="number">1033</span>, <span class="number">4444</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">78</span>),</span><br><span class="line">    (<span class="number">1033</span>, <span class="number">5555</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">82.5</span>),</span><br><span class="line">    (<span class="number">1572</span>, <span class="number">1111</span>, <span class="string">&#x27;2017-09-02&#x27;</span>, <span class="number">78</span>),</span><br><span class="line">    (<span class="number">1378</span>, <span class="number">1111</span>, <span class="string">&#x27;2017-09-05&#x27;</span>, <span class="number">82</span>),</span><br><span class="line">    (<span class="number">1378</span>, <span class="number">7777</span>, <span class="string">&#x27;2017-09-02&#x27;</span>, <span class="number">65.5</span>),</span><br><span class="line">    (<span class="number">2035</span>, <span class="number">7777</span>, <span class="string">&#x27;2018-09-03&#x27;</span>, <span class="number">88</span>),</span><br><span class="line">    (<span class="number">2035</span>, <span class="number">9999</span>, <span class="string">&#x27;2019-09-02&#x27;</span>, <span class="keyword">null</span>),</span><br><span class="line">    (<span class="number">3755</span>, <span class="number">1111</span>, <span class="string">&#x27;2019-09-02&#x27;</span>, <span class="keyword">null</span>),</span><br><span class="line">    (<span class="number">3755</span>, <span class="number">8888</span>, <span class="string">&#x27;2019-09-02&#x27;</span>, <span class="keyword">null</span>),</span><br><span class="line">    (<span class="number">3755</span>, <span class="number">9999</span>, <span class="string">&#x27;2017-09-01&#x27;</span>, <span class="number">92</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面的<code>insert</code>语句使用了批处理的方式来插入数据，这种做法插入数据的效率比较高。</p></blockquote><h3 id="2-3-DQL（数据查询语言）"><a href="#2-3-DQL（数据查询语言）" class="headerlink" title="2.3 DQL（数据查询语言）"></a>2.3 DQL（数据查询语言）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有学生的所有信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `tb_student`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生的学号、姓名和籍贯(投影)</span></span><br><span class="line"><span class="keyword">select</span> `stu_id`, `stu_name`, `stu_addr` <span class="keyword">from</span> `tb_student`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有课程的名称及学分(投影和别名)</span></span><br><span class="line"><span class="keyword">select</span> `cou_name` <span class="keyword">as</span> 课程名称, `cou_credit` <span class="keyword">as</span> 学分 <span class="keyword">from</span> `tb_course`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有女学生的姓名和出生日期(筛选)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_birth` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_sex`<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询籍贯为“四川成都”的女学生的姓名和出生日期(筛选)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_birth` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_sex`<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> `stu_addr`<span class="operator">=</span><span class="string">&#x27;四川成都&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询籍贯为“四川成都”或者性别为“女生”的学生</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_birth` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_sex`<span class="operator">=</span><span class="number">0</span> <span class="keyword">or</span> `stu_addr`<span class="operator">=</span><span class="string">&#x27;四川成都&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有80后学生的姓名、性别和出生日期(筛选)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_sex`, `stu_birth` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_birth`<span class="operator">&gt;=</span><span class="string">&#x27;1980-1-1&#x27;</span> <span class="keyword">and</span> `stu_birth`<span class="operator">&lt;=</span><span class="string">&#x27;1989-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_sex`, `stu_birth` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_birth` <span class="keyword">between</span> <span class="string">&#x27;1980-1-1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1989-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充：将表示性别的 1 和 0 处理成 “男” 和 “女”</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `stu_name` <span class="keyword">as</span> 姓名, </span><br><span class="line">    if(`stu_sex`, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>) <span class="keyword">as</span> 性别, </span><br><span class="line">    `stu_birth` <span class="keyword">as</span> 出生日期</span><br><span class="line"><span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_birth` <span class="keyword">between</span> <span class="string">&#x27;1980-1-1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1989-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `stu_name` <span class="keyword">as</span> 姓名, </span><br><span class="line">    <span class="keyword">case</span> `stu_sex` <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span> 性别, </span><br><span class="line">    `stu_birth` <span class="keyword">as</span> 出生日期</span><br><span class="line"><span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_birth` <span class="keyword">between</span> <span class="string">&#x27;1980-1-1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1989-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学分大于2的课程的名称和学分(筛选)</span></span><br><span class="line"><span class="keyword">select</span> `cou_name`, `cou_credit` <span class="keyword">from</span> `tb_course` <span class="keyword">where</span> `cou_credit`<span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学分是奇数的课程的名称和学分(筛选)</span></span><br><span class="line"><span class="keyword">select</span> `cou_name`, `cou_credit` <span class="keyword">from</span> `tb_course` <span class="keyword">where</span> `cou_credit`<span class="operator">%</span><span class="number">2</span><span class="operator">&lt;&gt;</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `cou_name`, `cou_credit` <span class="keyword">from</span> `tb_course` <span class="keyword">where</span> `cou_credit` mod <span class="number">2</span><span class="operator">&lt;&gt;</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询选择选了1111的课程考试成绩在90分以上的学生学号(筛选)</span></span><br><span class="line"><span class="keyword">select</span> `stu_id` <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `cou_id`<span class="operator">=</span><span class="number">1111</span> <span class="keyword">and</span> `score`<span class="operator">&gt;</span><span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字叫“杨过”的学生的姓名和性别</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_sex` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name`<span class="operator">=</span><span class="string">&#x27;杨过&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 查询姓“杨”的学生姓名和性别(模糊)</span></span><br><span class="line"><span class="comment">-- % - 通配符（wildcard），它可以匹配0个或任意多个字符</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_sex` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;杨%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓“杨”名字两个字的学生姓名和性别(模糊)</span></span><br><span class="line"><span class="comment">-- _ - 通配符（wildcard），它可以精确匹配一个字符</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_sex` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;杨_&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓“杨”名字三个字的学生姓名和性别(模糊)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_sex` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;杨__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字中有“不”字或“嫣”字的学生的姓名(模糊)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;%不%&#x27;</span> <span class="keyword">or</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;%嫣%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将“岳不群”改名为“岳不嫣”，比较下面两个查询的区别</span></span><br><span class="line"><span class="keyword">update</span> `tb_student` <span class="keyword">set</span> `stu_name`<span class="operator">=</span><span class="string">&#x27;岳不嫣&#x27;</span> <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1572</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;%不%&#x27;</span></span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;%嫣%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;%不%&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` <span class="keyword">like</span> <span class="string">&#x27;%嫣%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓“杨”或姓“林”名字三个字的学生的姓名(正则表达式模糊查询)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_name` regexp <span class="string">&#x27;[杨林].&#123;2&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询没有录入籍贯的学生姓名(空值处理)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_addr` <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_addr` <span class="operator">&lt;=&gt;</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询录入了籍贯的学生姓名(空值处理)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_addr` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 下面的查询什么也查不到，三值逻辑 --&gt; true / false / unknown</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_addr`<span class="operator">=</span><span class="keyword">null</span> <span class="keyword">or</span> `stu_addr`<span class="operator">&lt;&gt;</span><span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生选课的所有日期(去重)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> `sel_date` <span class="keyword">from</span> `tb_record`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生的籍贯(去重)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> `stu_addr` <span class="keyword">from</span> `tb_student` <span class="keyword">where</span> `stu_addr` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询男学生的姓名和生日按年龄从大到小排列(排序)</span></span><br><span class="line"><span class="comment">-- 升序：从小到大 - asc，降序：从大到小 - desc</span></span><br><span class="line"><span class="keyword">select</span> `stu_id`, `stu_name`, `stu_birth` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_sex`<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> `stu_birth` <span class="keyword">asc</span>, `stu_id` <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充：将上面的生日换算成年龄(日期函数、数值函数)</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `stu_id` <span class="keyword">as</span> 学号,</span><br><span class="line">    `stu_name` <span class="keyword">as</span> 姓名, </span><br><span class="line">    <span class="built_in">floor</span>(datediff(curdate(), `stu_birth`)<span class="operator">/</span><span class="number">365</span>) <span class="keyword">as</span> 年龄</span><br><span class="line"><span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_sex`<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> 年龄 <span class="keyword">desc</span>, `stu_id` <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄最大的学生的出生日期(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(`stu_birth`) <span class="keyword">from</span> `tb_student`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄最小的学生的出生日期(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(`stu_birth`) <span class="keyword">from</span> `tb_student`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询编号为1111的课程考试成绩的最高分(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(`score`) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `cou_id`<span class="operator">=</span><span class="number">1111</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学号为1001的学生考试成绩的最低分(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(`score`) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学号为1001的学生考试成绩的平均分(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(`score`) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(`score`) <span class="operator">/</span> <span class="built_in">count</span>(`score`) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学号为1001的学生考试成绩的平均分，如果有null值，null值算0分(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(`score`) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(ifnull(`score`, <span class="number">0</span>)) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学号为1001的学生考试成绩的标准差(聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> std(`score`), variance(`score`) <span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `stu_id`<span class="operator">=</span><span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询男女学生的人数(分组和聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">case</span> `stu_sex` <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span> 性别,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 人数</span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">group</span> <span class="keyword">by</span> `stu_sex`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个学院学生人数(分组和聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `col_id` <span class="keyword">as</span> 学院,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 人数</span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">group</span> <span class="keyword">by</span> `col_id` <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个学院男女学生人数(分组和聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `col_id` <span class="keyword">as</span> 学院,</span><br><span class="line">    if(`stu_sex`, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>) <span class="keyword">as</span> 性别,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 人数</span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">group</span> <span class="keyword">by</span> `col_id`, `stu_sex`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个学生的学号和平均成绩(分组和聚合函数)</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `stu_id`, </span><br><span class="line">    round(<span class="built_in">avg</span>(`score`), <span class="number">1</span>) <span class="keyword">as</span> avg_score</span><br><span class="line"><span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于等于90分的学生的学号和平均成绩</span></span><br><span class="line"><span class="comment">-- 分组以前的筛选使用where子句，分组以后的筛选使用having子句</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `stu_id`, </span><br><span class="line">    round(<span class="built_in">avg</span>(`score`), <span class="number">1</span>) <span class="keyword">as</span> avg_score</span><br><span class="line"><span class="keyword">from</span> `tb_record`</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> `stu_id` <span class="keyword">having</span> avg_score<span class="operator">&gt;=</span><span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询1111、2222、3333三门课程平均成绩大于等于90分的学生的学号和平均成绩</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    `stu_id`, </span><br><span class="line">    round(<span class="built_in">avg</span>(`score`), <span class="number">1</span>) <span class="keyword">as</span> avg_score</span><br><span class="line"><span class="keyword">from</span> `tb_record` <span class="keyword">where</span> `cou_id` <span class="keyword">in</span> (<span class="number">1111</span>, <span class="number">2222</span>, <span class="number">3333</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> `stu_id` <span class="keyword">having</span> avg_score<span class="operator">&gt;=</span><span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄最大的学生的姓名(子查询/嵌套查询)</span></span><br><span class="line"><span class="comment">-- 嵌套查询：把一个select的结果作为另一个select的一部分来使用</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_birth`<span class="operator">=</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">min</span>(`stu_birth`) <span class="keyword">from</span> `tb_student`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">where</span> `stu_id` <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id` <span class="keyword">from</span> `tb_record` </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> `stu_id` <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生的姓名、生日和所在学院名称</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_birth`, `col_name` </span><br><span class="line"><span class="keyword">from</span> `tb_student`, `tb_college` </span><br><span class="line"><span class="keyword">where</span> `tb_student`.`col_id`<span class="operator">=</span>`tb_college`.`col_id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_birth`, `col_name` </span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">inner</span> <span class="keyword">join</span> `tb_college` </span><br><span class="line"><span class="keyword">on</span> `tb_student`.`col_id`<span class="operator">=</span>`tb_college`.`col_id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `stu_birth`, `col_name` </span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">natural</span> <span class="keyword">join</span> `tb_college`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生姓名、课程名称以及成绩(连接查询/联结查询)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `cou_name`, `score` </span><br><span class="line"><span class="keyword">from</span> `tb_student`, `tb_course`, `tb_record` </span><br><span class="line"><span class="keyword">where</span> `tb_student`.`stu_id`<span class="operator">=</span>`tb_record`.`stu_id` </span><br><span class="line"><span class="keyword">and</span> `tb_course`.`cou_id`<span class="operator">=</span>`tb_record`.`cou_id` </span><br><span class="line"><span class="keyword">and</span> `score` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `cou_name`, `score` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> `tb_record` <span class="keyword">on</span> `tb_student`.`stu_id`<span class="operator">=</span>`tb_record`.`stu_id` </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> `tb_course` <span class="keyword">on</span> `tb_course`.`cou_id`<span class="operator">=</span>`tb_record`.`cou_id` </span><br><span class="line"><span class="keyword">where</span> `score` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `cou_name`, `score` <span class="keyword">from</span> `tb_student` </span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">join</span> `tb_record` </span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">join</span> `tb_course`</span><br><span class="line"><span class="keyword">where</span> `score` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充：上面的查询结果取前5条数据(分页查询)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `cou_name`, `score` </span><br><span class="line"><span class="keyword">from</span> `tb_student`, `tb_course`, `tb_record` </span><br><span class="line"><span class="keyword">where</span> `tb_student`.`stu_id`<span class="operator">=</span>`tb_record`.`stu_id` </span><br><span class="line"><span class="keyword">and</span> `tb_course`.`cou_id`<span class="operator">=</span>`tb_record`.`cou_id` </span><br><span class="line"><span class="keyword">and</span> `score` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">desc</span> </span><br><span class="line">limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充：上面的查询结果取第6-10条数据(分页查询)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `cou_name`, `score` </span><br><span class="line"><span class="keyword">from</span> `tb_student`, `tb_course`, `tb_record` </span><br><span class="line"><span class="keyword">where</span> `tb_student`.`stu_id`<span class="operator">=</span>`tb_record`.`stu_id` </span><br><span class="line"><span class="keyword">and</span> `tb_course`.`cou_id`<span class="operator">=</span>`tb_record`.`cou_id` </span><br><span class="line"><span class="keyword">and</span> `score` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">desc</span> </span><br><span class="line">limit <span class="number">5</span> <span class="keyword">offset</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充：上面的查询结果取第11-15条数据(分页查询)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `cou_name`, `score` </span><br><span class="line"><span class="keyword">from</span> `tb_student`, `tb_course`, `tb_record` </span><br><span class="line"><span class="keyword">where</span> `tb_student`.`stu_id`<span class="operator">=</span>`tb_record`.`stu_id` </span><br><span class="line"><span class="keyword">and</span> `tb_course`.`cou_id`<span class="operator">=</span>`tb_record`.`cou_id` </span><br><span class="line"><span class="keyword">and</span> `score` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">desc</span> </span><br><span class="line">limit <span class="number">5</span> <span class="keyword">offset</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询选课学生的姓名和平均成绩(子查询和连接查询)</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `avg_score` </span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id` <span class="keyword">as</span> `sid`, round(<span class="built_in">avg</span>(`score`), <span class="number">1</span>) <span class="keyword">as</span> avg_score </span><br><span class="line">    <span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`</span><br><span class="line">) <span class="keyword">as</span> `t2` <span class="keyword">on</span> `stu_id`<span class="operator">=</span>`sid`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生的姓名和选课的数量</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `total` <span class="keyword">from</span> `tb_student` <span class="keyword">as</span> `t1`</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id`, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> `total`</span><br><span class="line">    <span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`</span><br><span class="line">) <span class="keyword">as</span> `t2` <span class="keyword">on</span> `t1`.`stu_id`<span class="operator">=</span>`t2`.`stu_id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个学生的姓名和选课数量(左外连接和子查询)</span></span><br><span class="line"><span class="comment">-- 左外连接：左表（写在join左边的表）的每条记录都可以查出来，不满足连表条件的地方填充null。</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, <span class="built_in">coalesce</span>(`total`, <span class="number">0</span>) <span class="keyword">as</span> `total`</span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">as</span> `t1`</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id`, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> `total`</span><br><span class="line">    <span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`</span><br><span class="line">) <span class="keyword">as</span> `t2` <span class="keyword">on</span> `t1`.`stu_id`<span class="operator">=</span>`t2`.`stu_id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改选课记录表，去掉 stu_id 列的外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `tb_record` <span class="keyword">drop</span> <span class="keyword">foreign</span> key `fk_record_stu_id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入两条新纪录（注意：没有学号为 5566 的学生）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_record` </span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">default</span>, <span class="number">5566</span>, <span class="number">1111</span>, <span class="string">&#x27;2019-09-02&#x27;</span>, <span class="number">80</span>),</span><br><span class="line">    (<span class="keyword">default</span>, <span class="number">5566</span>, <span class="number">2222</span>, <span class="string">&#x27;2019-09-02&#x27;</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接：右表（写在join右边的表）的每条记录都可以查出来，不满足连表条件的地方填充null。</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `total` <span class="keyword">from</span> `tb_student` <span class="keyword">as</span> `t1`</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id`, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> `total`</span><br><span class="line">    <span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`</span><br><span class="line">) <span class="keyword">as</span> `t2` <span class="keyword">on</span> `t1`.`stu_id`<span class="operator">=</span>`t2`.`stu_id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全外连接：左表和右表的每条记录都可以查出来，不满足连表条件的地方填充null。</span></span><br><span class="line"><span class="comment">-- 说明：MySQL不支持全外连接，所以用左外连接和右外连接的并集来表示。</span></span><br><span class="line"><span class="keyword">select</span> `stu_name`, `total`</span><br><span class="line"><span class="keyword">from</span> `tb_student` <span class="keyword">as</span> `t1`</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id`, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> `total`</span><br><span class="line">    <span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`</span><br><span class="line">) <span class="keyword">as</span> `t2` <span class="keyword">on</span> `t1`.`stu_id`<span class="operator">=</span>`t2`.`stu_id`</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> `stu_name`, `total` <span class="keyword">from</span> `tb_student` <span class="keyword">as</span> `t1`</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> `stu_id`, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> `total`</span><br><span class="line">    <span class="keyword">from</span> `tb_record` <span class="keyword">group</span> <span class="keyword">by</span> `stu_id`</span><br><span class="line">) <span class="keyword">as</span> `t2` <span class="keyword">on</span> `t1`.`stu_id`<span class="operator">=</span>`t2`.`stu_id`;</span><br></pre></td></tr></table></figure><ol><li><p>MySQL目前的版本不支持全外连接，上面我们通过<code>union</code>操作，将左外连接和右外连接的结果求并集实现全外连接的效果。大家可以通过下面的图来加深对连表操作的认识。</p><img src="https://img-blog.csdnimg.cn/f43dcc0be6bc4e7e8b9fdabc464360de.png#pic_center" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/f43dcc0be6bc4e7e8b9fdabc464360de.png#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></li><li><p>MySQL 中支持多种类型的运算符，包括：算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）、比较运算符（<code>=</code>、<code>&lt;&gt;</code>、<code>&lt;=&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>BETWEEN...AND..</code>.、<code>IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>LIKE</code>、<code>RLIKE</code>、<code>REGEXP</code>）、逻辑运算符（<code>NOT</code>、<code>AND</code>、<code>OR</code>、<code>XOR</code>）和位运算符（<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>~</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;</code>），我们可以在 DML 中使用这些运算符处理数据。</p></li><li><p>在查询数据时，可以在<code>SELECT</code>语句及其子句（如<code>WHERE</code>子句、<code>ORDER BY</code>子句、<code>HAVING</code>子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。</p></li></ol><p>常用字符串函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>CONCAT</code></td><td>将多个字符串连接成一个字符串</td></tr><tr><td><code>FORMAT</code></td><td>将数值格式化成字符串并指定保留几位小数</td></tr><tr><td><code>FROM_BASE64</code> &#x2F; <code>TO_BASE64</code></td><td>BASE64解码&#x2F;编码</td></tr><tr><td><code>BIN</code> &#x2F; <code>OCT</code> &#x2F; <code>HEX</code></td><td>将数值转换成二进制&#x2F;八进制&#x2F;十六进制字符串</td></tr><tr><td><code>LOCATE</code></td><td>在字符串中查找一个子串的位置</td></tr><tr><td><code>LEFT</code> &#x2F; <code>RIGHT</code></td><td>返回一个字符串左边&#x2F;右边指定长度的字符</td></tr><tr><td><code>LENGTH</code> &#x2F; <code>CHAR_LENGTH</code></td><td>返回字符串的长度以字节&#x2F;字符为单位</td></tr><tr><td><code>LOWER</code> &#x2F; <code>UPPER</code></td><td>返回字符串的小写&#x2F;大写形式</td></tr><tr><td><code>LPAD</code> &#x2F; <code>RPAD</code></td><td>如果字符串的长度不足，在字符串左边&#x2F;右边填充指定的字符</td></tr><tr><td><code>LTRIM</code> &#x2F; <code>RTRIM</code></td><td>去掉字符串前面&#x2F;后面的空格</td></tr><tr><td><code>ORD</code> &#x2F; <code>CHAR</code></td><td>返回字符对应的编码&#x2F;返回编码对应的字符</td></tr><tr><td><code>STRCMP</code></td><td>比较字符串，返回-1、0、1分别表示小于、等于、大于</td></tr><tr><td><code>SUBSTRING</code></td><td>返回字符串指定范围的子串</td></tr></tbody></table><p>常用数值函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>ABS</code></td><td>返回一个数的绝度值</td></tr><tr><td><code>CEILING</code> &#x2F; <code>FLOOR</code></td><td>返回一个数上取整&#x2F;下取整的结果</td></tr><tr><td><code>CONV</code></td><td>将一个数从一种进制转换成另一种进制</td></tr><tr><td><code>CRC32</code></td><td>计算循环冗余校验码</td></tr><tr><td><code>EXP</code> &#x2F; <code>LOG</code> &#x2F; <code>LOG2</code> &#x2F; <code>LOG10</code></td><td>计算指数&#x2F;对数</td></tr><tr><td><code>POW</code></td><td>求幂</td></tr><tr><td><code>RAND</code></td><td>返回[0,1)范围的随机数</td></tr><tr><td><code>ROUND</code></td><td>返回一个数四舍五入后的结果</td></tr><tr><td><code>SQRT</code></td><td>返回一个数的平方根</td></tr><tr><td><code>TRUNCATE</code></td><td>截断一个数到指定的精度</td></tr><tr><td><code>SIN</code> &#x2F; <code>COS</code> &#x2F; <code>TAN</code> &#x2F; <code>COT</code> &#x2F; <code>ASIN</code> &#x2F; <code>ACOS</code> &#x2F; <code>ATAN</code></td><td>三角函数</td></tr></tbody></table><p>常用时间日期函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>CURDATE</code> &#x2F; <code>CURTIME</code> &#x2F; <code>NOW</code></td><td>获取当前日期&#x2F;时间&#x2F;日期和时间</td></tr><tr><td><code>ADDDATE</code> &#x2F; <code>SUBDATE</code></td><td>将两个日期表达式相加&#x2F;相减并返回结果</td></tr><tr><td><code>DATE</code> &#x2F; <code>TIME</code></td><td>从字符串中获取日期&#x2F;时间</td></tr><tr><td><code>YEAR</code> &#x2F; <code>MONTH</code> &#x2F; <code>DAY</code></td><td>从日期中获取年&#x2F;月&#x2F;日</td></tr><tr><td><code>HOUR</code> &#x2F; <code>MINUTE</code> &#x2F; <code>SECOND</code></td><td>从时间中获取时&#x2F;分&#x2F;秒</td></tr><tr><td><code>DATEDIFF</code> &#x2F; <code>TIMEDIFF</code></td><td>返回两个时间日期表达式相差多少天&#x2F;小时</td></tr><tr><td><code>MAKEDATE</code> &#x2F; <code>MAKETIME</code></td><td>制造一个日期&#x2F;时间</td></tr></tbody></table><p>常用流程函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>IF</code></td><td>根据条件是否成立返回不同的值</td></tr><tr><td><code>IFNULL</code></td><td>如果为NULL则返回指定的值否则就返回本身</td></tr><tr><td><code>NULLIF</code></td><td>两个表达式相等就返回NULL否则返回第一个表达式的值</td></tr></tbody></table><p>其他常用函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>MD5</code> &#x2F; <code>SHA1</code> &#x2F; <code>SHA2</code></td><td>返回字符串对应的哈希摘要</td></tr><tr><td><code>CHARSET</code> &#x2F; <code>COLLATION</code></td><td>返回字符集&#x2F;校对规则</td></tr><tr><td><code>USER</code> &#x2F; <code>CURRENT_USER</code></td><td>返回当前用户</td></tr><tr><td><code>DATABASE</code></td><td>返回当前数据库名</td></tr><tr><td><code>VERSION</code></td><td>返回当前数据库版本</td></tr><tr><td><code>FOUND_ROWS</code> &#x2F; <code>ROW_COUNT</code></td><td>返回查询到的行数&#x2F;受影响的行数</td></tr><tr><td><code>LAST_INSERT_ID</code></td><td>返回最后一个自增主键的值</td></tr><tr><td><code>UUID</code> &#x2F; <code>UUID_SHORT</code></td><td>返回全局唯一标识符</td></tr></tbody></table><h3 id="2-4-DCL（数据控制语言）"><a href="#2-4-DCL（数据控制语言）" class="headerlink" title="2.4 DCL（数据控制语言）"></a>2.4 DCL（数据控制语言）</h3><p>数据控制语言用于给指定的用户授权或者从召回指定用户的指定权限，这组操作对数据库管理员来说比较重要，将一个用户的权限最小化（刚好够用）是非常重要的，对数据库的安全至关重要。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建名为 wangdachui 的账号并为其指定口令，允许该账号从任意主机访问</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;wangdachui&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权 wangdachui 可以对名为school的数据库执行 select 和 insert 操作</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">insert</span> <span class="keyword">on</span> `school`.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;wangdachui&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 召回 wangdachui 对school数据库的 insert 权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span> <span class="keyword">on</span> `school`.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;wangdachui&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是SQL？简单地说，SQL就是访问和处理关系数据库的计算机标准语言。也就是说，无论用什么编程语言（Java、Python、C++……）编写程序，只要涉及到操作关系数据库，比如，一个电商网站需要把用户和商品信息存入数据库，或者一个手机游戏需要把用户的道具、通关信息存入数据库，都必须通过SQL来完成。本篇主要以构建一个简单的选课系统数据库来分析数据定义、数据操作、数据查询、数据控制。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="MySQL 基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MySQL-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="SQL" scheme="https://qxienote.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qxienote.com/article/0.html"/>
    <id>https://qxienote.com/article/0.html</id>
    <published>2023-08-01T11:25:57.598Z</published>
    <updated>2023-08-06T13:32:23.409Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组矩形，判断它们是否符合合并条件。给定输入数据rects， 其中单个矩形表示为rects[i] &#x3D; [x1,y2,x2,y2]，x1和y1表示左下角坐标，x2，y2表示右上角坐标。可以进行合并的条件:<br>1.任意两个矩形不存在交集;<br>2.所有矩形取并集也为矩形，不存在空隙。</p><p>示例：</p><p>请补充主函数的的输入输出代码，输入输出如下：<br>输入：[[0,1,2,4],[0,4,4,5],[1,1,4,2],[2,2,4,4]]<br>输出： False</p><p>现有n个编号为0~n-1的理电池，以一颗树的形式组织连接起来对于其中<br>的任何一个理电池，定义其供电难度为该锂电池到其他所有锂电池的距离之和（树状结构中每条连接线的长度记为1）。给定一个树形组织的钾电池组，公司需要求出每个钾电池的供电难度来判断最佳供电位置。</p><p>输入描述：第一行输入n，表示钾电池的数量接下来输入n-1行整数，每一行有两个整数i和j，表示编号为i的鲤电池和编号为j的钾电池相连<br>输出描述：输出一个长度为n的数组answer，其中answer[i]表示第i个电池的供电难度。</p><p>输入<br>6<br>0  1<br>0  2<br>2  3<br>2  4<br>2  5</p><p>输出<br>8   12  6   10  10  10</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一组矩形，判断它们是否符合合并条件。给定输入数据rects， 其中单个矩形表示为rects[i] &amp;#x3D;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>吴思历史经典三部曲-阅读笔记</title>
    <link href="https://qxienote.com/article/bdb71d14.html"/>
    <id>https://qxienote.com/article/bdb71d14.html</id>
    <published>2023-07-30T12:19:18.000Z</published>
    <updated>2023-07-30T12:59:48.946Z</updated>
    
    <content type="html"><![CDATA[<p>一口气读完潜规则、血酬定律、我想重新解释历史，不得不佩服作者解释历史的新视角，也会让自己更好地理解社会现象。</p><span id="more"></span><h2 id="《潜规则：中国历史中的真实游戏》"><a href="#《潜规则：中国历史中的真实游戏》" class="headerlink" title="《潜规则：中国历史中的真实游戏》"></a>《潜规则：中国历史中的真实游戏》</h2><h3 id="第2章-修订版说明"><a href="#第2章-修订版说明" class="headerlink" title="第2章 修订版说明"></a>第2章 修订版说明</h3><p>在仔细揣摩了一些历史人物和事件之后，我发现支配这个集团行为的东西，经常与他们宣称遵循的那些原则相去甚远。例如仁义道德，忠君爱民，清正廉明等等。真正支配这个集团行为的东西，在更大的程度上是非常现实的利害计算。</p><h3 id="第3章-自序：关于“潜规则”和这本书"><a href="#第3章-自序：关于“潜规则”和这本书" class="headerlink" title="第3章 自序：关于“潜规则”和这本书"></a>第3章 自序：关于“潜规则”和这本书</h3><p>中国社会在正式规定的各种制度之外，在种种明文规定的背后，实际存在着一个不成文的又获得广泛认可的规矩，一种可以称为内部章程的东西。恰恰是这种东西，而不是冠冕堂皇的正式规定，支配着现实生活的运行。</p><h3 id="第4章-《正编》：身怀利器"><a href="#第4章-《正编》：身怀利器" class="headerlink" title="第4章 《正编》：身怀利器"></a>第4章 《正编》：身怀利器</h3><p>如果没人较真，这些脑袋就是战功，大家升官发财，万事大吉。如果有人较真，这些脑袋就可能成为罪证，这帮将校罪过不小。</p><h3 id="第5章-老百姓是个冤大头"><a href="#第5章-老百姓是个冤大头" class="headerlink" title="第5章 老百姓是个冤大头"></a>第5章 老百姓是个冤大头</h3><p>个体狼的利益与狼群的集体利益未必一致。如果我的节制不能导致别人的节制，我的自我约束对羊群来说就没有任何意义，徒然减少自己的份额而已。在老狼忍不住饕餮的时候，我可以听到一声叹息：它们要是变成刺猬，俺们不就变成清官了么？</p><h3 id="第7章-当贪官的理由"><a href="#第7章-当贪官的理由" class="headerlink" title="第7章 当贪官的理由"></a>第7章 当贪官的理由</h3><p>无论哪朝哪代，人的一生必定要做平一个等式：一生总收入等于一生总开支。节余的是遗产，亏损的为债务。</p><h3 id="第8章-恶政是一面筛子"><a href="#第8章-恶政是一面筛子" class="headerlink" title="第8章 恶政是一面筛子"></a>第8章 恶政是一面筛子</h3><p>一个变质的政府，一个剥削性的越来越强，服务性越来越弱的政府，自然也需要变质的官员，需要他们泯灭良心，心狠手辣，否则就要请你走人。</p><p>帝国制度很善于把常人难免的弱点和毛病培育为全国性的灾难。</p><h3 id="第10章-摆平违规者"><a href="#第10章-摆平违规者" class="headerlink" title="第10章 摆平违规者"></a>第10章 摆平违规者</h3><p>既然这场对局成了一场要命的灾难，恐怕双方的策略都难以为后人效法，我们也就不能指望其成为定势或者叫常规。真实的常规是：对局者双赢，老百姓买单。</p><h3 id="第11章-论资排辈也是好东西"><a href="#第11章-论资排辈也是好东西" class="headerlink" title="第11章 论资排辈也是好东西"></a>第11章 论资排辈也是好东西</h3><p>论资排辈和抽签本身堪称极其高明的流线型设计。如果要发明一种在官场中的阻力最小、压力最轻、各方面都能接受的肥缺分配办法，恐怕那就是论资排辈加抽签。资格和辈分是硬指标，不容易产生争议，这就能够持久。人人都会老的，谁都不会觉得这个办法对自己格外不公平，这就容易接受</p><p>这就是说，在进行官场谋划，努力摆平各种利害关系的时候，无须考虑老百姓的压力，他们根本就不能构成一个压力集团，甚至连一个舆论集团也不是，不过是一盘散沙。那时候又没有“海选”的手段，难道某粒沙子还能跑到吏部去为你争肥缺或者砸饭碗么？如果不能，考虑他们岂不是多余？作为整个政权的根基，老百姓在理论和原则上非常重要，所谓“水可载舟，亦可覆舟”，因此才有了“选贤任能”、“为民父母”、“爱民如子”之类的大原则和正式规则，以免洪水泛滥，大家遭殃。如果真能做到这一套，老百姓也会感到十分幸福，当牛作马虽然免不了，皇亲贵族的三宫六院和伺候他们的万千宦官也要好好养活着伺候着，但身边毕竟有了一个好牧人。只要他早出晚归，兢兢业业地替天子放牧，屠宰的季节和数量掌握得比较有分寸，老百姓也就像鲁迅说的那样暂时作稳了奴隶。</p><h3 id="第12章-新官堕落定律"><a href="#第12章-新官堕落定律" class="headerlink" title="第12章 新官堕落定律"></a>第12章 新官堕落定律</h3><p>所谓堕落，当然是从圣贤要求的标准看。如果换成新官适应社会和熟悉业务的角度，我们看到的则是一个重新学习和迅速进步的过程，一个接受再教育的过程。第一次是接受圣贤的教育，第二次则是接受胥吏衙役和人间大学的教育。第一次教育教了官员们满口仁义道德，第二次教育教了他们一肚子男娼女盗。</p><h3 id="第13章-正义的边界总要老"><a href="#第13章-正义的边界总要老" class="headerlink" title="第13章 正义的边界总要老"></a>第13章 正义的边界总要老</h3><p>随着年头的增加，某些行为边界总要朝有利于官吏的方向移动。如果更细致地划分，行为边界的移动还有名义移动与实际移动之别。</p><h3 id="第14章-官场传统的心传"><a href="#第14章-官场传统的心传" class="headerlink" title="第14章 官场传统的心传"></a>第14章 官场传统的心传</h3><p>清朝官员到北京行贿，先要按规矩到琉璃厂的字画古董店问路。讲明想送某大官多少两银子之后，字画店老板就会很内行地告诉他，应该送一张某画家的画。收下银子后，字画店的老板会到那位大官的家里，用这笔银子买下那位官员收藏的这位画家的画，再将这张画交给行贿者。行贿者只要捧着这张很雅致的毫无铜臭的礼物登门拜访，完璧归赵，行贿就高雅地完成了。</p><h3 id="第15章-晏氏转型"><a href="#第15章-晏氏转型" class="headerlink" title="第15章 晏氏转型"></a>第15章 晏氏转型</h3><p>最开始，我们遵守仁义道德，不欺下不媚上，努力当好父母官。这是理想中的为官之道，是冠冕堂皇的官场进步策略，在历朝历代的官场上确实也可以找到这样的清官。可是我们在抵抗堕落的诱惑，努力当一个忠君爱民的好官的时候，竟然受到了来自上边和下边的强大压力。我们发现，原来上边是很想让我们媚的，诱导我们媚，暗示我们媚，强迫我们媚，不媚就有祸。而媚上就要上贡，就要贡鱼贡虾，这就难免欺负下边，让鱼虾们倒点霉。出乎意料的是，下边也很愿意我们欺负，虾群中的积极分子会主动协助我们欺负，把他们的邻居加工好，送货上门，并不用我们太费心。如此容易地“欺下”之后，我们又进一步认识到，原来老百姓并不难欺负，欺负了他们几次，他们也没什么办法。那么我们如何是好？是放弃仁义道德，转而采取欺下媚上的官场生存策略呢，还是明知山有虎，偏向虎山行，硬要跟领导和群众对着干呢？</p><h3 id="第16章-崇祯死弯——帝国潜规则的一个总结"><a href="#第16章-崇祯死弯——帝国潜规则的一个总结" class="headerlink" title="第16章 崇祯死弯——帝国潜规则的一个总结"></a>第16章 崇祯死弯——帝国潜规则的一个总结</h3><p>所以林彪元帅说：“枪杆子，笔杆子，夺取政权靠这两杆子，巩固政权也要靠这两杆子。”漂亮话确实可以当枪用。</p><h3 id="第17章-有关潜规则的定义"><a href="#第17章-有关潜规则的定义" class="headerlink" title="第17章 有关潜规则的定义"></a>第17章 有关潜规则的定义</h3><p>潜规则是人们私下认可的行为约束；2　这种行为约束，依据当事各方的造福或损害能力，在社会行为主体的互动中自发生成，可以使互动各方的冲突减少，交易成本降低；3　所谓约束，就是行为越界必将招致报复，对这种利害后果的共识，强化了互动各方对彼此行为的预期的稳定性；4　这种在实际上得到遵从的规矩，背离了正义观念或正式制度的规定，侵犯了主流意识形态或正式制度所维护的利益，因此不得不以隐蔽的形式存在，当事人对隐蔽形式本身也有明确的认可；5　通过这种隐蔽，当事人将正式规则的代表屏蔽于局部互动之外，或者，将代表拉入私下交易之中，凭借这种私下的规则替换，获取正式规则所不能提供的利益。我想再强调一句。在潜规则的生成过程中，当事人实际并不是两方，而是三方：交易双方再加上更高层次的正式制度代表。</p><h3 id="第18章-《杂编》：笑话天道"><a href="#第18章-《杂编》：笑话天道" class="headerlink" title="第18章 《杂编》：笑话天道"></a>第18章 《杂编》：笑话天道</h3><p>第一，天道可以有许多不同的叫法，譬如天命天意或者历史规律，但在深层结构上这两者是一回事。第二，天道或者历史规律与民心或者人民利益完全可能出现冲突，这时必定要遭遇究竟谁服从谁的问题，皇上们的固定看法是人民服从天道，因为他本人就是天道的代表。</p><h3 id="第21章-理解迷信"><a href="#第21章-理解迷信" class="headerlink" title="第21章 理解迷信"></a>第21章 理解迷信</h3><p>目前的意识形态舞台上，回荡着高昂的陈词滥调，演出着战国争雄的故事。而最终决定胜负的，大概是台下和台后的现实世界里发生的事情。</p><h3 id="第22章-代后记：农民与帝国"><a href="#第22章-代后记：农民与帝国" class="headerlink" title="第22章 代后记：农民与帝国"></a>第22章 代后记：农民与帝国</h3><p>暴力赋敛集团是比生产关系中的阶级划分根源更深的社会集团，他们是生产关系本身的直接选择者和维护者。这个集团控制着暴力资源，拥有强大的伤害能力。为了自身利益的最大化，他们可以占有生产资料和劳动者的人身，也可以用更有利或更省事的赋敛方式代替这种占有。</p><p>这种偏离均衡点的趋势，发源于官僚代理集团对代理人私利的不懈追求。最高统治者无力约束这种庞大的私下追求，弱小分散的小农阶级又无力抵抗各级权势集团整体或个体的巧取豪夺，于是就有了潜规则体系对儒家宣扬的均衡体系的替代，就有了王朝更替和治乱循环。王朝更替是帝国制度对过度失衡的自我校正机制。</p><h3 id="第23章-附录"><a href="#第23章-附录" class="headerlink" title="第23章 附录"></a>第23章 附录</h3><p>它其实就是一种权力结构的方式。无非是有那么一拨人掌握了合法伤害权，欺负另外一边，而另外一边反抗成本太高，那我只有认账了——行，就按你说的来吧，多交点儿就多交点儿，多上点贡就上点贡。这不就潜规则出来了？很简单，用不着捕风捉影讲那些虚的。</p><h2 id="《血酬定律：中国历史中的生存游戏》"><a href="#《血酬定律：中国历史中的生存游戏》" class="headerlink" title="《血酬定律：中国历史中的生存游戏》"></a>《血酬定律：中国历史中的生存游戏》</h2><h3 id="自序"><a href="#自序" class="headerlink" title="自序"></a>自序</h3><p>所有规则的设立，说到底，都遵循一条根本规则：暴力最强者说了算。这是一条元规则，决定规则的规则。</p><h3 id="匪变：血酬定律及其推想-1"><a href="#匪变：血酬定律及其推想-1" class="headerlink" title="匪变：血酬定律及其推想(1)"></a>匪变：血酬定律及其推想(1)</h3><p>消除潜规则的最有效的方式，就是允许受害者监督控制官吏，而让羊群监督甚至控制牧羊犬是很危险的，是可能导致变天的。正如老子和韩非所说，官爵赏罚和军队一样，乃“国之利器，不可以示人”。为了保证血染江山永不变色，控制权一定要牢牢掌握在牧主手中，哪怕潜规则泛滥为滔天洪水。</p><h3 id="命价考略-1"><a href="#命价考略-1" class="headerlink" title="命价考略(1)"></a>命价考略(1)</h3><p>绑票术语，除了上述之外，还有吊羊、接财神、请猪头、养鹅生蛋、票、肉票、架票、绑票、新票、彩票（富人）、当票（穷人）、土票（农民）、花票（女人）、水头（票价）、压水（说票者）、叫票（讲票价）、领票（赎回肉票）、看票（看守人质）、票房（拘留肉票之处）、票房头（管票房的头目）、叶子（肉票）、叶子官（看管肉票的头目）、滤叶子（审问拷打肉票）、撕票（杀人质）。</p><h3 id="命价考略-2"><a href="#命价考略-2" class="headerlink" title="命价考略(2)"></a>命价考略(2)</h3><p>当然，从来就没有什么救世主，也不能靠神仙皇帝。人民的生存权，与牛羊猪鸡的生存权一样，说到底，还是自己用肉蛋奶和皮毛换来的，具体到某个品种的生存权和发展权，则是靠比较高的生产力水平竞争来的。</p><p>在资源瓜分完毕的社会格局中，维持生存的底线是一条血线。血线之下，各种物资都获得了命资的意义，一碗饭可以延续一天的性命，一杯水也可以等于一条人命。突破血线必定导致流血，要么自己失血折命，要么博命威胁他人，劫夺活命之资。</p><h3 id="潜规则与正式规则切换的秘密"><a href="#潜规则与正式规则切换的秘密" class="headerlink" title="潜规则与正式规则切换的秘密"></a>潜规则与正式规则切换的秘密</h3><p>官话通常比较好听，因为它所代表的正式规范考虑到了“水可载舟、亦可覆舟”，不太敢玩水。问题在于，水并不总能以洪水的形态出现，那是非常时期暴民造反的形态。当水被装在缸里，盛在桶里，倒在碗里的时候，根本就没有载舟覆舟的力量。这时候，官话不过是说说而已，当真去做便是自找亏吃，而多数人是不会自找亏吃的。于是，官话就有了糊弄人的意思，就成了一个贬义词，说官话者的形象难免受损。可是官场风波险恶，说官话不会让人抓住把柄，形象受损也要说下去。</p><h3 id="刘瑾潜流-3"><a href="#刘瑾潜流-3" class="headerlink" title="刘瑾潜流(3)"></a>刘瑾潜流(3)</h3><p>实际上，每个官、吏、役的职位，包括临时性的职位，都是潜流网络中的一个节点。不同节点所连接的潜流数目不同，流量也不同，因而有了肥缺与苦差之别。这是一幅复杂得可怕的庞大图景，</p><p>天下的官随你至卑极小的，如仓大使、巡简司，也还有些外来钱。惟有这教官，管的是那几个酸子。有体面的，还来送你几分节仪；没体面的，终年也不来见你，有甚往来交际？所以这官极苦。</p><p>这些严重超编的吏员靠什么生活呢？中央财政的地方存留中没有他们的位置，少数在中央财政安排中有位置的吏员，名义收入也少得可怜。但他们的生活却很不错，并不比如今县委县政府的中层干部的自我感觉差。他们是各项工作的具体执行者，收取陋规和常例的机会也多得多。</p><p>实际上，最基层的毛渠系统恰恰最稳定的，就好像基本建筑材料一样，不管建筑样式或表面装修如何随着权力分布的变化而花样翻新，基本构成总是秦砖汉瓦，永远是衙役们面对百姓时的那副抽水机嘴脸。</p><p>我不能给你什么甜头，但我可以让你尝尝苦头。我成事不足，但我败事有余。你不想被害得倾家荡产，就要掏钱。横规矩就是这么牛气</p><h3 id="县官的隐身份-1"><a href="#县官的隐身份-1" class="headerlink" title="县官的隐身份(1)"></a>县官的隐身份(1)</h3><p>过客的权益不仅可以直接表现为他们的要求和勒索，间接地表现为同级或同事的讨好竞争，还可以表现为上级机关的财政提取，表现为兄弟单位的协助申请，表现为部下挨打犯难，甚至可以表现为关于儒家经典的哲学争论。</p><h3 id="县官的隐身份-2"><a href="#县官的隐身份-2" class="headerlink" title="县官的隐身份(2)"></a>县官的隐身份(2)</h3><p>徐霞客是我们的文化精英，但《徐霞客游记》也难免凝结着我们潜规则的文化传统。他旅游的许多费用，就是凭借捆绑和鞭挞的官府之威，违反中央规定，转嫁到了农民身上。在躲避逃亡的农民眼里，这等横吃横喝的过客无异于黑帮。</p><h3 id="灰牢考略-3"><a href="#灰牢考略-3" class="headerlink" title="灰牢考略(3)"></a>灰牢考略(3)</h3><p>总之，真正能阻止我们官吏成为酷吏的，恐怕既不是上级，也不是良心。把上级和良心糊弄好并不难。关键在于如何分配损害，也换句话说，就是要看我是否惹得起那些我打算损害的人。所谓惹不起，就是损害他们的风险很大，我可能因此遭到相同甚至更大的损害。</p><h3 id="庶人用暗器"><a href="#庶人用暗器" class="headerlink" title="庶人用暗器"></a>庶人用暗器</h3><p>这场被后来的历史学家视为革命的制度变迁，确实开辟了两个阶级共同受益的双赢局面，而新树立的规则其实并不神秘，无非是我们熟悉的那一套：“交足国家的，留够集体的，剩下都是自己的”，也就是1978年冒头的大包干——原来大包干也不是首创。</p><p>年轻的恋人们还在彼此思念和怨恨，蟋蟀还是同样地叫着，从田野里叫到屋檐下。人世过去了上百代，但人的本性和蟋蟀的本性一样，并没有多少变化。我们的心和古人的心是相通的。</p><h3 id="出售英雄-1"><a href="#出售英雄-1" class="headerlink" title="出售英雄(1)"></a>出售英雄(1)</h3><p>在任何时代的专制政府眼里，“聚众”都是重罪。</p><h3 id="出售英雄-3"><a href="#出售英雄-3" class="headerlink" title="出售英雄(3)"></a>出售英雄(3)</h3><p>算清了这笔账，我们就可以理解为何潜规则通行数十年而不遭抵抗。大家都愿意搭便车，最多不过出力拉拉边套，谁也不肯驾辕。驾辕者必须是一个不计较物质利益、不怕或不知风险、同时又有号召力的人。受儒家理想主义精神熏陶的周祥千恰恰满足了这些条件。他是红封阶级的一员，却热情地为白封小民争取道义要求的公正。这样的人，即使在读圣贤书的环境里也难得一见。所以，在他入狱后，那些愿意闹事又不敢挑头闹事的中农，在后怕和庆幸之余，难免会感到愤慨和良心的冲动。张潮青入狱后，东乡人的心理也应该类似。只要别太危险，他们当然想踹官府一脚，同时也为周祥千和张潮青做点什么。</p><p>从头到尾分析起来，民众尽管没有固定的脸谱，却始终是理性的趋利避害集团。他们没有永恒的朋友，也没有永恒的敌人，“只有自己的利益是永恒的”。而这个利益的安排和变动又可以在社会制度的特征中得到解释。</p><h3 id="洋旗的价值-3"><a href="#洋旗的价值-3" class="headerlink" title="洋旗的价值(3)"></a>洋旗的价值(3)</h3><p>所有规则的设立，说到底，都遵循一条根本规则：暴力最强者说了算。这是一条“元规则”，决定规则的规则。清政府打不过洋人，只好由洋人说了算，让轮船抢木船的饭碗。而木船船帮又打不过官府，要不来救济，只好向轮船开战。</p><h3 id="地霸发迹的历程-1"><a href="#地霸发迹的历程-1" class="headerlink" title="地霸发迹的历程(1)"></a>地霸发迹的历程(1)</h3><p>土地要素的报酬叫地租，资本要素的报酬叫利息，劳动要素的报酬叫工资，破坏要素的报酬应该叫什么呢？考虑到暴力与流血的必然联系，考虑到生命与生存资源的互换关系，我们不妨称之为“血酬”。</p><h3 id="地霸发迹的历程-2"><a href="#地霸发迹的历程-2" class="headerlink" title="地霸发迹的历程(2)"></a>地霸发迹的历程(2)</h3><p>生存资源是分层次的，所谓身外之物，只能用以称呼那些生存必需品之外的金钱货物，这条界线之内的则是“等身之物”，那是养身活命之物，甚至是命根子。在饥寒交迫濒临死亡者看来，寥寥衣食就意味着性命本身，绝非身外之物。这道界线是一条“命—物等价线”。突破了这条线，博命换物就可以视为等价交换。</p><h3 id="地霸发迹的历程-3"><a href="#地霸发迹的历程-3" class="headerlink" title="地霸发迹的历程(3)"></a>地霸发迹的历程(3)</h3><p>譬如黄股（资金股）、白股（技术股）、红股（实权人物的干股）、黑股（送给黑势力的股），以及“权力股”和“好汉股”等等，但我认为，这些概念都没有达到“硬股”的深度。</p><p>随着预期统治时间的延长，为了追求长期利益的最大化，狼群也要调整自己与羊群的关系，培养税基，确定最佳屠宰率，保护草场，维护羊群生存繁殖的有利条件，打退其他肉食动物的入侵。在这种情况下，血酬与报酬、掠夺与皇粮正税、横规矩与天经地义之间，确实存在相当大的重合部分。</p><p>毛泽东说中国“百代都行秦政制”，当然是不错的，这是“真龙”横空，百兽退避的格局。可是“飞龙在天”，不能一天到晚不睡觉，一年到头不休假。龙也有强有弱，有老有幼，有勤有懒。即使是一条勤快的强龙，高高在上，一双眼睛岂能看住伪装良好遍布天下的地头蛇？与真龙天子的控制强度反向对应，有多少漏洞死角，就有多少毒蛇猛兽。因此，帝国制度必定伴随着“半封建”或“小半封建”或“隐形半封建”制度，体现为地盘或地霸秩序。——越说越像是说大话了，就此打住。</p><h3 id="我认出了一个小物种"><a href="#我认出了一个小物种" class="headerlink" title="我认出了一个小物种"></a>我认出了一个小物种</h3><p>自然界的进化精彩纷呈，有了动物还会有专门麻痹它们神经的毒物，毒物之后还会进化出善于解毒的以毒物为食的动物，如此军备竞赛不断升级，生态体系也日趋复杂丰富，每个生态位上最终都会出现一个物种，可以充分利用那个位置上的资源流和能量流。我们的老大帝国历史悠久，社会生态的进化水平傲视全球。这个生态体系既然产生了肥硕的食肉物种，就难免产生吃他们的次级物种。</p><h3 id="白员的胜局-1"><a href="#白员的胜局-1" class="headerlink" title="白员的胜局(1)"></a>白员的胜局(1)</h3><p>当时的政府工作人员似乎也像如今一样，位子坐稳当了，就想把脏活累活交给临时工做。临时工干久了，位子也坐稳了，又会招徕和支使二等临时工，同一职位上就可以形成三个等级。</p><p>顾炎武说“一役而恒六七人共之”，说的是明末。明初吏治森严，腐败不那么严重，白员为正员的三倍。我在李昌平《我向总理说实话》一书中看到，2000年，湖北监利县容城财政所的正式编制为30多人，实际工作人员140多人，编外人员是编内人员的三四倍。[161]不如明初，却好于明末。</p><h3 id="金庸给我们编了什么梦"><a href="#金庸给我们编了什么梦" class="headerlink" title="金庸给我们编了什么梦"></a>金庸给我们编了什么梦</h3><p>我们特别怕麻烦，怕费心，怕受约束，还怕合作，怕处理复杂的人际关系，怕走复杂的组织程序，怕背诵复杂的法律条文，我们幻想舍弃这一切麻烦，不支付任何代价，像呼唤神灵一般地把正义从空中呼唤出来。</p><p>原来，我们的白日梦是一个富于正义感的懒汉的富贵幻想。</p><p>设身处地替皇上想一想，卧榻之畔岂容他人酣睡？一统天下正是追求社稷安全的合乎逻辑的行为。大侠凭着独步天下的武功不受任何威胁，皇上只有剪除异己才能不受任何威胁。在寻求绝对安全的意义上，追求绝顶武功的人，与追求天下一统的人，实属一丘之貉。</p><p>西方男人的幻想可以集中在巨大的财富上，但中国的财富很缺乏自卫能力，不那么值得幻想。在一个缺乏安全和秩序的社会里，对获利能力的幻想，不如对加害能力的幻想那么具有根本性，那么肆无忌惮所向披靡。这就是说，对加害能力和自卫能力的热切幻想，对公平和正义的热切幻想，反映了我们社会的缺陷。</p><h3 id="《万历十五年》没说透"><a href="#《万历十五年》没说透" class="headerlink" title="《万历十五年》没说透"></a>《万历十五年》没说透</h3><p>你发现合法地制造麻烦或为害他人的权力是值钱的，也确实不断地卖着大价钱，于是你给这种权力起了一个名字，叫做“合法伤害权”。</p><p>看来你们关心的都是同一个问题，就是公司的命运；所担忧的症结却不同，黄仁宇最担心的是公司管理，而你最担心的是公司与市场的关系。相比之下，黄仁宇更象一个管理学教授，而你更象是一个公司研究者。那你怎么看管理学教授所推重的数目字管理呢？</p><h3 id="潜规则的定义"><a href="#潜规则的定义" class="headerlink" title="潜规则的定义"></a>潜规则的定义</h3><p>我想再强调一句。在潜规则的生成过程中，当事人实际并不是两方，而是三方：交易双方再加上更高层次的正式制度代表。双方进行私下交易的时候确实是两个主体，但是，当他们隐蔽这种交易的时候，就变成以正式制度为对手的一个联盟。隐蔽本身就是一种策略，这种策略的存在，反映了更高层次的正式制度代表的存在。</p><h3 id="废渠的事理-1"><a href="#废渠的事理-1" class="headerlink" title="废渠的事理(1)"></a>废渠的事理(1)</h3><p>中国激进知识分子好谈专制与民主。他们只把专制与民主视为一种政治制度，又将政治制度视为一件可以随时替换的衣服。他们被西方政治概念蒙住了眼睛，看不到政治制度赖以有效运作的社会心理习惯。当广大村落农民尚未学会自我代表，且需要别人来代表时，一切法律与民主的制度建设，只能是一层浮在水面上的油。</p><h3 id="废渠的事理-2"><a href="#废渠的事理-2" class="headerlink" title="废渠的事理(2)"></a>废渠的事理(2)</h3><p>每个村都有别扭人，别说132户，就是32户里也不缺这样的人，他就要拿你一把，多捞一把，单靠谈判，靠利益引诱，却没有合法伤害别人的权力，事情简直就没有办成的希望。</p><p>民主在本质上不过是一种公共产品的交换机制，一些事情自己干不了，需要一个公仆替大家办，因此就要一边指挥并监督公仆，一边给他公平的报酬。小农经济的自给自足性强，与外界的交往少，对外界的依赖小，不那么愿意支付这笔费用。因此，小农经济很难自发地产生超家庭的合作组织。维持这种组织的费用太高了，谈判的费用太高了，监督的成本太高了，组织建立后向零散农户收取费用的成本也太高了，打起小算盘来竟然全面不合算。</p><h3 id="雁户：基本故事和变型故事"><a href="#雁户：基本故事和变型故事" class="headerlink" title="雁户：基本故事和变型故事"></a>雁户：基本故事和变型故事</h3><p>外出只是一个填补盖房之类的额外用度的青春期插曲。如果外出者没有在中途转变立足点，没有发生整个人生设计的改变，这些农民早晚是要回乡的。别小看这项简单的账目计算，它决定了数以亿计的当代中国农民的人生模式及悲欢离合。这是一个巨大的群体的基本故事。</p><h3 id="后记-1"><a href="#后记-1" class="headerlink" title="后记(1)"></a>后记(1)</h3><p>由秦国发挥到极致的国君集权制度，下层有一个能“尽其民力”和“地力”的自耕农制度，中层有一个由号令赏罚驱动的官僚代理制度，上层有一个控制一切资源的独裁者。凭借这个体制和奖励耕战的政策，秦国将作为主要物质生产者的农民的生产潜力激发出来，将各种人力资源的体力智力和勇气激发出来，并将激发出来的强大力量聚集在专制国君手中，形成了集中使用的巨大优势。依靠这种优势，秦国在暴力竞争中淘汰列强，创建了中国历史上第一个大一统帝国，礼乐征伐自天子出，立法权与合法暴力集中在皇帝一人手里。</p><p>“不为不可成，不求不可得，不处不可久，不行不可复。”在统治集团眼里，他们与物质生产者之间的关系，类似牧人与羊群的关系，而羊群对生长条件的要求、羊群的好恶和承受能力对牧人的行为是有重大影响的。为了长期利益的最大化，牧人必须约束自己，必须付出努力，提供并维护羊群的生长条件。这种政府功能，儒家称之为天恩或德政，西方现代政治经济理论称之为“公共产品”，由公民以付税的形式购买。</p><h3 id="后记-3"><a href="#后记-3" class="headerlink" title="后记(3)"></a>后记(3)</h3><p>欧洲统治者的额外索取不能超过资本抽逃的费用，超出的部分，不得不以权力交换，否则就要破坏自身的财政基础和政治稳定。退一步说，即使资本的存量部分抽逃困难，资本的增量部分也会望而却步，这就意味着自身财政基础逐渐被竞争对手超过，长此以往便有被淘汰吞并的危险。相比之下，中国的大一统帝国却不怕资本飞走，普天之下莫非王土，民间资本根本没有讨价还价不成时退出的空间，只能被帝国按住脑袋萎缩在角落里。</p><p>中国社会矛盾重重，战乱不断，阶级斗争的学说一定比和平宽容的自由主义更富于解释力。更重要的是，在马列主义描绘的世界历史图景中，蕴涵了重大的利益分配方案，而这种利益分配方式，特别能满足中国社会的各种期待。</p><p>这种理论隐藏着更富于诱惑力的利益分配方案：首先，一个特殊的意识形态集团，在关于自己的理论中获得了最崇高的中心位置，他们将掌握国家权力，支配一切，最后还要名垂青史。其次，无产阶级和其他劳动阶级将摆脱被剥削被压迫的地位，他们获得的是整个世界。最后，所有人类成员，最终都会在共产党人的事业中受益，人类将进入物质极大丰富，每个人都能自由发展的理想世界。</p><p>上述利益分配方案，潜伏在历史发展规律的客观而科学的表述之下。中国的读书人很熟悉这种路数。儒家的天道中就潜伏着重大的利益分配方案：皇权至高无上，官僚集团代天子牧民，劳力者交皇粮服劳役。马列主义在重新解释世界和历史的同时也重新进行利益分配，而马列主义在中国的命运，在很大程度上便取决于利益的分配是否妥当。</p><h3 id="附录-1"><a href="#附录-1" class="headerlink" title="附录(1)"></a>附录(1)</h3><p>劳动换取的收益叫工资，土地换取的收益叫地租，资本换取的收益叫利息，那么，流血拼命换取的收益叫什么？我称之为“血酬”。血酬的价值，取决于拼争对象的价值。如果拼抢的对象是人本身，譬如绑票，“票”价取决于当事人的支付能力和支付意愿。这就是血酬定律。在此过程中，人们的核心计算是：为了一定数量的生存资源，可以冒多大的伤亡风险？可以把自身这个资源需求者损害到什么程度？</p><h3 id="附录-2"><a href="#附录-2" class="headerlink" title="附录(2)"></a>附录(2)</h3><p>中国企业实际上是有等级身份的。按照公开宣称的说法，应该是人人平等，法人也人人平等，但是，如果企业是县太爷的儿子办的，就可以像县太爷一样享受本县百姓根本不能享受的特权。同样道理，皇家企业有皇家特权，黑道企业有黑道人物事实上享受的特权。每个企业都有自己的身份和相应的权利，最弱的是没有任何硬关系的平民身份。在中国，身份是企业构成的一个要素。</p><p>知识无涯，可多可少，灵魂却只有一个，不能让他枯萎了。</p><h2 id="《我想重新解释历史》"><a href="#《我想重新解释历史》" class="headerlink" title="《我想重新解释历史》"></a>《我想重新解释历史》</h2><h3 id="自序-1"><a href="#自序-1" class="headerlink" title="自序"></a>自序</h3><p>所有生存策略，从单细胞生物到人类各种职业，其存在和发展的条件是：所得≥所付。在等式之上，得付比越高，发展潜力越大，反之则衰亡。各种生存策略集团互动演化，好像不同物种互动演化一样，在自然环境的基础上形成世态平衡——人类社会各种生存策略的得付比平衡。换句话说，人往高处走，直到力尽计穷或得不偿失为止。</p><h3 id="官家主义和血酬史观"><a href="#官家主义和血酬史观" class="headerlink" title="官家主义和血酬史观"></a>官家主义和血酬史观</h3><p>血酬史观是用来分析暴力要素所主导的社会的历史观。它仅仅是历史观的一种特型。血酬史观很适合分析前资本主义时代，也就是暴力集团占据统治地位的时代。一旦暴力集团被生产集团取代，作为生产集团的资产阶级控制了暴力集团，把他们当作自己的守夜人，当作自己的保安，资本主义就诞生了。这时候，唯物史观“生产力决定生产关系、经济基础决定上层建筑”的解释力开始上升，因为资产阶级就是生产要素的组织者，他们支配经济，同时有力量影响上层建筑。</p><h3 id="建构血酬史观"><a href="#建构血酬史观" class="headerlink" title="建构血酬史观"></a>建构血酬史观</h3><p>消除潜规则很容易，有独立的司法、开放的传媒和专职的人大代表就可以。</p><p>土地仍在官市中交易。要改变房地产市场的现状，最根本的还是提高市场的纯度。即使政府依旧凭借权力分走一大块，如果拿这一大笔钱建廉租房，也可以改变现有的供求关系。另外好多人买房是为了回避通胀的危险，如果市场上投资途径增加，包括放开民间的金融，分流出部分资金，供求关系也会发生变化，高房价或许不至于如此过分。</p><p>土地仍在官市中交易。要改变房地产市场的现状，最根本的还是提高市场的纯度。即使政府依旧凭借权力分走一大块，如果拿这一大笔钱建廉租房，也可以改变现有的供求关系。另外好多人买房是为了回避通胀的危险，如果市场上投资途径增加，包括放开民间的金融，分流出部分资金，供求关系也会发生变化，高房价或许不至于如此过分。</p><p>“多数人”有同情心和正义感，但不至于杀身成仁、舍生取义，主要是利己的，不是利他的。承认这个事实，不管是经济政策还是政治制度的种种设计都要有所变化。</p><p>“多数人”有同情心和正义感，但不至于杀身成仁、舍生取义，主要是利己的，不是利他的。承认这个事实，不管是经济政策还是政治制度的种种设计都要有所变化。</p><p>“血酬定律”有更精确的定义，而后用潜规则和血酬定律这两个工具去分析中国社会，认为吃血酬的人构成一个暴力集团，或者叫破坏力集团，可以束缚生产力的发展，只有在它被遏制的时候生产力才能顺畅发展，这构成了一种新史观，我叫它“血酬史观”，用它去看中国历代王朝的演变，就会看到秦汉以来的社会不是封建社会，而是“官家主义”社会，是暴力集团打下江山后，选拔一批官员做自己的代理人，他们握有重权，形成一个“官家集团”；不仅政治上是这样，经济上也是，比如说一直有官市，还有民间的杂霸经济。官家把最好的东西拿走了，剩下的粗瓷大碗民间也要当成宝贝似的用暴力去争，形成一道道壁垒，整个市场被割得四分五裂。这样中国历史上就形成了一种既有官方暴力、又有民间暴力的杂霸经济。</p><p>“血酬定律”有更精确的定义，而后用潜规则和血酬定律这两个工具去分析中国社会，认为吃血酬的人构成一个暴力集团，或者叫破坏力集团，可以束缚生产力的发展，只有在它被遏制的时候生产力才能顺畅发展，这构成了一种新史观，我叫它“血酬史观”，用它去看中国历代王朝的演变，就会看到秦汉以来的社会不是封建社会，而是“官家主义”社会，是暴力集团打下江山后，选拔一批官员做自己的代理人，他们握有重权，形成一个“官家集团”；不仅政治上是这样，经济上也是，比如说一直有官市，还有民间的杂霸经济。官家把最好的东西拿走了，剩下的粗瓷大碗民间也要当成宝贝似的用暴力去争，形成一道道壁垒，整个市场被割得四分五裂。这样中国历史上就形成了一种既有官方暴力、又有民间暴力的杂霸经济。</p><h3 id="重建对中国历史的理解"><a href="#重建对中国历史的理解" class="headerlink" title="重建对中国历史的理解"></a>重建对中国历史的理解</h3><p>托尔斯泰的《战争与和平》或《安娜·卡列尼娜》。在主人公安德烈、彼尔和列文身上，我看到了自己的灵魂。我觉得托尔斯泰的句子可以直达我的心底，让我在不同的状态中再生活几遭。</p><p>《唐诗三百首》。古诗词可以迅速调动起我的人世沧桑感，呼唤出我的“根本性焦虑”。人生短暂，年华易逝，这种感觉让人的心境深远厚重，超越蝇营狗苟，进入造化的幽深，以至言语寥落，欲说还休。古诗十九首、宋词、元曲、《红楼梦》也有类似的功能。</p><p>贝克尔的《反抗死亡》。这本书对我的影响超过各派心理学的作品。这本书，还有蒂利希的《存在的勇气》，帮助我理解了人心和人性——超越动物的独有特性。10年前读毕此书，叹为观止，从此不再看心理学方面的书。</p><p>《庄子》。庄子描绘的人生和宇宙图景很精彩，可以把我们拔出自负和局促的泥潭，让我们面对那些最要紧的问题，同时又不至于沉溺太深，忘记自己在天地中的真实位置。</p><p>《微观经济学》，任意一本。尽管书中分析的是市场，但是理性清明，分析精巧，对我理解人心的一般状态和人际关系的均衡状态大有助益。读后有散光眼配了眼镜之感。</p><p>《制度经济学》，任意一本。用微观经济学的清明理性来分析制度变迁，这是一门历史学可以借用的好手艺，一旦领会了这种思路，想忘掉不用都难。</p><p>黄仁宇的《万历十五年》。1986年初读此书，便生出历史还可以这么写的感慨。数年后我也转向历史，多少受了这本书的影响。我还模仿过这本书的笔法，但不如我原来的写法顺手，只好作罢。至于写作深度，《万历十五年》沾了“形象大于思想”的光，给读者留下了见仁见智的余地，大体没什么问题。不过，真到了说几句硬话解释历史的关头，黄老先生的概括往往伤痕累累。</p><p>林达的《历史深处的忧虑》。这本书让我领会了美国及其政法制度的实质和演进历史。最难得的是，我觉得自己似乎随着林达在那个世界生活了一遭，所得所思格外深切。</p><h3 id="历史与公正计算"><a href="#历史与公正计算" class="headerlink" title="历史与公正计算"></a>历史与公正计算</h3><p>寻找最佳制度是一个历史过程，可能需要几代甚至十几代人。第一代人可能对新政策很满意，觉得比过去好。但第二第三代就不满了。第二代农民工对允许进城打工的政策不会再有感恩之情，他们更容易对歧视性待遇不满。</p><p>寻找最佳制度是一个历史过程，可能需要几代甚至十几代人。第一代人可能对新政策很满意，觉得比过去好。但第二第三代就不满了。第二代农民工对允许进城打工的政策不会再有感恩之情，他们更容易对歧视性待遇不满。</p><p>官家有三个主体，三个含义：第一个含义是皇帝，皇帝“主义”——当家作主，立法定规，立的法是王法；第二是条条块块的衙门，立的法是地方法规或部门法规。第三个含义是官员个人，官员个人凭借他代理的权力立法，就是潜规则。</p><h3 id="规则本身就是博弈的结果"><a href="#规则本身就是博弈的结果" class="headerlink" title="规则本身就是博弈的结果"></a>规则本身就是博弈的结果</h3><p>官府也是一种合法的暴力集团，有时候他们的活动与非法的暴力集团很难区分。理解了暴力活动背后的计算逻辑，才可以更深入地理解中国历史和中国社会。</p><h3 id="老子曲线"><a href="#老子曲线" class="headerlink" title="老子曲线"></a>老子曲线</h3><p>自由市场制度，自由企业制度，个体层面和宏观整体的自作自受的制度，与财富创造活动的强度，有很强的正相关。这是第一定律</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一口气读完潜规则、血酬定律、我想重新解释历史，不得不佩服作者解释历史的新视角，也会让自己更好地理解社会现象。&lt;/p&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://qxienote.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="观点摘录" scheme="https://qxienote.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E8%A7%82%E7%82%B9%E6%91%98%E5%BD%95/"/>
    
    
    <category term="唯物史观" scheme="https://qxienote.com/tags/%E5%94%AF%E7%89%A9%E5%8F%B2%E8%A7%82/"/>
    
  </entry>
  
  <entry>
    <title>数组(九) -- LC[1851] 包含每个查询的最小区间</title>
    <link href="https://qxienote.com/article/d322a40e.html"/>
    <id>https://qxienote.com/article/d322a40e.html</id>
    <published>2023-07-18T02:40:26.000Z</published>
    <updated>2023-07-19T07:48:32.811Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要以LeetCode[1851] 包含每个查询的最小区间为例，学习排序算法、优先队列、并查集的使用。</p><span id="more"></span><h2 id="1-包含每个查询的最小区间"><a href="#1-包含每个查询的最小区间" class="headerlink" title="1 包含每个查询的最小区间"></a>1 包含每个查询的最小区间</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给你一个二维整数数组 intervals ，其中 $intervals[i] &#x3D; [left_i, right_i]$ 表示第 $i$ 个区间开始于 $left_i$ 、结束于 $right_i$（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 $right_i - left_i + 1$。</p><p>再给你一个整数数组 queries 。第 j 个查询的答案是满足 $left_i &lt;&#x3D; queries[j] &lt;&#x3D; right_i$ 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。</p><p>以数组形式返回对应查询的所有答案。</p><blockquote><p>示例 1：<br>输入：intervals &#x3D; [[1,4],[2,4],[3,6],[4,4]], queries &#x3D; [2,3,4,5]<br>输出：[3,3,1,4]<br>解释：查询处理如下：</p><ul><li>Query &#x3D; 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 &#x3D; 3 。</li><li>Query &#x3D; 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 &#x3D; 3 。</li><li>Query &#x3D; 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 &#x3D; 1 。</li><li>Query &#x3D; 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 &#x3D; 4 。</li></ul></blockquote><blockquote><p>示例 2<br>输入：intervals &#x3D; [[2,3],[2,5],[1,8],[20,25]], queries &#x3D; [2,19,5,22]<br>输出：[2,-1,4,6]<br>解释：查询处理如下：</p><ul><li>Query &#x3D; 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 &#x3D; 2 。</li><li>Query &#x3D; 19：不存在包含 19 的区间，答案为 -1 。</li><li>Query &#x3D; 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 &#x3D; 4 。</li><li>Query &#x3D; 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 &#x3D; 6 。</li></ul></blockquote><p><strong>解法一：区间端点排序+离线查询+优先队列（小根堆）</strong></p><p>首先我们对问题进行分析，对于第 $j$ 个查询，可以遍历 $\textit{intervals}$，找到满足 $\textit{left}_i \le \textit{queries}_j \le \textit{right}_i$ 的长度最小区间 $i$ 的长度。以上思路对于每个查询，都需要重新遍历 $\textit{intervals}$。</p><p>如果查询是递增的，那么我们可以对 $\textit{intervals}$ 按左端点 $\textit{left}$ 从小到大进行排序，使用一个指针 $i$ 记录下一个要访问的区间 $\textit{intervals}[i]$，初始时 $i &#x3D; 0$，使用优先队列 $\textit{pq}$ 保存区间（优先队列的比较 $\textit{key}$ 为区间的长度，队首元素为长度最小的区间）。对于第 $j$ 个查询，我们执行以下步骤：</p><ol><li>如果 $i$ 等于 $\textit{intervals}$ 的长度或 $\textit{left}_i \gt \textit{queries}[j]$，终止步骤；</li><li>将 $\textit{intervals}[i]$ 添加到优先队列 $\textit{pq}$，将 $i$ 的值加 1，继续执行步骤 1。</li></ol><p>此时所有符合 $\textit{left} \le \textit{queries}_j \le \textit{right}$ 的区间都在 $\textit{pq}$，我们不断地获取优先队列 $\textit{pq}$ 的队首区间：</p><ul><li>如果队首区间的右端点 $\textit{right} \lt \textit{queries}[j]$，那么说明该区间不满足条件，从 $\textit{pq}$ 中出队；</li></ul><p>如果队首区间的右端点 $\textit{right} \ge \textit{queries}[j]$，那么该区间为第 $j$ 个查询的最小区间，终止过程。</p><p>对于第 $j+1$ 个查询，因为查询是递增的，所以有 $\textit{queries}[j + 1] \ge \textit{queries}[j]$，那么此时 $\textit{pq}$ 中的区间都满足 $\textit{left} \le \textit{queries}[j + 1]$。在第 $j$ 个查询中丢弃的区间有 $ \textit{right} \lt \textit{queries}[j] \le \textit{queries}[j + 1]$，因此丢弃的区间不满足第 $j + 1$ 个查询。同样在第 $j + 1$ 个查询执行与第 $j$ 个查询类似的步骤，将可能满足条件的区间加入优先队列 $\textit{pq}$ 中，那么此时所有满足条件的区间都在优先队列 $\textit{pq}$ 中，执行类似第 $j$ 个查询的出队操作。</p><p>由以上分析，如果查询满足递增的条件，那么可以利用优先队列进行优化。题目一次性提供所有的查询，基于离线原理，我们对所有查询从小到大进行排序，然后执行以上算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n, m = <span class="built_in">len</span>(intervals), <span class="built_in">len</span>(queries)</span><br><span class="line">        intervals.sort()</span><br><span class="line">        queries = <span class="built_in">sorted</span>((x, i) <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries))</span><br><span class="line">        ans = [-<span class="number">1</span>] * m</span><br><span class="line">        pq = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, j <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> intervals[i][<span class="number">0</span>] &lt;= x:</span><br><span class="line">                a, b = intervals[i]</span><br><span class="line">                heappush(pq, (b - a + <span class="number">1</span>, b))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> pq <span class="keyword">and</span> pq[<span class="number">0</span>][<span class="number">1</span>] &lt; x:</span><br><span class="line">                heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> pq:</span><br><span class="line">                ans[j] = pq[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 $O(n \times \log n + m \times \log m)$</li><li>空间复杂度 $O(n + m)$。其中 n 和 m 分别是数组 intervals 和 queries 的长度。</li></ul><p><strong>解法二：区间长度排序+离线询问+并查集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(intervals), <span class="built_in">len</span>(queries)</span><br><span class="line"></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] - x[<span class="number">0</span>])</span><br><span class="line">        queries = <span class="built_in">sorted</span>([(q, i) <span class="keyword">for</span> i, q <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries)])</span><br><span class="line"></span><br><span class="line">        fa = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x != fa[x]:</span><br><span class="line">                fa[x] = find(fa[x])</span><br><span class="line">            <span class="keyword">return</span> fa[x]</span><br><span class="line"></span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> l, r <span class="keyword">in</span> intervals:</span><br><span class="line">            length = r - l + <span class="number">1</span></span><br><span class="line">            pos = bisect_left(queries, (l, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            idx = find(pos)</span><br><span class="line">            <span class="keyword">while</span> idx &lt; n <span class="keyword">and</span> queries[idx][<span class="number">0</span>] &lt;= r:</span><br><span class="line">                ans[queries[idx][<span class="number">1</span>]] = length</span><br><span class="line">                fa[idx] = idx + <span class="number">1</span></span><br><span class="line">                idx = find(idx + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要以LeetCode[1851] 包含每个查询的最小区间为例，学习排序算法、优先队列、并查集的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="排序" scheme="https://qxienote.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="优先队列" scheme="https://qxienote.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="并查集" scheme="https://qxienote.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>数学(五) -- LC[415] 字符串相加</title>
    <link href="https://qxienote.com/article/a5210706.html"/>
    <id>https://qxienote.com/article/a5210706.html</id>
    <published>2023-07-17T03:47:36.000Z</published>
    <updated>2023-07-18T15:49:40.564Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习按位相加，采用模拟法进行数字字符串、数字链表的相加。</p><span id="more"></span><h2 id="1-字符串相加"><a href="#1-字符串相加" class="headerlink" title="1 字符串相加"></a>1 字符串相加</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p><blockquote><p>示例 1：<br>输入：num1 &#x3D; “11”, num2 &#x3D; “123”<br>输出：”134”</p></blockquote><blockquote><p>示例 2：<br>输入：num1 &#x3D; “456”, num2 &#x3D; “77”<br>输出：”533”</p></blockquote><blockquote><p>示例 3：<br>输入：num1 &#x3D; “0”, num2 &#x3D; “0”<br>输出：”0”</p></blockquote><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><ul><li>算法流程： 设定 $i，j$ 两指针分别指向 num1，num2 尾部，模拟人工加法；<ul><li>计算进位： 计算 carry &#x3D; tmp &#x2F;&#x2F; 10，代表当前位相加是否产生进位；</li><li>添加当前位： 计算 tmp &#x3D; n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；</li><li>索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 0，相当于给 num1，num2 中长度较短的数字前面填 0，以便后续计算。</li><li>当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 1，最终返回 res 即可。</li></ul></li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230701/001.4s173f3j2n8.gif#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        i, j, carry = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = <span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = <span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n = n1 + n2 + carry</span><br><span class="line">            carry = n // <span class="number">10</span></span><br><span class="line">            res = <span class="built_in">str</span>(n%<span class="number">10</span>) + res</span><br><span class="line">            i, j = i-<span class="number">1</span>, j-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>+res <span class="keyword">if</span> carry <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong><br>    - 时间复杂度 $O(max(M,N))$：其中 $M，N$ 为 $2$ 数字长度，按位遍历一遍数字（以较长的数字为准）；<br>    - 空间复杂度 $O(1)$：指针与变量使用常数大小空间。</p><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><blockquote><p>示例 1：<br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230701/001.4r3fkezt2uu0.webp#pic_center" width = 64%><blockquote><p>示例 2：<br>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p></blockquote><blockquote><p>示例 3：<br>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p></blockquote><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。</p><p>我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 $n1,n2$，进位值为 $\textit{carry}$，则它们的和为 $n1+n2+\textit{carry}$；其中，答案链表处相应位置的数字为 $(n1+n2+\textit{carry}) \bmod 10$，而新的进位值为 $\lfloor\frac{n1+n2+\textit{carry}}{10}\rfloor$。</p><p>如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。</p><p>此外，如果链表遍历结束后，有 $\textit{carry} &gt; 0$，还需要在答案链表的后面附加一个节点，节点的值为 $\textit{carry}$。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230701/002.3n0qk884hs80.gif#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        head = current = ListNode()</span><br><span class="line">        res, newval = <span class="number">0</span>, <span class="number">0</span>          <span class="comment"># 进位值和余数</span></span><br><span class="line">        <span class="keyword">while</span> res <span class="keyword">or</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1: l1, newval = l1.<span class="built_in">next</span>, l1.val + newval</span><br><span class="line">            <span class="keyword">if</span> l2: l2, newval = l2.<span class="built_in">next</span>, l2.val + newval</span><br><span class="line">            res, newval = <span class="built_in">divmod</span>(newval,<span class="number">10</span>)</span><br><span class="line">            current.<span class="built_in">next</span> = current = ListNode(newval)</span><br><span class="line">            newval = res</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\max(m,n))$，其中 $m$ 和 $n$ 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 $O(1)$ 的时间。</li><li>空间复杂度：$O(1)$。注意返回值不计入空间复杂度。</li></ul><h2 id="3-两数相加-II"><a href="#3-两数相加-II" class="headerlink" title="3 两数相加 II"></a>3 两数相加 II</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><blockquote><p>示例1：<br>输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,8,0,7]</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230701/017.3ayevdyxwku0.webp#pic_center" width = 64%><blockquote><p>示例2：<br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[8,0,7]</p></blockquote><blockquote><p>示例3：<br>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p></blockquote><h3 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h3><ul><li>反转链表 $l_1$</li><li>反转链表 $l_2$</li><li>调用 2. 两数相加 的代码，得到链表 $l_3$</li><li>反转链表 $l_3$ 返回 $l_3$ 作为答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">list_reverse</span>(<span class="params">l</span>):</span><br><span class="line">            prev, curr = <span class="literal">None</span>, l</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                temp = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = temp</span><br><span class="line">            <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">two_numbers</span>(<span class="params">l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            head = current = ListNode()</span><br><span class="line">            res, newval = <span class="number">0</span>, <span class="number">0</span>          <span class="comment"># 进位值和余数</span></span><br><span class="line">            <span class="keyword">while</span> res <span class="keyword">or</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">                <span class="keyword">if</span> l1: l1, newval = l1.<span class="built_in">next</span>, l1.val + newval</span><br><span class="line">                <span class="keyword">if</span> l2: l2, newval = l2.<span class="built_in">next</span>, l2.val + newval</span><br><span class="line">                res, newval = <span class="built_in">divmod</span>(newval,<span class="number">10</span>)</span><br><span class="line">                <span class="comment"># current.next = current = ListNode(newval)</span></span><br><span class="line">                current.<span class="built_in">next</span> = current = ListNode(newval)</span><br><span class="line">                newval = res</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        l1, l2 = list_reverse(l1), list_reverse(l2)</span><br><span class="line">        <span class="keyword">return</span> list_reverse(two_numbers(l1, l2))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要学习按位相加，采用模拟法进行数字字符串、数字链表的相加。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="模拟法" scheme="https://qxienote.com/tags/%E6%A8%A1%E6%8B%9F%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（八）-- LC[316]&amp;[321]&amp;[402] 去除重复字母</title>
    <link href="https://qxienote.com/article/1e9e829d.html"/>
    <id>https://qxienote.com/article/1e9e829d.html</id>
    <published>2023-06-17T03:09:01.000Z</published>
    <updated>2023-06-18T05:30:57.535Z</updated>
    
    <content type="html"><![CDATA[<p>移掉 K 位数字、去除重复字母、拼接最大数这三道题目都是同一套路，即删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这三道题目应该都可以轻松解决。</p><span id="more"></span><h2 id="1-移掉-K-位数字"><a href="#1-移掉-K-位数字" class="headerlink" title="1 移掉 K 位数字"></a>1 移掉 K 位数字</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/040.4ke3hv739fo0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/remove-k-digits/">https://leetcode.cn/problems/remove-k-digits/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>这道题让我们从一个字符串数字中删除 k 个数字，使得剩下的数最小。也就说，我们要保持原来的数字的相对位置不变。</p><p>以题目中的 $num &#x3D; 1432219，k &#x3D; 3$ 为例，我们需要返回一个长度为 4 的字符串，问题在于： 我们怎么才能求出这四个位置依次是什么呢？</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/041.3k2aqhji1d20.webp#pic_center" width = 48%><p>暴力法的话，我们需要枚举 $C_n^(n - k)$ 种序列（其中 $n$ 为数字长度），并逐个比较最大。这个时间复杂度是指数级别的，必须进行优化。</p><p>一个思路是：</p><ul><li>从左到右遍历</li><li>对于每一个遍历到的元素，我们决定是丢弃还是保留</li></ul><p>问题的关键是：我们怎么知道，一个元素是应该保留还是丢弃呢？</p><p>这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a &gt; b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小。</p><p>因此我们的思路就是：</p><ul><li>从左到右遍历</li><li>对于遍历到的元素，我们选择保留。</li><li>但是我们可以选择性丢弃前面相邻的元素。</li><li>丢弃与否的依据如上面的前置知识中阐述中的方法。</li></ul><p>以题目中的 $num &#x3D; 1432219，k &#x3D; 3$ 为例的图解过程如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/042.5xmn9diclm00.webp#pic_center" width = 36%><p>由于没有左侧相邻元素，因此没办法丢弃。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/043.3a4rwxtigf20.webp#pic_center" width = 36%><p>由于 4 比左侧相邻的 1 大。如果选择丢弃左侧的 1，那么会使得剩下的数字更大（开头的数从 1 变成了 4）。因此我们仍然选择不丢弃。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/044.5mzf9sc97z40.webp#pic_center" width = 36%><p>由于 3 比左侧相邻的 4 小。 如果选择丢弃左侧的 4，那么会使得剩下的数字更小（开头的数从 4 变成了 3）。因此我们选择丢弃。</p><p>后面的思路类似，这里就不继续分析啦。</p><p>然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远选择不丢弃。这个题目中要求的，我们要永远确保丢弃 k 个矛盾。</p><p>一个简单的思路就是：</p><ul><li>每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。</li><li>而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</li></ul><p>上面的思路可行，但是稍显复杂。</p><p>我们需要把思路逆转过来。刚才我的关注点一直是丢弃，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 $n - k$ 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前  $n - k$ 个元素即可。</p><p>按照上面的思路，我们来选择数据结构。由于我们需要保留和丢弃相邻的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num, k</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        remain = <span class="built_in">len</span>(num) - k</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:               <span class="comment"># 构建单调递增的数字串</span></span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span>      </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/045.2qdr9my17iw.gif#pic_center" width = 48%><p>提示： 如果题目改成求删除 k 个字符之后的最大数，我们只需要将 stack[-1] &gt; digit 中的大于号改成小于号即可</p><h2 id="2-去除重复字母"><a href="#2-去除重复字母" class="headerlink" title="2 去除重复字母"></a>2 去除重复字母</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/046.2cir1n6s89j4.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/remove-duplicate-letters/">https://leetcode.cn/problems/remove-duplicate-letters/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>与上面题目不同，这道题没有一个全局的删除次数 k。而是对于每一个在字符串 s 中出现的字母 c 都有一个 k 值。这个 k 是 c 出现次数 - 1。</p><p>沿用上面的知识的话，我们首先要做的就是计算每一个字符的 k，可以用一个字典来描述这种关系，其中 key 为 字符 c，value 为其出现的次数。</p><p>具体算法：</p><ul><li>建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。</li><li>从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1.</li><li>对于每一个字符，如果其对应的剩余出现次数大于 1，我们可以选择丢弃（也可以选择不丢弃），否则不可以丢弃。</li><li>是否丢弃的标准和上面题目类似。如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。</li></ul><p>还记得上面题目的边界条件么？如果栈中剩下的元素大于 $n−k$，我们选择截取前 $n - k$ 个数字。然而本题中的 k 是分散在各个字符中的，因此这种思路不可行的。</p><p>不过不必担心。由于题目是要求只出现一次。我们可以在遍历的时候简单地判断其是否在栈上即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/047.3dkxsbuhwk00.webp#pic_center" width = 48%><p>查询给定字符是否在一个序列中存在的方法。根本上来说，有两种可能：</p><ul><li>有序序列： 可以二分法，时间复杂度大致是 $O(N)$。</li><li>无序序列： 可以使用遍历的方式，最坏的情况下时间复杂度为 $O(N)$。我们也可以使用空间换时间的方式，使用 $N$ 的空间 换取 $O(1)$ 的时间复杂度。<br>由于本题中的 stack 并不是有序的，因此我们的优化点考虑空间换时间。而由于每种字符仅可以出现一次，这里使用 hashset 即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    seen.discard(stack.pop())</span><br><span class="line">                seen.add(c)</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h2 id="3-拼接最大数"><a href="#3-拼接最大数" class="headerlink" title="3 拼接最大数"></a>3 拼接最大数</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/048.6bvg2v7uuj40.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/create-maximum-number/">https://leetcode.cn/problems/create-maximum-number/</a></p><h3 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h3><p>和第一道题类似，只不不过这一次是两个数组，而不是一个，并且是求最大数。</p><p>最大最小是无关紧要的，关键在于是两个数组，并且要求从两个数组选取的元素个数加起来一共是 k。</p><p>然而在一个数组中取 k 个数字，并保持其最小（或者最大），我们已经会了。但是如果问题扩展到两个，会有什么变化呢？</p><p>实际上，问题本质并没有发生变化。 假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 &#x3D; k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。</p><p>假如 k1 和 k2 个数字，已经取出来了。那么剩下要做的就是将这个长度分别为 k1 和 k2 的数字，合并成一个长度为 k 的数组合并成一个最大的数组。</p><p>以题目的 nums1 &#x3D; [3, 4, 6, 5] nums2 &#x3D; [9, 1, 2, 5, 8, 3] k &#x3D; 5 为例。 假如我们从 num1 中取出 1 个数字，那么就要从 nums2 中取出 4 个数字。</p><p>运用第一题的方法，我们计算出应该取 nums1 的 [6]，并取 nums2 的 [9,5,8,3]。 如何将 [6] 和 [9,5,8,3]，使得数字尽可能大，并且保持相对位置不变呢？</p><p>实际上这个过程有点类似归并排序中的治，而上面我们分别计算 num1 和 num2 的最大数的过程类似归并排序中的分。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/049.58yaxtonyxs0.webp#pic_center" width = 48%><p>我们将从 num1 中挑选的 k1 个数组成的数组称之为 A，将从 num2 中挑选的 k2 个数组成的数组称之为 B，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, B</span>):</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">        bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">        ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">        bigger.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这里需要说明一下。 在很多编程语言中：如果 A 和 B 是两个数组，当前仅当 A 的首个元素字典序大于 B 的首个元素，A &gt; B 返回 true，否则返回 false。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">B = [<span class="number">2</span>]</span><br><span class="line">A &lt; B <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A &lt; B <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>以合并 [6] 和 [9,5,8,3] 为例，图解过程如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/050.3pp1a4yjzpe0.webp#pic_center" width = 36%><p>具体算法：</p><ul><li>从 nums1 中 取 $min(i, len(nums1))$个数形成新的数组 A（取的逻辑同第一题），其中 $i$ 等于 0,1,2, … k。</li><li>从 nums2 中 对应取 $min(j, len(nums2))$ 个数形成新的数组 B（取的逻辑同第一题），其中 $j$ 等于 $k - i$。</li><li>将 A 和 B 按照上面的 merge 方法合并</li></ul><p>上面我们暴力了 k 种组合情况，我们只需要将 k 种情况取出最大值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumber</span>(<span class="params">self, nums1, nums2, k</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pick_max</span>(<span class="params">nums, k</span>):</span><br><span class="line">            stack = []</span><br><span class="line">            drop = <span class="built_in">len</span>(nums) - k</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    drop -= <span class="number">1</span></span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">return</span> stack[:k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, B</span>):</span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">                bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">                ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">                bigger.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(merge(pick_max(nums1, i), pick_max(nums2, k-i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>) <span class="keyword">if</span> i &lt;= <span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i &lt;= <span class="built_in">len</span>(nums2))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/051.5bcgk06xnyc0.gif#pic_center" width = 48%><p><strong>小结</strong></p><p>这四道题都是删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这四个题目应该都可以轻松解决。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>不用字符的最小子序列：<a href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solutions/290204/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-6/">https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solutions/290204/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-6/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;移掉 K 位数字、去除重复字母、拼接最大数这三道题目都是同一套路，即删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这三道题目应该都可以轻松解决。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="单调栈" scheme="https://qxienote.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="贪心算法" scheme="https://qxienote.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（七）-- LC[53]&amp;[152] 最大子数组之和与乘积最大子数组</title>
    <link href="https://qxienote.com/article/745d3169.html"/>
    <id>https://qxienote.com/article/745d3169.html</id>
    <published>2023-06-17T03:08:29.000Z</published>
    <updated>2023-06-17T09:19:32.693Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要以解决最大子数组之和与乘积，详细分析动态规划的思考过程，同时也分析暴力法、贪心算法和分治法如何使用</p><span id="more"></span><h2 id="1-最大子数组之和"><a href="#1-最大子数组之和" class="headerlink" title="1 最大子数组之和"></a>1 最大子数组之和</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.6642xks3o5c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p><strong>1. 暴力法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            sum_sub_array = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">                sum_sub_array += nums[j]</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, sum_sub_array)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.79jjdyimrrw0.gif#pic_center" width = 48%><p><strong>2. 动态规划</strong></p><p><strong>关键 1：理解题意</strong></p><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><p><strong>关键 2：如何定义子问题（如何定义状态）</strong></p><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><ul><li>子问题 1：经过 −2 的连续子数组的最大和是多少；</li><li>子问题 2：经过 1 的连续子数组的最大和是多少；</li><li>子问题 3：经过 −3 的连续子数组的最大和是多少；</li><li>子问题 4：经过 4 的连续子数组的最大和是多少；</li><li>子问题 5：经过 −1 的连续子数组的最大和是多少；</li><li>子问题 6：经过 2 的连续子数组的最大和是多少；</li><li>子问题 7：经过 1 的连续子数组的最大和是多少；</li><li>子问题 8：经过 −5 的连续子数组的最大和是多少；</li><li>子问题 9：经过 4 的连续子数组的最大和是多少。</li></ul><p>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 −3 的连续子数组的最大和是多少。</p><p>「经过 −3 的连续子数组」我们任意举出几个：</p><ul><li>[-2,1,-3,4] ，−3 是这个连续子数组的第 3 个元素；</li><li>[1,-3,4,-1] ，−3 是这个连续子数组的第 2 个元素；</li><li>……</li></ul><p>我们不确定的是：−3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><ul><li>子问题 1：以 −2 结尾的连续子数组的最大和是多少；</li><li>子问题 2：以 1 结尾的连续子数组的最大和是多少；</li><li>子问题 3：以 −3 结尾的连续子数组的最大和是多少；</li><li>子问题 4：以 4 结尾的连续子数组的最大和是多少；</li><li>子问题 5：以 −1 结尾的连续子数组的最大和是多少；</li><li>子问题 6：以 2 结尾的连续子数组的最大和是多少；</li><li>子问题 7：以 1 结尾的连续子数组的最大和是多少；</li><li>子问题 8：以 −5 结尾的连续子数组的最大和是多少；</li><li>子问题 9：以 4 结尾的连续子数组的最大和是多少。</li></ul><p>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><ul><li>子问题 1：以 −2 结尾的连续子数组的最大和是多少；<br>以 −2 结尾的连续子数组是 [-2]，因此最大和就是 −2。</li><li>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。$-2 + 1 &#x3D; -1 &lt; 1$，因此「子问题 2」 的答案是 1。</li></ul><p>大家发现了吗，如果编号为 $i$ 的子问题的结果是负数或者 0 ，那么编号为 $i + 1$ 的子问题就可以把编号为 $i$ 的子问题的结果舍弃掉（这里 $i$ 为整数，最小值为 1 ，最大值为 8），这是因为：</p><ul><li>一个数 a 加上负数的结果比 a 更小；</li><li>一个数 a 加上 0 的结果不会比 a 更大；</li><li>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 $i + 1$ 的答案就是以 nums[i] 结尾的那个数。</li></ul><p>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><p><strong>定义状态（定义子问题）</strong><br>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。<br>说明：「结尾」和「连续」是关键字。</p><p><strong>状态转移方程（描述子问题之间的联系）</strong><br>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 $nums[i-1]$ 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 $dp[i] &#x3D; dp[i - 1] + nums[i]$。</p><p>可是 $dp[i-1]$ 有可能是负数，于是分类讨论：</p><ul><li>如果 $dp[i - 1] &gt; 0$，那么可以把 nums[i] 直接接在 $dp[i - 1]$ 表示的那个数组的后面，得到和更大的连续子数组；</li><li>如果 $dp[i - 1] &lt;&#x3D; 0$，那么 nums[i] 加上前面的数 $dp[i - 1]$ 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</li></ul><p>以上两种情况的最大值就是 dp[i] 的值，写出如下状态转移方程：</p><p>$$<br>dp[i] &#x3D;<br>\begin{cases}<br>dp[i - 1] + nums[i], &amp; if \quad dp[i - 1] &gt; 0 \<br>nums[i], &amp; if \quad dp[i - 1] \le 0<br>\end{cases}$$<br>​<br>记为「状态转移方程 1」。</p><p>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：</p><p>$$dp[i] &#x3D; \max {nums[i],; dp[i - 1] + nums[i]}$$</p><p>记为「状态转移方程 2」。</p><p> <strong>友情提示：</strong> 求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。</p><p><strong>思考初始值</strong><br>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 $dp[0] &#x3D; nums[0]$。</p><p><strong>思考输出</strong><br>注意：<br>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；这个问题的输出是把所有的 <code>dp[0]、dp[1]、……、dp[n - 1]</code> 都看一遍，取最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>进一步优化空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            pre = <span class="built_in">max</span>(nums[i], pre + nums[i])</span><br><span class="line">            res = <span class="built_in">max</span>(res, pre)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.7c33ynjbvxs0.gif#pic_center" width = 48%><p><strong>3. 贪心算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 时间复杂度：O(n), 遍历了一遍</span></span><br><span class="line">        <span class="comment"># 空间复杂度:O(1), 用了2个变量</span></span><br><span class="line">        cur_sum = nums[<span class="number">0</span>]</span><br><span class="line">        max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># range范围是[1，len(nums)) 左闭右开，切记切记</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 若当前指针指向元素之前的和小于0，则丢弃此元素之前的数列(拖后腿的丢弃！！！)</span></span><br><span class="line">            <span class="comment"># 当前和=当前值 与 当前值+之前最大和 的比较中较大的那个、</span></span><br><span class="line">            <span class="comment"># 通俗易懂的理解：看当前这个值和之前数列的和，是否会拖当前这个值的后腿，如果扯后腿了说明没必要把之前的数列放到当前和，如果没有扯后腿则把最新的较大数放在当前和里面</span></span><br><span class="line">            cur_sum = <span class="built_in">max</span>(nums[i], cur_sum+nums[i])</span><br><span class="line">            <span class="comment"># 最大和=当前和 与 最大和 的比较中较大的那个</span></span><br><span class="line">            <span class="comment"># 通俗易懂的理解：当前和就相当于当前潜在的最大和，把原来的最大和 与当前的潜在最大和进行比较，如果当前和比较大，则更换最大和，否则不更换</span></span><br><span class="line">            max_sum = <span class="built_in">max</span>(cur_sum, max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3m0i3ybmmns0.gif#pic_center" width = 48%><p><strong>4. 分治法</strong><br>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p><ul><li>第 1 部分：子区间 $[left, mid]$；</li><li>第 2 部分：子区间 $[mid + 1, right]$；</li><li>第 3 部分：包含子区间 $[mid , mid + 1]$ 的子区间，即 nums[mid] 与 nums[mid + 1] 一定会被选取。<br>对这三个部分求最大值即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.__max_sub_array(nums, <span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__max_sub_array</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.__max_sub_array(nums, left, mid),</span><br><span class="line">                   self.__max_sub_array(nums, mid + <span class="number">1</span>, right),</span><br><span class="line">                   self.__max_cross_array(nums, left, mid, right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__max_cross_array</span>(<span class="params">self, nums, left, mid, right</span>):</span><br><span class="line">        <span class="comment"># 一定包含 nums[mid] 元素的最大连续子数组的和，</span></span><br><span class="line">        <span class="comment"># 思路是看看左边&quot;扩散到底&quot;，得到一个最大数，右边&quot;扩散到底&quot;得到一个最大数</span></span><br><span class="line">        <span class="comment"># 然后再加上中间数</span></span><br><span class="line">        left_sum_max = <span class="number">0</span></span><br><span class="line">        start_left = mid - <span class="number">1</span></span><br><span class="line">        s1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start_left &gt;= left:</span><br><span class="line">            s1 += nums[start_left]</span><br><span class="line">            left_sum_max = <span class="built_in">max</span>(left_sum_max, s1)</span><br><span class="line">            start_left -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        right_sum_max = <span class="number">0</span></span><br><span class="line">        start_right = mid + <span class="number">1</span></span><br><span class="line">        s2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start_right &lt;= right:</span><br><span class="line">            s2 += nums[start_right]</span><br><span class="line">            right_sum_max = <span class="built_in">max</span>(right_sum_max, s2)</span><br><span class="line">            start_right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left_sum_max + nums[mid] + right_sum_max</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.4a1sywzk9og0.gif#pic_center" width = 48%><h2 id="2-乘积最大子数组"><a href="#2-乘积最大子数组" class="headerlink" title="2 乘积最大子数组"></a>2 乘积最大子数组</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.4k1vyb26ul20.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/">https://leetcode.cn/problems/maximum-product-subarray/description/</a></p><h3 id="2-2-求解思路"><a href="#2-2-求解思路" class="headerlink" title="2.2 求解思路"></a>2.2 求解思路</h3><p>如果我们用 $f_{\max}(i)$ 来表示以第 $i$ 个元素结尾的乘积最大子数组的乘积，$a$ 表示输入参数 nums，那么根据前面「53. 最大子序和」的经验，我们很容易推导出这样的状态转移方程：</p><p>$$f_{\max}(i) &#x3D; \max_{i &#x3D; 1}^{n} { f(i - 1) \times a_i, a_i }$$</p><p>它表示以第 $i$ 个元素结尾的乘积最大子数组的乘积可以考虑 $a_i$ 加入前面的 $f_{\max}(i - 1)$ 对应的一段，或者单独成为一段，这里两种情况下取最大值。求出所有的 $f_{\max}(i)$ 之后选取最大的一个作为答案。</p><p> <strong>可是在这里，这样做是错误的。为什么呢？</strong></p><p>因为这里的定义并不满足「最优子结构」。具体地讲，如果 $a &#x3D; { 5, 6, -3, 4, -3 }$，那么此时 $⁡f_{\max}$ 对应的序列是 ${ 5, 30, -3, 4, -3 }$，按照前面的算法我们可以得到答案为 30，即前两个数的乘积，而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个 −3 所对应的 $⁡f_{\max}$ 的值既不是 −3，也不是 $4 \times (-3)$，而是 $5 \times 6 \times (-3) \times 4 \times (-3)$。所以我们得到了一个结论：当前位置的最优解未必是由前一个位置的最优解转移得到的。</p><p>我们可以根据正负性进行分类讨论。</p><p>考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 $f_{\min}(i)$，它表示以第 $i$ 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：</p><p>$$<br>    \begin{aligned}<br>        f_{\max}(i) &amp;&#x3D; \max_{i &#x3D; 1}^{n} { f_{\max}(i - 1) \times a_i, f_{\min}(i - 1) \times a_i, a_i } \<br>        f_{\min}(i) &amp;&#x3D; \min_{i &#x3D; 1}^{n} { f_{\max}(i - 1) \times a_i, f_{\min}(i - 1) \times a_i, a_i }<br>    \end{aligned}<br>$$</p><p>它代表第 $i$ 个元素结尾的乘积最大子数组的乘积 $f_{\max}(i)$，可以考虑把 $a_i$ 加入第 $i - 1$ 个元素结尾的乘积最大或最小的子数组的乘积中，二者加上 $a_i$，$i$ 个元素结尾的乘积最大子数组的乘积。第 $i$ 个元素结尾的乘积最小子数组的乘积 $f_{\min}(i)$ 同理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_dp, min_dp = [nums[<span class="number">0</span>]], [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            max_dp.append(<span class="built_in">max</span>(max_dp[i-<span class="number">1</span>]*nums[i], min_dp[i-<span class="number">1</span>]*nums[i], nums[i]))</span><br><span class="line">            min_dp.append(<span class="built_in">min</span>(max_dp[i-<span class="number">1</span>]*nums[i], min_dp[i-<span class="number">1</span>]*nums[i], nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_dp)</span><br></pre></td></tr></table></figure><p><strong>进一步优化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;动态规划&#x27;&#x27;&#x27;</span></span><br><span class="line">        max_product, min_product, ans = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            max_nums, min_nums = max_product, min_product</span><br><span class="line">            max_product = <span class="built_in">max</span>(max_nums*num, min_nums*num, num)</span><br><span class="line">            min_product = <span class="built_in">min</span>(max_nums*num, min_nums*num, num)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, max_product)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>经典动态规划问题（理解「无后效性」）：<a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?orderBy=most_votes">https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?orderBy=most_votes</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要以解决最大子数组之和与乘积，详细分析动态规划的思考过程，同时也分析暴力法、贪心算法和分治法如何使用&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="贪心算法" scheme="https://qxienote.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="最大子数组" scheme="https://qxienote.com/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
    <category term="分治法" scheme="https://qxienote.com/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（六）-- LC[74]&amp;[240] 搜索二维矩阵矩阵与螺旋矩阵</title>
    <link href="https://qxienote.com/article/1cb8c955.html"/>
    <id>https://qxienote.com/article/1cb8c955.html</id>
    <published>2023-06-17T03:08:12.000Z</published>
    <updated>2023-06-17T09:17:39.639Z</updated>
    
    <content type="html"><![CDATA[<p>本篇分享LeetCode 搜索二维矩阵的两道题目，主要学习二分查找和双指针算法</p><span id="more"></span><h2 id="1-搜索二维矩阵"><a href="#1-搜索二维矩阵" class="headerlink" title="1 搜索二维矩阵"></a>1 搜索二维矩阵</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.bt6mp598usw.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p><strong>方法一：遍历</strong><br>该方法就是遍历查找每个位置，看 target 是否出现。这个方法也能通过本题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="comment"># return any(target in row for row in matrix)</span></span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： $O(M * N)$</li><li>间复杂度：$O(1)$</li></ul><p><strong>方法二：从左下角或者右上角开始查找</strong></p><p>这个方法是利用了矩阵的性质，如果我们从右上角开始遍历：</p><ul><li>如果要搜索的 target 比当前元素大，那么让行增加；</li><li>如果要搜索的 target 比当前元素小，那么让列减小；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row, col = <span class="number">0</span>, cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> matrix[row][col] &lt; target:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(M + N)$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法三：先寻找到所在行</strong></p><p>该方法利用了题目给出的矩阵的性质：每行元素都是单调递增的，并且下一行的元素会比本行更大。所以：</p><p>如果 target 大于这一行的末尾元素，那么 target 一定不在这一行中，只能出现在矩阵的下面的行中。</p><p>那么，假如 $target &lt; matrix[i][N - 1]$ 时，说明 target 可能在本行中出现，而且由于下面各行的元素都大于 $matrix[i][N - 1]$，所以，不可能在下面的行中出现。此时，可以在本行中使用顺序查找，或者二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">if</span> target &gt; matrix[i][N - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> matrix[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： 在行中遍历查找的时间复杂度是：$O(M+N)$；在行中进行二分查找的时间复杂度是 $O(M+log(N))$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法四：两次二分查找</strong><br>这个方法可以说是方法三的改进。在方法三种，我们是先遍历找到 target 在哪一行，然后在该行遍历或者二分查找的 target 。其实也可以先用二分找到 target 所在的行，然后在该行二分找到 target。</p><p>具体做法是，先找到 $matrix[i][0]$ 小于 target 并且 $matrix[i + 1][0] &gt; target$ 的第 $i$ 行，然后在该行内进行二分找到 target。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        col0 = [row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br><span class="line">        target_row = bisect.bisect_right(col0, target) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> target_row &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target_col = bisect.bisect_left(matrix[target_row], target)</span><br><span class="line">        <span class="keyword">if</span> target_col &gt;= N:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> matrix[target_row][target_col] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： $O(log(M) + log(N))$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法五：全局二分</strong></p><p>这个方法，是我们在二维矩阵上进行二分查找，这其实相当于把二维矩阵当做一维来做，要求每一行的最后一个元素小于下一行的第一个元素。</p><p>根据 mid 求出在二维矩阵中的具体位置，然后判断 left 和 right 的移动方式。整体做法和一维数组的二分没有区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right = <span class="number">0</span>, M * N - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            cur = matrix[mid // N][mid % N]</span><br><span class="line">            <span class="keyword">if</span> cur == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： $O(log(M∗N))$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法六：reshape成一维数组</strong></p><p>如果用python刷题，在leetcode中是支持使用 numpy 的，可以把 matrix 成一维有序的数组，然后按照一维数组去操作查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        matrix = np.reshape(matrix, [<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> target <span class="keyword">in</span> matrix</span><br></pre></td></tr></table></figure><hr><h2 id="2-搜索二维矩阵Ⅱ"><a href="#2-搜索二维矩阵Ⅱ" class="headerlink" title="2 搜索二维矩阵Ⅱ"></a>2 搜索二维矩阵Ⅱ</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.1bsh7ouswcg0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></p><h3 id="2-2-求解思路"><a href="#2-2-求解思路" class="headerlink" title="2.2 求解思路"></a>2.2 求解思路</h3><p><strong>方法一：直接查找</strong></p><p>直接遍历整个矩阵 $\textit{matrix}$，判断 $\textit{target}$ 是否出现即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> row:</span><br><span class="line">                <span class="keyword">if</span> element == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>方法二：减而治之</strong></p><p>(1) 选择左下角为起点，以下展示了「减治」的过程</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.5qxia2tpa340.gif#pic_center" width = 48%><p>总结出搜索的规律是：</p><ul><li>如果当前数比目标元素小，当前列就不可能存在目标值，「指针」就向右移一格（纵坐标加 1）；</li><li>如果当前数比目标元素大，当前行就不可能存在目标值，「指针」就向上移一格（横坐标减 1）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 起点：左下角</span></span><br><span class="line">        x, y = rows-<span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不越界的条件是：行大于等于 0，列小于 cols</span></span><br><span class="line">        <span class="keyword">while</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; cols:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &gt; target:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &lt; target:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：$O(M + N)$，$M$是这个矩阵的行数，$N$是这个矩阵的列数，我们看到，这种算法是不回头的，至多走 $M + N$ 步就能搜索到目标数值，或者判定目标数值在矩阵中不存在；</li><li>空间复杂度：$O(1)$，算法使用了常数个变量。</li></ul><p>(2) 如果选择右上角为起点，以下展示了「减治」的过程</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.ujgfc06gvt.gif#pic_center" width = 48%><p>总结出「搜索」的规律是：</p><ul><li>如果当前数比目标元素大，当前列就不可能存在目标值，「指针』就向左移一格（纵坐标减 1）；</li><li>如果当前数比目标元素小，当前行就不可能存在目标值，「指针」就向下移一格（横坐标加 1）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 起点：右上</span></span><br><span class="line">        x, y = <span class="number">0</span>, cols-<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不越界的条件是：行小于 rows，列大于等于 0</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; rows <span class="keyword">and</span> y &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &gt; target:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &lt; target:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>方法三：二分查找</strong></p><p>由于矩阵 $\textit{matrix}$ 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 $\textit{target}$ 是否在该行中，从而判断 $\textit{target}$ 是否出现。</p><p><strong>(1) 详细版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binay_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">            l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">if</span> line[<span class="number">0</span>] &lt;= target <span class="keyword">and</span> line[cols - <span class="number">1</span>] &gt;= target:</span><br><span class="line">                <span class="keyword">if</span> binay_search(line, target):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>(2) 简化版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            ind = bisect.bisect_left(row, target)</span><br><span class="line">            <span class="keyword">if</span> ind &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="keyword">and</span> row[ind] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \log n)$。对一行使用二分查找的时间复杂度为 $O(\log n)$，最多需要进行 $m$ 次二分查找。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>减而治之、二分查找：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/14389/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/?orderBy=most_votes">https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/14389/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/?orderBy=most_votes</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇分享LeetCode 搜索二维矩阵的两道题目，主要学习二分查找和双指针算法&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="双指针" scheme="https://qxienote.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分法" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（五）-- LC[48]&amp;[54]&amp;[59] 旋转矩阵与螺旋矩阵</title>
    <link href="https://qxienote.com/article/bee25f2c.html"/>
    <id>https://qxienote.com/article/bee25f2c.html</id>
    <published>2023-06-17T03:07:00.000Z</published>
    <updated>2023-06-17T09:17:39.636Z</updated>
    
    <content type="html"><![CDATA[<p>二维数组的遍历也属于常考题，思路不难，但要考虑边界，本篇就带你走进矩阵按形状和方向分别遍历</p><span id="more"></span><h2 id="1-二维数组遍历"><a href="#1-二维数组遍历" class="headerlink" title="1 二维数组遍历"></a>1 二维数组遍历</h2><p><strong>题库列表</strong></p><blockquote><ul><li><p><a href="https://leetcode.cn/problems/rotate-image/" target="_blank">48. 旋转图像</a> </p><li><p><a href="https://leetcode.cn/problems/spiral-matrix/" target="_blank">54. 螺旋矩阵</a></p><li><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank">59. 螺旋矩阵Ⅱ</a></p></li></ul></blockquote> <h3 id="1-1-旋转图像"><a href="#1-1-旋转图像" class="headerlink" title="1.1 旋转图像"></a>1.1 旋转图像</h3><h4 id="1-1-1-题目描述"><a href="#1-1-1-题目描述" class="headerlink" title="1.1.1 题目描述"></a>1.1.1 题目描述</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/012.6idldwe8z6s0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p><h4 id="1-1-2-辅助矩阵"><a href="#1-1-2-辅助矩阵" class="headerlink" title="1.1.2 辅助矩阵"></a>1.1.2 辅助矩阵</h4><p>如下图所示，矩阵顺时针旋转 $90^{\circ}$ 后，可找到以下规律：</p><ul><li>「第 $i$ 行」元素旋转到「第 $n−1−i$ 列」元素；</li><li>「第 $j$ 列」元素旋转到「第 $j$ 行」元素；</li></ul><p>因此，对于矩阵任意第 $i$ 行、第 $j$ 列元素 $matrix[i][j]$，矩阵旋转 $90^{\circ}$ 后「元素位置旋转公式」为：</p><p>$$\begin{aligned} matrix[i][j] &amp; \rightarrow matrix[j][n - 1 - i] \<br>原索引位置 &amp; \rightarrow 旋转后索引位置 \end{aligned}$$</p><p>​<img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/013.7ij6tw1obi80.webp#pic_center" width = 48%></p><p>根据以上「元素旋转公式」，考虑遍历矩阵，将各元素依次写入到旋转后的索引位置。但仍存在问题：在写入一个元素 $matrix[i][j] \rightarrow matrix[j][n - 1 - i]$ 后，原矩阵元素 $matrix[j][n - 1 - i]$ 就会被覆盖（即丢失），而此丢失的元素就无法被写入到旋转后的索引位置了。</p><p>为解决此问题，考虑借助一个「辅助矩阵」暂存原矩阵，通过遍历辅助矩阵所有元素，将各元素填入「原矩阵」旋转后的新索引位置即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 深拷贝 matrix -&gt; tmp</span></span><br><span class="line">        tmp = copy.deepcopy(matrix)</span><br><span class="line">        <span class="comment"># 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp[i][j]</span><br></pre></td></tr></table></figure><p>遍历矩阵所有元素的时间复杂度为 $O(N^2)$；由于借助了一个辅助矩阵，空间复杂度为 $O(N^2)$。</p><h4 id="1-1-3-原地修改"><a href="#1-1-3-原地修改" class="headerlink" title="1.1.3 原地修改"></a>1.1.3 原地修改</h4><p>考虑不借助辅助矩阵，通过在原矩阵中直接「原地修改」，实现空间复杂度 O(1)O(1)O(1) 的解法。</p><p>以位于矩阵四个角点的元素为例，设矩阵左上角元素 $A$、右上角元素 $B$、右下角元素 $C$、左下角元素 $D$。矩阵旋转 $90^{\circ}$ 后，相当于依次先后执行 $D \rightarrow A$，$C \rightarrow D$，$B \rightarrow C$，$A \rightarrow B$ 修改元素，即如下「首尾相接」的元素旋转操作：<br>$$A \leftarrow D \leftarrow C \leftarrow B \leftarrow A$$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/014.4r7gwd57gow0.webp#pic_center" width = 48%><p>如上图所示，由于第 $1$ 步 $D \rightarrow A$ 已经将 $A$ 覆盖（导致 $A$ 丢失），此丢失导致最后第 $4$ 步 $A \rightarrow B$ 无法赋值。为解决此问题，考虑借助一个「辅助变量 tmp」预先存储 $A$，此时的旋转操作变为：</p><p>$$暂存 tmp &#x3D; A \<br>A \leftarrow D \leftarrow C \leftarrow B \leftarrow tmp$$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/015.15fcoqfaesao.webp#pic_center" width = 48%><p>如上图所示，一轮可以完成矩阵 4 个元素的旋转。因而，只要分别以矩阵左上角 $\frac{1}{4}$ 的各元素为起始点执行以上旋转操作，即可完整实现矩阵旋转。</p><p>具体来看，当矩阵大小 $n$ 为偶数时，取前 $\frac{n}{2}$ 行、前 $\frac{n}{2}$ 列的元素为起始点；当矩阵大小 $n$ 为奇数时，取前 $\frac{n}{2}$ 行、前 $\frac{n + 1}{2}$ 列的元素为起始点。</p><p>令 $matrix[i][j]&#x3D;A$，根据文章开头的元素旋转公式，可推导得适用于任意起始点的元素旋转操作：</p><p>$$<br>暂存 tmp &#x3D; matrix[i][j] \<br>matrix[i][j] \leftarrow matrix[n - 1 - j][i] \leftarrow matrix[n - 1 - i][n - 1 - j] \leftarrow matrix[j][n - 1 - i] \leftarrow tmp $$</p><p>如下图所示，为示例矩阵的算法执行流程。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/016.399yf7ns71s0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 设矩阵行列数为 n</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 起始点范围为 0 &lt;= i &lt; n // 2 , 0 &lt;= j &lt; (n + 1) // 2</span></span><br><span class="line">        <span class="comment"># 其中 &#x27;//&#x27; 为整数除法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 暂存 A 至 tmp</span></span><br><span class="line">                tmp = matrix[i][j]</span><br><span class="line">                <span class="comment"># 元素旋转操作 A &lt;- D &lt;- C &lt;- B &lt;- tmp</span></span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i]</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j]</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i]</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 $O(N^2)$： 其中 $N$ 为输入矩阵的行（列）数。需要将矩阵中每个元素旋转到新的位置，即对矩阵所有元素操作一次，使用 $O(N^2)$ 时间。</li><li>空间复杂度 $O(1)$： 临时变量 $tmp$ 使用常数大小的额外空间。值得注意，当循环中进入下轮迭代，上轮迭代初始化的 $tmp$ 占用的内存就会被自动释放，因此无累计使用空间。</li></ul><h4 id="1-1-4-对角线反转，左右翻转"><a href="#1-1-4-对角线反转，左右翻转" class="headerlink" title="1.1.4 对角线反转，左右翻转"></a>1.1.4 对角线反转，左右翻转</h4><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/017.32d1erzigbm0.webp#pic_left" width = "20%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/018.3c4k05krrnw0.webp#pic_left"  width = "24%"></center></p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/019.qwpeb23ebi8.webp#pic_left" width = "24%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/020.5d64vfvqwis0.webp#pic_left"  width = "24%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 注意这里j的范围 如果j的范围也是0到n-1那么会出现交换后又交换回来 等于没有交换</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> matrix:</span><br><span class="line">            line.reverse()      <span class="comment"># 左右翻转</span></span><br></pre></td></tr></table></figure><h4 id="1-1-5-上下反转，对角线反转"><a href="#1-1-5-上下反转，对角线反转" class="headerlink" title="1.1.5 上下反转，对角线反转"></a>1.1.5 上下反转，对角线反转</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/021.734u593n8qw0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        matrix[:] = matrix[::-<span class="number">1</span>]        <span class="comment"># 上下反转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure><h3 id="1-2-螺旋矩阵"><a href="#1-2-螺旋矩阵" class="headerlink" title="1.2 螺旋矩阵"></a>1.2 螺旋矩阵</h3><h4 id="1-2-1-题目描述"><a href="#1-2-1-题目描述" class="headerlink" title="1.2.1 题目描述"></a>1.2.1 题目描述</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/022.86mcp8c7tfs.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p><h4 id="1-2-2-思路分析"><a href="#1-2-2-思路分析" class="headerlink" title="1.2.2 思路分析"></a>1.2.2 思路分析</h4><p><strong>1. 按照「形状」进行模拟</strong><br>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/023.1o2he25jd0w0.webp#pic_center" width = 30%><p>随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/024.3d7g5uixsgq0.webp#pic_center" width = 30%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    upper_bound = <span class="number">0</span></span><br><span class="line">    lower_bound = <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">    left_bound = <span class="number">0</span></span><br><span class="line">    right_bound = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># res.length == m * n 则遍历完整个数组</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt; m * n:</span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在顶部从左向右遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left_bound, right_bound + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[upper_bound][j])</span><br><span class="line">            <span class="comment"># 上边界下移</span></span><br><span class="line">            upper_bound += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在右侧从上向下遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(upper_bound, lower_bound + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right_bound])</span><br><span class="line">            <span class="comment"># 右边界左移</span></span><br><span class="line">            right_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在底部从右向左遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right_bound, left_bound - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[lower_bound][j])</span><br><span class="line">            <span class="comment"># 下边界上移</span></span><br><span class="line">            lower_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在左侧从下向上遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lower_bound, upper_bound - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left_bound])</span><br><span class="line">            <span class="comment"># 左边界右移</span></span><br><span class="line">            left_bound += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>2. 按照「方向」进行模拟</strong></p><p><strong>(1) 起始位置</strong><br>螺旋矩阵的遍历起点是矩阵的左上角，也就是 <code>(0, 0)</code> 位置。</p><p><strong>(2) 移动方向</strong><br>起始位置的下一个移动方向是向右。在遍历的过程中，移动方向是固定的：<br>$$右→，下↓，左←，上↑$$</p><p>移动方向是按照上面的顺序循环进行的。每次当移动到了边界，才会更改方向。但边界并不是固定的，请看下面分析。</p><p><strong>(3) 边界</strong><br>本题的边界是最大的难点，因为是随着遍历的过程而变化的。螺旋遍历的时候，已经遍历的数字不能再次遍历，所以边界会越来越小。</p><p>规则是：<font color=#9900CC><strong>如果当前行（列）遍历结束之后，就需要把这一行（列）的边界向内移动一格。</strong></font></p><p>以下面的图为例，up, down, left, right 分别表示四个方向的边界，初始时分别指向矩阵的四个边界。如果我们把第一行遍历结束（遍历到了右边界），此时需要修改新的移动方向为向下、并且把上边界 up 下移一格，即从 旧 up 位置移动到 新 up 位置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/025.6usmccgvppo0.webp#pic_center" width = 36%><p>当绕了一圈后，从下向上走到 新 up 边界的时候，此时需要修改新的移动方向为向右、并且把左边界 left 下移一格，即从 旧 left 位置移动到 新 left 位置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/026.4eiznf5r6xa0.webp#pic_center" width = 36%><p>由此可见，根据维护的四个方向的边界，就知道什么时候更改移动方向了。</p><p><strong>(4) 结束条件</strong><br>螺旋遍历的结束条件是所有的位置都被遍历到。</p><p><strong>代码实现：</strong></p><ul><li>up, down, left, right 分别表示四个方向的边界。</li><li>x, y 表示当前位置。</li><li>dirs 分别表示移动方向是 右、下、左、上 。</li><li>cur_d 表示当前的移动方向的下标，dirs[cur_d] 就是下一个方向需要怎么修改 x, y。</li><li><code>cur_d == 0 and y == right</code> 表示当前的移动方向是向右，并且到达了右边界，此时将移动方向更改为向下，并且上边界 up 向下移动一格。</li><li>结束条件是结果数组 res 的元素个数能与 matrix 中的元素个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> []</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, M - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        cur_d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) != M * N:</span><br><span class="line">            res.append(matrix[x][y])</span><br><span class="line">            <span class="keyword">if</span> cur_d == <span class="number">0</span> <span class="keyword">and</span> y == right:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">1</span> <span class="keyword">and</span> x == down:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">2</span> <span class="keyword">and</span> y == left:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">3</span> <span class="keyword">and</span> x == up:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            cur_d %= <span class="number">4</span></span><br><span class="line">            x += dirs[cur_d][<span class="number">0</span>]</span><br><span class="line">            y += dirs[cur_d][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1-3-螺旋矩阵Ⅱ"><a href="#1-3-螺旋矩阵Ⅱ" class="headerlink" title="1.3 螺旋矩阵Ⅱ"></a>1.3 螺旋矩阵Ⅱ</h3><h4 id="1-3-1-题目描述"><a href="#1-3-1-题目描述" class="headerlink" title="1.3.1 题目描述"></a>1.3.1 题目描述</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/027.5c98xx2b5bk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><h4 id="1-3-2-思路分析"><a href="#1-3-2-思路分析" class="headerlink" title="1.3.2 思路分析"></a>1.3.2 思路分析</h4><p><strong>1. 按照「形状」进行填充</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/028.41veaylr6u20.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    upper_bound, lower_bound = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    left_bound, right_bound = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 需要填入矩阵的数字</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num &lt;= n * n:</span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在顶部从左向右遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left_bound, right_bound+<span class="number">1</span>):</span><br><span class="line">                matrix[upper_bound][j] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 上边界下移</span></span><br><span class="line">            upper_bound += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在右侧从上向下遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(upper_bound, lower_bound+<span class="number">1</span>):</span><br><span class="line">                matrix[i][right_bound] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右边界左移</span></span><br><span class="line">            right_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在底部从右向左遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right_bound, left_bound-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[lower_bound][j] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 下边界上移</span></span><br><span class="line">            lower_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在左侧从下向上遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lower_bound, upper_bound-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[i][left_bound] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左边界右移</span></span><br><span class="line">            left_bound += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><p><strong>2. 按照「方向」进行填充</strong></p><p><strong>(1) 四个变量标记边界</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        cur_d = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count != n * n:</span><br><span class="line">            res[x][y] = count + <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_d == <span class="number">0</span> <span class="keyword">and</span> y == right:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">1</span> <span class="keyword">and</span> x == down:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">2</span> <span class="keyword">and</span> y == left:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">3</span> <span class="keyword">and</span> x == up:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            cur_d %= <span class="number">4</span></span><br><span class="line">            x += dirs[cur_d][<span class="number">0</span>]</span><br><span class="line">            y += dirs[cur_d][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>(2) 使用非 0 数字标记边界</strong></p><p>我们在遍历的过程中，需要依次放入 $1-N^2$ 数字，如果我们把结果数组的所有位置初始化为 0，那么非 0 的位置就代表我们已经遍历过了，相当于边界。</p><p>当遍历到数组的原始边界或者撞到了非 0 的数字，表示当前方向已经遍历到了边界，需要更改移动方向。这个做法的优点是省去了维护 4 个变量表示的边界。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.2orkop8wma40.webp#pic_center" width = 36%><p>初始移动方向是向右，如果遇到了数组边界或者遇到了非 0 的数字，那么就要转动方向。转向的方法是 <code>cur_d = (cur_d + 1) % 4</code>，cur_d 表示了当前的方向是 directions 中的哪个，顺序依次是 右、下、左、上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n</span>):</span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur_d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count != n * n:</span><br><span class="line">            res[x][y] = count + <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            dx, dy = directions[cur_d][<span class="number">0</span>], directions[cur_d][<span class="number">1</span>]</span><br><span class="line">            newx, newy = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> newx &lt; <span class="number">0</span> <span class="keyword">or</span> newx &gt;= n <span class="keyword">or</span> newy &lt; <span class="number">0</span> <span class="keyword">or</span> newy &gt;= n <span class="keyword">or</span> res[newx][newy] != <span class="number">0</span>:</span><br><span class="line">                cur_d = (cur_d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">                dx, dy = directions[cur_d][<span class="number">0</span>], directions[cur_d][<span class="number">1</span>]</span><br><span class="line">            x, y = x + dx, y + dy</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>旋转图像（辅助矩阵 &#x2F; 原地修改，清晰图解）：<a href="https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/">https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/</a></li><li>矩阵遍历问题的四部曲：<a href="https://leetcode.cn/problems/spiral-matrix-ii/solutions/659234/ju-zhen-bian-li-wen-ti-de-si-bu-qu-by-fu-sr5c/">https://leetcode.cn/problems/spiral-matrix-ii/solutions/659234/ju-zhen-bian-li-wen-ti-de-si-bu-qu-by-fu-sr5c/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二维数组的遍历也属于常考题，思路不难，但要考虑边界，本篇就带你走进矩阵按形状和方向分别遍历&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="旋转矩阵" scheme="https://qxienote.com/tags/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    
    <category term="螺旋矩阵" scheme="https://qxienote.com/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>数组（四）-- LC[1574] 删除最短的子数组使剩余数组有序</title>
    <link href="https://qxienote.com/article/830ec474.html"/>
    <id>https://qxienote.com/article/830ec474.html</id>
    <published>2023-06-17T02:21:21.000Z</published>
    <updated>2023-06-17T03:13:10.485Z</updated>
    
    <content type="html"><![CDATA[<p>LC[1574] 删除最短的子数组使剩余数组有序，通过题目深入理解滑动窗口的思想</p><span id="more"></span><h2 id="1-删除最短的子数组使剩余数组有序"><a href="#1-删除最短的子数组使剩余数组有序" class="headerlink" title="1  删除最短的子数组使剩余数组有序"></a>1  删除最短的子数组使剩余数组有序</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/009.1b99zv7n25og.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/</a></p><h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><p><strong>1. 枚举左端点，移动右端点</strong></p><p>核心思路：枚举 $\textit{left}$，增大 $\textit{right}$ 直到 $\textit{arr}[\textit{left}]\le\textit{arr}[\textit{right}]$，此时更新子数组长度的最小值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/010.2wx6zs4lrs60.gif#pic_center" width = 36%><p><strong>解疑答惑：</strong></p><p>问：为什么枚举一个新的 $\textit{left}$ 时，$\textit{right}$ 不会往左移？或者说，是否需要再次枚举之前枚举过的 $\textit{arr}[\textit{right}]$？</p><p>答：在向右移动时，由于 $\textit{arr}[\textit{left}]$ 和 $\textit{arr}[\textit{right}]$ 都是非递减的，所以 $\textit{right}$ 左侧之前枚举过的元素必然小于 $\textit{arr}[\textit{left}]$，无需再次枚举。这也是本题可以使用同向双指针（不定长滑动窗口）的前提。</p><p>问：在计算子数组长度时，我经常分不清下标是否要 +1 或 −1，请问如何解决？</p><p>答：第一，时刻把握住 $\textit{left}$ 和 $\textit{right}$ 的含义，对于本题来说是开区间 $(\textit{left},\textit{right})$，这两个指针指向的元素不能删除。第二，可以代入一些数据来验证，比如代入 $\textit{left}&#x3D;1, \textit{right}&#x3D;3$，此时只需要删除一个 $\textit{arr}[2]$，所以公式 $\textit{right}-\textit{left}-1$ 才是符合要求的。</p><p>问：为什么不用判断$\textit{left}&lt;\textit{right}$，难道不会出现 $\textit{left}\ge\textit{right}$ 的情况吗？</p><p>答：由于提前判断了 $\textit{arr}$ 是非递减数组的情况，后面的循环 $\textit{left}$ 必定小于 $\textit{right}$。反证：如果某个时刻 $\textit{left}$ 达到了 $\textit{right}$，就说明整个数组是有序的，但这种情况已经提前判断了。</p><p>问：能不能先把 $\textit{left}$ 的最大值算出来，然后再去枚举 $\textit{left}$ 或 $\textit{right}$？</p><p>答：可以。根据对称性，这种做法和先算 $\textit{right}$ 的最小值的做法是一样的，只不过枚举的顺序相反而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> arr[right - <span class="number">1</span>] &lt;= arr[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span>:  <span class="comment"># arr 已经是非递减数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 此时 arr[right-1] &gt; arr[right]</span></span><br><span class="line">        ans = right  <span class="comment"># 删除 arr[:right]</span></span><br><span class="line">        left = <span class="number">0</span>  <span class="comment"># 枚举 left</span></span><br><span class="line">        <span class="keyword">while</span> left == <span class="number">0</span> <span class="keyword">or</span> arr[left - <span class="number">1</span>] &lt;= arr[left]:</span><br><span class="line">            <span class="keyword">while</span> right &lt; n <span class="keyword">and</span> arr[right] &lt; arr[left]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时 arr[left] &lt;= arr[right]，删除 arr[left+1:right]</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, right - left - <span class="number">1</span>)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为 $\textit{nums}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{right}$ 加一的总执行次数不会超过 $n$ 次，所以总的时间复杂度为 $O(n)$。</li><li>空间复杂度：$O(1)$，仅用到若干额外变量。</li></ul><p><strong>2. 枚举右端点，移动左端点</strong></p><p>核心思路：枚举 $\textit{right}$，增大 $\textit{left}$ 直到 $\textit{arr}[\textit{left}]&gt;\textit{arr}[\textit{right}]$。在增大过程中去更新子数组长度的最小值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/011.1pr1dt5dsy0w.gif#pic_center" width = 36%><p>问：为什么枚举一个新的 $\textit{right}$ 时，$\textit{left}$ 不会往左移？或者说，是否需要再次枚举之前枚举过的 $\textit{arr}[\textit{left}]$？</p><p>答：在向右移动时，由于 $\textit{arr}[\textit{left}]$ 和 $\textit{arr}[\textit{right}]$ 都是非递减的，所以 $\textit{left}$ 左侧之前枚举过的元素必然小于等于 $\textit{arr}[\textit{right}]$，由于这样的子数组长度更长，无需再次枚举。这也是本题可以使用同向双指针（不定长滑动窗口）的前提。</p><p>问：为什么循环一定会结束？</p><p>答：代码中提前判断了 $\textit{arr}$ 已经是非递减数组的情况，所以后面的循环一定存在 $\textit{left}$，使得 $\textit{arr}[\textit{left}]&gt;\textit{arr}[\textit{left}+1]$ 成立。</p><p>注：最坏情况下，当 $\textit{right}&#x3D;n$ 时才会去移动 $\textit{left}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> arr[right - <span class="number">1</span>] &lt;= arr[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span>:  <span class="comment"># arr 已经是非递减数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 此时 arr[right-1] &gt; arr[right]</span></span><br><span class="line">        ans = right  <span class="comment"># 删除 arr[:right]</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 枚举 right</span></span><br><span class="line">            <span class="keyword">while</span> right == n <span class="keyword">or</span> arr[left] &lt;= arr[right]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right - left - <span class="number">1</span>)  <span class="comment"># 删除 arr[left+1:right]</span></span><br><span class="line">                <span class="keyword">if</span> arr[left] &gt; arr[left + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为 $\textit{nums}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{left}$ 加一的总执行次数不会超过 $n$ 次，所以总的时间复杂度为 $O(n)$。</li><li>空间复杂度：$O(1)$，仅用到若干额外变量。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>删除最短的子数组使剩余数组有序：<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/2189149/dong-hua-yi-xie-jiu-cuo-liang-chong-xie-iijwz/">https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/2189149/dong-hua-yi-xie-jiu-cuo-liang-chong-xie-iijwz/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LC[1574] 删除最短的子数组使剩余数组有序，通过题目深入理解滑动窗口的思想&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="滑动窗口" scheme="https://qxienote.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="子数组" scheme="https://qxienote.com/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
    <category term="枚举法" scheme="https://qxienote.com/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（三）-- LC[370]&amp;[1109]&amp;[1094] 区间加法</title>
    <link href="https://qxienote.com/article/29a8c889.html"/>
    <id>https://qxienote.com/article/29a8c889.html</id>
    <published>2023-06-17T02:20:51.000Z</published>
    <updated>2023-06-17T03:12:35.973Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要以LeetCode[370]区间加法、LeetCode[1109]航班预定统计、LeetCode[1094]拼车为例，讲解差分数组的思想和应用。</p><span id="more"></span><h2 id="1-区间加法"><a href="#1-区间加法" class="headerlink" title="1 区间加法"></a>1 区间加法</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/001.186b44op9p9c.webp#pic_center" width = 64%><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p>常规的思路很容易，给区间 nums[i: j] 加上 val，那就⼀个 for 循环给它们都加上呗，但这种思路的时间复杂度是 $O(N)$，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。</p><p>这⾥就需要差分数组的技巧，差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。</p><p>差分数组的性质是：当我们希望对原数组的某一个区间[i, j]施加一个增量 inc 时，差分数组d对应的变化是：d[i]增加inc，d[j+1]减少inc，并且这种操作是可以叠加的。</p><p>下面举个例子：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.o2smmp2nbps.webp#pic_center" width = 64%><p>差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。</p><p>还是上面那个表里的例子，我们需要进行以下操作：</p><ol><li>将区间[1，4]的数值全部加上3</li><li>将区间[3，5]的数值全部减去5</li></ol><p>很简单对吧，你可以进行枚举。但是如果给你的数据量是1e5，操作量1e5，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。</p><p>其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。</p><p>利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.26qp336md6ow.webp#pic_center" width = 64%><p>进行下一个操作，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.5fbtn7ubb500.webp#pic_center" width = 64%><p>这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。</p><p>本部分参考自：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分详解+例题</a></p><p>也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。</p><p><strong>代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (length+<span class="number">1</span>)  <span class="comment"># 末尾多个0，防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end + <span class="number">1</span>] -= inc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            diff[i] += diff[i - <span class="number">1</span>]            <span class="comment"># 对差分数组求前缀和便可得到原数组</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> diff[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="2-航班预订统计"><a href="#2-航班预订统计" class="headerlink" title="2 航班预订统计"></a>2 航班预订统计</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.7jqt4ty7a0o0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>题⽬说的 n 是从 1 开始计数的，⽽数组索引从 0 开始，在构造差分数组时，需要相应的调整数组下标对应关系，这里在前面添加0，和三元组 (i, j, k) 依次对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            start, end, inc = booking[<span class="number">0</span>], booking[<span class="number">1</span>], booking[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            <span class="keyword">if</span> end &lt; n:             <span class="comment"># 没在末尾添加0，要判断一下边界</span></span><br><span class="line">                diff[end+<span class="number">1</span>] -= inc</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n+m)$，其中 $n$ 为要求的数组长度，$m$ 为预定记录的数量。我们需要对于每一条预定记录处理一次差分数组，并最后对差分数组求前缀和。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="3-拼车"><a href="#3-拼车" class="headerlink" title="3 拼车"></a>3 拼车</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.2mzdjelg76k0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/car-pooling/">https://leetcode.cn/problems/car-pooling/</a></p><h3 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h3><ol><li><p>首先大致可以看出这也是数组子区间增减问题，使用数组画出来看一下，是否能用差分数组</p></li><li><p>定义数组保存每一站车上人数，接客是对子区间全部元素加 n 运算，多次上下车后，看最终数组每一站人数是否超过capacity，超过则说明有乘客上不来</p></li><li><p>注意：</p></li></ol><ul><li>接人影响的子区间为[start, end-1]，因为这批乘客在下车站已经下车了</li><li>0 &lt;&#x3D; trips[i][1] &lt; trips[i][2] &lt;&#x3D; 1000，可以看出trips中start&#x2F;end就是数组下标，这里可以直接定义差分数组大小，也可以使用循环找到最多有几站</li></ul><p>以trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4为例，数组变化：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/007.6bjq9cr5fw00.webp#pic_center" width = 64%><ol><li>说明：</li></ol><ul><li>数组长度为8，表示全程 0~7 共8个站点，元素值表示在第i站车上人数</li><li>没有接人时为原数组，接人是对数组的修改</li><li>最后看每站人数是否超过capacity</li><li>因为3&#x2F;4站人数超过capacity，说明到第3站有乘客上不来</li></ul><ol start="5"><li>观察上面数组变化，可以看出是子区间内元素全部加 n，多次修改后求修改后数组的问题——典型的差分数组求解，对应差分数组变化：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/008.mm47mmjjymo.webp#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="number">1001</span>)      <span class="comment"># 题目中最多有1001个车站</span></span><br><span class="line">        max_station = <span class="number">0</span>          <span class="comment"># 找到车站数</span></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            inc, start, end = trip[<span class="number">0</span>], trip[<span class="number">1</span>], trip[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end] -= inc      <span class="comment"># 第end站乘客已经下车，这里就不用end+1</span></span><br><span class="line">            max_station = <span class="built_in">max</span>(max_station, end)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_station+<span class="number">1</span>): <span class="comment"># 进行区间求和</span></span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(diff[:max_station]) &gt; capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要以LeetCode[370]区间加法、LeetCode[1109]航班预定统计、LeetCode[1094]拼车为例，讲解差分数组的思想和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="差分数组" scheme="https://qxienote.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
    <category term="数组区间修改" scheme="https://qxienote.com/tags/%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>数组（二）-- LC[303]&amp;[304] 区域和检索 - 数组不可变</title>
    <link href="https://qxienote.com/article/a991eb96.html"/>
    <id>https://qxienote.com/article/a991eb96.html</id>
    <published>2023-06-15T14:14:56.000Z</published>
    <updated>2023-06-17T02:15:33.003Z</updated>
    
    <content type="html"><![CDATA[<p>做这种初始化一次、检索多次的题目的秘诀：在初始化的时候做预处理，前缀和技巧就适⽤于快速、频繁地计算⼀个索引区间内的元素之和。本节主要学习区域和检索在数组和矩阵不可变情况下的，如何使用前缀和技巧提高效率。</p><span id="more"></span><h2 id="1-区域和检索-数组不可变"><a href="#1-区域和检索-数组不可变" class="headerlink" title="1 区域和检索 - 数组不可变"></a>1 区域和检索 - 数组不可变</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/016.16tdea598mkg.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>最朴素的想法是存储数组 nums 的值，每次调用 sumRange 时，通过循环的方法计算数组 nums 从下标 $i$ 到下标 $j$ 范围内的元素和，需要计算 $j−i+1$ 个元素的和。由于每次检索的时间和检索的下标范围有关，因此检索的时间复杂度较高，如果检索次数较多，则会超出时间限制。</p><p>由于会进行多次检索，即多次调用 sumRange，因此为了降低检索的总时间，应该降低 sumRange 的时间复杂度，最理想的情况是时间复杂度 $O(1)$。为了将检索的时间复杂度降到 $O(1)$，需要在初始化的时候进行预处理。</p><p>注意到当 $i≤j$ 时，sumRange(i,j) 可以写成如下形式：</p><p>$$\begin{aligned} &amp; \operatorname{sum} \operatorname{Range}(i, j) \ &#x3D; &amp; \sum_{k&#x3D;i}^j n u m s[k] \ &#x3D; &amp; \sum_{k&#x3D;0}^j n u m s[k]-\sum_{k&#x3D;0}^{i-1} n u m s[k]\end{aligned}$$</p><p>由此可知，要计算 sumRange(i,j)，则需要计算数组 nums 在下标 $j$ 和下标 $i−1$ 的前缀和，然后计算两个前缀和的差。</p><p>如果可以在初始化的时候计算出数组 nums 在每个下标处的前缀和 pre_sum，即可满足每次调用 sumRange 的时间复杂度都是 $O(1)$。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.pre_sum = [<span class="number">0</span>]            <span class="comment"># 便于计算累加和，若直接分配数组空间，计算效率更高</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.pre_sum.append(self.pre_sum[i] + nums[i])  <span class="comment"># 计算nums累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.pre_sum[right+<span class="number">1</span>] - self.pre_sum[left]</span><br></pre></td></tr></table></figure><p>下面以数组 [1, 12, -5, -6, 50, 3] 为例，展示了求 pre_sum 的过程。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/017.4h0ovjbmi640.gif#pic_center" width = 64%><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：初始化 $O(n)$，每次检索 $O(1)$，其中 $n$ 是数组 nums 的长度。初始化需要遍历数组 nums 计算前缀和，时间复杂度是 $O(n)$。每次检索只需要得到两个下标处的前缀和，然后计算差值，时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(n)$，其中 $n$ 是数组 nums 的长度。需要创建一个长度为 $n+1$ 的前缀和数组。</li></ul><hr><h2 id="2-二维区域和检索-矩阵不可变"><a href="#2-二维区域和检索-矩阵不可变" class="headerlink" title="2 二维区域和检索 - 矩阵不可变"></a>2 二维区域和检索 - 矩阵不可变</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/018.60fo4kdbbs00.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">https://leetcode.cn/problems/range-sum-query-2d-immutable/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>这部分借鉴自：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/er-wei-qian-zhui-he-jian-dan-tui-dao-tu-sqekv/">笨猪爆破组的题解————从暴力法开始优化 「二维前缀和」做了什么事 | leetcode.304</a></p><p><strong>1. 暴力法</strong></p><p>对二维矩阵，求子矩阵 $(n*m)$ 的和。两重循环，累加求和。</p><p>每次查询时间复杂度 $O(n∗m)$，n和m是子矩阵的行数和列数。查询的代价大。</p><p><strong>2. 第一步优化</strong></p><p>上面的暴力法其实也分了 n 步：第一行的求和，到第 n 行的求和，它们是 n 个一维数组。</p><p>昨天我们学习了一维前缀和，我们可以对这n个一维数组求前缀和，得到n个一维pre_sum数组。</p><p>为了节省查询的时间，我们求出整个矩阵每一行的一维pre_sum数组</p><p>根据前缀和定义：${pre}_{sum}[i]&#x3D;nums[0]+nums[1]+\cdots+nums[i]$，求出前缀和（下图红字）：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/019.3u6m52tef9s0.webp#pic_center" width = 48%><p>然后套用通式：$nums[i]+\cdots+nums[j]&#x3D;pre_sum[j]-pre_sum[i-1]$</p><p>即可求出粉色子阵列的和，计算情况如下图。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/020.hj2lugpi4p4.webp#pic_center" width = 48%><p>可见，如果想多次查询子阵列的和，我们可以提前求出每一行数组的一维前缀和。</p><p>那么查询阶段，求出一行子数组的求和，就只是 $O(1)$，查询 n 行的子阵列，每次就查询花费 $O(n)$，比 $O(n^2)$ 好</p><p><strong>3. 示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])          <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i].append(self.pre_sum[i][j]+matrix[i][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([self.pre_sum[i][col2+<span class="number">1</span>]-self.pre_sum[i][col1] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2+<span class="number">1</span>)])</span><br></pre></td></tr></table></figure><p><strong>4. 第二步优化</strong><br>还可以继续优化吗？</p><p>我们引入一个概念：二维前缀和，定义式如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/021.2ysqnsk7mj40.webp#pic_center" width = 48%><p><code>pre_sum[i][j]</code> 表示：左上角为 <code>arr[0][0]</code>，右下角为 <code>arr[i][j]</code> 的阵列的求和.</p><p>我们把这个阵列拆分成四个部分，如图中的色块。</p><p>要想求出 <code>pre_sum[i][j]</code>，根据上图，由容斥原理，有：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/022.8w4fiqsxvew.webp#pic_center" width = 48%><p>移项后：</p><p>$$arr[i][j] &#x3D; pre_sum[i][j] + pre_sum[i-1][j-1] - pre_sum[i-1][j] - pre_sum[i][j-1]$$</p><p>现在想求：行 从 a 到 A，列 从 b 到 B 的子阵列的和。叠加上式，各种相消后。得：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/023.6dkvz3kmwdc0.webp#pic_center" width = 48%><p>回到粉色子阵列，求她的和，就是如下图的 4 个 pre_sum 矩阵元素相加减。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/024.79mvkez7230.webp#pic_center" width = 48%><p>问题来了，怎么求出 pre_sum 二维阵列的每一项？</p><p>就是用遍历原矩阵，两层循环，套下图的公式。</p><p>注意到上图黄字，在 -1 位置上预置了 0，只是为了让处于边界的 preSum 元素，也能套用下面的通式。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/025.5ybgixgg7ds0.webp#pic_center" width = 48%><p>两个关键式 <code>pre_sum[i][j]</code> 的定义式如下，并且预置 <code>pre-sum[-1][j]</code> 和 <code>pre_sum[i][-1]</code> 为 0：</p><p>$$<br>\operatorname{preSum}[i][j]&#x3D;\sum_{x&#x3D;0}^i \sum_{y&#x3D;0}^j \operatorname{arr}[x][y]<br>$$</p><p>求：行从 a 到 A，列从 b 到 B 的子阵列的和的通式：<br>$$<br>\sum_{i&#x3D;a}^A \sum_{i&#x3D;b}^B \operatorname{arr}[i][j]&#x3D;\operatorname{pre_sum}[A][B]+\operatorname{pre_sum}[a-1][b-1]-\operatorname{pre_sum}[A][b-1]-\operatorname{pre_sum}[a-1][B]<br>$$</p><p>查询的时间复杂度降下来了<br>因此子阵列的求和，都只需要访问二维 pre_sum 数组的四个值。</p><p>预处理阶段，求出二维 pre_sum 数组，需要花费 $O(n∗m)$，n和m是子矩阵的行数和列数。</p><p>但之后每次查询，就都是 $O(1)$ 的时间复杂度</p><p><strong>5. 调整 pre_sum 矩阵</strong></p><p>为了减少特判的代码，我们调整一下 pre_sum 矩阵，原先 <code>arr[i][j]</code> 对应 <code>pre_sum[i][j]</code></p><p>现在错开，<code>arr[i][j]</code> 对应 <code>pre_sum[i+1][j+1]</code>。</p><p>如下图所示，pre_sum 阵列会比原矩阵多一行一列，为了让 pre_sum 的 -1 列 -1 行变成 0 行 0 列</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/026.20ie8zlewqps.webp#pic_center" width = 48%><p>现在 preSum[i][j] 的定义式，改一下</p><p>$$<br>\operatorname{pre_sum}[i+1][j+1]&#x3D;\sum_{x&#x3D;0}^i \sum_{y&#x3D;0}^j \operatorname{arr}[x][y]<br>$$</p><p>并且预置 <code>pre_sum[0][j]</code> 和 <code>pre_sum[i][0]</code> 为 0</p><p>求：行从 a 到 A，列从 b 到 B 的子阵列的和，的通式，改一下：<br>$$<br>\sum_{i&#x3D;a}^A \sum_{i&#x3D;b}^B \operatorname{arr}[i][j]&#x3D;\operatorname{pre_sum}[A+1][B+1]+\operatorname{pre_sum}[a][b]-\operatorname{pre_sum}[A+1][b]-\operatorname{pre_sum}[a][B+1]<br>$$</p><p><strong>6. 示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])          <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.pre_sum[i+<span class="number">1</span>][j] + self.pre_sum[i][j+<span class="number">1</span>] - self.pre_sum[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.pre_sum[row1][col2+<span class="number">1</span>] - self.pre_sum[row2+<span class="number">1</span>][col1] + self.pre_sum[row1][col1])</span><br></pre></td></tr></table></figure><p><strong>7. 复杂度分析</strong></p><ul><li>时间复杂度：初始化 $O(mn)$，每次检索 $O(1)$，其中 m 和 n 分别是矩阵 matrix 的行数和列数。初始化需要遍历矩阵 matrix 计算二维前缀和，时间复杂度是 $O(mn)$。每次检索的时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(mn)$，其中m和n分别是矩阵 matrix 的行数和列数。需要创建一个 m＋1 行 n+1 列的二维前缀和数组 pre_sum。</li></ul><blockquote><p>做题心得：以后会不会延伸到张量呢，更高维数的也是总结通式，就比如三维是一个立方体，依然是计算每个小立方体的和。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;做这种初始化一次、检索多次的题目的秘诀：在初始化的时候做预处理，前缀和技巧就适⽤于快速、频繁地计算⼀个索引区间内的元素之和。本节主要学习区域和检索在数组和矩阵不可变情况下的，如何使用前缀和技巧提高效率。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="前缀和" scheme="https://qxienote.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="区域和检索" scheme="https://qxienote.com/tags/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>数组（一）-- LC[26]&amp;[80] 删除有序数组中的重复元素</title>
    <link href="https://qxienote.com/article/cce29ffb.html"/>
    <id>https://qxienote.com/article/cce29ffb.html</id>
    <published>2023-06-15T13:56:27.000Z</published>
    <updated>2023-06-15T14:11:34.260Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode[26] 删除有序数组中的重复元素，原地删除重复出现的元素，使每个元素 只出现1&#x2F;2次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。使用双指针的通用解法</p><span id="more"></span><h2 id="1-删除有序数组中的重复项"><a href="#1-删除有序数组中的重复项" class="headerlink" title="1 删除有序数组中的重复项"></a>1 删除有序数组中的重复项</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给你一个 <strong>升序排列</strong> 的数组 nums ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong>，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><blockquote><p>示例 1：<br>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><blockquote><p>示例 2：<br>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>已知数组 nums 是有序的，而且我们只能在原地修改 nums 数组，不能创建新的数组空间来存储删除重复出现的元素后的结果。我们需要一边遍历数组查找相同元素，一边在对比发现不同元素时修改数组元素，那么我们可以考虑双指针法的快慢指针了，定义 p 和 q 作为指针，初始化时指针 p 指向数组的起始位置（nums[0]），指针 q 指向指针 p 的后一个位置（nums[1]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；</li></ul><p>图示：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/014.7ehk7ns70rk0.webp#pic_center" width = 36%></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>复杂度分析：时间复杂度：$O(n)$。 空间复杂度：$O(1)$。</p><p>进一步优化：</p><p>考虑如下数组：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/015.1pxc8t12z3gg.webp#pic_center" width = 36%><p>此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p><p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p]:</span><br><span class="line">                <span class="keyword">if</span> q - p &gt; <span class="number">1</span>:</span><br><span class="line">                    nums[p+<span class="number">1</span>] = nums[q]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-删除有序数组中的重复项-II"><a href="#2-删除有序数组中的重复项-II" class="headerlink" title="2 删除有序数组中的重复项 II"></a>2 删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><blockquote><p>示例 1：<br>输入：nums &#x3D; [1,1,1,2,2,3]<br>输出：5, nums &#x3D; [1,1,2,2,3]<br>解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</p></blockquote><blockquote><p>示例 2：<br>输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]<br>输出：7, nums &#x3D; [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>思路和上面的类似，改变的地方是：初始化时指针 p 指向数组的起始位置（nums[1]），指针 q 指向指针 p 的后一个位置（nums[2]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p-1]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p-<span class="number">1</span>]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>通用解法：</strong><br>为了让解法更具有一般性，我们将原问题的「最多保留 1 位」修改为「最多保留 k 位」。<br>对于此类问题，我们应该进行如下考虑：</p><ul><li>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。</li><li>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。</li></ul><p>此时，初始化时指针 p 指向数组的起始位置（nums[k-1]），指针 q 指向指针 p 的后一个位置（nums[k]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p-k+1]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode[26] 删除有序数组中的重复元素，原地删除重复出现的元素，使每个元素 只出现1&amp;#x2F;2次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。使用双指针的通用解法&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="双指针" scheme="https://qxienote.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>字符串（二）-- LC[17] 电话号码的字母组合</title>
    <link href="https://qxienote.com/article/6b74a168.html"/>
    <id>https://qxienote.com/article/6b74a168.html</id>
    <published>2023-06-15T13:46:40.000Z</published>
    <updated>2023-06-15T14:11:34.259Z</updated>
    
    <content type="html"><![CDATA[<p>LC[17] 电话号码的字母组合，本题主要考察字符串的操作，回溯和递归的理解，以及队列的使用</p><span id="more"></span><h2 id="1-电话号码的字母组合"><a href="#1-电话号码的字母组合" class="headerlink" title="1 电话号码的字母组合"></a>1 电话号码的字母组合</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.434zi36fo760.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p><h3 id="1-2-回溯解法"><a href="#1-2-回溯解法" class="headerlink" title="1.2 回溯解法"></a>1.2 回溯解法</h3><p>这道题的解法是用回溯的方式，在循环里面套了递归调用。本来递归就不好理解了，再加上循环的递归，就更难理解了。 我们先不考虑递归，先看看下面这个问题怎么解决。 假设输入是2，只有一个字符，那么应该怎么解呢？ 按照题目要求2&#x3D;“abc”，所以结果应该是<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>先不用想着怎么去写递归，只思考下怎么打印出这个结果。 这个太简单了，一个循环就搞定了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    result.append(ch)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上面是伪代码，一个循环就搞定了。 如果输入的是23，应该怎么做呢？23的结果是<code>[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]</code>，我们仍然不考虑怎么去写递归，只是考虑怎么把这个结果给弄出来。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        result.append(ch1+ch2)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>也就是说23这样的长度为2的字符串可以用两层循环搞定。 如果输入的是234呢，仍然不要考虑怎么去写递归，而是想怎么把结果打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> <span class="string">&quot;ghi&quot;</span>:</span><br><span class="line">            result.append(ch1+ch2+ch3)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这次用了三层循环。 如果输入的是2345，那么代码可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> <span class="string">&quot;ghi&quot;</span>:</span><br><span class="line">            <span class="keyword">for</span> ch4 <span class="keyword">in</span> <span class="string">&quot;jkl&quot;</span>:</span><br><span class="line">                result.append(ch1+ch2+ch3+ch4)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这次是用了四层循环。现在是不是能看出一些门道了？对的。循环的嵌套层数，就是输入的字符串长度。输入的字符串长度是1，循环只有1层。 输入的字符串长度是3，循环就是3层。如果输入的字符串长度是10，那么循环就是10层。 可是输入的字符串长度是不固定的，对应的循环的嵌套层数也是不固定的，那这种情况怎么解决呢？这时候递归就派上用场了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.55ctnj0dzeg0.webp#pic_center" width = 36%><p>对于打印”2345”这样的字符串： 第一次递归就是上图中最下面的方格，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数 第二次递归处理3，将字符串改变成”45”后再次递归 第三次递归处理4，将字符串改变成”5”后继续递归 第四次递归处理5，将字符串改变成””后继续递归 最后发现字符串为空了，将结果放到列表中并返回 上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是 $O(3^n)$ 这个级别的，空间复杂度是 $O(n)$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.ivt8h2jae5c.webp#pic_center" width = 36%><p>动图如下：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.3kyeb4smemw0.gif#pic_center" width = 48%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type digits: str</span></span><br><span class="line"><span class="string">:rtype: List[str]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 注意边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="comment"># 一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">d = [<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line"><span class="comment"># 最终输出结果的list</span></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">tmp, index</span>):</span><br><span class="line"><span class="comment"># 递归的终止条件，注意这里的终止条件看上去跟动态演示图有些不同，主要是做了点优化</span></span><br><span class="line"><span class="comment"># 动态图中是每次截取字符串的一部分，&quot;234&quot;，变成&quot;23&quot;，再变成&quot;3&quot;，最后变成&quot;&quot;，这样性能不佳</span></span><br><span class="line"><span class="comment"># 而用index记录每次遍历到字符串的位置，这样性能更好</span></span><br><span class="line"><span class="keyword">if</span> index==<span class="built_in">len</span>(digits):</span><br><span class="line">res.append(tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment"># 获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line"><span class="comment"># 第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line"><span class="comment"># subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line">c = digits[index]</span><br><span class="line"><span class="comment"># map_string的下表是从0开始一直到9， ord(c)-48 是获取c的ASCII码然后-48, 48是0的ASCII</span></span><br><span class="line"><span class="comment"># 比如c=2时候，2-&#x27;0&#x27;，获取下标为2, letter_map[2]就是&quot;abc&quot;</span></span><br><span class="line">letters = d[<span class="built_in">ord</span>(c)-<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字符串，比如第一次得到的是2，页就是遍历&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> letters:</span><br><span class="line"><span class="comment"># 调用下一层递归，用文字很难描述，请配合动态图理解</span></span><br><span class="line">backtrack(tmp+i, index+<span class="number">1</span>)</span><br><span class="line">backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1-3-队列"><a href="#1-3-队列" class="headerlink" title="1.3 队列"></a>1.3 队列</h3><p>我们也可以使用队列，先将输入的 digits 中第一个数字对应的每一个字母入队，然后将出队的元素与第二个数字对应的每一个字母组合后入队…直到遍历到 digits 的结尾。最后队列中的元素就是所求结果。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/007.solwru43pr4.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type digits: str</span></span><br><span class="line"><span class="string">:rtype: List[str]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="comment"># 一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">d = [<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line"><span class="comment"># 先往队列中加入一个空字符</span></span><br><span class="line">res = [<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">size = <span class="built_in">len</span>(res)</span><br><span class="line"><span class="comment"># 由当前遍历到的字符，取字典表中查找对应的字符串</span></span><br><span class="line">letters = d[<span class="built_in">ord</span>(i)-<span class="number">48</span>]</span><br><span class="line"><span class="comment"># 计算出队列长度后，将队列中的每个元素挨个拿出来</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> xrange(size):</span><br><span class="line"><span class="comment"># 每次都从队列中拿出第一个元素</span></span><br><span class="line">tmp = res.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 然后跟&quot;def&quot;这样的字符串拼接，并再次放到队列中</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> letters:</span><br><span class="line">res.append(tmp+j)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>通俗易懂+动画演示 17. 电话号码的字母组合：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/44182/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/44182/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/</a></li><li>回溯+队列 图解：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LC[17] 电话号码的字母组合，本题主要考察字符串的操作，回溯和递归的理解，以及队列的使用&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="String" scheme="https://qxienote.com/categories/LeetCode/String/"/>
    
    
    <category term="字符串" scheme="https://qxienote.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回溯法" scheme="https://qxienote.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    <category term="递归" scheme="https://qxienote.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>字符串（一）-- LC[3] 无重复字符的最长子串</title>
    <link href="https://qxienote.com/article/284005f2.html"/>
    <id>https://qxienote.com/article/284005f2.html</id>
    <published>2023-06-15T13:46:09.000Z</published>
    <updated>2023-06-15T14:11:34.256Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode[3] 无重复字符的最长子串使用滑动窗口，就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。</p><span id="more"></span><h2 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1 无重复字符的最长子串"></a>1 无重复字符的最长子串</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><blockquote><p>示例 1:<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><blockquote><p>示例 2:<br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><blockquote><p>示例 3:<br>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p> <strong>滑动窗口法：其实用一句话描述就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。</strong> 示意图如下面：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.4aq0ytbcaeq0.webp#pic_center" width = 48%><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>思路一：滑动窗口法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 思路一：滑动窗口法</span></span><br><span class="line">        temp_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len, current_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> temp_str:</span><br><span class="line">                temp_str += s[i]</span><br><span class="line">                current_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = temp_str.index(s[i])</span><br><span class="line">                temp_str = temp_str[index+<span class="number">1</span>:]</span><br><span class="line">                temp_str += s[i]</span><br><span class="line">                current_len = <span class="built_in">len</span>(temp_str)</span><br><span class="line">            <span class="keyword">if</span> max_len &lt; current_len:</span><br><span class="line">                max_len = current_len</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode[3] 无重复字符的最长子串使用滑动窗口，就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="String" scheme="https://qxienote.com/categories/LeetCode/String/"/>
    
    
    <category term="滑动窗口" scheme="https://qxienote.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="字符串" scheme="https://qxienote.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数学(四) -- LC[29]&amp;[166] 两数相除与分数到小数</title>
    <link href="https://qxienote.com/article/77d95398.html"/>
    <id>https://qxienote.com/article/77d95398.html</id>
    <published>2023-06-14T03:10:55.000Z</published>
    <updated>2023-07-17T09:56:39.612Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习LeetCode两数相除里面用到的快速乘和二分查找的算法进行两数的相除，同时学习长除法的解题技巧</p><span id="more"></span><h2 id="1-分数到小数"><a href="#1-分数到小数" class="headerlink" title="1 分数到小数"></a>1 分数到小数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/010.7da1gbtbx5c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/description/">https://leetcode.cn/problems/fraction-to-recurring-decimal/description/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>1. 长除法</strong></p><p>题目要求根据给定的分子和分母，将分数转成整数或小数。由于给定的分子和分母的取值范围都是 $[-2^{31}, 2^{31}-1]$，为了防止计算过程中产生溢出，需要将分子和分母转成 64 位整数表示。</p><p>将分数转成整数或小数，做法是计算分子和分母相除的结果。可能的结果有三种：整数、有限小数、无限循环小数。</p><p>如果分子可以被分母整除，则结果是整数，将分子除以分母的商以字符串的形式返回即可。</p><p>如果分子不能被分母整除，则结果是有限小数或无限循环小数，需要通过模拟长除法的方式计算结果。为了方便处理，首先根据分子和分母的正负决定结果的正负（注意此时分子和分母都不为 0），然后将分子和分母都转成正数，再计算长除法。</p><p>计算长除法时，首先计算结果的整数部分，将以下部分依次拼接到结果中：</p><ol><li>如果结果是负数则将负号拼接到结果中，如果结果是正数则跳过这一步；</li><li>将整数部分拼接到结果中；</li><li>将小数点拼接到结果中。</li></ol><p>完成上述拼接之后，根据余数计算小数部分。</p><p>计算小数部分时，每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。</p><ul><li>如果余数变成 0，则结果是有限小数，将小数部分拼接到结果中。</li><li>如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。</li></ul><p>如何判断是否找到循环节？注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的，因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。</p><p>假设在计算小数部分的第 $i$ 位之前，余数为 $\textit{remainder}<em>i$，则在计算小数部分的第 $i$ 位之后，余数为 $\textit{remainder}</em>{i+1}$。</p><p>假设存在下标 $j$ 和 $k$，满足 $j \le k$ 且 $\textit{remainder}<em>j &#x3D; \textit{remainder}</em>{k+1}$，则小数部分的第 $k+1$ 位和小数部分的第 $j$ 位相同，因此小数部分的第 $j$ 位到第 $k$ 位是一个循环节。在计算小数部分的第 $k$ 位之后就会发现这个循环节的存在，因此在小数部分的第 $j$ 位之前加上左括号，在小数部分的末尾（即第 $k$ 位之后）加上右括号。</p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/011.1g836fzb4800.webp#pic_left" width = "50%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/012.1ysut58coneo.webp#pic_left"  width = "48%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fractionToDecimal</span>(<span class="params">self, numerator: <span class="built_in">int</span>, denominator: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果本身能够整除，直接返回计算结果</span></span><br><span class="line">        <span class="keyword">if</span> numerator % denominator == <span class="number">0</span>: <span class="keyword">return</span> <span class="built_in">str</span>(numerator//denominator)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> numerator * denominator &lt; <span class="number">0</span>:             <span class="comment"># 如果其一为负数，先追加负号</span></span><br><span class="line">            res.append(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        numerator, denominator = <span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator)</span><br><span class="line">        res.append(<span class="built_in">str</span>(numerator//denominator))     <span class="comment">#  计算整数部分，并将余数赋值给 remainder</span></span><br><span class="line">        res.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        remainder = numerator % denominator</span><br><span class="line">        index_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> remainder <span class="keyword">and</span> remainder <span class="keyword">not</span> <span class="keyword">in</span> index_map:</span><br><span class="line">            index_map[remainder] = <span class="built_in">len</span>(res)         <span class="comment"># 记录当前余数所在答案的位置，并继续模拟除法运算</span></span><br><span class="line">            remainder *= <span class="number">10</span></span><br><span class="line">            res.append(<span class="built_in">str</span>(remainder//denominator))</span><br><span class="line">            remainder %= denominator</span><br><span class="line">        <span class="keyword">if</span> remainder:                   <span class="comment"># 当前余数之前出现过，则将出现位置和最后位置添加&#x27;()&#x27;</span></span><br><span class="line">            ind = index_map[remainder]</span><br><span class="line">            res.insert(ind, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            res.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(l)$，其中 $l$ 是答案字符串的长度，这道题中 $l \le 10^4$。对于答案字符串中的每一个字符，计算时间都是 $O(1)$。</li><li>空间复杂度：$O(l)$，其中 $l$ 是答案字符串的长度，这道题中 $l \le 10^4$。空间复杂度主要取决于答案字符串和哈希表，哈希表中的每个键值对所对应的下标各不相同，因此键值对的数量不会超过 $l$。</li></ul><h2 id="2-两数相除"><a href="#2-两数相除" class="headerlink" title="2 两数相除"></a>2 两数相除</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/013.6o6qc5moj0c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/divide-two-integers/description/">https://leetcode.cn/problems/divide-two-integers/description/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p><strong>1. 二分查找</strong></p><p>如果除法结果溢出，那么我们需要返回 $2^{31}-1$ 作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：</p><ul><li>当被除数为 32 位有符号整数的最小值 $-2^{31}$ 时：<ul><li>如果除数为 1，那么我们可以直接返回答案 $-2^{31}$；</li><li>如果除数为 −1，那么答案为 $2^{31}$，产生了溢出。此时我们需要返回 $2^{31} - 1$。</li></ul></li><li>当除数为 32 位有符号整数的最小值 $s-2^{31}$ 时：<ul><li>如果被除数同样为 $-2^{31}$，那么我们可以直接返回答案 111；</li><li>对于其余的情况，我们返回答案 0。</li></ul></li><li>当被除数为 0 时，我们可以直接返回答案 0。</li></ul><p>对于一般的情况，根据除数和被除数的符号，我们需要考虑 444 种不同的可能性。因此，为了方便编码，我们可以将被除数或者除数取相反数，使得它们符号相同。</p><p>如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 $-2^{31}$ 时，它的相反数 $2^{31}$ 产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 1 种情况了。</p><p>如果我们将被除数和除数的其中（恰好）一个变为了正数，那么在返回答案之前，我们需要对答案也取相反数。</p><p><strong>方法一：二分查找</strong></p><p>根据「前言」部分的讨论，我们记被除数为 X，除数为 Y，并且 X 和 Y 都是负数。我们需要找出 X&#x2F;Y 的结果 Z。Z 一定是正数或 0。</p><p>根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：</p><p>$$Z\times Y \geq X \geq (Z+1) \times Y$$</p><p>因此，我们可以使用二分查找的方法得到 ZZZ，即找出最大的 ZZZ 使得 Z×Y≥XZ \times Y \geq XZ×Y≥X 成立。</p><p>由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 $Z \times Y$ 的值。</p><p>由于我们只能使用 32 位整数，因此二分查找中会有很多细节。</p><p>首先，二分查找的下界为 1，上界为 $2^{31} - 1$。唯一可能出现的答案为 $2^{31}$ 的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 $2^{31} - 1$。如果二分查找失败，那么答案一定为 0。</p><p>在实现「快速乘」时，我们需要使用加法运算，然而较大的 Z 也会导致加法运算溢出。例如我们要判断 A + B 是否小于 C 时（其中 A,B,C 均为负数），A + B 可能会产生溢出，因此我们必须将判断改为 $A &lt; C - B$ 是否成立。由于任意两个负数的差一定在 $[-2^{31} + 1, 2^{31} - 1]$ 范围内，这样就不会产生溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        INT_MIN, INT_MAX = -<span class="number">2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == INT_MIN:</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MIN</span><br><span class="line">            <span class="keyword">if</span> divisor == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MAX</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == INT_MIN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> dividend == INT_MIN <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment"># 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        rev = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> dividend &gt; <span class="number">0</span>:</span><br><span class="line">            dividend = -dividend</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line">        <span class="keyword">if</span> divisor &gt; <span class="number">0</span>:</span><br><span class="line">            divisor = -divisor</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 快速乘</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickAdd</span>(<span class="params">y: <span class="built_in">int</span>, z: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment"># 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            result, add = <span class="number">0</span>, y</span><br><span class="line">            <span class="keyword">while</span> z &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> result &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    result += add</span><br><span class="line">                <span class="keyword">if</span> z != <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> add &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    add += add</span><br><span class="line">                <span class="comment"># 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        left, right, ans = <span class="number">1</span>, INT_MAX, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 注意溢出，并且不能使用除法</span></span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            check = quickAdd(divisor, mid, dividend)</span><br><span class="line">            <span class="keyword">if</span> check:</span><br><span class="line">                ans = mid</span><br><span class="line">                <span class="comment"># 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> mid == INT_MAX:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -ans <span class="keyword">if</span> rev <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：$O(\log^2 C)$，其中 $C$ 表示 32 位整数的范围。二分查找的次数为 $O(\log C)$，其中的每一步我们都需要 $O(\log C)$ 使用「快速乘」算法判断 $Z \times Y \geq X$ 是否成立，因此总时间复杂度为 $O(\log^2 C)$。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>2. 减法试除</strong><br><strong>思路一</strong><br>首先需要考虑正负号，处理为分子分母全是正数， 其次在返回的时候要注意是否溢出，如果溢出要判断。</p><p>核心是div函数怎么写？例如方法1中的div函数， 利用二进制搜索的思想就是， 每次利用加法，将当前的 divisor 乘以两倍，并同时用 multiple 记录下乘以了 2 的多少次方， multiple 的变化过程是1，2，4，8，16 。。。</p><p>因为任何一个数都可以用二进制的方法得到，所以我们可以利用二进制的思想来代表乘数 multiple， 最终能够得到一个 <code>divisor * multiple = dividend</code> 的multiple。</p><p>举例：算 $63 &#x2F; 8$ 过程为：$63 &#x2F; 8 &#x3D; (63-32) &#x2F; 8 + 4 &#x3D; (63-32-16) &#x2F; 8 + 2 + 4 &#x3D; (63-32-16-8) &#x2F; 8 + 1+ 2 + 4 &#x3D; 7$ 其中 $(63-32-16-8) &#x2F; 8 &#x3D; 7 &#x2F; 8 &#x3D; 0$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN_INT, MAX_INT = -<span class="number">2147483648</span>, <span class="number">2147483647</span>  <span class="comment"># [−2**31, 2**31−1]</span></span><br><span class="line">        flag = <span class="number">1</span>                                    <span class="comment"># 存储正负号，并将分子分母转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>: flag, dividend = -flag, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>: flag, divisor  = -flag, -divisor </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">dividend, divisor</span>):                 <span class="comment"># 例：1023 / 1 = 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 1</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cur = divisor</span><br><span class="line">            multiple = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur + cur &lt; dividend:             <span class="comment"># 用加法求出保证divisor * multiple &lt;= dividend的最大multiple</span></span><br><span class="line">                cur += cur                          <span class="comment"># 即cur分别乘以1, 2, 4, 8, 16...2^n，即二进制搜索</span></span><br><span class="line">                multiple += multiple</span><br><span class="line">            <span class="keyword">return</span> multiple + div(dividend - cur, divisor)</span><br><span class="line">        res = div(dividend, divisor)</span><br><span class="line"></span><br><span class="line">        res = res <span class="keyword">if</span> flag &gt; <span class="number">0</span> <span class="keyword">else</span> -res             <span class="comment"># 恢复正负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN_INT:                           <span class="comment"># 根据是否溢出返回结果</span></span><br><span class="line">            <span class="keyword">return</span> MIN_INT</span><br><span class="line">        <span class="keyword">elif</span> MIN_INT &lt;= res &lt;= MAX_INT:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN_INT, MAX_INT = -<span class="number">2147483648</span>, <span class="number">2147483647</span>  <span class="comment"># [−2**31, 2**31−1]</span></span><br><span class="line">        flag = <span class="number">1</span>                                    <span class="comment"># 存储正负号，并将分子分母转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>: flag, dividend = -flag, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>: flag, divisor  = -flag, -divisor </span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:                  <span class="comment"># 例：1023 / 1 = 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 1</span></span><br><span class="line">            cur = divisor</span><br><span class="line">            multiple = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur + cur &lt; dividend:             <span class="comment"># 用加法求出保证divisor * multiple &lt;= dividend的最大multiple</span></span><br><span class="line">                cur += cur                          <span class="comment"># 即cur分别乘以1, 2, 4, 8, 16...2^n，即二进制搜索</span></span><br><span class="line">                multiple += multiple</span><br><span class="line">            dividend -= cur                         <span class="comment"># 辗转相减法</span></span><br><span class="line">            res += multiple</span><br><span class="line">        </span><br><span class="line">        res = res <span class="keyword">if</span> flag &gt; <span class="number">0</span> <span class="keyword">else</span> -res             <span class="comment"># 恢复正负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN_INT:                           <span class="comment"># 根据是否溢出返回结果</span></span><br><span class="line">            <span class="keyword">return</span> MIN_INT</span><br><span class="line">        <span class="keyword">elif</span> MIN_INT &lt;= res &lt;= MAX_INT:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br></pre></td></tr></table></figure><p><strong>思路二</strong></p><p>用 $2^i$ 去作为乘法基数, $x * 2^i &#x3D; x &lt;&lt; i$。 从 $2^{31}$ 试到 $2^0$ 直到被除数被减到比除数小， 每个能满足除出来的最大的 2 的幂都加入答案, 也可以理解为每次计算出答案的 32 位中的某一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> dividend == -<span class="number">2147483648</span> <span class="keyword">and</span> divisor == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">        a, b, res = <span class="built_in">abs</span>(dividend), <span class="built_in">abs</span>(divisor), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 2^i * b &lt;= a 换句话说 a/b = 2^i + (a-2^i*b)/b</span></span><br><span class="line">            <span class="keyword">if</span> (b &lt;&lt; i) &lt;= a:</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">                a -= b &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>两数相除——官方题解：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/">https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/</a></li><li>减法试除：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/1042741/pythonjavajavascript-jian-fa-shi-chu-by-amrow/">https://leetcode.cn/problems/divide-two-integers/solutions/1042741/pythonjavajavascript-jian-fa-shi-chu-by-amrow/</a></li><li>二进制搜索的思想：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/458026/29-python3-li-yong-er-jin-zhi-sou-suo-de-si-xiang-/">https://leetcode.cn/problems/divide-two-integers/solutions/458026/29-python3-li-yong-er-jin-zhi-sou-suo-de-si-xiang-/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要学习LeetCode两数相除里面用到的快速乘和二分查找的算法进行两数的相除，同时学习长除法的解题技巧&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="二分查找" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="长除法" scheme="https://qxienote.com/tags/%E9%95%BF%E9%99%A4%E6%B3%95/"/>
    
    <category term="快速乘" scheme="https://qxienote.com/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"/>
    
  </entry>
  
  <entry>
    <title>数学(三) -- LC[1010]&amp;[1015] 可被 K 整除的最小整数</title>
    <link href="https://qxienote.com/article/e0f9f6cf.html"/>
    <id>https://qxienote.com/article/e0f9f6cf.html</id>
    <published>2023-06-14T03:10:34.000Z</published>
    <updated>2023-06-14T03:25:32.929Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要结合LeetCode上的题目分析常用的取模运算、带余除法、鸽巢定理、组合数学的解题技巧。</p><span id="more"></span><h2 id="1-可被-K-整除的最小整数"><a href="#1-可被-K-整除的最小整数" class="headerlink" title="1 可被 K 整除的最小整数"></a>1 可被 K 整除的最小整数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.4r4wqioa0sk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/">https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>模运算</strong></p><p>如果让你计算 $1234 \cdot 6789$ 的个位数，你会如何计算？</p><p>由于只有个位数会影响到乘积的个位数，那么 $4\cdot 9&#x3D;36$ 的个位数 $6$ 就是答案。</p><p>对于 $1234+6789$ 的个位数，同理，$4+9&#x3D;13$ 的个位数 $3$ 就是答案。</p><p>你能把这个结论抽象成数学等式吗？</p><p>一般地，涉及到取模的题目，通常会用到如下等式(上面计算的是 $m&#x3D;10$):</p><p>$$<br>(a+b)\bmod m &#x3D; ((a\bmod m) + (b\bmod m)) \bmod m \<br>(a\cdot b) \bmod m&#x3D;((a\bmod m)\cdot  (b\bmod m)) \bmod m<br>$$</p><p>证明：根据<a href="https://zhuanlan.zhihu.com/p/147079013">带余除法</a>，任意整数 $a$ 都可以表示为 $a&#x3D;km+r$，这里 $r$ 相当于 $a mod m$。那么设 $a&#x3D;k_1m+r_1,\ b&#x3D;k_2m+r_2$。</p><p><strong>第一个等式：</strong><br>$$<br>\begin{aligned}<br>&amp;(a+b) \bmod m\<br>&#x3D;&amp;((k_1+k_2) m+r_1+r_2)\bmod m\<br>&#x3D;&amp;(r_1+r_2)\bmod m\<br>&#x3D;&amp;((a\bmod m) + (b\bmod m)) \bmod m<br>\end{aligned}<br>$$</p><p>即：两个数相加对某个数求余等于两个数分别求余相加之后再求余。</p><p><strong>第二个等式：</strong><br>$$<br>\begin{aligned}<br>&amp;(a\cdot b) \bmod m\<br>&#x3D;&amp;(k_1k_2m^2+(k_1r_2+k_2r_1)m+r_1r_2)\bmod m\<br>&#x3D;&amp;(r_1r_2)\bmod m\<br>&#x3D;&amp;((a\bmod m)\cdot  (b\bmod m)) \bmod m<br>\end{aligned}<br>$$</p><p><strong>举例一: $k &#x3D; 7$</strong></p><p>从小到大枚举$n$，第一个能被 $k$ 整除的数的长度即为答案。</p><p>$$1 \rightarrow 11 \rightarrow 111 \rightarrow 1111 \rightarrow 11111 \rightarrow 111111$$</p><p>根据前置知识，设 $x$ 是上一次运算的结果(初始为1)，则下一个 $n$ 模 $k$ 的结果为 $(10x + 1) mod k$，看它是否为0。</p><p>$$1 \rightarrow 4 \longrightarrow 6 \longrightarrow 5 \longrightarrow 2 \longrightarrow 0$$</p><p><strong>举例二: $k&#x3D;24$</strong></p><p>如果计算结果和之前的某个数相同，由于计算规则不变，后面会无限重复下去，无法得到0。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.54n4hhi87cg0.webp#pic_center" width = 48%><p><strong>方法一：哈希表</strong></p><p>用哈希表记录计算结果。如果在算出0之前就遇到了在哈希表中的数字，则返回-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">1</span> % k           <span class="comment">#  x 为余数</span></span><br><span class="line">        seen = <span class="built_in">set</span>()        <span class="comment">#  创建一个无序集合，用于存储余数</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> seen:      <span class="comment"># 当余数为0或者余数重复出现，退出循环</span></span><br><span class="line">            seen.add(x)</span><br><span class="line">            x = (<span class="number">10</span> * x + <span class="number">1</span>) % k</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> x <span class="keyword">else</span> <span class="built_in">len</span>(seen) + <span class="number">1</span>   <span class="comment"># 余数不为0，返回-1，余数为0，返回len(seen)+1    </span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(k)$。</li><li>空间复杂度：$\mathcal{O}(k)$。</li></ul><p><strong>方法二：抽屉原理</strong></p><p>循环 $k$ 次，如果没有算出0，则返回-1。为什么？模 $k$ 的结果在 $[0, k-1]$ 中，这有 $k$ 个数字。如果循环 $k$ 次还没有找到0,根据<a href="https://oi-wiki.org/math/number-theory/fermat/#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">鸽巢原理(抽屉原理)</a>，必然有重复的数字。这也同时说明算法一的时间复杂度为 $O(k)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> k % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        x = <span class="number">1</span> % k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">1</span>):              <span class="comment"># 一定有解</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            x = (x * <span class="number">10</span> + <span class="number">1</span>) % k</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(k)$。</li><li>空间复杂度：$\mathcal{O}(1)$，仅用到若干额外变量。</li></ul><p><code>itertools.count(start=0, step=1)</code></p><p>创建一个迭代器，它从 start 值开始，返回均匀间隔的值。常用于 <code>map()</code> 中的实参来生成连续的数据点。此外，还用于 <code>zip()</code> 来添加序列号。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">start=<span class="number">0</span>, step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) --&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure><p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如：<code>(start + step * i for i in count())</code>。</p><p><strong>方法三：数学推导</strong></p><p>设 $n$ 的长度为 $x$，那么 $n&#x3D;\frac{10^x-1}{9}$。$n$ 是 $k$ 的倍数，等价于 $10^x-1$ 是 $9k$ 的倍数，即 $10^x \equiv 1(mod 9k)$ 。</p><ul><li>结论：最小的 $x$ 必然是 $\phi(9k)$ 的因子。</li><li>反证：如果 $\phi(9k) &#x3D; px + r (0 &lt; r &lt;x)$，根据欧拉定理，$10^{\phi(9k)}&#x3D;(10)P﹒10”&#x3D;10”&#x3D; 1(mod 9k)$，这说明有一个比 $x$ 更小的 $r$，矛盾。</li></ul><p>那么计算 $\phi(9k)$ 并枚举其因子 $d$，用快速幂判断 $10^d mod (9k)$ 是否等于1。这一做法只需要 $(\sqrt(k)log k )$ 的时间。</p><p><strong>一点优化</strong></p><p>由于 $n$ 的个位数是1，所以必然不是 2 的倍数和 5 的倍数。如果 $k$ 是 2 的倍数或 5 的倍数，那么必然无解，返回 —1。否则一定有解。</p><p>证明：根据算法二，在计算过程中必然会出现两个数模 $k$ 同余。设这两个数为 $a&#x3D;\frac{10^x-1}{9}$ 和 $b&#x3D;\frac{10^y-1}{9}$，且 $a &gt; b$。那么 $a-b$ 是 $k$ 的倍数。</p><p>注意 $a-b&#x3D;\frac{10^x-10^y}{9}&#x3D;10^y\cdot\frac{10^{x-y}-1}{9}$。$k$在没有因子 2 和 5 的情况下，要想整除上式，必须要整除 $\frac{10^{x-y}-1}{9}$，这说明 $n$ 的长度可以是 $x-y$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算欧拉函数（n 以内的与 n 互质的数的个数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phi</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = n</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            res = res // i * (i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n //= i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        res = res // n * (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> k % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        m = phi(k * <span class="number">9</span>)</span><br><span class="line">        <span class="comment"># 从小到大枚举不超过 sqrt(m) 的因子</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt;= m:</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">10</span>, i, k * <span class="number">9</span>) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从小到大枚举不低于 sqrt(m) 的因子</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">10</span>, m // i, k * <span class="number">9</span>) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> m // i</span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(\sqrt{k}\log k)$。计算 $\phi(9k)$ 和枚举 $\phi(9k)$ 的因子都需要 $\mathcal{O}(\sqrt{k})$ 的时间，对每个因子计算快速幂需要 $\mathcal{O}(\log k)$ 的时间，所以时间复杂度为 $\mathcal{O}(\sqrt{k}\log k)$。</li><li>空间复杂度：$\mathcal{O}(1)$。仅用到若干额外变量。</li></ul><h2 id="2-总持续时间可被-60-整除的歌曲"><a href="#2-总持续时间可被-60-整除的歌曲" class="headerlink" title="2 总持续时间可被 60 整除的歌曲"></a>2 总持续时间可被 60 整除的歌曲</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.3bcoupelrdk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/">https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p><strong>1. 组合数学</strong></p><p>遍历数组的同时用一个哈希表（或者数组）记录元素的出现次数。</p><p>遍历 $\textit{time}$：</p><ul><li>举例，如果 $\textit{time}[i]&#x3D;1$，那么需要知道左边有多少个模 60 余数是 59 的数。</li><li>举例，如果 $\textit{time}[i]&#x3D;62$，那么需要知道左边有多少个模 60 余数是 58 的数。</li><li>一般地，对于 $\textit{time}[i]$，需要知道左边有多少个模 60 余数是 $60-\textit{time}[i] mod 60$ 的数。<br>特别地，如果 $\textit{time}[i]$ 模 60 的余数是 0，那么需要知道左边有多少个模 60 余数也是 0 的数。<br>这两种情况可以合并为：累加左边 $(60-\textit{time}[i] mod 60) mod 60$ 的出现次数。</li></ul><p>代码实现时，用一个长为 60 的数组 $\textit{cnt}$ 维护 $\textit{time}[i] mod 60$ 的出现次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numPairsDivisibleBy60</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">60</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">            <span class="comment"># 先查询 cnt，再更新 cnt，因为题目要求 i&lt;j</span></span><br><span class="line">            <span class="comment"># 如果先更新，再查询，就把 i=j 的情况也考虑进去了</span></span><br><span class="line">            ans += cnt[(<span class="number">60</span> - t % <span class="number">60</span>) % <span class="number">60</span>]</span><br><span class="line">            cnt[t % <span class="number">60</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(n+U)$，其中 $n$ 为 $\textit{nums}$ 的长度，$U&#x3D;60$。</li><li>空间复杂度：$\mathcal{O}(U)$。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>三种算法+优化：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/">https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/</a></li><li>「两数之和」的本质是什么？：<a href="https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2259343/liang-shu-zhi-he-de-ben-zhi-shi-shi-yao-bd0r1/">https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2259343/liang-shu-zhi-he-de-ben-zhi-shi-shi-yao-bd0r1/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要结合LeetCode上的题目分析常用的取模运算、带余除法、鸽巢定理、组合数学的解题技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="LeetCode" scheme="https://qxienote.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
