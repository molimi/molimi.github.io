<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CarpeDiem&#39;s Blog</title>
  
  <subtitle>虽不能至，心向往之</subtitle>
  <link href="https://qxienote.com/atom.xml" rel="self"/>
  
  <link href="https://qxienote.com/"/>
  <updated>2023-06-17T09:17:39.638Z</updated>
  <id>https://qxienote.com/</id>
  
  <author>
    <name>Carpe Diem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组（八）-- LC[316]&amp;[321]&amp;[402] 去除重复字母</title>
    <link href="https://qxienote.com/article/1e9e829d.html"/>
    <id>https://qxienote.com/article/1e9e829d.html</id>
    <published>2023-06-17T03:09:01.000Z</published>
    <updated>2023-06-17T09:17:39.638Z</updated>
    
    <content type="html"><![CDATA[<p>移掉 K 位数字、去除重复字母、拼接最大数这三道题目都是同一套路，即删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这三道题目应该都可以轻松解决。</p><span id="more"></span><h2 id="1-移掉-K-位数字"><a href="#1-移掉-K-位数字" class="headerlink" title="1 移掉 K 位数字"></a>1 移掉 K 位数字</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/040.4ke3hv739fo0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/remove-k-digits/">https://leetcode.cn/problems/remove-k-digits/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>这道题让我们从一个字符串数字中删除 k 个数字，使得剩下的数最小。也就说，我们要保持原来的数字的相对位置不变。</p><p>以题目中的 $num &#x3D; 1432219，k &#x3D; 3$ 为例，我们需要返回一个长度为 4 的字符串，问题在于： 我们怎么才能求出这四个位置依次是什么呢？</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/041.3k2aqhji1d20.webp#pic_center" width = 48%><p>暴力法的话，我们需要枚举 $C_n^(n - k)$ 种序列（其中 $n$ 为数字长度），并逐个比较最大。这个时间复杂度是指数级别的，必须进行优化。</p><p>一个思路是：</p><ul><li>从左到右遍历</li><li>对于每一个遍历到的元素，我们决定是丢弃还是保留</li></ul><p>问题的关键是：我们怎么知道，一个元素是应该保留还是丢弃呢？</p><p>这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a &gt; b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小。</p><p>因此我们的思路就是：</p><ul><li>从左到右遍历</li><li>对于遍历到的元素，我们选择保留。</li><li>但是我们可以选择性丢弃前面相邻的元素。</li><li>丢弃与否的依据如上面的前置知识中阐述中的方法。</li></ul><p>以题目中的 $num &#x3D; 1432219，k &#x3D; 3$ 为例的图解过程如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/042.5xmn9diclm00.webp#pic_center" width = 36%><p>由于没有左侧相邻元素，因此没办法丢弃。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/043.3a4rwxtigf20.webp#pic_center" width = 36%><p>由于 4 比左侧相邻的 1 大。如果选择丢弃左侧的 1，那么会使得剩下的数字更大（开头的数从 1 变成了 4）。因此我们仍然选择不丢弃。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/044.5mzf9sc97z40.webp#pic_center" width = 36%><p>由于 3 比左侧相邻的 4 小。 如果选择丢弃左侧的 4，那么会使得剩下的数字更小（开头的数从 4 变成了 3）。因此我们选择丢弃。</p><p>后面的思路类似，这里就不继续分析啦。</p><p>然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远选择不丢弃。这个题目中要求的，我们要永远确保丢弃 k 个矛盾。</p><p>一个简单的思路就是：</p><ul><li>每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。</li><li>而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</li></ul><p>上面的思路可行，但是稍显复杂。</p><p>我们需要把思路逆转过来。刚才我的关注点一直是丢弃，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 $n - k$ 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前  $n - k$ 个元素即可。</p><p>按照上面的思路，我们来选择数据结构。由于我们需要保留和丢弃相邻的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num, k</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        remain = <span class="built_in">len</span>(num) - k</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:               <span class="comment"># 构建单调递增的数字串</span></span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span>      </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/045.2qdr9my17iw.gif#pic_center" width = 48%><p>提示： 如果题目改成求删除 k 个字符之后的最大数，我们只需要将 stack[-1] &gt; digit 中的大于号改成小于号即可</p><h2 id="2-去除重复字母"><a href="#2-去除重复字母" class="headerlink" title="2 去除重复字母"></a>2 去除重复字母</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/046.2cir1n6s89j4.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/remove-duplicate-letters/">https://leetcode.cn/problems/remove-duplicate-letters/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>与上面题目不同，这道题没有一个全局的删除次数 k。而是对于每一个在字符串 s 中出现的字母 c 都有一个 k 值。这个 k 是 c 出现次数 - 1。</p><p>沿用上面的知识的话，我们首先要做的就是计算每一个字符的 k，可以用一个字典来描述这种关系，其中 key 为 字符 c，value 为其出现的次数。</p><p>具体算法：</p><ul><li>建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。</li><li>从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1.</li><li>对于每一个字符，如果其对应的剩余出现次数大于 1，我们可以选择丢弃（也可以选择不丢弃），否则不可以丢弃。</li><li>是否丢弃的标准和上面题目类似。如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。</li></ul><p>还记得上面题目的边界条件么？如果栈中剩下的元素大于 $n−k$，我们选择截取前 $n - k$ 个数字。然而本题中的 k 是分散在各个字符中的，因此这种思路不可行的。</p><p>不过不必担心。由于题目是要求只出现一次。我们可以在遍历的时候简单地判断其是否在栈上即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/047.3dkxsbuhwk00.webp#pic_center" width = 48%><p>查询给定字符是否在一个序列中存在的方法。根本上来说，有两种可能：</p><ul><li>有序序列： 可以二分法，时间复杂度大致是 $O(N)$。</li><li>无序序列： 可以使用遍历的方式，最坏的情况下时间复杂度为 $O(N)$。我们也可以使用空间换时间的方式，使用 $N$ 的空间 换取 $O(1)$ 的时间复杂度。<br>由于本题中的 stack 并不是有序的，因此我们的优化点考虑空间换时间。而由于每种字符仅可以出现一次，这里使用 hashset 即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    seen.discard(stack.pop())</span><br><span class="line">                seen.add(c)</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h2 id="3-拼接最大数"><a href="#3-拼接最大数" class="headerlink" title="3 拼接最大数"></a>3 拼接最大数</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/048.6bvg2v7uuj40.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/create-maximum-number/">https://leetcode.cn/problems/create-maximum-number/</a></p><h3 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h3><p>和第一道题类似，只不不过这一次是两个数组，而不是一个，并且是求最大数。</p><p>最大最小是无关紧要的，关键在于是两个数组，并且要求从两个数组选取的元素个数加起来一共是 k。</p><p>然而在一个数组中取 k 个数字，并保持其最小（或者最大），我们已经会了。但是如果问题扩展到两个，会有什么变化呢？</p><p>实际上，问题本质并没有发生变化。 假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 &#x3D; k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。</p><p>假如 k1 和 k2 个数字，已经取出来了。那么剩下要做的就是将这个长度分别为 k1 和 k2 的数字，合并成一个长度为 k 的数组合并成一个最大的数组。</p><p>以题目的 nums1 &#x3D; [3, 4, 6, 5] nums2 &#x3D; [9, 1, 2, 5, 8, 3] k &#x3D; 5 为例。 假如我们从 num1 中取出 1 个数字，那么就要从 nums2 中取出 4 个数字。</p><p>运用第一题的方法，我们计算出应该取 nums1 的 [6]，并取 nums2 的 [9,5,8,3]。 如何将 [6] 和 [9,5,8,3]，使得数字尽可能大，并且保持相对位置不变呢？</p><p>实际上这个过程有点类似归并排序中的治，而上面我们分别计算 num1 和 num2 的最大数的过程类似归并排序中的分。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/049.58yaxtonyxs0.webp#pic_center" width = 48%><p>我们将从 num1 中挑选的 k1 个数组成的数组称之为 A，将从 num2 中挑选的 k2 个数组成的数组称之为 B，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, B</span>):</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">        bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">        ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">        bigger.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这里需要说明一下。 在很多编程语言中：如果 A 和 B 是两个数组，当前仅当 A 的首个元素字典序大于 B 的首个元素，A &gt; B 返回 true，否则返回 false。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">B = [<span class="number">2</span>]</span><br><span class="line">A &lt; B <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A &lt; B <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>以合并 [6] 和 [9,5,8,3] 为例，图解过程如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/050.3pp1a4yjzpe0.webp#pic_center" width = 36%><p>具体算法：</p><ul><li>从 nums1 中 取 $min(i, len(nums1))$个数形成新的数组 A（取的逻辑同第一题），其中 $i$ 等于 0,1,2, … k。</li><li>从 nums2 中 对应取 $min(j, len(nums2))$ 个数形成新的数组 B（取的逻辑同第一题），其中 $j$ 等于 $k - i$。</li><li>将 A 和 B 按照上面的 merge 方法合并</li></ul><p>上面我们暴力了 k 种组合情况，我们只需要将 k 种情况取出最大值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumber</span>(<span class="params">self, nums1, nums2, k</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pick_max</span>(<span class="params">nums, k</span>):</span><br><span class="line">            stack = []</span><br><span class="line">            drop = <span class="built_in">len</span>(nums) - k</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    drop -= <span class="number">1</span></span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">return</span> stack[:k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, B</span>):</span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">                bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">                ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">                bigger.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(merge(pick_max(nums1, i), pick_max(nums2, k-i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>) <span class="keyword">if</span> i &lt;= <span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i &lt;= <span class="built_in">len</span>(nums2))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/051.5bcgk06xnyc0.gif#pic_center" width = 48%><p><strong>小结</strong></p><p>这四道题都是删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这四个题目应该都可以轻松解决。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>不用字符的最小子序列：<a href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solutions/290204/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-6/">https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solutions/290204/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-6/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;移掉 K 位数字、去除重复字母、拼接最大数这三道题目都是同一套路，即删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这三道题目应该都可以轻松解决。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="单调栈" scheme="https://qxienote.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="贪心算法" scheme="https://qxienote.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（七）-- LC[53]&amp;[152] 最大子数组之和与乘积最大子数组</title>
    <link href="https://qxienote.com/article/745d3169.html"/>
    <id>https://qxienote.com/article/745d3169.html</id>
    <published>2023-06-17T03:08:29.000Z</published>
    <updated>2023-06-17T09:19:32.693Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要以解决最大子数组之和与乘积，详细分析动态规划的思考过程，同时也分析暴力法、贪心算法和分治法如何使用</p><span id="more"></span><h2 id="1-最大子数组之和"><a href="#1-最大子数组之和" class="headerlink" title="1 最大子数组之和"></a>1 最大子数组之和</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.6642xks3o5c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p><strong>1. 暴力法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            sum_sub_array = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">                sum_sub_array += nums[j]</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, sum_sub_array)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.79jjdyimrrw0.gif#pic_center" width = 48%><p><strong>2. 动态规划</strong></p><p><strong>关键 1：理解题意</strong></p><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><p><strong>关键 2：如何定义子问题（如何定义状态）</strong></p><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><ul><li>子问题 1：经过 −2 的连续子数组的最大和是多少；</li><li>子问题 2：经过 1 的连续子数组的最大和是多少；</li><li>子问题 3：经过 −3 的连续子数组的最大和是多少；</li><li>子问题 4：经过 4 的连续子数组的最大和是多少；</li><li>子问题 5：经过 −1 的连续子数组的最大和是多少；</li><li>子问题 6：经过 2 的连续子数组的最大和是多少；</li><li>子问题 7：经过 1 的连续子数组的最大和是多少；</li><li>子问题 8：经过 −5 的连续子数组的最大和是多少；</li><li>子问题 9：经过 4 的连续子数组的最大和是多少。</li></ul><p>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 −3 的连续子数组的最大和是多少。</p><p>「经过 −3 的连续子数组」我们任意举出几个：</p><ul><li>[-2,1,-3,4] ，−3 是这个连续子数组的第 3 个元素；</li><li>[1,-3,4,-1] ，−3 是这个连续子数组的第 2 个元素；</li><li>……</li></ul><p>我们不确定的是：−3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><ul><li>子问题 1：以 −2 结尾的连续子数组的最大和是多少；</li><li>子问题 2：以 1 结尾的连续子数组的最大和是多少；</li><li>子问题 3：以 −3 结尾的连续子数组的最大和是多少；</li><li>子问题 4：以 4 结尾的连续子数组的最大和是多少；</li><li>子问题 5：以 −1 结尾的连续子数组的最大和是多少；</li><li>子问题 6：以 2 结尾的连续子数组的最大和是多少；</li><li>子问题 7：以 1 结尾的连续子数组的最大和是多少；</li><li>子问题 8：以 −5 结尾的连续子数组的最大和是多少；</li><li>子问题 9：以 4 结尾的连续子数组的最大和是多少。</li></ul><p>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><ul><li>子问题 1：以 −2 结尾的连续子数组的最大和是多少；<br>以 −2 结尾的连续子数组是 [-2]，因此最大和就是 −2。</li><li>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。$-2 + 1 &#x3D; -1 &lt; 1$，因此「子问题 2」 的答案是 1。</li></ul><p>大家发现了吗，如果编号为 $i$ 的子问题的结果是负数或者 0 ，那么编号为 $i + 1$ 的子问题就可以把编号为 $i$ 的子问题的结果舍弃掉（这里 $i$ 为整数，最小值为 1 ，最大值为 8），这是因为：</p><ul><li>一个数 a 加上负数的结果比 a 更小；</li><li>一个数 a 加上 0 的结果不会比 a 更大；</li><li>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 $i + 1$ 的答案就是以 nums[i] 结尾的那个数。</li></ul><p>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><p><strong>定义状态（定义子问题）</strong><br>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。<br>说明：「结尾」和「连续」是关键字。</p><p><strong>状态转移方程（描述子问题之间的联系）</strong><br>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 $nums[i-1]$ 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 $dp[i] &#x3D; dp[i - 1] + nums[i]$。</p><p>可是 $dp[i-1]$ 有可能是负数，于是分类讨论：</p><ul><li>如果 $dp[i - 1] &gt; 0$，那么可以把 nums[i] 直接接在 $dp[i - 1]$ 表示的那个数组的后面，得到和更大的连续子数组；</li><li>如果 $dp[i - 1] &lt;&#x3D; 0$，那么 nums[i] 加上前面的数 $dp[i - 1]$ 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</li></ul><p>以上两种情况的最大值就是 dp[i] 的值，写出如下状态转移方程：</p><p>$$<br>dp[i] &#x3D;<br>\begin{cases}<br>dp[i - 1] + nums[i], &amp; if \quad dp[i - 1] &gt; 0 \<br>nums[i], &amp; if \quad dp[i - 1] \le 0<br>\end{cases}$$<br>​<br>记为「状态转移方程 1」。</p><p>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：</p><p>$$dp[i] &#x3D; \max {nums[i],; dp[i - 1] + nums[i]}$$</p><p>记为「状态转移方程 2」。</p><p> <strong>友情提示：</strong> 求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。</p><p><strong>思考初始值</strong><br>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 $dp[0] &#x3D; nums[0]$。</p><p><strong>思考输出</strong><br>注意：<br>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；这个问题的输出是把所有的 <code>dp[0]、dp[1]、……、dp[n - 1]</code> 都看一遍，取最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>进一步优化空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            pre = <span class="built_in">max</span>(nums[i], pre + nums[i])</span><br><span class="line">            res = <span class="built_in">max</span>(res, pre)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.7c33ynjbvxs0.gif#pic_center" width = 48%><p><strong>3. 贪心算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 时间复杂度：O(n), 遍历了一遍</span></span><br><span class="line">        <span class="comment"># 空间复杂度:O(1), 用了2个变量</span></span><br><span class="line">        cur_sum = nums[<span class="number">0</span>]</span><br><span class="line">        max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># range范围是[1，len(nums)) 左闭右开，切记切记</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 若当前指针指向元素之前的和小于0，则丢弃此元素之前的数列(拖后腿的丢弃！！！)</span></span><br><span class="line">            <span class="comment"># 当前和=当前值 与 当前值+之前最大和 的比较中较大的那个、</span></span><br><span class="line">            <span class="comment"># 通俗易懂的理解：看当前这个值和之前数列的和，是否会拖当前这个值的后腿，如果扯后腿了说明没必要把之前的数列放到当前和，如果没有扯后腿则把最新的较大数放在当前和里面</span></span><br><span class="line">            cur_sum = <span class="built_in">max</span>(nums[i], cur_sum+nums[i])</span><br><span class="line">            <span class="comment"># 最大和=当前和 与 最大和 的比较中较大的那个</span></span><br><span class="line">            <span class="comment"># 通俗易懂的理解：当前和就相当于当前潜在的最大和，把原来的最大和 与当前的潜在最大和进行比较，如果当前和比较大，则更换最大和，否则不更换</span></span><br><span class="line">            max_sum = <span class="built_in">max</span>(cur_sum, max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3m0i3ybmmns0.gif#pic_center" width = 48%><p><strong>4. 分治法</strong><br>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p><ul><li>第 1 部分：子区间 $[left, mid]$；</li><li>第 2 部分：子区间 $[mid + 1, right]$；</li><li>第 3 部分：包含子区间 $[mid , mid + 1]$ 的子区间，即 nums[mid] 与 nums[mid + 1] 一定会被选取。<br>对这三个部分求最大值即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.__max_sub_array(nums, <span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__max_sub_array</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.__max_sub_array(nums, left, mid),</span><br><span class="line">                   self.__max_sub_array(nums, mid + <span class="number">1</span>, right),</span><br><span class="line">                   self.__max_cross_array(nums, left, mid, right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__max_cross_array</span>(<span class="params">self, nums, left, mid, right</span>):</span><br><span class="line">        <span class="comment"># 一定包含 nums[mid] 元素的最大连续子数组的和，</span></span><br><span class="line">        <span class="comment"># 思路是看看左边&quot;扩散到底&quot;，得到一个最大数，右边&quot;扩散到底&quot;得到一个最大数</span></span><br><span class="line">        <span class="comment"># 然后再加上中间数</span></span><br><span class="line">        left_sum_max = <span class="number">0</span></span><br><span class="line">        start_left = mid - <span class="number">1</span></span><br><span class="line">        s1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start_left &gt;= left:</span><br><span class="line">            s1 += nums[start_left]</span><br><span class="line">            left_sum_max = <span class="built_in">max</span>(left_sum_max, s1)</span><br><span class="line">            start_left -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        right_sum_max = <span class="number">0</span></span><br><span class="line">        start_right = mid + <span class="number">1</span></span><br><span class="line">        s2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start_right &lt;= right:</span><br><span class="line">            s2 += nums[start_right]</span><br><span class="line">            right_sum_max = <span class="built_in">max</span>(right_sum_max, s2)</span><br><span class="line">            start_right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left_sum_max + nums[mid] + right_sum_max</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.4a1sywzk9og0.gif#pic_center" width = 48%><h2 id="2-乘积最大子数组"><a href="#2-乘积最大子数组" class="headerlink" title="2 乘积最大子数组"></a>2 乘积最大子数组</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.4k1vyb26ul20.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/">https://leetcode.cn/problems/maximum-product-subarray/description/</a></p><h3 id="2-2-求解思路"><a href="#2-2-求解思路" class="headerlink" title="2.2 求解思路"></a>2.2 求解思路</h3><p>如果我们用 $f_{\max}(i)$ 来表示以第 $i$ 个元素结尾的乘积最大子数组的乘积，$a$ 表示输入参数 nums，那么根据前面「53. 最大子序和」的经验，我们很容易推导出这样的状态转移方程：</p><p>$$f_{\max}(i) &#x3D; \max_{i &#x3D; 1}^{n} { f(i - 1) \times a_i, a_i }$$</p><p>它表示以第 $i$ 个元素结尾的乘积最大子数组的乘积可以考虑 $a_i$ 加入前面的 $f_{\max}(i - 1)$ 对应的一段，或者单独成为一段，这里两种情况下取最大值。求出所有的 $f_{\max}(i)$ 之后选取最大的一个作为答案。</p><p> <strong>可是在这里，这样做是错误的。为什么呢？</strong></p><p>因为这里的定义并不满足「最优子结构」。具体地讲，如果 $a &#x3D; { 5, 6, -3, 4, -3 }$，那么此时 $⁡f_{\max}$ 对应的序列是 ${ 5, 30, -3, 4, -3 }$，按照前面的算法我们可以得到答案为 30，即前两个数的乘积，而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个 −3 所对应的 $⁡f_{\max}$ 的值既不是 −3，也不是 $4 \times (-3)$，而是 $5 \times 6 \times (-3) \times 4 \times (-3)$。所以我们得到了一个结论：当前位置的最优解未必是由前一个位置的最优解转移得到的。</p><p>我们可以根据正负性进行分类讨论。</p><p>考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 $f_{\min}(i)$，它表示以第 $i$ 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：</p><p>$$<br>    \begin{aligned}<br>        f_{\max}(i) &amp;&#x3D; \max_{i &#x3D; 1}^{n} { f_{\max}(i - 1) \times a_i, f_{\min}(i - 1) \times a_i, a_i } \<br>        f_{\min}(i) &amp;&#x3D; \min_{i &#x3D; 1}^{n} { f_{\max}(i - 1) \times a_i, f_{\min}(i - 1) \times a_i, a_i }<br>    \end{aligned}<br>$$</p><p>它代表第 $i$ 个元素结尾的乘积最大子数组的乘积 $f_{\max}(i)$，可以考虑把 $a_i$ 加入第 $i - 1$ 个元素结尾的乘积最大或最小的子数组的乘积中，二者加上 $a_i$，$i$ 个元素结尾的乘积最大子数组的乘积。第 $i$ 个元素结尾的乘积最小子数组的乘积 $f_{\min}(i)$ 同理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_dp, min_dp = [nums[<span class="number">0</span>]], [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            max_dp.append(<span class="built_in">max</span>(max_dp[i-<span class="number">1</span>]*nums[i], min_dp[i-<span class="number">1</span>]*nums[i], nums[i]))</span><br><span class="line">            min_dp.append(<span class="built_in">min</span>(max_dp[i-<span class="number">1</span>]*nums[i], min_dp[i-<span class="number">1</span>]*nums[i], nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_dp)</span><br></pre></td></tr></table></figure><p><strong>进一步优化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;动态规划&#x27;&#x27;&#x27;</span></span><br><span class="line">        max_product, min_product, ans = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            max_nums, min_nums = max_product, min_product</span><br><span class="line">            max_product = <span class="built_in">max</span>(max_nums*num, min_nums*num, num)</span><br><span class="line">            min_product = <span class="built_in">min</span>(max_nums*num, min_nums*num, num)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, max_product)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>经典动态规划问题（理解「无后效性」）：<a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?orderBy=most_votes">https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?orderBy=most_votes</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要以解决最大子数组之和与乘积，详细分析动态规划的思考过程，同时也分析暴力法、贪心算法和分治法如何使用&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="贪心算法" scheme="https://qxienote.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="最大子数组" scheme="https://qxienote.com/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
    <category term="分治法" scheme="https://qxienote.com/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（六）-- LC[74]&amp;[240] 搜索二维矩阵矩阵与螺旋矩阵</title>
    <link href="https://qxienote.com/article/1cb8c955.html"/>
    <id>https://qxienote.com/article/1cb8c955.html</id>
    <published>2023-06-17T03:08:12.000Z</published>
    <updated>2023-06-17T09:17:39.639Z</updated>
    
    <content type="html"><![CDATA[<p>本篇分享LeetCode 搜索二维矩阵的两道题目，主要学习二分查找和双指针算法</p><span id="more"></span><h2 id="1-搜索二维矩阵"><a href="#1-搜索二维矩阵" class="headerlink" title="1 搜索二维矩阵"></a>1 搜索二维矩阵</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.bt6mp598usw.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p><strong>方法一：遍历</strong><br>该方法就是遍历查找每个位置，看 target 是否出现。这个方法也能通过本题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="comment"># return any(target in row for row in matrix)</span></span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： $O(M * N)$</li><li>间复杂度：$O(1)$</li></ul><p><strong>方法二：从左下角或者右上角开始查找</strong></p><p>这个方法是利用了矩阵的性质，如果我们从右上角开始遍历：</p><ul><li>如果要搜索的 target 比当前元素大，那么让行增加；</li><li>如果要搜索的 target 比当前元素小，那么让列减小；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row, col = <span class="number">0</span>, cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> matrix[row][col] &lt; target:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(M + N)$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法三：先寻找到所在行</strong></p><p>该方法利用了题目给出的矩阵的性质：每行元素都是单调递增的，并且下一行的元素会比本行更大。所以：</p><p>如果 target 大于这一行的末尾元素，那么 target 一定不在这一行中，只能出现在矩阵的下面的行中。</p><p>那么，假如 $target &lt; matrix[i][N - 1]$ 时，说明 target 可能在本行中出现，而且由于下面各行的元素都大于 $matrix[i][N - 1]$，所以，不可能在下面的行中出现。此时，可以在本行中使用顺序查找，或者二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">if</span> target &gt; matrix[i][N - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> matrix[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： 在行中遍历查找的时间复杂度是：$O(M+N)$；在行中进行二分查找的时间复杂度是 $O(M+log(N))$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法四：两次二分查找</strong><br>这个方法可以说是方法三的改进。在方法三种，我们是先遍历找到 target 在哪一行，然后在该行遍历或者二分查找的 target 。其实也可以先用二分找到 target 所在的行，然后在该行二分找到 target。</p><p>具体做法是，先找到 $matrix[i][0]$ 小于 target 并且 $matrix[i + 1][0] &gt; target$ 的第 $i$ 行，然后在该行内进行二分找到 target。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        col0 = [row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br><span class="line">        target_row = bisect.bisect_right(col0, target) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> target_row &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target_col = bisect.bisect_left(matrix[target_row], target)</span><br><span class="line">        <span class="keyword">if</span> target_col &gt;= N:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> matrix[target_row][target_col] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： $O(log(M) + log(N))$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法五：全局二分</strong></p><p>这个方法，是我们在二维矩阵上进行二分查找，这其实相当于把二维矩阵当做一维来做，要求每一行的最后一个元素小于下一行的第一个元素。</p><p>根据 mid 求出在二维矩阵中的具体位置，然后判断 left 和 right 的移动方式。整体做法和一维数组的二分没有区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right = <span class="number">0</span>, M * N - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            cur = matrix[mid // N][mid % N]</span><br><span class="line">            <span class="keyword">if</span> cur == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度： $O(log(M∗N))$</li><li>空间复杂度：$O(1)$</li></ul><p><strong>方法六：reshape成一维数组</strong></p><p>如果用python刷题，在leetcode中是支持使用 numpy 的，可以把 matrix 成一维有序的数组，然后按照一维数组去操作查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        matrix = np.reshape(matrix, [<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> target <span class="keyword">in</span> matrix</span><br></pre></td></tr></table></figure><hr><h2 id="2-搜索二维矩阵Ⅱ"><a href="#2-搜索二维矩阵Ⅱ" class="headerlink" title="2 搜索二维矩阵Ⅱ"></a>2 搜索二维矩阵Ⅱ</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.1bsh7ouswcg0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></p><h3 id="2-2-求解思路"><a href="#2-2-求解思路" class="headerlink" title="2.2 求解思路"></a>2.2 求解思路</h3><p><strong>方法一：直接查找</strong></p><p>直接遍历整个矩阵 $\textit{matrix}$，判断 $\textit{target}$ 是否出现即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> row:</span><br><span class="line">                <span class="keyword">if</span> element == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>方法二：减而治之</strong></p><p>(1) 选择左下角为起点，以下展示了「减治」的过程</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.5qxia2tpa340.gif#pic_center" width = 48%><p>总结出搜索的规律是：</p><ul><li>如果当前数比目标元素小，当前列就不可能存在目标值，「指针」就向右移一格（纵坐标加 1）；</li><li>如果当前数比目标元素大，当前行就不可能存在目标值，「指针」就向上移一格（横坐标减 1）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 起点：左下角</span></span><br><span class="line">        x, y = rows-<span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不越界的条件是：行大于等于 0，列小于 cols</span></span><br><span class="line">        <span class="keyword">while</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; cols:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &gt; target:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &lt; target:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：$O(M + N)$，$M$是这个矩阵的行数，$N$是这个矩阵的列数，我们看到，这种算法是不回头的，至多走 $M + N$ 步就能搜索到目标数值，或者判定目标数值在矩阵中不存在；</li><li>空间复杂度：$O(1)$，算法使用了常数个变量。</li></ul><p>(2) 如果选择右上角为起点，以下展示了「减治」的过程</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.ujgfc06gvt.gif#pic_center" width = 48%><p>总结出「搜索」的规律是：</p><ul><li>如果当前数比目标元素大，当前列就不可能存在目标值，「指针』就向左移一格（纵坐标减 1）；</li><li>如果当前数比目标元素小，当前行就不可能存在目标值，「指针」就向下移一格（横坐标加 1）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 起点：右上</span></span><br><span class="line">        x, y = <span class="number">0</span>, cols-<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不越界的条件是：行小于 rows，列大于等于 0</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; rows <span class="keyword">and</span> y &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &gt; target:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &lt; target:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>方法三：二分查找</strong></p><p>由于矩阵 $\textit{matrix}$ 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 $\textit{target}$ 是否在该行中，从而判断 $\textit{target}$ 是否出现。</p><p><strong>(1) 详细版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binay_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">            l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">if</span> line[<span class="number">0</span>] &lt;= target <span class="keyword">and</span> line[cols - <span class="number">1</span>] &gt;= target:</span><br><span class="line">                <span class="keyword">if</span> binay_search(line, target):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>(2) 简化版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            ind = bisect.bisect_left(row, target)</span><br><span class="line">            <span class="keyword">if</span> ind &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="keyword">and</span> row[ind] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \log n)$。对一行使用二分查找的时间复杂度为 $O(\log n)$，最多需要进行 $m$ 次二分查找。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>减而治之、二分查找：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/14389/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/?orderBy=most_votes">https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/14389/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/?orderBy=most_votes</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇分享LeetCode 搜索二维矩阵的两道题目，主要学习二分查找和双指针算法&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="双指针" scheme="https://qxienote.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分法" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（五）-- LC[48]&amp;[54]&amp;[59] 旋转矩阵与螺旋矩阵</title>
    <link href="https://qxienote.com/article/bee25f2c.html"/>
    <id>https://qxienote.com/article/bee25f2c.html</id>
    <published>2023-06-17T03:07:00.000Z</published>
    <updated>2023-06-17T09:17:39.636Z</updated>
    
    <content type="html"><![CDATA[<p>二维数组的遍历也属于常考题，思路不难，但要考虑边界，本篇就带你走进矩阵按形状和方向分别遍历</p><span id="more"></span><h2 id="1-二维数组遍历"><a href="#1-二维数组遍历" class="headerlink" title="1 二维数组遍历"></a>1 二维数组遍历</h2><p><strong>题库列表</strong></p><blockquote><ul><li><p><a href="https://leetcode.cn/problems/rotate-image/" target="_blank">48. 旋转图像</a> </p><li><p><a href="https://leetcode.cn/problems/spiral-matrix/" target="_blank">54. 螺旋矩阵</a></p><li><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank">59. 螺旋矩阵Ⅱ</a></p></li></ul></blockquote> <h3 id="1-1-旋转图像"><a href="#1-1-旋转图像" class="headerlink" title="1.1 旋转图像"></a>1.1 旋转图像</h3><h4 id="1-1-1-题目描述"><a href="#1-1-1-题目描述" class="headerlink" title="1.1.1 题目描述"></a>1.1.1 题目描述</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/012.6idldwe8z6s0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p><h4 id="1-1-2-辅助矩阵"><a href="#1-1-2-辅助矩阵" class="headerlink" title="1.1.2 辅助矩阵"></a>1.1.2 辅助矩阵</h4><p>如下图所示，矩阵顺时针旋转 $90^{\circ}$ 后，可找到以下规律：</p><ul><li>「第 $i$ 行」元素旋转到「第 $n−1−i$ 列」元素；</li><li>「第 $j$ 列」元素旋转到「第 $j$ 行」元素；</li></ul><p>因此，对于矩阵任意第 $i$ 行、第 $j$ 列元素 $matrix[i][j]$，矩阵旋转 $90^{\circ}$ 后「元素位置旋转公式」为：</p><p>$$\begin{aligned} matrix[i][j] &amp; \rightarrow matrix[j][n - 1 - i] \<br>原索引位置 &amp; \rightarrow 旋转后索引位置 \end{aligned}$$</p><p>​<img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/013.7ij6tw1obi80.webp#pic_center" width = 48%></p><p>根据以上「元素旋转公式」，考虑遍历矩阵，将各元素依次写入到旋转后的索引位置。但仍存在问题：在写入一个元素 $matrix[i][j] \rightarrow matrix[j][n - 1 - i]$ 后，原矩阵元素 $matrix[j][n - 1 - i]$ 就会被覆盖（即丢失），而此丢失的元素就无法被写入到旋转后的索引位置了。</p><p>为解决此问题，考虑借助一个「辅助矩阵」暂存原矩阵，通过遍历辅助矩阵所有元素，将各元素填入「原矩阵」旋转后的新索引位置即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 深拷贝 matrix -&gt; tmp</span></span><br><span class="line">        tmp = copy.deepcopy(matrix)</span><br><span class="line">        <span class="comment"># 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp[i][j]</span><br></pre></td></tr></table></figure><p>遍历矩阵所有元素的时间复杂度为 $O(N^2)$；由于借助了一个辅助矩阵，空间复杂度为 $O(N^2)$。</p><h4 id="1-1-3-原地修改"><a href="#1-1-3-原地修改" class="headerlink" title="1.1.3 原地修改"></a>1.1.3 原地修改</h4><p>考虑不借助辅助矩阵，通过在原矩阵中直接「原地修改」，实现空间复杂度 O(1)O(1)O(1) 的解法。</p><p>以位于矩阵四个角点的元素为例，设矩阵左上角元素 $A$、右上角元素 $B$、右下角元素 $C$、左下角元素 $D$。矩阵旋转 $90^{\circ}$ 后，相当于依次先后执行 $D \rightarrow A$，$C \rightarrow D$，$B \rightarrow C$，$A \rightarrow B$ 修改元素，即如下「首尾相接」的元素旋转操作：<br>$$A \leftarrow D \leftarrow C \leftarrow B \leftarrow A$$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/014.4r7gwd57gow0.webp#pic_center" width = 48%><p>如上图所示，由于第 $1$ 步 $D \rightarrow A$ 已经将 $A$ 覆盖（导致 $A$ 丢失），此丢失导致最后第 $4$ 步 $A \rightarrow B$ 无法赋值。为解决此问题，考虑借助一个「辅助变量 tmp」预先存储 $A$，此时的旋转操作变为：</p><p>$$暂存 tmp &#x3D; A \<br>A \leftarrow D \leftarrow C \leftarrow B \leftarrow tmp$$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/015.15fcoqfaesao.webp#pic_center" width = 48%><p>如上图所示，一轮可以完成矩阵 4 个元素的旋转。因而，只要分别以矩阵左上角 $\frac{1}{4}$ 的各元素为起始点执行以上旋转操作，即可完整实现矩阵旋转。</p><p>具体来看，当矩阵大小 $n$ 为偶数时，取前 $\frac{n}{2}$ 行、前 $\frac{n}{2}$ 列的元素为起始点；当矩阵大小 $n$ 为奇数时，取前 $\frac{n}{2}$ 行、前 $\frac{n + 1}{2}$ 列的元素为起始点。</p><p>令 $matrix[i][j]&#x3D;A$，根据文章开头的元素旋转公式，可推导得适用于任意起始点的元素旋转操作：</p><p>$$<br>暂存 tmp &#x3D; matrix[i][j] \<br>matrix[i][j] \leftarrow matrix[n - 1 - j][i] \leftarrow matrix[n - 1 - i][n - 1 - j] \leftarrow matrix[j][n - 1 - i] \leftarrow tmp $$</p><p>如下图所示，为示例矩阵的算法执行流程。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/016.399yf7ns71s0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 设矩阵行列数为 n</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 起始点范围为 0 &lt;= i &lt; n // 2 , 0 &lt;= j &lt; (n + 1) // 2</span></span><br><span class="line">        <span class="comment"># 其中 &#x27;//&#x27; 为整数除法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 暂存 A 至 tmp</span></span><br><span class="line">                tmp = matrix[i][j]</span><br><span class="line">                <span class="comment"># 元素旋转操作 A &lt;- D &lt;- C &lt;- B &lt;- tmp</span></span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i]</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j]</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i]</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 $O(N^2)$： 其中 $N$ 为输入矩阵的行（列）数。需要将矩阵中每个元素旋转到新的位置，即对矩阵所有元素操作一次，使用 $O(N^2)$ 时间。</li><li>空间复杂度 $O(1)$： 临时变量 $tmp$ 使用常数大小的额外空间。值得注意，当循环中进入下轮迭代，上轮迭代初始化的 $tmp$ 占用的内存就会被自动释放，因此无累计使用空间。</li></ul><h4 id="1-1-4-对角线反转，左右翻转"><a href="#1-1-4-对角线反转，左右翻转" class="headerlink" title="1.1.4 对角线反转，左右翻转"></a>1.1.4 对角线反转，左右翻转</h4><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/017.32d1erzigbm0.webp#pic_left" width = "20%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/018.3c4k05krrnw0.webp#pic_left"  width = "24%"></center></p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/019.qwpeb23ebi8.webp#pic_left" width = "24%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/020.5d64vfvqwis0.webp#pic_left"  width = "24%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 注意这里j的范围 如果j的范围也是0到n-1那么会出现交换后又交换回来 等于没有交换</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> matrix:</span><br><span class="line">            line.reverse()      <span class="comment"># 左右翻转</span></span><br></pre></td></tr></table></figure><h4 id="1-1-5-上下反转，对角线反转"><a href="#1-1-5-上下反转，对角线反转" class="headerlink" title="1.1.5 上下反转，对角线反转"></a>1.1.5 上下反转，对角线反转</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/021.734u593n8qw0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        matrix[:] = matrix[::-<span class="number">1</span>]        <span class="comment"># 上下反转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure><h3 id="1-2-螺旋矩阵"><a href="#1-2-螺旋矩阵" class="headerlink" title="1.2 螺旋矩阵"></a>1.2 螺旋矩阵</h3><h4 id="1-2-1-题目描述"><a href="#1-2-1-题目描述" class="headerlink" title="1.2.1 题目描述"></a>1.2.1 题目描述</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/022.86mcp8c7tfs.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p><h4 id="1-2-2-思路分析"><a href="#1-2-2-思路分析" class="headerlink" title="1.2.2 思路分析"></a>1.2.2 思路分析</h4><p><strong>1. 按照「形状」进行模拟</strong><br>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/023.1o2he25jd0w0.webp#pic_center" width = 30%><p>随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/024.3d7g5uixsgq0.webp#pic_center" width = 30%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    upper_bound = <span class="number">0</span></span><br><span class="line">    lower_bound = <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">    left_bound = <span class="number">0</span></span><br><span class="line">    right_bound = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># res.length == m * n 则遍历完整个数组</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt; m * n:</span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在顶部从左向右遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left_bound, right_bound + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[upper_bound][j])</span><br><span class="line">            <span class="comment"># 上边界下移</span></span><br><span class="line">            upper_bound += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在右侧从上向下遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(upper_bound, lower_bound + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right_bound])</span><br><span class="line">            <span class="comment"># 右边界左移</span></span><br><span class="line">            right_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在底部从右向左遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right_bound, left_bound - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[lower_bound][j])</span><br><span class="line">            <span class="comment"># 下边界上移</span></span><br><span class="line">            lower_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在左侧从下向上遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lower_bound, upper_bound - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left_bound])</span><br><span class="line">            <span class="comment"># 左边界右移</span></span><br><span class="line">            left_bound += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>2. 按照「方向」进行模拟</strong></p><p><strong>(1) 起始位置</strong><br>螺旋矩阵的遍历起点是矩阵的左上角，也就是 <code>(0, 0)</code> 位置。</p><p><strong>(2) 移动方向</strong><br>起始位置的下一个移动方向是向右。在遍历的过程中，移动方向是固定的：<br>$$右→，下↓，左←，上↑$$</p><p>移动方向是按照上面的顺序循环进行的。每次当移动到了边界，才会更改方向。但边界并不是固定的，请看下面分析。</p><p><strong>(3) 边界</strong><br>本题的边界是最大的难点，因为是随着遍历的过程而变化的。螺旋遍历的时候，已经遍历的数字不能再次遍历，所以边界会越来越小。</p><p>规则是：<font color=#9900CC><strong>如果当前行（列）遍历结束之后，就需要把这一行（列）的边界向内移动一格。</strong></font></p><p>以下面的图为例，up, down, left, right 分别表示四个方向的边界，初始时分别指向矩阵的四个边界。如果我们把第一行遍历结束（遍历到了右边界），此时需要修改新的移动方向为向下、并且把上边界 up 下移一格，即从 旧 up 位置移动到 新 up 位置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/025.6usmccgvppo0.webp#pic_center" width = 36%><p>当绕了一圈后，从下向上走到 新 up 边界的时候，此时需要修改新的移动方向为向右、并且把左边界 left 下移一格，即从 旧 left 位置移动到 新 left 位置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/026.4eiznf5r6xa0.webp#pic_center" width = 36%><p>由此可见，根据维护的四个方向的边界，就知道什么时候更改移动方向了。</p><p><strong>(4) 结束条件</strong><br>螺旋遍历的结束条件是所有的位置都被遍历到。</p><p><strong>代码实现：</strong></p><ul><li>up, down, left, right 分别表示四个方向的边界。</li><li>x, y 表示当前位置。</li><li>dirs 分别表示移动方向是 右、下、左、上 。</li><li>cur_d 表示当前的移动方向的下标，dirs[cur_d] 就是下一个方向需要怎么修改 x, y。</li><li><code>cur_d == 0 and y == right</code> 表示当前的移动方向是向右，并且到达了右边界，此时将移动方向更改为向下，并且上边界 up 向下移动一格。</li><li>结束条件是结果数组 res 的元素个数能与 matrix 中的元素个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> []</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, M - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        cur_d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) != M * N:</span><br><span class="line">            res.append(matrix[x][y])</span><br><span class="line">            <span class="keyword">if</span> cur_d == <span class="number">0</span> <span class="keyword">and</span> y == right:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">1</span> <span class="keyword">and</span> x == down:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">2</span> <span class="keyword">and</span> y == left:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">3</span> <span class="keyword">and</span> x == up:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            cur_d %= <span class="number">4</span></span><br><span class="line">            x += dirs[cur_d][<span class="number">0</span>]</span><br><span class="line">            y += dirs[cur_d][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1-3-螺旋矩阵Ⅱ"><a href="#1-3-螺旋矩阵Ⅱ" class="headerlink" title="1.3 螺旋矩阵Ⅱ"></a>1.3 螺旋矩阵Ⅱ</h3><h4 id="1-3-1-题目描述"><a href="#1-3-1-题目描述" class="headerlink" title="1.3.1 题目描述"></a>1.3.1 题目描述</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/027.5c98xx2b5bk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><h4 id="1-3-2-思路分析"><a href="#1-3-2-思路分析" class="headerlink" title="1.3.2 思路分析"></a>1.3.2 思路分析</h4><p><strong>1. 按照「形状」进行填充</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/028.41veaylr6u20.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    upper_bound, lower_bound = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    left_bound, right_bound = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 需要填入矩阵的数字</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num &lt;= n * n:</span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在顶部从左向右遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left_bound, right_bound+<span class="number">1</span>):</span><br><span class="line">                matrix[upper_bound][j] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 上边界下移</span></span><br><span class="line">            upper_bound += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在右侧从上向下遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(upper_bound, lower_bound+<span class="number">1</span>):</span><br><span class="line">                matrix[i][right_bound] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右边界左移</span></span><br><span class="line">            right_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> upper_bound &lt;= lower_bound:</span><br><span class="line">            <span class="comment"># 在底部从右向左遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right_bound, left_bound-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[lower_bound][j] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 下边界上移</span></span><br><span class="line">            lower_bound -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_bound &lt;= right_bound:</span><br><span class="line">            <span class="comment"># 在左侧从下向上遍历</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lower_bound, upper_bound-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[i][left_bound] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左边界右移</span></span><br><span class="line">            left_bound += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><p><strong>2. 按照「方向」进行填充</strong></p><p><strong>(1) 四个变量标记边界</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        cur_d = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count != n * n:</span><br><span class="line">            res[x][y] = count + <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_d == <span class="number">0</span> <span class="keyword">and</span> y == right:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">1</span> <span class="keyword">and</span> x == down:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">2</span> <span class="keyword">and</span> y == left:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_d == <span class="number">3</span> <span class="keyword">and</span> x == up:</span><br><span class="line">                cur_d += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            cur_d %= <span class="number">4</span></span><br><span class="line">            x += dirs[cur_d][<span class="number">0</span>]</span><br><span class="line">            y += dirs[cur_d][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>(2) 使用非 0 数字标记边界</strong></p><p>我们在遍历的过程中，需要依次放入 $1-N^2$ 数字，如果我们把结果数组的所有位置初始化为 0，那么非 0 的位置就代表我们已经遍历过了，相当于边界。</p><p>当遍历到数组的原始边界或者撞到了非 0 的数字，表示当前方向已经遍历到了边界，需要更改移动方向。这个做法的优点是省去了维护 4 个变量表示的边界。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.2orkop8wma40.webp#pic_center" width = 36%><p>初始移动方向是向右，如果遇到了数组边界或者遇到了非 0 的数字，那么就要转动方向。转向的方法是 <code>cur_d = (cur_d + 1) % 4</code>，cur_d 表示了当前的方向是 directions 中的哪个，顺序依次是 右、下、左、上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n</span>):</span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur_d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count != n * n:</span><br><span class="line">            res[x][y] = count + <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            dx, dy = directions[cur_d][<span class="number">0</span>], directions[cur_d][<span class="number">1</span>]</span><br><span class="line">            newx, newy = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> newx &lt; <span class="number">0</span> <span class="keyword">or</span> newx &gt;= n <span class="keyword">or</span> newy &lt; <span class="number">0</span> <span class="keyword">or</span> newy &gt;= n <span class="keyword">or</span> res[newx][newy] != <span class="number">0</span>:</span><br><span class="line">                cur_d = (cur_d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">                dx, dy = directions[cur_d][<span class="number">0</span>], directions[cur_d][<span class="number">1</span>]</span><br><span class="line">            x, y = x + dx, y + dy</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>旋转图像（辅助矩阵 &#x2F; 原地修改，清晰图解）：<a href="https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/">https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/</a></li><li>矩阵遍历问题的四部曲：<a href="https://leetcode.cn/problems/spiral-matrix-ii/solutions/659234/ju-zhen-bian-li-wen-ti-de-si-bu-qu-by-fu-sr5c/">https://leetcode.cn/problems/spiral-matrix-ii/solutions/659234/ju-zhen-bian-li-wen-ti-de-si-bu-qu-by-fu-sr5c/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二维数组的遍历也属于常考题，思路不难，但要考虑边界，本篇就带你走进矩阵按形状和方向分别遍历&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="旋转矩阵" scheme="https://qxienote.com/tags/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    
    <category term="螺旋矩阵" scheme="https://qxienote.com/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>数组（四）-- LC[1574] 删除最短的子数组使剩余数组有序</title>
    <link href="https://qxienote.com/article/830ec474.html"/>
    <id>https://qxienote.com/article/830ec474.html</id>
    <published>2023-06-17T02:21:21.000Z</published>
    <updated>2023-06-17T03:13:10.485Z</updated>
    
    <content type="html"><![CDATA[<p>LC[1574] 删除最短的子数组使剩余数组有序，通过题目深入理解滑动窗口的思想</p><span id="more"></span><h2 id="1-删除最短的子数组使剩余数组有序"><a href="#1-删除最短的子数组使剩余数组有序" class="headerlink" title="1  删除最短的子数组使剩余数组有序"></a>1  删除最短的子数组使剩余数组有序</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/009.1b99zv7n25og.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/</a></p><h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><p><strong>1. 枚举左端点，移动右端点</strong></p><p>核心思路：枚举 $\textit{left}$，增大 $\textit{right}$ 直到 $\textit{arr}[\textit{left}]\le\textit{arr}[\textit{right}]$，此时更新子数组长度的最小值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/010.2wx6zs4lrs60.gif#pic_center" width = 36%><p><strong>解疑答惑：</strong></p><p>问：为什么枚举一个新的 $\textit{left}$ 时，$\textit{right}$ 不会往左移？或者说，是否需要再次枚举之前枚举过的 $\textit{arr}[\textit{right}]$？</p><p>答：在向右移动时，由于 $\textit{arr}[\textit{left}]$ 和 $\textit{arr}[\textit{right}]$ 都是非递减的，所以 $\textit{right}$ 左侧之前枚举过的元素必然小于 $\textit{arr}[\textit{left}]$，无需再次枚举。这也是本题可以使用同向双指针（不定长滑动窗口）的前提。</p><p>问：在计算子数组长度时，我经常分不清下标是否要 +1 或 −1，请问如何解决？</p><p>答：第一，时刻把握住 $\textit{left}$ 和 $\textit{right}$ 的含义，对于本题来说是开区间 $(\textit{left},\textit{right})$，这两个指针指向的元素不能删除。第二，可以代入一些数据来验证，比如代入 $\textit{left}&#x3D;1, \textit{right}&#x3D;3$，此时只需要删除一个 $\textit{arr}[2]$，所以公式 $\textit{right}-\textit{left}-1$ 才是符合要求的。</p><p>问：为什么不用判断$\textit{left}&lt;\textit{right}$，难道不会出现 $\textit{left}\ge\textit{right}$ 的情况吗？</p><p>答：由于提前判断了 $\textit{arr}$ 是非递减数组的情况，后面的循环 $\textit{left}$ 必定小于 $\textit{right}$。反证：如果某个时刻 $\textit{left}$ 达到了 $\textit{right}$，就说明整个数组是有序的，但这种情况已经提前判断了。</p><p>问：能不能先把 $\textit{left}$ 的最大值算出来，然后再去枚举 $\textit{left}$ 或 $\textit{right}$？</p><p>答：可以。根据对称性，这种做法和先算 $\textit{right}$ 的最小值的做法是一样的，只不过枚举的顺序相反而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> arr[right - <span class="number">1</span>] &lt;= arr[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span>:  <span class="comment"># arr 已经是非递减数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 此时 arr[right-1] &gt; arr[right]</span></span><br><span class="line">        ans = right  <span class="comment"># 删除 arr[:right]</span></span><br><span class="line">        left = <span class="number">0</span>  <span class="comment"># 枚举 left</span></span><br><span class="line">        <span class="keyword">while</span> left == <span class="number">0</span> <span class="keyword">or</span> arr[left - <span class="number">1</span>] &lt;= arr[left]:</span><br><span class="line">            <span class="keyword">while</span> right &lt; n <span class="keyword">and</span> arr[right] &lt; arr[left]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时 arr[left] &lt;= arr[right]，删除 arr[left+1:right]</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, right - left - <span class="number">1</span>)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为 $\textit{nums}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{right}$ 加一的总执行次数不会超过 $n$ 次，所以总的时间复杂度为 $O(n)$。</li><li>空间复杂度：$O(1)$，仅用到若干额外变量。</li></ul><p><strong>2. 枚举右端点，移动左端点</strong></p><p>核心思路：枚举 $\textit{right}$，增大 $\textit{left}$ 直到 $\textit{arr}[\textit{left}]&gt;\textit{arr}[\textit{right}]$。在增大过程中去更新子数组长度的最小值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/011.1pr1dt5dsy0w.gif#pic_center" width = 36%><p>问：为什么枚举一个新的 $\textit{right}$ 时，$\textit{left}$ 不会往左移？或者说，是否需要再次枚举之前枚举过的 $\textit{arr}[\textit{left}]$？</p><p>答：在向右移动时，由于 $\textit{arr}[\textit{left}]$ 和 $\textit{arr}[\textit{right}]$ 都是非递减的，所以 $\textit{left}$ 左侧之前枚举过的元素必然小于等于 $\textit{arr}[\textit{right}]$，由于这样的子数组长度更长，无需再次枚举。这也是本题可以使用同向双指针（不定长滑动窗口）的前提。</p><p>问：为什么循环一定会结束？</p><p>答：代码中提前判断了 $\textit{arr}$ 已经是非递减数组的情况，所以后面的循环一定存在 $\textit{left}$，使得 $\textit{arr}[\textit{left}]&gt;\textit{arr}[\textit{left}+1]$ 成立。</p><p>注：最坏情况下，当 $\textit{right}&#x3D;n$ 时才会去移动 $\textit{left}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> arr[right - <span class="number">1</span>] &lt;= arr[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span>:  <span class="comment"># arr 已经是非递减数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 此时 arr[right-1] &gt; arr[right]</span></span><br><span class="line">        ans = right  <span class="comment"># 删除 arr[:right]</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 枚举 right</span></span><br><span class="line">            <span class="keyword">while</span> right == n <span class="keyword">or</span> arr[left] &lt;= arr[right]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right - left - <span class="number">1</span>)  <span class="comment"># 删除 arr[left+1:right]</span></span><br><span class="line">                <span class="keyword">if</span> arr[left] &gt; arr[left + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为 $\textit{nums}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{left}$ 加一的总执行次数不会超过 $n$ 次，所以总的时间复杂度为 $O(n)$。</li><li>空间复杂度：$O(1)$，仅用到若干额外变量。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>删除最短的子数组使剩余数组有序：<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/2189149/dong-hua-yi-xie-jiu-cuo-liang-chong-xie-iijwz/">https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/2189149/dong-hua-yi-xie-jiu-cuo-liang-chong-xie-iijwz/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LC[1574] 删除最短的子数组使剩余数组有序，通过题目深入理解滑动窗口的思想&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="滑动窗口" scheme="https://qxienote.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="子数组" scheme="https://qxienote.com/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
    <category term="枚举法" scheme="https://qxienote.com/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组（三）-- LC[370]&amp;[1109]&amp;[1094] 区间加法</title>
    <link href="https://qxienote.com/article/29a8c889.html"/>
    <id>https://qxienote.com/article/29a8c889.html</id>
    <published>2023-06-17T02:20:51.000Z</published>
    <updated>2023-06-17T03:12:35.973Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要以LeetCode[370]区间加法、LeetCode[1109]航班预定统计、LeetCode[1094]拼车为例，讲解差分数组的思想和应用。</p><span id="more"></span><h2 id="1-区间加法"><a href="#1-区间加法" class="headerlink" title="1 区间加法"></a>1 区间加法</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/001.186b44op9p9c.webp#pic_center" width = 64%><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p>常规的思路很容易，给区间 nums[i: j] 加上 val，那就⼀个 for 循环给它们都加上呗，但这种思路的时间复杂度是 $O(N)$，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。</p><p>这⾥就需要差分数组的技巧，差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。</p><p>差分数组的性质是：当我们希望对原数组的某一个区间[i, j]施加一个增量 inc 时，差分数组d对应的变化是：d[i]增加inc，d[j+1]减少inc，并且这种操作是可以叠加的。</p><p>下面举个例子：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.o2smmp2nbps.webp#pic_center" width = 64%><p>差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。</p><p>还是上面那个表里的例子，我们需要进行以下操作：</p><ol><li>将区间[1，4]的数值全部加上3</li><li>将区间[3，5]的数值全部减去5</li></ol><p>很简单对吧，你可以进行枚举。但是如果给你的数据量是1e5，操作量1e5，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。</p><p>其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。</p><p>利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.26qp336md6ow.webp#pic_center" width = 64%><p>进行下一个操作，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.5fbtn7ubb500.webp#pic_center" width = 64%><p>这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。</p><p>本部分参考自：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分详解+例题</a></p><p>也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。</p><p><strong>代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (length+<span class="number">1</span>)  <span class="comment"># 末尾多个0，防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end + <span class="number">1</span>] -= inc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            diff[i] += diff[i - <span class="number">1</span>]            <span class="comment"># 对差分数组求前缀和便可得到原数组</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> diff[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="2-航班预订统计"><a href="#2-航班预订统计" class="headerlink" title="2 航班预订统计"></a>2 航班预订统计</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.7jqt4ty7a0o0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>题⽬说的 n 是从 1 开始计数的，⽽数组索引从 0 开始，在构造差分数组时，需要相应的调整数组下标对应关系，这里在前面添加0，和三元组 (i, j, k) 依次对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            start, end, inc = booking[<span class="number">0</span>], booking[<span class="number">1</span>], booking[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            <span class="keyword">if</span> end &lt; n:             <span class="comment"># 没在末尾添加0，要判断一下边界</span></span><br><span class="line">                diff[end+<span class="number">1</span>] -= inc</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n+m)$，其中 $n$ 为要求的数组长度，$m$ 为预定记录的数量。我们需要对于每一条预定记录处理一次差分数组，并最后对差分数组求前缀和。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="3-拼车"><a href="#3-拼车" class="headerlink" title="3 拼车"></a>3 拼车</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.2mzdjelg76k0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/car-pooling/">https://leetcode.cn/problems/car-pooling/</a></p><h3 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h3><ol><li><p>首先大致可以看出这也是数组子区间增减问题，使用数组画出来看一下，是否能用差分数组</p></li><li><p>定义数组保存每一站车上人数，接客是对子区间全部元素加 n 运算，多次上下车后，看最终数组每一站人数是否超过capacity，超过则说明有乘客上不来</p></li><li><p>注意：</p></li></ol><ul><li>接人影响的子区间为[start, end-1]，因为这批乘客在下车站已经下车了</li><li>0 &lt;&#x3D; trips[i][1] &lt; trips[i][2] &lt;&#x3D; 1000，可以看出trips中start&#x2F;end就是数组下标，这里可以直接定义差分数组大小，也可以使用循环找到最多有几站</li></ul><p>以trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4为例，数组变化：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/007.6bjq9cr5fw00.webp#pic_center" width = 64%><ol><li>说明：</li></ol><ul><li>数组长度为8，表示全程 0~7 共8个站点，元素值表示在第i站车上人数</li><li>没有接人时为原数组，接人是对数组的修改</li><li>最后看每站人数是否超过capacity</li><li>因为3&#x2F;4站人数超过capacity，说明到第3站有乘客上不来</li></ul><ol start="5"><li>观察上面数组变化，可以看出是子区间内元素全部加 n，多次修改后求修改后数组的问题——典型的差分数组求解，对应差分数组变化：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/008.mm47mmjjymo.webp#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="number">1001</span>)      <span class="comment"># 题目中最多有1001个车站</span></span><br><span class="line">        max_station = <span class="number">0</span>          <span class="comment"># 找到车站数</span></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            inc, start, end = trip[<span class="number">0</span>], trip[<span class="number">1</span>], trip[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end] -= inc      <span class="comment"># 第end站乘客已经下车，这里就不用end+1</span></span><br><span class="line">            max_station = <span class="built_in">max</span>(max_station, end)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_station+<span class="number">1</span>): <span class="comment"># 进行区间求和</span></span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(diff[:max_station]) &gt; capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要以LeetCode[370]区间加法、LeetCode[1109]航班预定统计、LeetCode[1094]拼车为例，讲解差分数组的思想和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="差分数组" scheme="https://qxienote.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
    <category term="数组区间修改" scheme="https://qxienote.com/tags/%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>数组（二）-- LC[303]&amp;[304] 区域和检索 - 数组不可变</title>
    <link href="https://qxienote.com/article/a991eb96.html"/>
    <id>https://qxienote.com/article/a991eb96.html</id>
    <published>2023-06-15T14:14:56.000Z</published>
    <updated>2023-06-17T02:15:33.003Z</updated>
    
    <content type="html"><![CDATA[<p>做这种初始化一次、检索多次的题目的秘诀：在初始化的时候做预处理，前缀和技巧就适⽤于快速、频繁地计算⼀个索引区间内的元素之和。本节主要学习区域和检索在数组和矩阵不可变情况下的，如何使用前缀和技巧提高效率。</p><span id="more"></span><h2 id="1-区域和检索-数组不可变"><a href="#1-区域和检索-数组不可变" class="headerlink" title="1 区域和检索 - 数组不可变"></a>1 区域和检索 - 数组不可变</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/016.16tdea598mkg.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>最朴素的想法是存储数组 nums 的值，每次调用 sumRange 时，通过循环的方法计算数组 nums 从下标 $i$ 到下标 $j$ 范围内的元素和，需要计算 $j−i+1$ 个元素的和。由于每次检索的时间和检索的下标范围有关，因此检索的时间复杂度较高，如果检索次数较多，则会超出时间限制。</p><p>由于会进行多次检索，即多次调用 sumRange，因此为了降低检索的总时间，应该降低 sumRange 的时间复杂度，最理想的情况是时间复杂度 $O(1)$。为了将检索的时间复杂度降到 $O(1)$，需要在初始化的时候进行预处理。</p><p>注意到当 $i≤j$ 时，sumRange(i,j) 可以写成如下形式：</p><p>$$\begin{aligned} &amp; \operatorname{sum} \operatorname{Range}(i, j) \ &#x3D; &amp; \sum_{k&#x3D;i}^j n u m s[k] \ &#x3D; &amp; \sum_{k&#x3D;0}^j n u m s[k]-\sum_{k&#x3D;0}^{i-1} n u m s[k]\end{aligned}$$</p><p>由此可知，要计算 sumRange(i,j)，则需要计算数组 nums 在下标 $j$ 和下标 $i−1$ 的前缀和，然后计算两个前缀和的差。</p><p>如果可以在初始化的时候计算出数组 nums 在每个下标处的前缀和 pre_sum，即可满足每次调用 sumRange 的时间复杂度都是 $O(1)$。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.pre_sum = [<span class="number">0</span>]            <span class="comment"># 便于计算累加和，若直接分配数组空间，计算效率更高</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.pre_sum.append(self.pre_sum[i] + nums[i])  <span class="comment"># 计算nums累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.pre_sum[right+<span class="number">1</span>] - self.pre_sum[left]</span><br></pre></td></tr></table></figure><p>下面以数组 [1, 12, -5, -6, 50, 3] 为例，展示了求 pre_sum 的过程。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/017.4h0ovjbmi640.gif#pic_center" width = 64%><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：初始化 $O(n)$，每次检索 $O(1)$，其中 $n$ 是数组 nums 的长度。初始化需要遍历数组 nums 计算前缀和，时间复杂度是 $O(n)$。每次检索只需要得到两个下标处的前缀和，然后计算差值，时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(n)$，其中 $n$ 是数组 nums 的长度。需要创建一个长度为 $n+1$ 的前缀和数组。</li></ul><hr><h2 id="2-二维区域和检索-矩阵不可变"><a href="#2-二维区域和检索-矩阵不可变" class="headerlink" title="2 二维区域和检索 - 矩阵不可变"></a>2 二维区域和检索 - 矩阵不可变</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/018.60fo4kdbbs00.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">https://leetcode.cn/problems/range-sum-query-2d-immutable/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>这部分借鉴自：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/er-wei-qian-zhui-he-jian-dan-tui-dao-tu-sqekv/">笨猪爆破组的题解————从暴力法开始优化 「二维前缀和」做了什么事 | leetcode.304</a></p><p><strong>1. 暴力法</strong></p><p>对二维矩阵，求子矩阵 $(n*m)$ 的和。两重循环，累加求和。</p><p>每次查询时间复杂度 $O(n∗m)$，n和m是子矩阵的行数和列数。查询的代价大。</p><p><strong>2. 第一步优化</strong></p><p>上面的暴力法其实也分了 n 步：第一行的求和，到第 n 行的求和，它们是 n 个一维数组。</p><p>昨天我们学习了一维前缀和，我们可以对这n个一维数组求前缀和，得到n个一维pre_sum数组。</p><p>为了节省查询的时间，我们求出整个矩阵每一行的一维pre_sum数组</p><p>根据前缀和定义：${pre}_{sum}[i]&#x3D;nums[0]+nums[1]+\cdots+nums[i]$，求出前缀和（下图红字）：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/019.3u6m52tef9s0.webp#pic_center" width = 48%><p>然后套用通式：$nums[i]+\cdots+nums[j]&#x3D;pre_sum[j]-pre_sum[i-1]$</p><p>即可求出粉色子阵列的和，计算情况如下图。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/020.hj2lugpi4p4.webp#pic_center" width = 48%><p>可见，如果想多次查询子阵列的和，我们可以提前求出每一行数组的一维前缀和。</p><p>那么查询阶段，求出一行子数组的求和，就只是 $O(1)$，查询 n 行的子阵列，每次就查询花费 $O(n)$，比 $O(n^2)$ 好</p><p><strong>3. 示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])          <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i].append(self.pre_sum[i][j]+matrix[i][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([self.pre_sum[i][col2+<span class="number">1</span>]-self.pre_sum[i][col1] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2+<span class="number">1</span>)])</span><br></pre></td></tr></table></figure><p><strong>4. 第二步优化</strong><br>还可以继续优化吗？</p><p>我们引入一个概念：二维前缀和，定义式如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/021.2ysqnsk7mj40.webp#pic_center" width = 48%><p><code>pre_sum[i][j]</code> 表示：左上角为 <code>arr[0][0]</code>，右下角为 <code>arr[i][j]</code> 的阵列的求和.</p><p>我们把这个阵列拆分成四个部分，如图中的色块。</p><p>要想求出 <code>pre_sum[i][j]</code>，根据上图，由容斥原理，有：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/022.8w4fiqsxvew.webp#pic_center" width = 48%><p>移项后：</p><p>$$arr[i][j] &#x3D; pre_sum[i][j] + pre_sum[i-1][j-1] - pre_sum[i-1][j] - pre_sum[i][j-1]$$</p><p>现在想求：行 从 a 到 A，列 从 b 到 B 的子阵列的和。叠加上式，各种相消后。得：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/023.6dkvz3kmwdc0.webp#pic_center" width = 48%><p>回到粉色子阵列，求她的和，就是如下图的 4 个 pre_sum 矩阵元素相加减。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/024.79mvkez7230.webp#pic_center" width = 48%><p>问题来了，怎么求出 pre_sum 二维阵列的每一项？</p><p>就是用遍历原矩阵，两层循环，套下图的公式。</p><p>注意到上图黄字，在 -1 位置上预置了 0，只是为了让处于边界的 preSum 元素，也能套用下面的通式。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/025.5ybgixgg7ds0.webp#pic_center" width = 48%><p>两个关键式 <code>pre_sum[i][j]</code> 的定义式如下，并且预置 <code>pre-sum[-1][j]</code> 和 <code>pre_sum[i][-1]</code> 为 0：</p><p>$$<br>\operatorname{preSum}[i][j]&#x3D;\sum_{x&#x3D;0}^i \sum_{y&#x3D;0}^j \operatorname{arr}[x][y]<br>$$</p><p>求：行从 a 到 A，列从 b 到 B 的子阵列的和的通式：<br>$$<br>\sum_{i&#x3D;a}^A \sum_{i&#x3D;b}^B \operatorname{arr}[i][j]&#x3D;\operatorname{pre_sum}[A][B]+\operatorname{pre_sum}[a-1][b-1]-\operatorname{pre_sum}[A][b-1]-\operatorname{pre_sum}[a-1][B]<br>$$</p><p>查询的时间复杂度降下来了<br>因此子阵列的求和，都只需要访问二维 pre_sum 数组的四个值。</p><p>预处理阶段，求出二维 pre_sum 数组，需要花费 $O(n∗m)$，n和m是子矩阵的行数和列数。</p><p>但之后每次查询，就都是 $O(1)$ 的时间复杂度</p><p><strong>5. 调整 pre_sum 矩阵</strong></p><p>为了减少特判的代码，我们调整一下 pre_sum 矩阵，原先 <code>arr[i][j]</code> 对应 <code>pre_sum[i][j]</code></p><p>现在错开，<code>arr[i][j]</code> 对应 <code>pre_sum[i+1][j+1]</code>。</p><p>如下图所示，pre_sum 阵列会比原矩阵多一行一列，为了让 pre_sum 的 -1 列 -1 行变成 0 行 0 列</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/026.20ie8zlewqps.webp#pic_center" width = 48%><p>现在 preSum[i][j] 的定义式，改一下</p><p>$$<br>\operatorname{pre_sum}[i+1][j+1]&#x3D;\sum_{x&#x3D;0}^i \sum_{y&#x3D;0}^j \operatorname{arr}[x][y]<br>$$</p><p>并且预置 <code>pre_sum[0][j]</code> 和 <code>pre_sum[i][0]</code> 为 0</p><p>求：行从 a 到 A，列从 b 到 B 的子阵列的和，的通式，改一下：<br>$$<br>\sum_{i&#x3D;a}^A \sum_{i&#x3D;b}^B \operatorname{arr}[i][j]&#x3D;\operatorname{pre_sum}[A+1][B+1]+\operatorname{pre_sum}[a][b]-\operatorname{pre_sum}[A+1][b]-\operatorname{pre_sum}[a][B+1]<br>$$</p><p><strong>6. 示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])          <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.pre_sum[i+<span class="number">1</span>][j] + self.pre_sum[i][j+<span class="number">1</span>] - self.pre_sum[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.pre_sum[row1][col2+<span class="number">1</span>] - self.pre_sum[row2+<span class="number">1</span>][col1] + self.pre_sum[row1][col1])</span><br></pre></td></tr></table></figure><p><strong>7. 复杂度分析</strong></p><ul><li>时间复杂度：初始化 $O(mn)$，每次检索 $O(1)$，其中 m 和 n 分别是矩阵 matrix 的行数和列数。初始化需要遍历矩阵 matrix 计算二维前缀和，时间复杂度是 $O(mn)$。每次检索的时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(mn)$，其中m和n分别是矩阵 matrix 的行数和列数。需要创建一个 m＋1 行 n+1 列的二维前缀和数组 pre_sum。</li></ul><blockquote><p>做题心得：以后会不会延伸到张量呢，更高维数的也是总结通式，就比如三维是一个立方体，依然是计算每个小立方体的和。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;做这种初始化一次、检索多次的题目的秘诀：在初始化的时候做预处理，前缀和技巧就适⽤于快速、频繁地计算⼀个索引区间内的元素之和。本节主要学习区域和检索在数组和矩阵不可变情况下的，如何使用前缀和技巧提高效率。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="前缀和" scheme="https://qxienote.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="区域和检索" scheme="https://qxienote.com/tags/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>数组（一）-- LC[26]&amp;[80] 删除有序数组中的重复元素</title>
    <link href="https://qxienote.com/article/cce29ffb.html"/>
    <id>https://qxienote.com/article/cce29ffb.html</id>
    <published>2023-06-15T13:56:27.000Z</published>
    <updated>2023-06-15T14:11:34.260Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode[26] 删除有序数组中的重复元素，原地删除重复出现的元素，使每个元素 只出现1&#x2F;2次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。使用双指针的通用解法</p><span id="more"></span><h2 id="1-删除有序数组中的重复项"><a href="#1-删除有序数组中的重复项" class="headerlink" title="1 删除有序数组中的重复项"></a>1 删除有序数组中的重复项</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给你一个 <strong>升序排列</strong> 的数组 nums ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong>，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><blockquote><p>示例 1：<br>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><blockquote><p>示例 2：<br>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>已知数组 nums 是有序的，而且我们只能在原地修改 nums 数组，不能创建新的数组空间来存储删除重复出现的元素后的结果。我们需要一边遍历数组查找相同元素，一边在对比发现不同元素时修改数组元素，那么我们可以考虑双指针法的快慢指针了，定义 p 和 q 作为指针，初始化时指针 p 指向数组的起始位置（nums[0]），指针 q 指向指针 p 的后一个位置（nums[1]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；</li></ul><p>图示：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/014.7ehk7ns70rk0.webp#pic_center" width = 36%></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>复杂度分析：时间复杂度：$O(n)$。 空间复杂度：$O(1)$。</p><p>进一步优化：</p><p>考虑如下数组：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/015.1pxc8t12z3gg.webp#pic_center" width = 36%><p>此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p><p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p]:</span><br><span class="line">                <span class="keyword">if</span> q - p &gt; <span class="number">1</span>:</span><br><span class="line">                    nums[p+<span class="number">1</span>] = nums[q]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-删除有序数组中的重复项-II"><a href="#2-删除有序数组中的重复项-II" class="headerlink" title="2 删除有序数组中的重复项 II"></a>2 删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><blockquote><p>示例 1：<br>输入：nums &#x3D; [1,1,1,2,2,3]<br>输出：5, nums &#x3D; [1,1,2,2,3]<br>解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</p></blockquote><blockquote><p>示例 2：<br>输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]<br>输出：7, nums &#x3D; [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>思路和上面的类似，改变的地方是：初始化时指针 p 指向数组的起始位置（nums[1]），指针 q 指向指针 p 的后一个位置（nums[2]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p-1]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p-<span class="number">1</span>]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>通用解法：</strong><br>为了让解法更具有一般性，我们将原问题的「最多保留 1 位」修改为「最多保留 k 位」。<br>对于此类问题，我们应该进行如下考虑：</p><ul><li>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。</li><li>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。</li></ul><p>此时，初始化时指针 p 指向数组的起始位置（nums[k-1]），指针 q 指向指针 p 的后一个位置（nums[k]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p-k+1]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode[26] 删除有序数组中的重复元素，原地删除重复出现的元素，使每个元素 只出现1&amp;#x2F;2次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。使用双指针的通用解法&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Array" scheme="https://qxienote.com/categories/LeetCode/Array/"/>
    
    
    <category term="双指针" scheme="https://qxienote.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>字符串（二）-- LC[17] 电话号码的字母组合</title>
    <link href="https://qxienote.com/article/6b74a168.html"/>
    <id>https://qxienote.com/article/6b74a168.html</id>
    <published>2023-06-15T13:46:40.000Z</published>
    <updated>2023-06-15T14:11:34.259Z</updated>
    
    <content type="html"><![CDATA[<p>LC[17] 电话号码的字母组合，本题主要考察字符串的操作，回溯和递归的理解，以及队列的使用</p><span id="more"></span><h2 id="1-电话号码的字母组合"><a href="#1-电话号码的字母组合" class="headerlink" title="1 电话号码的字母组合"></a>1 电话号码的字母组合</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.434zi36fo760.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p><h3 id="1-2-回溯解法"><a href="#1-2-回溯解法" class="headerlink" title="1.2 回溯解法"></a>1.2 回溯解法</h3><p>这道题的解法是用回溯的方式，在循环里面套了递归调用。本来递归就不好理解了，再加上循环的递归，就更难理解了。 我们先不考虑递归，先看看下面这个问题怎么解决。 假设输入是2，只有一个字符，那么应该怎么解呢？ 按照题目要求2&#x3D;“abc”，所以结果应该是<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>先不用想着怎么去写递归，只思考下怎么打印出这个结果。 这个太简单了，一个循环就搞定了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    result.append(ch)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上面是伪代码，一个循环就搞定了。 如果输入的是23，应该怎么做呢？23的结果是<code>[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]</code>，我们仍然不考虑怎么去写递归，只是考虑怎么把这个结果给弄出来。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        result.append(ch1+ch2)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>也就是说23这样的长度为2的字符串可以用两层循环搞定。 如果输入的是234呢，仍然不要考虑怎么去写递归，而是想怎么把结果打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> <span class="string">&quot;ghi&quot;</span>:</span><br><span class="line">            result.append(ch1+ch2+ch3)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这次用了三层循环。 如果输入的是2345，那么代码可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> <span class="string">&quot;ghi&quot;</span>:</span><br><span class="line">            <span class="keyword">for</span> ch4 <span class="keyword">in</span> <span class="string">&quot;jkl&quot;</span>:</span><br><span class="line">                result.append(ch1+ch2+ch3+ch4)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这次是用了四层循环。现在是不是能看出一些门道了？对的。循环的嵌套层数，就是输入的字符串长度。输入的字符串长度是1，循环只有1层。 输入的字符串长度是3，循环就是3层。如果输入的字符串长度是10，那么循环就是10层。 可是输入的字符串长度是不固定的，对应的循环的嵌套层数也是不固定的，那这种情况怎么解决呢？这时候递归就派上用场了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.55ctnj0dzeg0.webp#pic_center" width = 36%><p>对于打印”2345”这样的字符串： 第一次递归就是上图中最下面的方格，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数 第二次递归处理3，将字符串改变成”45”后再次递归 第三次递归处理4，将字符串改变成”5”后继续递归 第四次递归处理5，将字符串改变成””后继续递归 最后发现字符串为空了，将结果放到列表中并返回 上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是 $O(3^n)$ 这个级别的，空间复杂度是 $O(n)$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.ivt8h2jae5c.webp#pic_center" width = 36%><p>动图如下：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.3kyeb4smemw0.gif#pic_center" width = 48%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type digits: str</span></span><br><span class="line"><span class="string">:rtype: List[str]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 注意边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="comment"># 一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">d = [<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line"><span class="comment"># 最终输出结果的list</span></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">tmp, index</span>):</span><br><span class="line"><span class="comment"># 递归的终止条件，注意这里的终止条件看上去跟动态演示图有些不同，主要是做了点优化</span></span><br><span class="line"><span class="comment"># 动态图中是每次截取字符串的一部分，&quot;234&quot;，变成&quot;23&quot;，再变成&quot;3&quot;，最后变成&quot;&quot;，这样性能不佳</span></span><br><span class="line"><span class="comment"># 而用index记录每次遍历到字符串的位置，这样性能更好</span></span><br><span class="line"><span class="keyword">if</span> index==<span class="built_in">len</span>(digits):</span><br><span class="line">res.append(tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment"># 获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line"><span class="comment"># 第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line"><span class="comment"># subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line">c = digits[index]</span><br><span class="line"><span class="comment"># map_string的下表是从0开始一直到9， ord(c)-48 是获取c的ASCII码然后-48, 48是0的ASCII</span></span><br><span class="line"><span class="comment"># 比如c=2时候，2-&#x27;0&#x27;，获取下标为2, letter_map[2]就是&quot;abc&quot;</span></span><br><span class="line">letters = d[<span class="built_in">ord</span>(c)-<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字符串，比如第一次得到的是2，页就是遍历&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> letters:</span><br><span class="line"><span class="comment"># 调用下一层递归，用文字很难描述，请配合动态图理解</span></span><br><span class="line">backtrack(tmp+i, index+<span class="number">1</span>)</span><br><span class="line">backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1-3-队列"><a href="#1-3-队列" class="headerlink" title="1.3 队列"></a>1.3 队列</h3><p>我们也可以使用队列，先将输入的 digits 中第一个数字对应的每一个字母入队，然后将出队的元素与第二个数字对应的每一个字母组合后入队…直到遍历到 digits 的结尾。最后队列中的元素就是所求结果。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/007.solwru43pr4.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type digits: str</span></span><br><span class="line"><span class="string">:rtype: List[str]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="comment"># 一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">d = [<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line"><span class="comment"># 先往队列中加入一个空字符</span></span><br><span class="line">res = [<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">size = <span class="built_in">len</span>(res)</span><br><span class="line"><span class="comment"># 由当前遍历到的字符，取字典表中查找对应的字符串</span></span><br><span class="line">letters = d[<span class="built_in">ord</span>(i)-<span class="number">48</span>]</span><br><span class="line"><span class="comment"># 计算出队列长度后，将队列中的每个元素挨个拿出来</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> xrange(size):</span><br><span class="line"><span class="comment"># 每次都从队列中拿出第一个元素</span></span><br><span class="line">tmp = res.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 然后跟&quot;def&quot;这样的字符串拼接，并再次放到队列中</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> letters:</span><br><span class="line">res.append(tmp+j)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>通俗易懂+动画演示 17. 电话号码的字母组合：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/44182/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/44182/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/</a></li><li>回溯+队列 图解：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LC[17] 电话号码的字母组合，本题主要考察字符串的操作，回溯和递归的理解，以及队列的使用&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="String" scheme="https://qxienote.com/categories/LeetCode/String/"/>
    
    
    <category term="字符串" scheme="https://qxienote.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回溯法" scheme="https://qxienote.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    <category term="递归" scheme="https://qxienote.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>字符串（一）-- LC[3] 无重复字符的最长子串</title>
    <link href="https://qxienote.com/article/284005f2.html"/>
    <id>https://qxienote.com/article/284005f2.html</id>
    <published>2023-06-15T13:46:09.000Z</published>
    <updated>2023-06-15T14:11:34.256Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode[3] 无重复字符的最长子串使用滑动窗口，就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。</p><span id="more"></span><h2 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1 无重复字符的最长子串"></a>1 无重复字符的最长子串</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><blockquote><p>示例 1:<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><blockquote><p>示例 2:<br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><blockquote><p>示例 3:<br>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p> <strong>滑动窗口法：其实用一句话描述就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。</strong> 示意图如下面：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.4aq0ytbcaeq0.webp#pic_center" width = 48%><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>思路一：滑动窗口法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 思路一：滑动窗口法</span></span><br><span class="line">        temp_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len, current_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> temp_str:</span><br><span class="line">                temp_str += s[i]</span><br><span class="line">                current_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = temp_str.index(s[i])</span><br><span class="line">                temp_str = temp_str[index+<span class="number">1</span>:]</span><br><span class="line">                temp_str += s[i]</span><br><span class="line">                current_len = <span class="built_in">len</span>(temp_str)</span><br><span class="line">            <span class="keyword">if</span> max_len &lt; current_len:</span><br><span class="line">                max_len = current_len</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode[3] 无重复字符的最长子串使用滑动窗口，就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="String" scheme="https://qxienote.com/categories/LeetCode/String/"/>
    
    
    <category term="滑动窗口" scheme="https://qxienote.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="字符串" scheme="https://qxienote.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数学(四) -- LC[29]&amp;[166] 两数相除与分数到小数</title>
    <link href="https://qxienote.com/article/77d95398.html"/>
    <id>https://qxienote.com/article/77d95398.html</id>
    <published>2023-06-14T03:10:55.000Z</published>
    <updated>2023-06-15T14:08:33.487Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习LeetCode两数相除里面用到的快速乘和二分查找的算法进行两数的相除，同时学习长除法的解题技巧</p><span id="more"></span><h2 id="1-分数到小数"><a href="#1-分数到小数" class="headerlink" title="1 分数到小数"></a>1 分数到小数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/010.7da1gbtbx5c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/description/">https://leetcode.cn/problems/fraction-to-recurring-decimal/description/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>1. 长除法</strong></p><p>题目要求根据给定的分子和分母，将分数转成整数或小数。由于给定的分子和分母的取值范围都是 $[-2^{31}, 2^{31}-1]$，为了防止计算过程中产生溢出，需要将分子和分母转成 64 位整数表示。</p><p>将分数转成整数或小数，做法是计算分子和分母相除的结果。可能的结果有三种：整数、有限小数、无限循环小数。</p><p>如果分子可以被分母整除，则结果是整数，将分子除以分母的商以字符串的形式返回即可。</p><p>如果分子不能被分母整除，则结果是有限小数或无限循环小数，需要通过模拟长除法的方式计算结果。为了方便处理，首先根据分子和分母的正负决定结果的正负（注意此时分子和分母都不为 0），然后将分子和分母都转成正数，再计算长除法。</p><p>计算长除法时，首先计算结果的整数部分，将以下部分依次拼接到结果中：</p><ol><li>如果结果是负数则将负号拼接到结果中，如果结果是正数则跳过这一步；</li><li>将整数部分拼接到结果中；</li><li>将小数点拼接到结果中。</li></ol><p>完成上述拼接之后，根据余数计算小数部分。</p><p>计算小数部分时，每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。</p><ul><li>如果余数变成 0，则结果是有限小数，将小数部分拼接到结果中。</li><li>如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。</li></ul><p>如何判断是否找到循环节？注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的，因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。</p><p>假设在计算小数部分的第 $i$ 位之前，余数为 $\textit{remainder}<em>i$，则在计算小数部分的第 $i$ 位之后，余数为 $\textit{remainder}</em>{i+1}$。</p><p>假设存在下标 $j$ 和 $k$，满足 $j \le k$ 且 $\textit{remainder}<em>j &#x3D; \textit{remainder}</em>{k+1}$，则小数部分的第 $k+1$ 位和小数部分的第 $j$ 位相同，因此小数部分的第 $j$ 位到第 $k$ 位是一个循环节。在计算小数部分的第 $k$ 位之后就会发现这个循环节的存在，因此在小数部分的第 $j$ 位之前加上左括号，在小数部分的末尾（即第 $k$ 位之后）加上右括号。</p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/011.1g836fzb4800.webp#pic_left" width = "50%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/012.1ysut58coneo.webp#pic_left"  width = "48%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fractionToDecimal</span>(<span class="params">self, numerator: <span class="built_in">int</span>, denominator: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果本身能够整除，直接返回计算结果</span></span><br><span class="line">        <span class="keyword">if</span> numerator % denominator == <span class="number">0</span>: <span class="keyword">return</span> <span class="built_in">str</span>(numerator//denominator)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> numerator * denominator &lt; <span class="number">0</span>:             <span class="comment"># 如果其一为负数，先追加负号</span></span><br><span class="line">            res.append(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        numerator, denominator = <span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator)</span><br><span class="line">        res.append(<span class="built_in">str</span>(numerator//denominator))     <span class="comment">#  计算整数部分，并将余数赋值给 remainder</span></span><br><span class="line">        res.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        remainder = numerator % denominator</span><br><span class="line">        index_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> remainder <span class="keyword">and</span> remainder <span class="keyword">not</span> <span class="keyword">in</span> index_map:</span><br><span class="line">            index_map[remainder] = <span class="built_in">len</span>(res)         <span class="comment"># 记录当前余数所在答案的位置，并继续模拟除法运算</span></span><br><span class="line">            remainder *= <span class="number">10</span></span><br><span class="line">            res.append(<span class="built_in">str</span>(remainder//denominator))</span><br><span class="line">            remainder %= denominator</span><br><span class="line">        <span class="keyword">if</span> remainder:                   <span class="comment"># 当前余数之前出现过，则将出现位置和最后位置添加&#x27;()&#x27;</span></span><br><span class="line">            ind = index_map[remainder]</span><br><span class="line">            res.insert(ind, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            res.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(l)$，其中 $l$ 是答案字符串的长度，这道题中 $l \le 10^4$。对于答案字符串中的每一个字符，计算时间都是 $O(1)$。</li><li>空间复杂度：$O(l)$，其中 $l$ 是答案字符串的长度，这道题中 $l \le 10^4$。空间复杂度主要取决于答案字符串和哈希表，哈希表中的每个键值对所对应的下标各不相同，因此键值对的数量不会超过 $l$。</li></ul><h2 id="2-两数相除"><a href="#2-两数相除" class="headerlink" title="2 两数相除"></a>2 两数相除</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/013.6o6qc5moj0c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/divide-two-integers/description/">https://leetcode.cn/problems/divide-two-integers/description/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p><strong>1. 二分查找</strong></p><p>如果除法结果溢出，那么我们需要返回 $2^{31}-1$ 作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：</p><ul><li>当被除数为 32 位有符号整数的最小值 $-2^{31}$ 时：<ul><li>如果除数为 1，那么我们可以直接返回答案 $-2^{31}$；</li><li>如果除数为 −1，那么答案为 $2^{31}$，产生了溢出。此时我们需要返回 $2^{31} - 1$。</li></ul></li><li>当除数为 32 位有符号整数的最小值 $s-2^{31}$ 时：<ul><li>如果被除数同样为 $-2^{31}$，那么我们可以直接返回答案 111；</li><li>对于其余的情况，我们返回答案 0。</li></ul></li><li>当被除数为 0 时，我们可以直接返回答案 0。</li></ul><p>对于一般的情况，根据除数和被除数的符号，我们需要考虑 444 种不同的可能性。因此，为了方便编码，我们可以将被除数或者除数取相反数，使得它们符号相同。</p><p>如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 $-2^{31}$ 时，它的相反数 $2^{31}$ 产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 1 种情况了。</p><p>如果我们将被除数和除数的其中（恰好）一个变为了正数，那么在返回答案之前，我们需要对答案也取相反数。</p><p><strong>方法一：二分查找</strong></p><p>根据「前言」部分的讨论，我们记被除数为 X，除数为 Y，并且 X 和 Y 都是负数。我们需要找出 X&#x2F;Y 的结果 Z。Z 一定是正数或 0。</p><p>根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：</p><p>$$Z\times Y \geq X \geq (Z+1) \times Y$$</p><p>因此，我们可以使用二分查找的方法得到 ZZZ，即找出最大的 ZZZ 使得 Z×Y≥XZ \times Y \geq XZ×Y≥X 成立。</p><p>由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 $Z \times Y$ 的值。</p><p>由于我们只能使用 32 位整数，因此二分查找中会有很多细节。</p><p>首先，二分查找的下界为 1，上界为 $2^{31} - 1$。唯一可能出现的答案为 $2^{31}$ 的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 $2^{31} - 1$。如果二分查找失败，那么答案一定为 0。</p><p>在实现「快速乘」时，我们需要使用加法运算，然而较大的 Z 也会导致加法运算溢出。例如我们要判断 A + B 是否小于 C 时（其中 A,B,C 均为负数），A + B 可能会产生溢出，因此我们必须将判断改为 $A &lt; C - B$ 是否成立。由于任意两个负数的差一定在 $[-2^{31} + 1, 2^{31} - 1]$ 范围内，这样就不会产生溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        INT_MIN, INT_MAX = -<span class="number">2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == INT_MIN:</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MIN</span><br><span class="line">            <span class="keyword">if</span> divisor == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MAX</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == INT_MIN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> dividend == INT_MIN <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment"># 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        rev = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> dividend &gt; <span class="number">0</span>:</span><br><span class="line">            dividend = -dividend</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line">        <span class="keyword">if</span> divisor &gt; <span class="number">0</span>:</span><br><span class="line">            divisor = -divisor</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 快速乘</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickAdd</span>(<span class="params">y: <span class="built_in">int</span>, z: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment"># 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            result, add = <span class="number">0</span>, y</span><br><span class="line">            <span class="keyword">while</span> z &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> result &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    result += add</span><br><span class="line">                <span class="keyword">if</span> z != <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> add &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    add += add</span><br><span class="line">                <span class="comment"># 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        left, right, ans = <span class="number">1</span>, INT_MAX, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 注意溢出，并且不能使用除法</span></span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            check = quickAdd(divisor, mid, dividend)</span><br><span class="line">            <span class="keyword">if</span> check:</span><br><span class="line">                ans = mid</span><br><span class="line">                <span class="comment"># 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> mid == INT_MAX:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -ans <span class="keyword">if</span> rev <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：$O(\log^2 C)$，其中 $C$ 表示 32 位整数的范围。二分查找的次数为 $O(\log C)$，其中的每一步我们都需要 $O(\log C)$ 使用「快速乘」算法判断 $Z \times Y \geq X$ 是否成立，因此总时间复杂度为 $O(\log^2 C)$。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>2. 减法试除</strong><br><strong>思路一</strong><br>首先需要考虑正负号，处理为分子分母全是正数， 其次在返回的时候要注意是否溢出，如果溢出要判断。</p><p>核心是div函数怎么写？例如方法1中的div函数， 利用二进制搜索的思想就是， 每次利用加法，将当前的 divisor 乘以两倍，并同时用 multiple 记录下乘以了 2 的多少次方， multiple 的变化过程是1，2，4，8，16 。。。</p><p>因为任何一个数都可以用二进制的方法得到，所以我们可以利用二进制的思想来代表乘数 multiple， 最终能够得到一个 <code>divisor * multiple = dividend</code> 的multiple。</p><p>举例：算 $63 &#x2F; 8$ 过程为：$63 &#x2F; 8 &#x3D; (63-32) &#x2F; 8 + 4 &#x3D; (63-32-16) &#x2F; 8 + 2 + 4 &#x3D; (63-32-16-8) &#x2F; 8 + 1+ 2 + 4 &#x3D; 7$ 其中 $(63-32-16-8) &#x2F; 8 &#x3D; 7 &#x2F; 8 &#x3D; 0$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN_INT, MAX_INT = -<span class="number">2147483648</span>, <span class="number">2147483647</span>  <span class="comment"># [−2**31, 2**31−1]</span></span><br><span class="line">        flag = <span class="number">1</span>                                    <span class="comment"># 存储正负号，并将分子分母转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>: flag, dividend = -flag, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>: flag, divisor  = -flag, -divisor </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">dividend, divisor</span>):                 <span class="comment"># 例：1023 / 1 = 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 1</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cur = divisor</span><br><span class="line">            multiple = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur + cur &lt; dividend:             <span class="comment"># 用加法求出保证divisor * multiple &lt;= dividend的最大multiple</span></span><br><span class="line">                cur += cur                          <span class="comment"># 即cur分别乘以1, 2, 4, 8, 16...2^n，即二进制搜索</span></span><br><span class="line">                multiple += multiple</span><br><span class="line">            <span class="keyword">return</span> multiple + div(dividend - cur, divisor)</span><br><span class="line">        res = div(dividend, divisor)</span><br><span class="line"></span><br><span class="line">        res = res <span class="keyword">if</span> flag &gt; <span class="number">0</span> <span class="keyword">else</span> -res             <span class="comment"># 恢复正负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN_INT:                           <span class="comment"># 根据是否溢出返回结果</span></span><br><span class="line">            <span class="keyword">return</span> MIN_INT</span><br><span class="line">        <span class="keyword">elif</span> MIN_INT &lt;= res &lt;= MAX_INT:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN_INT, MAX_INT = -<span class="number">2147483648</span>, <span class="number">2147483647</span>  <span class="comment"># [−2**31, 2**31−1]</span></span><br><span class="line">        flag = <span class="number">1</span>                                    <span class="comment"># 存储正负号，并将分子分母转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>: flag, dividend = -flag, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>: flag, divisor  = -flag, -divisor </span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:                  <span class="comment"># 例：1023 / 1 = 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 1</span></span><br><span class="line">            cur = divisor</span><br><span class="line">            multiple = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur + cur &lt; dividend:             <span class="comment"># 用加法求出保证divisor * multiple &lt;= dividend的最大multiple</span></span><br><span class="line">                cur += cur                          <span class="comment"># 即cur分别乘以1, 2, 4, 8, 16...2^n，即二进制搜索</span></span><br><span class="line">                multiple += multiple</span><br><span class="line">            dividend -= cur                         <span class="comment"># 辗转相减法</span></span><br><span class="line">            res += multiple</span><br><span class="line">        </span><br><span class="line">        res = res <span class="keyword">if</span> flag &gt; <span class="number">0</span> <span class="keyword">else</span> -res             <span class="comment"># 恢复正负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN_INT:                           <span class="comment"># 根据是否溢出返回结果</span></span><br><span class="line">            <span class="keyword">return</span> MIN_INT</span><br><span class="line">        <span class="keyword">elif</span> MIN_INT &lt;= res &lt;= MAX_INT:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br></pre></td></tr></table></figure><p><strong>思路二</strong></p><p>用 $2^i$ 去作为乘法基数, $x * 2^i &#x3D; x &lt;&lt; i$。 从 $2^{31}$ 试到 $2^0$ 直到被除数被减到比除数小， 每个能满足除出来的最大的 2 的幂都加入答案, 也可以理解为每次计算出答案的 32 位中的某一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> dividend == -<span class="number">2147483648</span> <span class="keyword">and</span> divisor == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">        a, b, res = <span class="built_in">abs</span>(dividend), <span class="built_in">abs</span>(divisor), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 2^i * b &lt;= a 换句话说 a/b = 2^i + (a-2^i*b)/b</span></span><br><span class="line">            <span class="keyword">if</span> (b &lt;&lt; i) &lt;= a:</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">                a -= b &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>两数相除——官方题解：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/">https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/</a></li><li>减法试除：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/1042741/pythonjavajavascript-jian-fa-shi-chu-by-amrow/">https://leetcode.cn/problems/divide-two-integers/solutions/1042741/pythonjavajavascript-jian-fa-shi-chu-by-amrow/</a></li><li>二进制搜索的思想：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/458026/29-python3-li-yong-er-jin-zhi-sou-suo-de-si-xiang-/">https://leetcode.cn/problems/divide-two-integers/solutions/458026/29-python3-li-yong-er-jin-zhi-sou-suo-de-si-xiang-/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要学习LeetCode两数相除里面用到的快速乘和二分查找的算法进行两数的相除，同时学习长除法的解题技巧&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="二分查找" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="长除法" scheme="https://qxienote.com/tags/%E9%95%BF%E9%99%A4%E6%B3%95/"/>
    
    <category term="快速乘" scheme="https://qxienote.com/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"/>
    
  </entry>
  
  <entry>
    <title>数学(三) -- LC[1010]&amp;[1015] 可被 K 整除的最小整数</title>
    <link href="https://qxienote.com/article/e0f9f6cf.html"/>
    <id>https://qxienote.com/article/e0f9f6cf.html</id>
    <published>2023-06-14T03:10:34.000Z</published>
    <updated>2023-06-14T03:25:32.929Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要结合LeetCode上的题目分析常用的取模运算、带余除法、鸽巢定理、组合数学的解题技巧。</p><span id="more"></span><h2 id="1-可被-K-整除的最小整数"><a href="#1-可被-K-整除的最小整数" class="headerlink" title="1 可被 K 整除的最小整数"></a>1 可被 K 整除的最小整数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.4r4wqioa0sk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/">https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>模运算</strong></p><p>如果让你计算 $1234 \cdot 6789$ 的个位数，你会如何计算？</p><p>由于只有个位数会影响到乘积的个位数，那么 $4\cdot 9&#x3D;36$ 的个位数 $6$ 就是答案。</p><p>对于 $1234+6789$ 的个位数，同理，$4+9&#x3D;13$ 的个位数 $3$ 就是答案。</p><p>你能把这个结论抽象成数学等式吗？</p><p>一般地，涉及到取模的题目，通常会用到如下等式(上面计算的是 $m&#x3D;10$):</p><p>$$<br>(a+b)\bmod m &#x3D; ((a\bmod m) + (b\bmod m)) \bmod m \<br>(a\cdot b) \bmod m&#x3D;((a\bmod m)\cdot  (b\bmod m)) \bmod m<br>$$</p><p>证明：根据<a href="https://zhuanlan.zhihu.com/p/147079013">带余除法</a>，任意整数 $a$ 都可以表示为 $a&#x3D;km+r$，这里 $r$ 相当于 $a mod m$。那么设 $a&#x3D;k_1m+r_1,\ b&#x3D;k_2m+r_2$。</p><p><strong>第一个等式：</strong><br>$$<br>\begin{aligned}<br>&amp;(a+b) \bmod m\<br>&#x3D;&amp;((k_1+k_2) m+r_1+r_2)\bmod m\<br>&#x3D;&amp;(r_1+r_2)\bmod m\<br>&#x3D;&amp;((a\bmod m) + (b\bmod m)) \bmod m<br>\end{aligned}<br>$$</p><p>即：两个数相加对某个数求余等于两个数分别求余相加之后再求余。</p><p><strong>第二个等式：</strong><br>$$<br>\begin{aligned}<br>&amp;(a\cdot b) \bmod m\<br>&#x3D;&amp;(k_1k_2m^2+(k_1r_2+k_2r_1)m+r_1r_2)\bmod m\<br>&#x3D;&amp;(r_1r_2)\bmod m\<br>&#x3D;&amp;((a\bmod m)\cdot  (b\bmod m)) \bmod m<br>\end{aligned}<br>$$</p><p><strong>举例一: $k &#x3D; 7$</strong></p><p>从小到大枚举$n$，第一个能被 $k$ 整除的数的长度即为答案。</p><p>$$1 \rightarrow 11 \rightarrow 111 \rightarrow 1111 \rightarrow 11111 \rightarrow 111111$$</p><p>根据前置知识，设 $x$ 是上一次运算的结果(初始为1)，则下一个 $n$ 模 $k$ 的结果为 $(10x + 1) mod k$，看它是否为0。</p><p>$$1 \rightarrow 4 \longrightarrow 6 \longrightarrow 5 \longrightarrow 2 \longrightarrow 0$$</p><p><strong>举例二: $k&#x3D;24$</strong></p><p>如果计算结果和之前的某个数相同，由于计算规则不变，后面会无限重复下去，无法得到0。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.54n4hhi87cg0.webp#pic_center" width = 48%><p><strong>方法一：哈希表</strong></p><p>用哈希表记录计算结果。如果在算出0之前就遇到了在哈希表中的数字，则返回-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">1</span> % k           <span class="comment">#  x 为余数</span></span><br><span class="line">        seen = <span class="built_in">set</span>()        <span class="comment">#  创建一个无序集合，用于存储余数</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> seen:      <span class="comment"># 当余数为0或者余数重复出现，退出循环</span></span><br><span class="line">            seen.add(x)</span><br><span class="line">            x = (<span class="number">10</span> * x + <span class="number">1</span>) % k</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> x <span class="keyword">else</span> <span class="built_in">len</span>(seen) + <span class="number">1</span>   <span class="comment"># 余数不为0，返回-1，余数为0，返回len(seen)+1    </span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(k)$。</li><li>空间复杂度：$\mathcal{O}(k)$。</li></ul><p><strong>方法二：抽屉原理</strong></p><p>循环 $k$ 次，如果没有算出0，则返回-1。为什么？模 $k$ 的结果在 $[0, k-1]$ 中，这有 $k$ 个数字。如果循环 $k$ 次还没有找到0,根据<a href="https://oi-wiki.org/math/number-theory/fermat/#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">鸽巢原理(抽屉原理)</a>，必然有重复的数字。这也同时说明算法一的时间复杂度为 $O(k)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> k % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        x = <span class="number">1</span> % k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">1</span>):              <span class="comment"># 一定有解</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            x = (x * <span class="number">10</span> + <span class="number">1</span>) % k</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(k)$。</li><li>空间复杂度：$\mathcal{O}(1)$，仅用到若干额外变量。</li></ul><p><code>itertools.count(start=0, step=1)</code></p><p>创建一个迭代器，它从 start 值开始，返回均匀间隔的值。常用于 <code>map()</code> 中的实参来生成连续的数据点。此外，还用于 <code>zip()</code> 来添加序列号。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">start=<span class="number">0</span>, step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) --&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure><p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如：<code>(start + step * i for i in count())</code>。</p><p><strong>方法三：数学推导</strong></p><p>设 $n$ 的长度为 $x$，那么 $n&#x3D;\frac{10^x-1}{9}$。$n$ 是 $k$ 的倍数，等价于 $10^x-1$ 是 $9k$ 的倍数，即 $10^x \equiv 1(mod 9k)$ 。</p><ul><li>结论：最小的 $x$ 必然是 $\phi(9k)$ 的因子。</li><li>反证：如果 $\phi(9k) &#x3D; px + r (0 &lt; r &lt;x)$，根据欧拉定理，$10^{\phi(9k)}&#x3D;(10)P﹒10”&#x3D;10”&#x3D; 1(mod 9k)$，这说明有一个比 $x$ 更小的 $r$，矛盾。</li></ul><p>那么计算 $\phi(9k)$ 并枚举其因子 $d$，用快速幂判断 $10^d mod (9k)$ 是否等于1。这一做法只需要 $(\sqrt(k)log k )$ 的时间。</p><p><strong>一点优化</strong></p><p>由于 $n$ 的个位数是1，所以必然不是 2 的倍数和 5 的倍数。如果 $k$ 是 2 的倍数或 5 的倍数，那么必然无解，返回 —1。否则一定有解。</p><p>证明：根据算法二，在计算过程中必然会出现两个数模 $k$ 同余。设这两个数为 $a&#x3D;\frac{10^x-1}{9}$ 和 $b&#x3D;\frac{10^y-1}{9}$，且 $a &gt; b$。那么 $a-b$ 是 $k$ 的倍数。</p><p>注意 $a-b&#x3D;\frac{10^x-10^y}{9}&#x3D;10^y\cdot\frac{10^{x-y}-1}{9}$。$k$在没有因子 2 和 5 的情况下，要想整除上式，必须要整除 $\frac{10^{x-y}-1}{9}$，这说明 $n$ 的长度可以是 $x-y$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算欧拉函数（n 以内的与 n 互质的数的个数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phi</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = n</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            res = res // i * (i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n //= i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        res = res // n * (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> k % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        m = phi(k * <span class="number">9</span>)</span><br><span class="line">        <span class="comment"># 从小到大枚举不超过 sqrt(m) 的因子</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt;= m:</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">10</span>, i, k * <span class="number">9</span>) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从小到大枚举不低于 sqrt(m) 的因子</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">10</span>, m // i, k * <span class="number">9</span>) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> m // i</span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(\sqrt{k}\log k)$。计算 $\phi(9k)$ 和枚举 $\phi(9k)$ 的因子都需要 $\mathcal{O}(\sqrt{k})$ 的时间，对每个因子计算快速幂需要 $\mathcal{O}(\log k)$ 的时间，所以时间复杂度为 $\mathcal{O}(\sqrt{k}\log k)$。</li><li>空间复杂度：$\mathcal{O}(1)$。仅用到若干额外变量。</li></ul><h2 id="2-总持续时间可被-60-整除的歌曲"><a href="#2-总持续时间可被-60-整除的歌曲" class="headerlink" title="2 总持续时间可被 60 整除的歌曲"></a>2 总持续时间可被 60 整除的歌曲</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.3bcoupelrdk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/">https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p><strong>1. 组合数学</strong></p><p>遍历数组的同时用一个哈希表（或者数组）记录元素的出现次数。</p><p>遍历 $\textit{time}$：</p><ul><li>举例，如果 $\textit{time}[i]&#x3D;1$，那么需要知道左边有多少个模 60 余数是 59 的数。</li><li>举例，如果 $\textit{time}[i]&#x3D;62$，那么需要知道左边有多少个模 60 余数是 58 的数。</li><li>一般地，对于 $\textit{time}[i]$，需要知道左边有多少个模 60 余数是 $60-\textit{time}[i] mod 60$ 的数。<br>特别地，如果 $\textit{time}[i]$ 模 60 的余数是 0，那么需要知道左边有多少个模 60 余数也是 0 的数。<br>这两种情况可以合并为：累加左边 $(60-\textit{time}[i] mod 60) mod 60$ 的出现次数。</li></ul><p>代码实现时，用一个长为 60 的数组 $\textit{cnt}$ 维护 $\textit{time}[i] mod 60$ 的出现次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numPairsDivisibleBy60</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">60</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">            <span class="comment"># 先查询 cnt，再更新 cnt，因为题目要求 i&lt;j</span></span><br><span class="line">            <span class="comment"># 如果先更新，再查询，就把 i=j 的情况也考虑进去了</span></span><br><span class="line">            ans += cnt[(<span class="number">60</span> - t % <span class="number">60</span>) % <span class="number">60</span>]</span><br><span class="line">            cnt[t % <span class="number">60</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(n+U)$，其中 $n$ 为 $\textit{nums}$ 的长度，$U&#x3D;60$。</li><li>空间复杂度：$\mathcal{O}(U)$。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>三种算法+优化：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/">https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/</a></li><li>「两数之和」的本质是什么？：<a href="https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2259343/liang-shu-zhi-he-de-ben-zhi-shi-shi-yao-bd0r1/">https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2259343/liang-shu-zhi-he-de-ben-zhi-shi-shi-yao-bd0r1/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要结合LeetCode上的题目分析常用的取模运算、带余除法、鸽巢定理、组合数学的解题技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="LeetCode" scheme="https://qxienote.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数学（二）-- LC[204] 计数质数</title>
    <link href="https://qxienote.com/article/d3e16ec0.html"/>
    <id>https://qxienote.com/article/d3e16ec0.html</id>
    <published>2023-06-14T03:10:19.000Z</published>
    <updated>2023-06-14T03:25:32.934Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode[204] 计数质数，涉及的知识主要有质数的判断、枚举法、厄拉多塞筛算法</p><span id="more"></span><h2 id="1-计数质数"><a href="#1-计数质数" class="headerlink" title="1 计数质数"></a>1 计数质数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。</p><blockquote><p>示例 1：<br>输入：n &#x3D; 10<br>输出：4<br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p></blockquote><blockquote><p>示例 2：<br>输入：n &#x3D; 0<br>输出：0</p></blockquote><blockquote><p>示例 3：<br>输入：n &#x3D; 1<br>输出：0</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/count-primes/">https://leetcode.cn/problems/count-primes</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>方法一：枚举法（计算超时）</strong></p><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 $x$，我们可以从小到大枚举 $[2, −1]$ 中的每个数 $y$，判断 $y$ 是否为 $x$ 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 $O(n)$，无法通过所有测试数据。</p><p>考虑到如果 $y$ 是 $x$ 的因数，那么 $\frac{x}{y}$ 也必然是 $x$ 的因数，因此我们只要校验 $y$ 或者 $\frac{x}{y}$ 即可。而如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在 $[2, \sqrt(x)]$ 的区间中，因此我们只需要枚举  $[2, \sqrt(x)]$  中的所有数即可，这样单次检查的时间复杂度从 $O(n)$ 降低至了 $O(\sqrt(n))$。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">if</span> is_prime(i):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(n\sqrt(n))$。单个数检查的时间复杂度为$O(\sqrt(n))$，一共要检查 $O(n)$ 个数，因此总时间复杂度为：$O(n\sqrt(n))$。</li><li>空间复杂度：$O(1)$。</li></ul><p>做进一步的优化，首先素数的判断，没必要去除以 $[2, \sqrt(x)]$ 之间的所有数，寻找质数时，质数里除了2以外都是奇数，只需要遍历小于 $n$ 的奇数即可，虽然提高程序运行效率，但依然超时，毕竟复杂度的数量级没降下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">number</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;优化对素数的判断&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> number == <span class="number">2</span> <span class="keyword">or</span> number == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> number % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="built_in">int</span>(sqrt(number))+<span class="number">2</span>, <span class="number">6</span>):  </span><br><span class="line">                <span class="keyword">if</span> number % (i-<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">or</span> number % (i+<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n, <span class="number">2</span>):    <span class="comment"># 偶数除了2肯定不能是质数，只判断奇数</span></span><br><span class="line">            <span class="keyword">if</span> is_prime(i):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>方法二：厄拉多塞筛算法</strong></p><p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出，简称埃氏筛，也称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt(n)$以内的素数的倍数标记为 <strong>合数</strong>，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。厄拉多塞筛算法具体步骤如下：</p><ol><li>读取输入的数 n，将 2 到 n 的所有整数记录在表中</li><li>从 $i&#x3D;2$ 开始，划去表中所有 2 的倍数</li><li>由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数</li><li>重复第（3）步，直到找到的 $i$ 大于$\sqrt(n)$为止</li><li>表中所有未被划去的整数均为素数</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/001.4amrzpcmi3q0.webp#pic_center" width = 48%><p><strong>算法流程图：</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.4erghtl420w0.webp#pic_center" width = 36%><blockquote><p>一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。</p></blockquote><p>下面以所有不超过100的素数为例，因为小于等于10的所有素数为2、3、5、7，所以依次删除2、3、5、7的倍数。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.2bbbtx0zzuqs.gif#pic_center" width = 36%><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span>                  <span class="comment"># 不存在小于 2 的素数</span></span><br><span class="line">        flag_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        flag_list[:<span class="number">2</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):   <span class="comment">#  遍历 i=2 到 根号 n</span></span><br><span class="line">            <span class="keyword">if</span> flag_list[i]:                 <span class="comment"># 筛去 i 的倍数</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i*i, n, i):</span><br><span class="line">                    flag_list[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(flag_list)</span><br></pre></td></tr></table></figure><p>这里在筛去 $i$ 的倍数的时候，第一个数是 $i \times i$ 而不是 $i$，这是因为对于所有 $k\times i$，$k&lt;i$，都在前面被筛过，故可以跳过这些数。<code>return sum(flag_list)</code> 这里列表中每个质数位的值均为 1 ，其余合数位的值均为 0 ，<code>sum(flag_list)</code> 的结果就是 n 以内质数的个数。</p><p>进一步优化，第二个<code>for</code>循环是可以直接用列表的索引把质数的所有倍数所在的位置赋值为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        flag_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        flag_list[:<span class="number">2</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> flag_list[i]:</span><br><span class="line">                flag_list[i*i:n:i] = [<span class="number">0</span>] * ((n - i * i - <span class="number">1</span>) // i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(flag_list)</span><br></pre></td></tr></table></figure><p> <code>flag_list[i*i:n:i] = [0] * ((n - i * i - 1) // i + 1)</code> 指定步长参数，进行列表切片赋值，这里要计算好列表切片取出多少个值。</p><p> <strong>温馨提示：</strong> 使用 python 时间和空间效率都较低，对于标记素数，可以采用 c++ 的 bitset，bitset 是以比特为单位标记的，会极大降低存储消耗。可以参考：<a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-bao-li-fa-ji-you-hua-shai-fa-ji-you/">运用比特表（Bitmap）算法对筛法进行内存优化</a></p><p><strong>小结：</strong> 厄拉多塞筛算法的核心就是要得到自然数 n 以内的全部质数，必须把不大于 根号n 的所有质数的倍数剔除，剩下的就是质数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode[204] 计数质数，涉及的知识主要有质数的判断、枚举法、厄拉多塞筛算法&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://qxienote.com/categories/LeetCode/"/>
    
    <category term="Math" scheme="https://qxienote.com/categories/LeetCode/Math/"/>
    
    
    <category term="LeetCode" scheme="https://qxienote.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十五）-- 二叉树的遍历：深度优先搜索与广度优先搜索</title>
    <link href="https://qxienote.com/article/49dac87b.html"/>
    <id>https://qxienote.com/article/49dac87b.html</id>
    <published>2023-06-11T10:01:24.000Z</published>
    <updated>2023-06-13T15:24:38.027Z</updated>
    
    <content type="html"><![CDATA[<p>本篇带你走进二叉树，使用深度优先搜索和广度优先搜索思想进行二叉树的顺序遍历和层序遍历，带你刷遍LeetCode上的二叉树遍历题目。</p><span id="more"></span><p>本篇开始总结二叉树的常用解题技巧，二叉树的顺序遍历和层序遍历刚好对应深度优先搜索和广度优先搜索。</p><h2 id="1-顺序遍历"><a href="#1-顺序遍历" class="headerlink" title="1 顺序遍历"></a>1 顺序遍历</h2><p><strong>题目列表</strong></p><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank">144. 前序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank">145. 二叉树的后序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">94. 二叉树的中序遍历</a></p></li></ul></blockquote> <p><strong>144. 二叉树的前序遍历</strong><br>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.6ualntxoeg80.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><p>递归算法三要素：确定递归函数的参数和返回值、确定终止条件、确定单层递归的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            result.append(root.val)                 <span class="comment"># 先将根节点值加入结果</span></span><br><span class="line">            <span class="keyword">if</span> root.left: traversal(root.left)      <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">if</span> root.right: traversal(root.right)    <span class="comment"># 右</span></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result </span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.f5i9bhxllkg.gif#pic_center" width = 48%><p><strong>94. 二叉树的中序遍历</strong></p><p>给你二叉树的根节点 root ，返回它节点值的 中序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.5jrflywetw00.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traversal(root.left)    <span class="comment"># 左</span></span><br><span class="line">            result.append(root.val) <span class="comment"># 中序</span></span><br><span class="line">            traversal(root.right)   <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:    <span class="keyword">return</span> []   <span class="comment"># 空树</span></span><br><span class="line">        stack = []                  <span class="comment"># 不能提前将root结点加入stack中&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:                 <span class="comment"># 先迭代访问最底层左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 到达最左节点后处理栈顶结点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right     <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.6tugbwc3y2s0.gif#pic_center" width = 48%><p><strong>145. 二叉树的后序遍历</strong><br>给你二叉树的根节点 root ，返回它节点值的 后序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.25hp5m11l5s0.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            self.traversal(root.left)               <span class="comment"># 左</span></span><br><span class="line">            self.traversal(root.right)              <span class="comment"># 右</span></span><br><span class="line">            self.result.append(root.val)            <span class="comment"># 中</span></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.3e8o26ewkj20.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="3-层序遍历"><a href="#3-层序遍历" class="headerlink" title="3 层序遍历"></a>3 层序遍历</h2><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank">102. 二叉树的层序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank">107. 二叉树的层次遍历II</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank">199. 二叉树的右视图</a></p></li><li><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank">637.二叉树的层平均值</a></p></li><li><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank">429. N叉树的层序遍历/a></p></li><li><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank">515. 在每个树行中找最大值</a></p></li><li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank">116. 填充每个节点的下一个右侧节点指针</a></p></li><li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank">117.填充每个节点的下一个右侧节点指针II</a></a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank">104. 二叉树的最大深度</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank">111. 二叉树的最小深度</a></p></li></ul></blockquote> <p><strong>102. 二叉树的层序遍历</strong></p><p>给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.6wjqhxodwm80.webp#pic_center" width = 48%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p></blockquote><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.6gyzeourbyc0.gif#pic_center" width = 64%><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 二叉树层序遍历迭代解法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):       <span class="comment"># 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的</span></span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><p>用广度优先处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.96gmi09otqg.webp#pic_center" width = 36%><p>我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个 list。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.ka118nd4zgw.webp#pic_center" width = 36%><p>按照深度优先的处理顺序，会先访问节点 1，再访问节点 2，接着是节点 3。 之后是第二列的 4 和 5，最后是第三列的 6。</p><p>每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。</p><p>动态演示如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.26ehjiwrja80.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 假设 res 是 [[1], [2,3]]， level 是 3，就再插入一个 [root.val] 放到 res 中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将当前节点的值加入到res中，level 代表当前层，假设 level 是 3，节点值是 99</span></span><br><span class="line">    <span class="comment"># res 是 [[1], [2,3], [4]]，加入后 res 就变为 [[1], [2,3], [4,99]]</span></span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            <span class="comment"># 递归的处理左子树，右子树，同时将层数 level+1</span></span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>107. 二叉树的层次遍历II</strong></p><p>给你二叉树的根节点 root ，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5xg8urhe4hw0.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        results.reverse()</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>) </span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>199. 二叉树的右视图</strong></p><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.17zbfv1u8sqo.webp#pic_center" width = 36%><blockquote><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># deque 相比list的好处是，list的 pop(0) 是 O(n) 复杂度，deque 的 popleft() 是 O(1) 复杂度</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            res.append(que[-<span class="number">1</span>].val)         <span class="comment"># 每次都取最后一个node就可以</span></span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):           <span class="comment"># 执行这个遍历的目的是获取下一层所有的node</span></span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>637. 二叉树的层平均值</strong></p><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.57u4p7etgy40.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><p>从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p><p>如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：</p><ul><li>初始时，将根节点加入队列；</li><li>每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。</li></ul><p>由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。</p><p>具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 $\textit{size}$，遍历时只遍历 $\textit{size}$ 个节点，即可满足每一轮遍历的是同一层的全部节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                total += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">            result.append(total/size)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><p>使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，$\textit{counts}$ 用于存储二叉树的每一层的节点数，$\textit{sums}$ 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 $i$ 层，则将 $\textit{counts}[i]$ 的值加 1，并将该节点的值加到 $\textit{sums}[i]$。</p><p>遍历结束之后，第 $i$ 层的平均值即为 $\textit{sums}[i] &#x2F; \textit{counts}[i]$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode], level: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(total) &lt; level:          </span><br><span class="line">                total.append(root.val)</span><br><span class="line">                count.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total[level-<span class="number">1</span>] += root.val</span><br><span class="line">                count[level-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        count, total = [], []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> [t/c <span class="keyword">for</span> t, c <span class="keyword">in</span> <span class="built_in">zip</span>(total, count)]</span><br></pre></td></tr></table></figure><p><strong>429. N叉树的层序遍历</strong></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.6di4q19r8ac0.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="comment"># cur.children 是 Node 对象组成的列表，也可能为 None</span></span><br><span class="line">                <span class="keyword">if</span> node.children:</span><br><span class="line">                    que.extend(node.children)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                dfs(child, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>515. 在每个树行中找最大值</strong></p><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.6b1t4g5prm40.webp#pic_center" width = 36%><blockquote><p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">             size = <span class="built_in">len</span>(que)</span><br><span class="line">             max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">             <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                 node = que.popleft()</span><br><span class="line">                 max_value = <span class="built_in">max</span>(max_value, node.val)</span><br><span class="line">                 <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                 <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">             res.append(max_value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>] = (<span class="built_in">max</span>(root.val, res[level-<span class="number">1</span>]))</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>116. 填充每个节点的下一个右侧节点指针</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.29xb4d83sgis.webp#pic_center" width = 64%><p><strong>方法一：层序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span>        <span class="comment"># 这里空树，直接返回None</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>: <span class="keyword">break</span>          <span class="comment"># 遍历到最右边，结束本行循环</span></span><br><span class="line">                cur.<span class="built_in">next</span> = que[<span class="number">0</span>]           <span class="comment"># 指向同一行的右边节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>117. 填充每个节点的下一个右侧节点指针 II</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.2g4tll9f5pxc.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size =  <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> i == size-<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">                cur.<span class="built_in">next</span> = que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>104. 二叉树的最大深度</strong></p><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><ul><li>说明: 叶子节点是指没有子节点的节点。</li><li>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></li></ul><p>返回它的最大深度 3。</p><p><strong>方法一：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><strong>方法二：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># DFS 自底向上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 感受一下这里是将最底层的结果往上抛</span></span><br><span class="line">        <span class="comment"># 因为这里的递归边界条件是叶子节点</span></span><br><span class="line">        left_height = self.maxDepth(root.left)</span><br><span class="line">        right_height = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># DFS 自顶向下</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, depth</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res = <span class="built_in">max</span>(res, depth)</span><br><span class="line">            dfs(root.left, depth+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, depth+<span class="number">1</span>)</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>自顶向下：直接return 函数调用自身下一级实现，比如 <code>return Fibonacci(n-1) + Fibonacci(n-2)</code>;</li><li>自底向上：先递归到最小单位(叶子节点)，再从最小单位往上抛结果，传递结果</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.2dn4dh1cdzms.gif#pic_center" width = 49%> <p><strong>111. 二叉树的最小深度</strong></p><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><ul><li>说明：叶子节点是指没有子节点的节点。</li><li>示例 1：</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.69r8h85mqxc0.webp#pic_center" width = 48%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p></blockquote><p><strong>方法一：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_depth = <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.left), min_depth)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.right), min_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>方法二：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        que = collections.deque([(root, <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            node, depth = que.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                que.append((node.left, depth + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                que.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>二叉树遍历暂时告一段落，但还有很多自己不满意的地方，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.58rb9k1endc0.gif#pic_center" width = 48%><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇带你走进二叉树，使用深度优先搜索和广度优先搜索思想进行二叉树的顺序遍历和层序遍历，带你刷遍LeetCode上的二叉树遍历题目。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先遍历" scheme="https://qxienote.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
    <category term="广度优先遍历" scheme="https://qxienote.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十四）-- 冒泡排序算法</title>
    <link href="https://qxienote.com/article/234fdd80.html"/>
    <id>https://qxienote.com/article/234fdd80.html</id>
    <published>2023-06-11T10:00:54.000Z</published>
    <updated>2023-06-14T03:08:02.680Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p><span id="more"></span><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p><p>当一趟操作完成时，序列中最大的未排序元素就被放置到了所有未排序的元素中最后的位置上，它就像水中的石块一样沉到了水底。而其它较小的元素则被移动到了序列的前面，就像水中的气泡冒到了水面一样。这就是为什么该算法被叫做冒泡排序的原因。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/028.3mbc0z7sie60.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/028.3mbc0z7sie60.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图1  冒泡排序的基本原理</div> </center><hr><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1.1 算法原理"></a>1.1 算法原理</h3><p>图1展示了冒泡排序的基本原理。假设一个序列中共有 n 个元素，那么上面的比较和交换过程一共需要进行$n-1$趟：</p><ul><li>第一趟需要比较序列中的所有元素，它的效果是将整个序列中最大的元素放置到了序列最后一个位置上。</li><li>第二趟只需要比较前面$n-1$个元素，因为前一趟中已经将最大的元素移到了它最终的位置上了。这一趟结束时，整个序列中第二大的元素就被放置到了倒数第二个位置上。</li><li>同样的，第三趟只需要比较前面$n-2$个元素。该趟结束时，序列中第三大的元素就被放到了倒数第三个位置上。<br>当进行第$i$趟的时候，需要比较的是前面$n-(i-1)$个元素，因为序列中最大的$i-1$个元素已经在前面的$i-1$趟排序中被排好了。注意，比较 $n-(i-1)$个元素需要进行$n-i$次比较。</li><li>当最终到达第$n-1$趟的时候，只需要比较序列中最前面的两个数而已。该趟结束时，序列中第二小的数就被放置到了顺数第二个位置上。同时，序列中最小的数也被放到了第一个位置上。整个排序过程完成。</li></ul><p>从以上对算法原理的讲解中，我们首先可以知道冒泡排序是一种交换排序，它需要进行大量的交换操作。其次，因为当两个元素相等时它们不会被交换，所以相等元素的相对位置在排序前后不会改变，因此冒泡排序又是一种稳定的排序算法。</p><p>假设待排序序列为[5,1,4,2,8]，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：</p><ol><li><p>第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图2所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.6dqaxm0x0p40.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.6dqaxm0x0p40.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图2  第一轮排序（白色字体表示参与比较的一对相邻元素）</div> </center>从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。</li><li><p>第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图3所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.8ij9ffq6n24.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.8ij9ffq6n24.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图3  第二轮排序</div> </center></li></ol><p>可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol><li>第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图4所示。<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.5aimida0q180.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.5aimida0q180.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图4  第三轮排序</div> </center></li></ol><p>经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol><li><p>第四轮排序，此时待排序序列包含前 2 个元素，对其进行冒泡排序的整个过程如图5所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.6ptwpdge2h00.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.6ptwpdge2h00.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图5  第四轮排序</div> </center>经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。</li><li><p>当进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列（如图6所示）。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.4t75fyuqob60.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.4t75fyuqob60.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图6  冒泡排序好的序列</div> </center></li></ol><p><strong>代码一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]        <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)     <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面n-(i-1)个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><h3 id="1-2-性能分析"><a href="#1-2-性能分析" class="headerlink" title="1.2 性能分析"></a>1.2 性能分析</h3><p>由上面的排序步骤可知：$N$个数字要排序完成，总共进行$N-1$趟排序，每$i$趟的排序次数为$(N-i)$次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><p>冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，每进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p><p>时间复杂度：1）如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数$C$和记录移动次数$M$均达到最小值，即：$C_{min}&#x3D;n-1; M_{min}&#x3D;0$；所以，冒泡排序最好的时间复杂度为$O(n)$；2）如果很不幸我们的数据是反序的，则需要进行$n-1$趟排序。每趟排序要进行$n-i$次比较($1≤i≤n-1$)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$$C_{max}&#x3D;\frac{n(n-1)}{2}&#x3D;O(n^2)\<br>M_{max}&#x3D;\frac{3n(n-1)}{2}&#x3D;O(n^2)$$</p><p>综上所述：冒泡排序总的平均时间复杂度为：$O(n^2)$时间复杂度和数据状况无关。</p><hr><h2 id="2-算法优化"><a href="#2-算法优化" class="headerlink" title="2 算法优化"></a>2 算法优化</h2><h3 id="2-1-第一次优化"><a href="#2-1-第一次优化" class="headerlink" title="2.1 第一次优化"></a>2.1 第一次优化</h3><p>因为冒泡排序必须要在最终位置找到之前不断交换数据项，所以它经常被认为是最低效的排序方法。这些“浪费式”的交换操作消耗了许多时间。比如序列中的元素有可能出现这样的情况，即经过前面几趟的排序后整个序列就已经排好序了，那么后面的那几趟排序就不需要再执行了。但是我们上面的第一版的冒泡排序即便是在这种情况下，仍然会执行所有的$n-1$趟的排序。即使后面几趟排序只进行比较而不需交换元素，但是当数据量很大的时候，这依旧会造成整体性能的明显下降。</p><p>因此，我们首先想到的优化方案就是当某一趟排序之后，如果整个序列已排好序了，那么就立即退出函数。这要怎么实现呢？其实很简单，只要在某一趟的排序中没有进行任何一次的元素交换，那么此时整个序列就排好序了。</p><p>因此，在每一趟排序的开始将一个标记<code>swapped</code>设置为<code>False</code>。在这一趟排序过程中，如果发生了数据交换，那么就将<code>swapped</code>设置为<code>True</code>。当这一趟排序结束，我们通过检查该<code>swapped</code>的值就可以知道整个序列是否已经排好序了。</p><p>假设我们有一个序列，它的元素分别为整数9、4、6、15、13。那么图7至图8则展示了经本次优化后的冒泡排序的完整执行过程。注意，虽然第一趟排序后整个序列就排好序了，但在第一趟排序中进行了元素交换（<code>swapped</code>被设置为<code>True</code>），算法此时并不知道整个序列已经排好了，所以还要进行第二趟排序。在第二趟排序中，不会进行任何元素交换（<code>swapped</code>最终为<code>False</code>），此时算法才知道整个序列已经是排好序了的。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.2rojc9iqteg0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.2rojc9iqteg0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%>  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图7  [9,4,6,15,13] 第1趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.33chi518g6e0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.33chi518g6e0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图8  [9,4,6,15,13] 第2趟排序</div> </center><p>综上，如果一个列表只需要几次遍历就可排好，冒泡排序就占有优势：它可以在发现列表已排好时立刻结束。代码二就是改良版冒泡排序。它通常被称作“短路冒泡排序”。<br><strong>代码二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;第一次优化&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False，False表示为交换，True表示交换</span></span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面n-(i-1)个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>在最好的情况下，第二版冒泡排序只需进行$n-1$次比较和0次元素移动；在最坏的情况下，还是进行$n(n-1)&#x2F;2$次比较和$3n(n-1)&#x2F;2$次元素移动。虽然这一版的冒泡排序的时间复杂度依旧是$O(n^2)$，但是和第一版相比肯定性能上更好。</p><h3 id="2-2-第二次优化"><a href="#2-2-第二次优化" class="headerlink" title="2.2 第二次优化"></a>2.2 第二次优化</h3><p>在我们之前的想法中，当进行第$i$趟排序时，序列中只有最大的$i-1$个元素已经排好序了。因为那时我们认为每一趟仅排好一个元素，即它比较的所有元素中最大的那一个。因此第$i$趟排序的时候，需要对前面$n-(i-1)$个元素进行比较和交换。但其实此时这前$n-(i-1)$个元素中可能最大的那几个元素已经在它们最终的位置上了，这时第$i$趟实际需要比较的元素个数就可以小于$n-(i-1)$。</p><p>比如有一个序列24、30、12、40、50，那么第1趟排序之后的结果为24、12、30、40、50。在原来的想法中，第2趟需要比较前面4个数。但此时前4个数中最大的两个30和40已经在它们最终的位置上了，不需要再对它们进行位置上的调整。因此，第2趟可以只比较前两个数。</p><p>注意这个例子中，虽然在序列的初始状态中40和50就已经在它们最终的位置上了，但第1趟排序还是需要比较全部的5个数。因为此时没有任何信息可以将序列的这种特殊状态告知算法，某一趟是否可以执行比它原本理论上更少的比较次数，需要前一趟排序对序列状态的了解。</p><p>在每一趟排序中，我们都用一个变量<code>last_index</code>记录下本趟排序最后一次元素交换中前一个元素的下标。在该下标之后没有发生交换，说明该下标之后的所有元素都已经排好序了。那么下一趟排序就只需要对该下标及其之前的元素进行比较而已。这样下一趟排序需要比较的次数可能比原本需要的次数更少，也就在一定程度上提升了算法的效率。<br><strong>代码三：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    last_index = length - <span class="number">1</span><span class="comment"># 记录每一趟中最后一次交换中前一个元素的下标，他的初值为n-1</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False，False表示为交换，True表示交换</span></span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面last_index+1个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(last_index):</span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">                last_index = j  <span class="comment"># 记录本次交换中前一个元素的下标</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>图9至图11详细展示了经过第二次优化后的冒泡排序对[24, 30, 12, 40, 50]这个序列的执行情况。该例子中另一个值得注意的问题是，虽然在第2趟排序后整个序列就已经排好序了，但是第2趟中进行了一次元素交换而导致<code>swapped</code>等于<code>True</code>。因此第2趟后并不会立即退出函数，还要进行第3趟排序。在第3趟中内层循环不会执行而立即退出，因为此时<code>last_index</code>等于0，<code>j</code>（此时也等于0）小于<code>last_index</code>的条件不满足。在第3趟最后<code>swapped</code>为<code>False</code>，此时才退出算法。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.47232a8lqkq0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.47232a8lqkq0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图9  [24, 30, 12, 40, 50] 第1趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3yaeqpkaep40.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3yaeqpkaep40.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图10  [24, 30, 12, 40, 50] 第2趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.jbnxksu0sxk.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.jbnxksu0sxk.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图11  [24, 30, 12, 40, 50] 第3趟排序</div> </center><h3 id="2-3-鸡尾酒排序"><a href="#2-3-鸡尾酒排序" class="headerlink" title="2.3 鸡尾酒排序"></a>2.3 鸡尾酒排序</h3><p><a href="https://baike.baidu.com/item/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/7515196#:~:text=%E9%B8%A1%E5%B0%BE%E9%85%92%20%E6%8E%92%E5%BA%8F%E5%8F%88%E7%A7%B0%E5%8F%8C%E5%90%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%B8%A1%E5%B0%BE%E9%85%92%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F%E3%80%81%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F%E3%80%81%E6%B6%9F%E6%BC%AA%E6%8E%92%E5%BA%8F%E3%80%81%E6%9D%A5%E5%9B%9E%E6%8E%92%E5%BA%8F%E6%88%96%E5%BF%AB%E4%B9%90%E5%B0%8F%E6%97%B6%E6%8E%92%E5%BA%8F,,%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%98%E5%BD%A2%E3%80%82%20%E8%AF%A5%E7%AE%97%E6%B3%95%E4%B8%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E5%9C%A8%E4%BA%8E%E6%8E%92%E5%BA%8F%E6%97%B6%E6%98%AF%E4%BB%A5%E5%8F%8C%E5%90%91%E5%9C%A8%E5%BA%8F%E5%88%97%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E3%80%82%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%9C%AC%E6%98%AF%E6%97%A0%E8%A7%84%E5%BE%8B%E7%9A%84%E6%8E%92%E6%94%BE%EF%BC%8C%E5%85%88%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E6%8A%8A%E4%BB%96%E6%94%BE%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E3%80%82">鸡尾酒排序</a>又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。因此，根据名字可以看到搅拌排序的原理，每次都是从左往右，交换相邻的元素，从而达到循环一边可以把最大的元素放在右边。而双向冒泡排序，在完成一次从左往右的冒泡排序后，再从右往左进行冒泡，从而把小的元素放在左边。<br>下面这张图可以很好地表达：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.5othrnnkxjg0.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.5othrnnkxjg0.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图12 双向排序动图演示</div> </center><p><strong>代码四：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cocktail_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;搅拌排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(length/<span class="number">2</span>)):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False</span></span><br><span class="line">        <span class="comment"># 正向：把当前循环最大的放到最右边</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">        <span class="keyword">if</span> swapped:</span><br><span class="line">            swapped = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 反向：把当前循环最小的放到最右边</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(length-i-<span class="number">1</span>, i-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> items[k-<span class="number">1</span>] &gt; items[k]:</span><br><span class="line">                    items[k], items[k-<span class="number">1</span>] = items[k-<span class="number">1</span>], items[k]</span><br><span class="line">                    swapped = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><hr><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h3><ul><li>图文详解冒泡排序：<a href="https://baijiahao.baidu.com/s?id=1662238914941980592&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1662238914941980592&wfr=spider&for=pc</a></li><li>Python 冒泡排序：<a href="https://www.runoob.com/python3/python-bubble-sort.html">https://www.runoob.com/python3/python-bubble-sort.html</a></li><li>冒泡排序算法：<a href="http://c.biancheng.net/view/6506.html">http://c.biancheng.net/view/6506.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="冒泡排序" scheme="https://qxienote.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    <category term="搅拌排序" scheme="https://qxienote.com/tags/%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十三）-- 位运算与使用技巧</title>
    <link href="https://qxienote.com/article/e701713c.html"/>
    <id>https://qxienote.com/article/e701713c.html</id>
    <published>2023-06-11T10:00:29.000Z</published>
    <updated>2023-06-13T15:01:04.617Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习Python中的二进制运算，通过位运算实现乘除法、交换两数、判断奇偶数、交换符号、求绝对值、二进制逆序、统计二进制中1的个数，最后结合LeetCode常见题目进行练习。</p><span id="more"></span><p>计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。</p><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1 操作符"></a>1 操作符</h2><h3 id="1-1-基本运算"><a href="#1-1-基本运算" class="headerlink" title="1.1 基本运算"></a>1.1 基本运算</h3><ul><li>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">&amp;  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">------------------------------   </span><br><span class="line">   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><ul><li>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">|   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">------------------------------   </span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><ul><li>^ 异或运算，两个位相同则为 0，不同则为 1，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">^   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">-----------------------------   </span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><ul><li>~ 取反运算，0 则变为 1，1 则变为 0，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">-----------------------------   </span><br><span class="line">   <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ​</span><br></pre></td></tr></table></figure><h3 id="1-2-左移操作-lt-lt-与-右移操作-gt-gt"><a href="#1-2-左移操作-lt-lt-与-右移操作-gt-gt" class="headerlink" title="1.2 左移操作&lt;&lt; 与 右移操作&gt;&gt;"></a>1.2 左移操作&lt;&lt; 与 右移操作&gt;&gt;</h3><p><strong>左移操作</strong><br>左移操作，左移一位相当于乘以 b，<code>a&lt;&lt;b, a&#39; = a*(2^b)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&lt;&lt;<span class="number">3</span>)     <span class="comment"># 2*2^3 = 16，2的二进制10，向左移动3位后10000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&lt;&lt;<span class="number">1</span>)     <span class="comment"># 2*2^1 = 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&lt;&lt;<span class="number">4</span>)     <span class="comment"># 3*2^4 = 48,3的二进制为11，向左移动四位后110000</span></span><br></pre></td></tr></table></figure><p><strong>右移操作</strong><br>右移操作，右移一位相当于除以 b，<code>a&gt;&gt;b, a&#39; = a//(2^b)</code>注意这里是整除，当向右移动位数大于能移动的位数时，置为0【可以理解为会将尾巴截掉】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&gt;&gt;<span class="number">3</span>)     <span class="comment"># 2//2^3 = 0，2的二进制10，向右最多移动2位后，所以多移动无疑为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&gt;&gt;<span class="number">1</span>)     <span class="comment"># 2//2^1 = 1，向右移动一位为 01,</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&gt;&gt;<span class="number">4</span>)     <span class="comment"># 3//2^4 = 0, 3 的二进制为11，向右移动四位后00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&gt;&gt;<span class="number">1</span>)     <span class="comment"># 3//2^1 = 1, 3 的二进制为11，向右移动一位后为01</span></span><br></pre></td></tr></table></figure><blockquote><p>$&gt;&gt;$ 和 $&lt;&lt;$ 都是位运算，对二进制数进行移位操作。$&lt;&lt;$ 是左移，末位补 0，类比十进制数在末尾添 0 相当于原数乘以 10，$x&lt;&lt;1$ 是将 $x$ 的二进制表示左移一位，相当于原数 $x$ 乘 2。比如整数 4 在二进制下是100，$4&lt;&lt;1$ 左移1位变成1000(二进制)，结果是 8。$&gt;&gt;$ 是右移，右移1位相当于除以2。<br><br></br><br>而 $&gt;&gt;&#x3D;$ 和 $&lt;&lt;&#x3D;$，就是对变量进行位运算移位之后的结果再赋值给原来的变量，可以类比赋值运算符 $+&#x3D;$ 和 $-&#x3D;$ 可以理解。比如 $x&gt;&gt;&#x3D;2$， 就是把变量 $x$ 右移2位，再保留x操作后的值。</p></blockquote><h2 id="2-常见位运算问题"><a href="#2-常见位运算问题" class="headerlink" title="2 常见位运算问题"></a>2 常见位运算问题</h2><h3 id="2-1-位操作实现乘除法"><a href="#2-1-位操作实现乘除法" class="headerlink" title="2.1 位操作实现乘除法"></a>2.1 位操作实现乘除法</h3><p>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">a &gt;&gt; <span class="number">1</span>  <span class="comment"># 1</span></span><br><span class="line">a &lt;&lt; <span class="number">1</span>  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h3 id="2-2-位操作交换两数"><a href="#2-2-位操作交换两数" class="headerlink" title="2.2 位操作交换两数"></a>2.2 位操作交换两数</h3><p>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a         <span class="comment"># 普通操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位操作</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li>第一步：a ^&#x3D; b —&gt; a &#x3D; (a^b)</li><li>第二步：b ^&#x3D; a —&gt; b &#x3D; b^(a^b) —&gt; b &#x3D; (b^b)^a &#x3D; a</li><li>第三步：a ^&#x3D; b —&gt; a &#x3D; (a^b)^a &#x3D; (a^a)^b &#x3D; b</li></ul><h3 id="2-3-位操作判断奇偶数"><a href="#2-3-位操作判断奇偶数" class="headerlink" title="2.3 位操作判断奇偶数"></a>2.3 位操作判断奇偶数</h3><p>要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;偶数&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-位操作交换符号"><a href="#2-4-位操作交换符号" class="headerlink" title="2.4 位操作交换符号"></a>2.4 位操作交换符号</h3><p>交换符号将正数变成负数，负数变成正数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversal</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> ~a + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><h3 id="2-5-位操作求绝对值"><a href="#2-5-位操作求绝对值" class="headerlink" title="2.5 位操作求绝对值"></a>2.5 位操作求绝对值</h3><p>正数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1，即 <code>0xffffffff</code>），然后根据符号进行相应的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">a</span>):</span><br><span class="line">    i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> (~a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面的操作可以进行优化，可以将 i &#x3D;&#x3D; 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i &#x3D; 0 为正，i &#x3D; -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 <code>0xffffffff</code> 进行异或就相当于对此数进行取反，因此可以将上面三目元算符转换为 <code>((a^i)-i)</code>，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 <code>0xffffffff</code> 异或将 a 进行取反，然后在加上 1，即减去 i(i &#x3D;-1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs2</span>(<span class="params">a</span>):</span><br><span class="line">     i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">     <span class="keyword">return</span> ((a^i)-i)</span><br></pre></td></tr></table></figure><h3 id="2-6-位操作进行高低位交换"><a href="#2-6-位操作进行高低位交换" class="headerlink" title="2.6 位操作进行高低位交换"></a>2.6 位操作进行高低位交换</h3><p>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">将其高<span class="number">8</span>位与低<span class="number">8</span>位进行交换，得到一个新的二进制数：</span><br><span class="line"><span class="number">11011000</span> <span class="number">10000110</span></span><br><span class="line">其十进制为<span class="number">55430</span></span><br></pre></td></tr></table></figure><p>从上面移位操作我们可以知道，只要将无符号数 <code>a &gt;&gt; 8</code> 即可得到其高 8 位移到低 8 位，高位补 0；将 <code>a &lt;&lt; 8</code> 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 <code>a &gt;&gt; 8</code> 和 <code>a &lt;&lt; 8</code> 进行或操作既可求得交换后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34520</span></span><br><span class="line">a = (a &gt;&gt; <span class="number">8</span>) | (a &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-位操作进行二进制逆序"><a href="#2-7-位操作进行二进制逆序" class="headerlink" title="2.7 位操作进行二进制逆序"></a>2.7 位操作进行二进制逆序</h3><p>将无符号数的二进制表示进行逆序，求取逆序后的结果，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数<span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">逆序后则为：</span><br><span class="line">00011011 01100001</span><br><span class="line">它的十进制为<span class="number">7009</span></span><br></pre></td></tr></table></figure><p>在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。</p><ul><li>第一步：以每 2 位为一组，组内进行高低位交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">10</span> <span class="number">00</span> 01 <span class="number">10</span> <span class="number">11</span> 01 <span class="number">10</span> <span class="number">00</span></span><br><span class="line">交换后： 01 <span class="number">00</span> <span class="number">10</span> 01 <span class="number">11</span> <span class="number">10</span> 01 <span class="number">00</span></span><br></pre></td></tr></table></figure></li><li>第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">0</span>100 <span class="number">1001</span> <span class="number">1110</span> <span class="number">0</span>100</span><br><span class="line">交换后： 0001 0110 <span class="number">1011</span> 0001</span><br></pre></td></tr></table></figure></li><li>第三步：以每 8 位为一组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">000</span>10110 <span class="number">10110001</span></span><br><span class="line">交换后： 01100001 00011011</span><br></pre></td></tr></table></figure></li><li>第四步：以每16位为一组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： 0110000100011011</span><br><span class="line">交换后： 0001101101100001</span><br></pre></td></tr></table></figure></li></ul><p>对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原数：  <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位： <span class="number">10000010</span> <span class="number">10001000</span></span><br><span class="line">偶数位： <span class="number">00000</span>100 <span class="number">0</span>1010000</span><br></pre></td></tr></table></figure><p>再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原数：  <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位右移一位： <span class="number">0</span> <span class="number">10000010</span> <span class="number">1000100</span></span><br><span class="line">偶数位左移一位：<span class="number">0000</span>100 <span class="number">0</span>1010000 <span class="number">0</span></span><br><span class="line">两数相或得到： <span class="number">0</span>1001001 <span class="number">11100100</span></span><br></pre></td></tr></table></figure><p>上面的方法用位操作可以表示为：</p><ul><li>取 a 的奇数位并用 0 进行填充可以表示为：<code>a &amp; 0xAAAA</code></li><li>取 a 的偶数为并用 0 进行填充可以表示为：<code>a &amp; 0x5555</code> 因此，上面的第一步可以表示为：<br><code>a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1)</code></li></ul><p>同理，可以得到其第二、三和四步为：</p><ul><li>a &#x3D; ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2)</li><li>a &#x3D; ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4)</li><li>a &#x3D; ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8)</li></ul><p>因此整个操作为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34520</span>;</span><br><span class="line">a = ((a &amp; <span class="number">0xAAAA</span>) &gt;&gt; <span class="number">1</span>) | ((a &amp; <span class="number">0x5555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xCCCC</span>) &gt;&gt; <span class="number">2</span>) | ((a &amp; <span class="number">0x3333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xF0F0</span>) &gt;&gt; <span class="number">4</span>) | ((a &amp; <span class="number">0x0F0F</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) | ((a &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="2-8-位操作统计二进制中-1-的个数"><a href="#2-8-位操作统计二进制中-1-的个数" class="headerlink" title="2.8 位操作统计二进制中 1 的个数"></a>2.8 位操作统计二进制中 1 的个数</h3><p>统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &amp;&#x3D; (a-1)的结果：</p><ul><li>第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000</li><li>第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000</li><li>第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000</li></ul><p>我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(a):</span><br><span class="line">    a = a &amp; (a-<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.3l5z91u11180.webp#pic_center" width = 36%><h3 id="2-9-原码、反码、补码"><a href="#2-9-原码、反码、补码" class="headerlink" title="2.9 原码、反码、补码"></a>2.9 原码、反码、补码</h3><p>机器数：一个数在计算机中的二进制表示形式，机器数带符号，在计算机用一个数的最高位存放符号，正数为0，负数为1</p><blockquote><p>例如： 十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011。其中，00000011 和 10000011就是机器数</p></blockquote><p>真值：将带符号位的机器数对应的真正数值称为机器数的真值。</p><p><strong>1. 原码</strong></p><p>原码就是符号位加上真值的绝对值，即用第一位表示符号, 其余位表示值。例如：如果是8位二进制，那么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>]原 = <span class="number">0000</span> 0001</span><br><span class="line">[-<span class="number">1</span>]原 = <span class="number">1000</span> 0001</span><br></pre></td></tr></table></figure><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1111</span> <span class="number">1111</span>, 0111 <span class="number">1111</span>]</span><br><span class="line">[-<span class="number">127</span>, <span class="number">127</span>]</span><br></pre></td></tr></table></figure><p><font color=#9900CC><strong>原码在展示上是与机器数相同的</font></strong></p><p><strong>2. 反码</strong></p><p>反码的表示方法是:</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [00000001]原 = [00000001]反</span><br><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反</span><br></pre></td></tr></table></figure><p><strong>3. 补码</strong></p><p>补码的表示方法是:</p><ul><li>正数的补码就是其本身</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。(即在反码的基础上+1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。不管 n 是正数还是负数，只需要下面的语句便可得到此数的补码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(n &amp; <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><p>了解更多，请移步：<a href="https://zhuanlan.zhihu.com/p/106535460">原码反码补码的通俗解释</a></p><h3 id="2-10-进制之间的转换"><a href="#2-10-进制之间的转换" class="headerlink" title="2.10 进制之间的转换"></a>2.10 进制之间的转换</h3><p>二进制、八进制、十进制、十六进制转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(-<span class="number">10</span>))         <span class="comment"># &#x27;-0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0o12&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0xa&#x27;</span></span><br><span class="line">a = <span class="number">0b1010</span></span><br><span class="line">b = <span class="number">0x11</span></span><br><span class="line">x = <span class="string">&#x27;1010&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;11&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)                <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(x, <span class="number">2</span>))        <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(b)                <span class="comment"># 17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(y, <span class="number">16</span>))       <span class="comment"># 17</span></span><br></pre></td></tr></table></figure><h3 id="2-11-加一减一"><a href="#2-11-加一减一" class="headerlink" title="2.11 加一减一"></a>2.11 加一减一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">n = -~n             <span class="comment"># +1</span></span><br><span class="line"><span class="built_in">print</span>(n)            <span class="comment"># 11</span></span><br><span class="line">n = ~-n             <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(n)            <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断两个数是否异号</span></span><br><span class="line">x, y = -<span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>((x^y)&lt;<span class="number">0</span>)          <span class="comment"># True</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>((x^y)&lt;<span class="number">0</span>)          <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3 常见题型"></a>3 常见题型</h2><h3 id="3-1-题库列表"><a href="#3-1-题库列表" class="headerlink" title="3.1 题库列表"></a>3.1 题库列表</h3><div style="text-align: center;"><table border="1" style="margin: auto；" width='60%'><tr><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/reverse-bits/" target="_blank">190. 颠倒二进制位</a></p></td><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/number-of-1-bits/" target="_blank">191. 位1的个数</a></p></td><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/hamming-distance/" target="_blank">461. 汉明距离</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/missing-number/" target="_blank">268. 丢失的数字</a></p></td><td><p><a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字</a></p></td><td><p><a href="https://leetcode.cn/problems/single-number-ii/" target="_blank">137. 只出现一次的数字 II</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/single-number-iii/" target="_blank">260. 只出现一次的数字 III</a></p></td><td><p><a href="https://leetcode.cn/problems/power-of-two/" target="_blank">231. 2 的幂</a></p></td><td><p><a href="https://leetcode.cn/problems/counting-bits/" target="_blank">338. 比特位计数</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/sum-of-two-integers/" target="_blank">371. 两整数之和</a></p></td><td><p><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/" target="_blank">405. 数字转换为十六进制数</a></p></td><td><p><a href="https://leetcode.cn/problems/number-complement/" target="_blank">476. 数字的补数</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/total-hamming-distance/" target="_blank">477. 汉明距离总和</a></p></td><td><p><a href="https://leetcode.cn/problems/beautiful-arrangement/" target="_blank">526. 优美的排列</a></p></td><td><p><a href="https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/" target="_blank">1178. 猜字谜</a></p></td></tr></table></div><h3 id="3-2-真题演练"><a href="#3-2-真题演练" class="headerlink" title="3.2 真题演练"></a>3.2 真题演练</h3><p><strong>190. 颠倒二进制位</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        res = 0</span></span><br><span class="line"><span class="string">        for _ in range(32):</span></span><br><span class="line"><span class="string">            res = (res &lt;&lt; 1) | (n &amp; 1)</span></span><br><span class="line"><span class="string">            n &gt;&gt;= 1</span></span><br><span class="line"><span class="string">        return res</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p><strong>191. 位1的个数</strong><br>题目描述：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p><strong>1. 消除二进制末尾的 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>2. 右移 32 次</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            count += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>3. 库函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>461. 汉明距离</strong></p><p>题目描述：两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p><strong>1. 异或速解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x^y).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>2. 统计1的个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        z = x ^ y           <span class="comment"># 异或运算，二进制位不同的位置为1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> z:            <span class="comment"># 统计运算之后结果中 1 的个数</span></span><br><span class="line">            z = z &amp; (z-<span class="number">1</span>)   </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>3. 字符串解题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        bx, by = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].zfill(<span class="number">32</span>), <span class="built_in">bin</span>(y)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> bx[i] != by[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>268. 丢失的数字</strong></p><p>题目描述：给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p>思路分析：以示例 1 为例 nums &#x3D; [3,0,1]，其长度为3，不难看出其不缺失的原数组为 [0, 1, 2, 3]。如果将nums与其原数组异或会发生什么呢？异或满足交互律 即 (a^b)^c &#x3D; a^(b^c)。我们不妨将其调整一下位置，即<br>nums    原数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   ^    <span class="number">0</span>     =&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   ^    <span class="number">1</span>     =&gt; <span class="number">0</span></span><br><span class="line">无 <span class="number">2</span> =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   ^    <span class="number">3</span>     =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所有一样的数全部异或之后成了0，最后所剩下的2与0异或即为本身，也就是所缺失的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  <span class="comment"># 此处 num 代表nums， i 代表原数组</span></span><br><span class="line">            ans ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> ans ^ <span class="built_in">len</span>(nums)          <span class="comment"># 因为原数组比nums长度多1, 所有这里多异或了一次</span></span><br></pre></td></tr></table></figure><p><strong>136. 只出现一次的数字</strong></p><p>题目描述：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p><ul><li>任何数和 0 做异或运算，结果仍然是原来的数，即 $a⊕0&#x3D;a$。</li><li>任何数和其自身做异或运算，结果是 0，即 $a⊕a&#x3D;0$。</li><li>异或运算满足交换律和结合律，即 $a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b$。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.6tbqu4dvz7w0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;异或运算&#x27;&#x27;&#x27;</span></span><br><span class="line">        re = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            re ^= num</span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure><p><strong>137. 只出现一次的数字 II</strong></p><p>题目描述：给你一个整数数组 nums，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/022.3jilsm2r0jg0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:’</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 数学运算</span></span><br><span class="line"><span class="string">        return (sum(set(nums))*3-sum(nums)) // 2</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):             <span class="comment"># nums[i] 是32位整数，</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span>                     <span class="comment"># 针对每一位的对应二进制数值求和</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="built_in">sum</span> += (num &gt;&gt; i) &amp; <span class="number">1</span>   <span class="comment"># 提取从右往左数第i位的数值，将所有nums[i], 二进制下的第i位数值进行求和</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">3</span> == <span class="number">1</span>:            <span class="comment"># 如果没办法被3整除，那么说明落单的那个数的第i位是 1 不是 0</span></span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i           <span class="comment"># 恢复第 i 位的值到 ans</span></span><br><span class="line">        <span class="keyword">return</span> ~(ans^<span class="number">0xffffffff</span>) <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">else</span> ans   <span class="comment"># 这里最后的sum是符号位，可以判断最后输出的数字是否是负数</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 由于 Python 的存储负数的特殊性，需要先将 0-32 位取反（即 <code>res^0xffffffff </code>），再将所有位取反（即 ~ ）。两个组合操作实质上是将数字 32 以上位取反，0-32位不变。</p><p><strong>260. 只出现一次的数字 III</strong></p><p>题目描述：给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        mask = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 异或运算，目的是找到两个落单数值的不同，便于后面分类</span></span><br><span class="line">            mask ^= num</span><br><span class="line">        mask  &amp;= (-mask)            <span class="comment"># 直接获取 mask 二进制表示的最低位的 1</span></span><br><span class="line">        type1, type2 = <span class="number">0</span>, <span class="number">0</span>         </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 把数组分为两部分，每部分再分别异或</span></span><br><span class="line">            <span class="keyword">if</span> mask &amp; num:          <span class="comment"># 对于 num，如果 mask 为1，分类为 type1，对这个 type1 进行异或，可以找到落单的数值</span></span><br><span class="line">                type1 ^= num</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 如果 num 的 mask 对应的是0，那么异或找到另一个落单的数值</span></span><br><span class="line">                type2 ^= num</span><br><span class="line">        <span class="keyword">return</span> [type1, type2] </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/023.27s42my22s9w.webp#pic_center" width = 36%><p><strong>231. 2 的幂</strong><br>题目描述：给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true；否则，返回 false。如果存在一个整数 x 使得 $n &#x3D;&#x3D; 2^x$ ，则认为 n 是 2 的幂次方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return n&gt;0 and n&amp;(-n)==n   </span></span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> n&amp;(n-<span class="number">1</span>)==<span class="number">0</span>   </span><br></pre></td></tr></table></figure><p><strong>338. 比特位计数</strong></p><p>题目描述：给你一个整数 $n$ ，对于 $0 &lt;&#x3D; i &lt;&#x3D; n$ 中的每个 $i$ ，计算其二进制表示中 1 的个数 ，返回一个长度为 $n + 1$ 的数组 ans 作为答案。</p><p>思路分析：对于正整数 $x$，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 $⌊\frac{x}{2}⌋$。如果 $bits[⌊\frac{x}{2}⌋]$ 的值已知，则可以得到 $bits[x]$ 的值：</p><ul><li>如果 $x$ 是偶数，则 $bits[x]&#x3D;bits[⌊\frac{x}{2}⌋]$；</li><li>如果 $x$ 是奇数，则 $bits[x]&#x3D;bits[⌊\frac{x}{2}⌋]+1$。</li></ul><p>上述两种情况可以合并成: $bits[x]$ 的值等于 $bits[⌊\frac{x}{2}⌋]$ 的值加上 $x$ 除以 2 的余数。由于$⌊\frac{x}{2}⌋$ 可以通过 $x &gt;&gt;1$ 得到，$x$ 除以 2 的余数可以通过 $x &amp; 1$ 得到，因此有: $bits[x] &#x3D; bits[x &gt;&gt; 1]+(x &amp; 1)$。</p><p>另一种思路：令 $y &#x3D; x &amp;(x —1)$，则 $y$ 为将 $x$ 的最低设置位从 1 变成 0 之后的数，显然 $0≤y&lt;x$, $bits[x]&#x3D; bits[y]＋+1$。因此对任意正整数 $x$，都有 $bits[x]&#x3D; bits[x &amp; (x-1)]+1$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 遍历与统计</span></span><br><span class="line"><span class="string">        return [bin(i).count(&#x27;1&#x27;) for i in range(n+1)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        ans = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            ans[i] = ans[i&gt;&gt;<span class="number">1</span>] + (i&amp;<span class="number">1</span>)      <span class="comment"># ans[i] = ans[i&amp;(i-1)]+1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>342. 4的幂</strong></p><p>题目描述：给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false。整数 n 是 4 的幂次方需满足：存在整数 x 使得 $n &#x3D;&#x3D; 4^x$</p><p>思路分析：如果 n 是 4 的幂，那么 n 一定也是 2 的幂。因此我们可以首先判断 n 是否是 2 的幂，在此基础上再判断 n 是否是 4 的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1，并且这个 1 出现在从低位开始的第偶数个二进制位上（这是因为这个 1 后面必须有偶数个0）。因此我们可以构造一个整数 mask，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。这样一来，我们将 n 和 mask 进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。</p><p>思路二：如果 n 是 4 的幂，可以发现它除以 3 的余数一定为 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return n &gt; 0 and n&amp;(n-1) == 0 and (n%3) == 1</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n&amp;(n-<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> (n&amp;<span class="number">0xaaaaaaaa</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>371. 两整数之和</strong></p><p>题目描述：给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSum</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mask1 = <span class="number">0xffffffff</span></span><br><span class="line">        a &amp;= mask1</span><br><span class="line">        b &amp;= mask1</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>        <span class="comment"># 将存在进位的位置置1</span></span><br><span class="line">            a ^= b                      <span class="comment"># 计算无进位的结果</span></span><br><span class="line">            b = carry</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt; <span class="number">0x80000000</span> <span class="keyword">else</span> ~(a^mask1)  <span class="comment"># 考虑负数时的输出</span></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/024.6nw71yc5zds0.webp#pic_center" width = 48%><p><strong>405. 数字转换为十六进制数</strong></p><p>题目描述：给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p><strong>1. 精简版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># return hex(num&amp;0xffffffff)[2:]       </span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;模拟法&#x27;&#x27;&#x27;</span></span><br><span class="line">        CONV = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            num = <span class="number">2</span> ** <span class="number">32</span> + num             </span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            num, res = <span class="built_in">divmod</span>(num, <span class="number">16</span>)</span><br><span class="line">            ans += CONV[res]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 详细版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        CONV = <span class="string">&quot;0123456789abcdef&quot;</span></span><br><span class="line">        ans = []    </span><br><span class="line">        <span class="comment"># 32位2进制数，转换成16进制 -&gt; 4个一组，一共八组</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="comment"># 当输入值num为-1 ，第一次进入循环</span></span><br><span class="line">            ans.append(num % <span class="number">16</span>)    <span class="comment"># num % 16 = 15</span></span><br><span class="line">            num //= <span class="number">16</span>              <span class="comment"># num // 16 = -1</span></span><br><span class="line">            <span class="comment"># Python中的//运算取整除：向下取接近商的整数</span></span><br><span class="line">            <span class="comment"># % 取模运算返回整除的余数 （余数 = 被除数 - 除数 * 商）</span></span><br><span class="line">            <span class="comment"># 负整数 // 正整数 的最大值为-1</span></span><br><span class="line">            <span class="comment"># -1 // 16 = -1</span></span><br><span class="line">            <span class="comment"># -1 % 16 = 15</span></span><br><span class="line">            <span class="comment"># 即如num为负数，则一定会跑满for的8次循环</span></span><br><span class="line">            <span class="comment"># 正整数 // 正整数 的最小值为0</span></span><br><span class="line">            <span class="comment"># 1 // 16 = 0</span></span><br><span class="line">            <span class="comment"># 1 % 16 = 1</span></span><br><span class="line">            <span class="comment"># 即num为正数时，有可能触发下面的if语句，提前结束for循环</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num:     <span class="comment"># 如果num不为0则继续下一次for循环</span></span><br><span class="line">                <span class="keyword">break</span>       <span class="comment"># 如果num为0则终止for循环</span></span><br><span class="line">            <span class="comment"># 正整数 // 负整数 的最大值为-1，如1 // -16 = -1; 1 % -16 = -15</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(CONV[n] <span class="keyword">for</span> n <span class="keyword">in</span> ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>476. 数字补数</strong></p><p>题目描述：对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。例如，整数 5 的二进制表示是 “101”，取反后得到 “010”，再转回十进制表示得到补数 2。给你一个整数 num ，输出它的补数。</p><p><strong>1. 与运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num &amp; <span class="number">1</span>):           <span class="comment"># 该位为0</span></span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>2. 异或运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_copy = num</span><br><span class="line">        num_1 = <span class="number">1</span>              </span><br><span class="line">        <span class="keyword">while</span> num_copy:</span><br><span class="line">            num_1 &lt;&lt;= <span class="number">1</span> </span><br><span class="line">            num_copy &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num ^ (num_1-<span class="number">1</span>)          <span class="comment"># num_1 二进制位数比num多一位，减1后与num二进制位数相同，且各位均为1</span></span><br></pre></td></tr></table></figure><p><strong>3. 遍历字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> bt <span class="keyword">in</span> <span class="built_in">bin</span>(num)[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> bt == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                result.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(result), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>477. 汉明距离的总和</strong><br>题目描述：两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。</p><p>对于某个 nums[i] 我们只关心在 nums 中有多少数的第 $x$ 位的与其不同，而不关心具体是哪些数与其不同，同时二进制表示中非 0 即 1。</p><p>这样我们可以建立两个集合 $s_0$ 和 $s_1$，分别统计出 nums 中所有数的第 $x$ 位中 0 的个数和 1 的个数，集合中的每次计数代表了 nums 中的某一元素，根据所在集合的不同代表了其第 $x$ 位的值。那么要找到在 nums 中有多少数与某一个数的第 $x$ 位不同，只需要读取另外一个集合的元素个数即可，变成了 $O(1)$ 操作。那么要求得「第 $x$ 位所有不同数」的对数的个数，只需要应用乘法原理，将两者元素个数相乘即可。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/025.2f84rabei5c0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalHammingDistance</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            temp = <span class="built_in">sum</span>((num &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line">            ans += temp * (<span class="built_in">len</span>(nums) - temp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>526. 优美的排列</strong></p><p>题目描述：假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：</p><ul><li>perm[i] 能够被 i 整除</li><li>i 能够被 perm[i] 整除</li></ul><p>给你一个整数 n ，返回可以构造的 优美排列 的 数量 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countArrangement</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        canFill = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j % i == <span class="number">0</span> <span class="keyword">or</span> i % j == <span class="number">0</span>:        <span class="comment"># 每个位置可以填入哪些数</span></span><br><span class="line">                    canFill[i].append(j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        order = <span class="built_in">sorted</span>(canFill.keys(), key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(canFill[x]))    <span class="comment"># 根据可填入数字的个数排序，优先填入个数少的</span></span><br><span class="line">        end = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">state</span>):</span><br><span class="line">            <span class="keyword">if</span> state == end:                    <span class="comment"># 全部填入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            cnts = ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):                  <span class="comment"># 当前该填第几个位置</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i) &amp; state:</span><br><span class="line">                    cnts += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> canFill[order[cnts]]:      <span class="comment"># 当前位置可以填哪些数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((<span class="number">1</span> &lt;&lt; i) &amp; state):      <span class="comment"># 哪些数还没被填</span></span><br><span class="line">                    ans += dfs(state ^ (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>1178. 猜字谜</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/026.7959elkbflg0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumOfValidWords</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], puzzles: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        frequency = collections.Counter()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(mask)).count(<span class="string">&quot;1&quot;</span>) &lt;= <span class="number">7</span>:</span><br><span class="line">                frequency[mask] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> puzzle <span class="keyword">in</span> puzzles:</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举子集方法一</span></span><br><span class="line">            <span class="comment"># for choose in range(1 &lt;&lt; 6):</span></span><br><span class="line">            <span class="comment">#     mask = 0</span></span><br><span class="line">            <span class="comment">#     for i in range(6):</span></span><br><span class="line">            <span class="comment">#         if choose &amp; (1 &lt;&lt; i):</span></span><br><span class="line">            <span class="comment">#             mask |= (1 &lt;&lt; (ord(puzzle[i + 1]) - ord(&quot;a&quot;)))</span></span><br><span class="line">            <span class="comment">#     mask |= (1 &lt;&lt; (ord(puzzle[0]) - ord(&quot;a&quot;)))</span></span><br><span class="line">            <span class="comment">#     if mask in frequency:</span></span><br><span class="line">            <span class="comment">#         total += frequency[mask]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举子集方法二</span></span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">            </span><br><span class="line">            subset = mask</span><br><span class="line">            <span class="keyword">while</span> subset:</span><br><span class="line">                s = subset | (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> frequency:</span><br><span class="line">                    total += frequency[s]</span><br><span class="line">                subset = (subset - <span class="number">1</span>) &amp; mask</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在枚举子集的过程中，要么会漏掉全集 mask，要么会漏掉空集</span></span><br><span class="line">            <span class="comment"># 这里会漏掉空集，因此需要额外判断空集</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))) <span class="keyword">in</span> frequency:</span><br><span class="line">                total += frequency[<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))]</span><br><span class="line"></span><br><span class="line">            ans.append(total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>位运算和使用技巧暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/027.4jw2tcniyw80.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python位运算——左移操作（＜＜）右移操作＞＞：<a href="https://blog.csdn.net/qq_45769063/article/details/118618810">https://blog.csdn.net/qq_45769063&#x2F;article&#x2F;details&#x2F;118618810</a></li><li>Python异或运算：<a href="https://www.jianshu.com/p/ffa9fdf192a5">https://www.jianshu.com/p/ffa9fdf192a5</a></li><li>位运算技巧：<a href="https://www.zhihu.com/question/38206659">https://www.zhihu.com/question/38206659</a></li><li>位运算：<a href="http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting">http://graphics.stanford.edu/~seander&#x2F;bithacks.html#OperationCounting</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇主要学习Python中的二进制运算，通过位运算实现乘除法、交换两数、判断奇偶数、交换符号、求绝对值、二进制逆序、统计二进制中1的个数，最后结合LeetCode常见题目进行练习。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://qxienote.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="二进制逆序" scheme="https://qxienote.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%86%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十二）-- 树和二叉树</title>
    <link href="https://qxienote.com/article/48fcde60.html"/>
    <id>https://qxienote.com/article/48fcde60.html</id>
    <published>2023-06-11T10:00:07.000Z</published>
    <updated>2023-06-13T14:49:35.810Z</updated>
    
    <content type="html"><![CDATA[<p>终于学到了二叉树，LeetCode里面三分之一都是关于二叉树，俗话说打铁还需自身硬，本节学习树的基本概念，二叉树的实现、遍历、转换二叉树等。</p><span id="more"></span><h2 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1 树的概念"></a>1 树的概念</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 $n$（$n\geq 1$）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.7c11iupwauk0.webp#pic_center" width = 48%><h3 id="1-2-树的术语"><a href="#1-2-树的术语" class="headerlink" title="1.2 树的术语"></a>1.2 树的术语</h3><ul><li>节点的度：一个节点含有的子树的个数称为该节点的度；</li><li>树的度：一棵树中，最大的节点的度称为树的度；</li><li>叶节点或终端节点：度为零的节点；</li><li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li><li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li></ul><p>如下图，A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.7d6hue0pbm00.webp#pic_center" width = 48%><ul><li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>树的高度或深度：树中节点的最大层次；</li><li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li><li>节点的祖先：从根到该节点所经分支上的所有节点；</li><li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙；</li><li>森林：由 $m$（$m\geq 0$）棵互不相交的树的集合称为森林。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.5sez1y8lbt40.webp#pic_center" width = 48%><ul><li>深度：对于任意节点n, n 的深度为从根到 n 的唯一路径长，根的深度为0；</li><li>高度：对于任意节点n, n的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0；</li><li>结点的层次：规定根结点在1层，其它任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列 $n_1, n_2, \cdots, n_k, n_i$ 是 $n_{i+1}$ 的父结点。路径所包含边的个数为路径的长度。</li></ul><h3 id="1-3-树的种类"><a href="#1-3-树的种类" class="headerlink" title="1.3 树的种类"></a>1.3 树的种类</h3><ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li><li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul><li>二叉树：每个节点最多含有两个子树的树称为二叉树；<ul><li>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</li><li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li>排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</li></ul></li><li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li><li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li></ul></li></ul><p>用图片来展示什么是完全二叉树，请看下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.1b9h32y2iji8.webp#pic_center" width = 48%><p>下面这两棵树都是搜索树</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.5ku881wu4to0.webp#pic_center" width = 48%><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.5fiprv9i92w0.webp#pic_center" width = 48%><h4 id="1-4-树的存储和表示"><a href="#1-4-树的存储和表示" class="headerlink" title="1.4 树的存储和表示"></a>1.4 树的存储和表示</h4><p><strong>1. 链式存储法</strong></p><p>一种基于指针或者引用的二叉链式存储法，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。结构如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.6kxybgrn4pg0.webp#pic_center" width = 48%><p><strong>2. 顺序存储法</strong></p><p>顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。我们把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。即如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.vvpo3mca8g0.webp#pic_center" width = 48%><p>不过上图是一颗完全二叉树，所以数组仅仅浪费了下标为0的存储位置，如果是非完全二叉树，则可能会浪费比较多的数组内存空间。所以当要存储的树是一颗完全二叉树时，数组才是最合适的选择。所以，二叉树通常以链式存储。</p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2 二叉树"></a>2 二叉树</h2><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”(left subtree)和“右子树”(right subtree)。</p><h3 id="2-1-二叉树的性质"><a href="#2-1-二叉树的性质" class="headerlink" title="2.1 二叉树的性质"></a>2.1 二叉树的性质</h3><p><strong>1.层结点</strong><br>在二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点(i&gt;&#x3D;1)</p><p><strong>2.总结点</strong><br>深度为 $k$ 的二叉树最多有 $2^{k+1}-1$ 个结点(k&gt;&#x3D;1)</p><p><strong>3.深度</strong><br>具有 $n$ 个结点的完全二叉树的深度为 $\lfloor \log_{2}n \rfloor$</p><p><strong>4. 结点数</strong></p><p>对于任意一棵二叉树，度为 0 的结点数等于度为 2 的结点数 +1。</p><p><strong>5. 孩子结点</strong></p><p>对完全二叉树，若从上至下、从左至右编号，则编号为 $i$ 的结点，其左孩子编号必为 $2i$，其右孩子编号必为 $2i＋1$ ；其双亲的编号必为i&#x2F;2（i＝1 时为根，除外）</p><blockquote><p>完全二叉树————若设二叉树的高度为$h$，除第 $h$ 层外，其它各层 $(1~h-1)$ 的结点数都达到最大个数，第 $h$ 层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.1fabcfnlkitc.webp#pic_center" width = 48%><blockquote><p>满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.4pofeqgfk9s0.webp#pic_center" width = 48%><h3 id="2-2-二叉树的实现"><a href="#2-2-二叉树的实现" class="headerlink" title="2.2 二叉树的实现"></a>2.2 二叉树的实现</h3><p><strong>1. 列表实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/27</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 树的列表实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_tree</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">return</span> [r, [], []]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">root, new_branch</span>):</span><br><span class="line">    t = root.pop(<span class="number">1</span>)     <span class="comment"># 取出左子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:      <span class="comment"># 左子树已存在</span></span><br><span class="line">        root.insert(<span class="number">1</span>, [new_branch, t, []])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">1</span>, [new_branch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">root, new_branch</span>):</span><br><span class="line">    t = root.pop(<span class="number">2</span>)     <span class="comment"># 取出右子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:      <span class="comment"># 右子树已存在</span></span><br><span class="line">        root.insert(<span class="number">2</span>, [new_branch, [], t])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>, [new_branch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_root_val</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_root_val</span>(<span class="params">root, new_val</span>):</span><br><span class="line">    root[<span class="number">0</span>] = new_val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_left_child</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_right_child</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">r = binary_tree(<span class="number">3</span>)</span><br><span class="line">insert_left(r, <span class="number">4</span>)</span><br><span class="line">insert_left(r, <span class="number">5</span>)</span><br><span class="line">insert_right(r, <span class="number">6</span>)</span><br><span class="line">insert_right(r, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">l = get_left_child(r)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line">set_root_val(l, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">insert_left(l, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(get_right_child(get_right_child(r)))</span><br></pre></td></tr></table></figure><p><strong>2. 链表实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_obj</span>):</span><br><span class="line">        self.key = root_obj</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">self, new_node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.left_child == <span class="literal">None</span>:</span><br><span class="line">            self.left_child = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(new_node)</span><br><span class="line">            t.left_child = self.left_child</span><br><span class="line">            self.left_child = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">self, new_node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.right_child == <span class="literal">None</span>:</span><br><span class="line">            self.right_child = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(new_node)</span><br><span class="line">            t.right_child = self.right_child</span><br><span class="line">            self.right_child = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_right_child</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.right_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_left_child</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.left_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_root_val</span>(<span class="params">self, obj</span>):</span><br><span class="line">        self.key = obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root_val</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure><h3 id="2-3-二叉树的遍历"><a href="#2-3-二叉树的遍历" class="headerlink" title="2.3 二叉树的遍历"></a>2.3 二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p><ul><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ul><p>从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.46af021h4fo0.webp#pic_center" width = 48%><p>下面以LeetCode为例，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="2-3-1-前序遍历"><a href="#2-3-1-前序遍历" class="headerlink" title="2.3.1 前序遍历"></a>2.3.1 前序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5qei5gwywa80.webp#pic_center" width = 48%><ul><li>遍历顺序：根结点-&gt;左子树-&gt;右子树</li><li>动态图解：和上面的动态图一样，先序遍历就像一个小人从根结点开始，围绕二叉树的外圈开始跑（遇到缝隙就钻进去），按照跑的顺序，依次输出序列</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归实现</span></span><br><span class="line">        self.result = []                <span class="comment"># 使用布局变量存储结果</span></span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.result.append(root.val)    <span class="comment"># 前序</span></span><br><span class="line">        self.traverse(root.left)        <span class="comment"># 左</span></span><br><span class="line">        self.traverse(root.right)       <span class="comment"># 右</span></span><br></pre></td></tr></table></figure><p><strong>2. 迭代遍历</strong></p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.5m8n41fvngc0.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)         <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)    <span class="comment"># 右子树先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)     <span class="comment"># 左子树先入栈</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-3-2-中序遍历"><a href="#2-3-2-中序遍历" class="headerlink" title="2.3.2 中序遍历"></a>2.3.2 中序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.zoh9hj3411s.webp#pic_center" width = 48%><ul><li>遍历顺序：左子树-&gt;根结点-&gt;右子树</li><li>动态图解：中序遍历就像投影仪一样，将二叉树从最左侧到最右侧依次投影到同一水平线上面，得到的从左到右的相关序列就是二叉树的中序遍历</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.result = []</span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        self.traversal(root.left)               <span class="comment"># 前</span></span><br><span class="line">        self.result.append(root.val)            <span class="comment"># 中</span></span><br><span class="line">        self.traversal(root.right)              <span class="comment"># 后</span></span><br></pre></td></tr></table></figure><p><strong>2. 顺序遍历</strong></p><p>分析一下为什么前面写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.a7oiu182jww.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = []                      <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:         </span><br><span class="line">            <span class="keyword">if</span> cur:                     <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 到达最左节点后处理栈顶结点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                cur = cur.right         <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-3-3-后序遍历"><a href="#2-3-3-后序遍历" class="headerlink" title="2.3.3 后序遍历"></a>2.3.3 后序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.4w5738j4umi0.webp#pic_center" width = 48%><ul><li>遍历顺序：左子树-&gt;右子树-&gt;根结点</li><li>动态图解： 后序遍历也是按照先序遍历的顺序输出，不过后序遍历就像剪葡萄，只能一个个剪，不能让超过1个的葡萄一起掉下来，那就错了。例如上图中的 B，剪去 B 后面的 D、E、H、I、J 都会掉下来，而 H 剪去只会掉下 H，规律就是这个规律</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.result = []</span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.traversal(root.left)               <span class="comment"># 左</span></span><br><span class="line">        self.traversal(root.right)              <span class="comment"># 右</span></span><br><span class="line">        self.result.append(root.val)            <span class="comment"># 中</span></span><br></pre></td></tr></table></figure><p><strong>2. 顺序遍历</strong></p><p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.6ln5rgj5w0w0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)                     <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)       <span class="comment"># 左子树先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)     <span class="comment"># 右子树后入栈</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]                             <span class="comment"># 将最终数组反转</span></span><br></pre></td></tr></table></figure><h4 id="2-3-4-层序遍历"><a href="#2-3-4-层序遍历" class="headerlink" title="2.3.4 层序遍历"></a>2.3.4 层序遍历</h4><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.5in2a4wgs600.gif#pic_center" width = 36%><p><strong>1. 迭代法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">        <span class="comment"># 二叉树层序遍历迭代解法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):       <span class="comment"># 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的</span></span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>2. 递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 递归法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.res = []</span><br><span class="line">        self.helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], depth</span>) -&gt; <span class="type">Optional</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.res) == depth: self.res.append([])</span><br><span class="line">        self.res[depth].append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.left: self.helper(root.left, depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right: self.helper(root.right, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>二叉树基础部分已整理完毕，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.32u2n6vhr4o0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>树结构详解：<a href="http://c.biancheng.net/data_structure/tree/">http://c.biancheng.net/data_structure&#x2F;tree&#x2F;</a></li><li>树和二叉树全面总结：<a href="https://juejin.cn/post/7065513748789723150">https://juejin.cn/post/7065513748789723150</a></li><li>数据结构与算法————二叉树：<a href="https://www.cnblogs.com/jasonbourne3/p/17143620.html">https://www.cnblogs.com/jasonbourne3/p/17143620.html</a></li><li>二叉树入门和刷题：<a href="https://zhuanlan.zhihu.com/p/136758152">https://zhuanlan.zhihu.com/p/136758152</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于学到了二叉树，LeetCode里面三分之一都是关于二叉树，俗话说打铁还需自身硬，本节学习树的基本概念，二叉树的实现、遍历、转换二叉树等。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://qxienote.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十一）-- 链表的应用与常见题型</title>
    <link href="https://qxienote.com/article/ae2fd3ce.html"/>
    <id>https://qxienote.com/article/ae2fd3ce.html</id>
    <published>2023-06-11T09:59:42.000Z</published>
    <updated>2023-06-13T14:41:16.362Z</updated>
    
    <content type="html"><![CDATA[<p>本篇信息量巨大，首先对比链表和数组，接着解决单链表的反转、删除某一节点、插入数据、查找中间节点、求倒数第k个结点、对称链表、单链表是否有环、两个链表是否相交，最后用LeetCode上的真题来实战删除链表结点、反转链表、合并、排序、环形链表常用技巧。</p><span id="more"></span><p>这一部分的内容，前面的大佬总结的挺多，这里进行汇总，方便和大家一起学习和回顾，欢迎大家继续补充。</p><h2 id="1-链表和数组"><a href="#1-链表和数组" class="headerlink" title="1 链表和数组"></a>1 链表和数组</h2><p>作为线性表的两种存储方式————链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。</p><p>数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。</p><p>但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 $O(n)$。增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.22jcviirxk5c.gif#pic_center" width = 48%><p>删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.60mgplwxlw40.gif#pic_center" width = 48%><p> <strong>总结一下数组的优缺点：</strong></p><ul><li>优点：可以根据偏移实现快速的随机读写。</li><li>缺点：扩容，增删元素极慢。</li></ul><p>上面对数组增删元素的操作表明使用数组需要注意的东西真的很多很多，这样一来，我们就开始说说链表，链表也是一种数据结构，它弥补了数组带来的诸多不便，让我们可以任意为一些数据进行空间的分配，根据需要进行内存单元的开辟。</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，由若干个结点组成，在每一个结点里存到下一个结点的指针(Next)。采用动态分配存储单元方式。它能够有效地节省存储空间（同数组比较）。结点结构如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.35g0aiddrry0.webp#pic_center" width = 48%><p>一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.55ls7z5t19g0.webp#pic_center" width = 48%><p>对于链表而言，分为静态链表和动态链表，根据处理数据的方向又分为单向链表和双向链表。对于链表的更多操作，请阅读 <a href="https://blog.csdn.net/xq151750111/article/details/129130524?spm=1001.2014.3001.5501">Python数据结构与算法篇（四）– 链表的实现</a></p><p><strong>小结：</strong> 从本质上来讲，<font color=#9900CC><strong>链表与数组的确有相似之处，他们的相同点是都是线性数据结构，这与树和图不同，而它们的不同之处在于数组是一块连续的内存，而链表可以不是连续内存，链表的节点与节点之间通过指针来联系。</font></strong></p><hr><h2 id="2-常见链表问题解决思路"><a href="#2-常见链表问题解决思路" class="headerlink" title="2 常见链表问题解决思路"></a>2 常见链表问题解决思路</h2><h3 id="2-1-单链表的反转"><a href="#2-1-单链表的反转" class="headerlink" title="2.1 单链表的反转"></a>2.1 单链表的反转</h3><p><strong>方法一：头插法（迭代法）</strong><br>算法思想：&#x3D;&#x3D;逆置链表初始为空，表中节点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），&#x3D;&#x3D; 使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空。</p><p><strong>方法二：递归法：</strong><br>算法思想：从后向前改变指向，可以理解成向后的箭头变成了向前的箭头</p><p><strong>方法三：三指针法</strong><br>算法思想：从前向后改变指向，可以理解成向后的箭头变成了向前的箭头</p><h3 id="2-2-单链表的删除某一结点"><a href="#2-2-单链表的删除某一结点" class="headerlink" title="2.2 单链表的删除某一结点"></a>2.2 单链表的删除某一结点</h3><p><strong>方法一：遍历</strong><br>思路：查找到所要删除的节点，以及其前驱节点，让其前驱节点，指向其后继节点</p><p><strong>方法二：置换法（移花接木）</strong><br>思路：明确要删除的节点后，把其后继节点复制到该节点上，然后删除那个后继节点，也等于变相的删除节点（注意如果删除的是尾节点 删除的链表只有一个节点）</p><h3 id="2-3-在当前节点前插入一个数据"><a href="#2-3-在当前节点前插入一个数据" class="headerlink" title="2.3 在当前节点前插入一个数据"></a>2.3 在当前节点前插入一个数据</h3><p><strong>方法一：遍历</strong><br>思路：找出当前结点的前驱节点，完成插入；</p><p><strong>方法二：置换法</strong><br>思路：把插入节点的数据放到新节点上，把新节点的数据放到插入节点的数据上，这样我们就可以实现在当前节点前插入一个节点了。</p><h3 id="2-4-查找链表的中间结点"><a href="#2-4-查找链表的中间结点" class="headerlink" title="2.4 查找链表的中间结点"></a>2.4 查找链表的中间结点</h3><p><strong>快慢指针法</strong><br>思路：给一个快指针，让快指针每次移动两步，给一个慢指针，让慢指针每次移动一步，最后结果就是快指针移动到最后一个节点，慢指针最后移动到了中间的节点上。</p><p>设有两个指针 fast 和 slow，&#x3D;&#x3D;初始时指向头节点&#x3D;&#x3D;。每次移动时，fast 向后走两次，slow 向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n&#x2F;2 轮。&#x3D;&#x3D;当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠后一个。&#x3D;&#x3D;</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.6wtkyvc1a1g0.webp#pic_center" width = 48%><h3 id="2-5-单链表的倒数第k个结点"><a href="#2-5-单链表的倒数第k个结点" class="headerlink" title="2.5 单链表的倒数第k个结点"></a>2.5 单链表的倒数第k个结点</h3><p><strong>方法一：正数转换法</strong><br>思路：遍历一遍单链表，记录单链表的长度，倒数第k个，即正数 length-k+1 个，在重头遍历一次便能够找到</p><p><strong>方法二：快慢指针法</strong><br>思路：一个指针先走k步，然后两个指针同时走，当先走的那个指针指向空的时候，后面的指针所指即为倒数第K个节点。</p><p>设有两个指针 p 和 q，&#x3D;&#x3D;初始时均指向头结点&#x3D;&#x3D;。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1 个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.4g7u9ztqez20.webp#pic_center" width = 48%><h3 id="2-6-对称单链表"><a href="#2-6-对称单链表" class="headerlink" title="2.6 对称单链表"></a>2.6 对称单链表</h3><p><strong>1. 知道链表的长度</strong><br>思路：根据对称来确定两个指针的位置，对所指向的元素进行判断，不断前进指针</p><p><strong>2. 链表长度未知</strong><br>思路1：将前一半的节点压入栈中，并将当前节点继续遍历，每遍历一个都与栈弹出的节点相比较，若不同则不是。额外空间复杂度 O(N&#x2F;2)。</p><p>思路2：不使用辅助空间 两个指针，一个指向头 first，指向头的后继节点 last；first 走一步，last走两步；直到 last 为空或 last 的后继节点为空，此时 first 指向（链表长度为奇数，指向中间；为偶数，指向一半）；然后 fisrt 向后走，再申请一个节点指向头，不断进行比较，直到 first 指向空。</p><h3 id="2-7-单链表是否有环"><a href="#2-7-单链表是否有环" class="headerlink" title="2.7 单链表是否有环"></a>2.7 单链表是否有环</h3><p><strong>方法一：map表法</strong><br>算法思想：每走一步将走过的节点使用map表存储起来，当遇到第一个在map中存在的节点时，就说明回到了出发点，即链表有环，同时也找到了环的入口。</p><p><strong>方法二：快慢指针法</strong><br>算法思想：一个指针走两步；一个指针走一步；如果存在环，两个指针最终会指向同一个元素；如果不存在环，走两步的会最终走向空节点。</p><p>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.2t8k9zey8280.gif#pic_center" width = 24%><p><strong>确定有环后求环的长度</strong></p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.safh0w2cugw.webp#pic_left" width = "45%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.580tqn3izyk0.webp#pic_left"  width = "50%"></center></p><p>通过公式的推导我们发现 $L&#x3D;kc-n$（这里的 $k$ 是倍数，有可能快指针在环里转了 $k$ 圈），即<font color=#9900CC><strong>相遇节点到入环点的距离等于链表的头到入环点的距离</font></strong>。写代码的时候只需要找到相遇节点，再让一个指针从头开始走即可。</p><h3 id="2-8-判断两个链表是否相交"><a href="#2-8-判断两个链表是否相交" class="headerlink" title="2.8 判断两个链表是否相交"></a>2.8 判断两个链表是否相交</h3><p><strong>1. 相交则求交点（链表不带环）</strong><br>思路：若两个不带环的链表相交，则他们的尾节点必相同；若要求交点，则需要比较两个链表的长度，让较长的链表先向后遍历至和较短的链表长度相等，然后两个链表同时向后遍历，并比较节点是否相同，当遇到第一个相同的节点时，则为两个链表的交点。</p><p><strong>2. 相交则求交点（链表可能带环）</strong><br>情况分析：<br>若有两个链表，则他们的带环情况有以下三种可能：<br>（1）两个链表都不带环<br>直接采用上述思路即可；<br>（2）一个链表带环一个链表不带环<br>必定不想交；<br>（3）两个链表都带环<br>下面详细讨论：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.6rl0uys7mkc0.webp#pic_center" width = 48%><ul><li>当出现①情况时，两个链表不相交。</li><li>当出现②情况时，两个链表的交点在环外，那么我们可以转化为不带环链表判断相交即可。</li><li>当出现③情况时，两个链表的交点在环内，那么我们可以遍历其中一个链表的环，若在环内与另一个链表环的入口点相交，则两个链表相交，相遇点即为两个链表的交点。</li><li>要判断为情况②还是情况③，只需判断两个链表环的入口点是否相同即可。</li></ul><p><strong>链表的 <code>.next</code> 指向问题</strong></p><p>如果放在左边就表示是自己的指向，如果放在右边就表示是它的下一个节点。类似于代码中的这三行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="built_in">next</span> = head.<span class="built_in">next</span>;</span><br><span class="line">head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">node.<span class="built_in">next</span>.<span class="built_in">next</span> = head;</span><br></pre></td></tr></table></figure><p>这种就代表等号左边指向右边，左边的是指向，右边就代表确切的下一个节点。</p><p>如果类似于后两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = node.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">head = head.<span class="built_in">next</span>;</span><br></pre></td></tr></table></figure><p>像这样，左边不带 <code>.next</code> 的是类似于赋值语句，自己的指针指向右边位置。</p><hr><h2 id="3-LeetCode"><a href="#3-LeetCode" class="headerlink" title="3 LeetCode"></a>3 LeetCode</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.394jgp0avbs0.webp#pic_center" width = 100%><p>俗话说一图胜千言，接下来主要通过图片展示解决思路，通过代码展示实现的细节。</p><h3 id="3-1-删除结点"><a href="#3-1-删除结点" class="headerlink" title="3.1 删除结点"></a>3.1 删除结点</h3><h4 id="3-1-1-题解方法"><a href="#3-1-1-题解方法" class="headerlink" title="3.1.1 题解方法"></a>3.1.1 题解方法</h4><p> <strong>1. 画草图：</strong> 理解指针的变动与思考逻辑！！(重要！实用！)<br> <strong>2. 边界条件：</strong> 怎么处理不会有空指针异常？在循环里放什么停止条件</p><blockquote><ul><li>如果是遍历链表元素，<code>while(node!=null)</code> </li><li>如果是删除某个元素，需要，<code>while(node.next!=null)</code></li><li>需要考虑的仅仅是被改变 next 指针的部分，并且循环之后哪个指针在最后的节点处，就判断谁</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如快慢指针，输出中间节点，slow 和 fast 的指针都在变，但是 fast 先指向链表尾巴，所以判断 fast</span></span><br><span class="line"><span class="comment"># 同时每个判断 next.next 的都必须先判断，next，才能保证 奇偶链长 中不会出现空指针异常</span></span><br><span class="line"><span class="keyword">while</span>(fast.<span class="built_in">next</span>!=null &amp;&amp; fast.<span class="built_in">next</span>.<span class="built_in">next</span>!=null)&#123;</span><br><span class="line">            slow = slow.<span class="built_in">next</span>;</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><font color=#9900CC><strong>3. 只要会删除头结点，都要进行 dummy虚指针，有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性</font></strong><br><strong>4. 特殊的需求可以考虑结合各种工具类，比如删除重复里面，利用HashSet，删除倒数第k个，利用栈LinkedList</strong></p><h4 id="1-3-2-可能出现的问题"><a href="#1-3-2-可能出现的问题" class="headerlink" title="1.3.2 可能出现的问题"></a>1.3.2 可能出现的问题</h4><p>① NullPointerException，就是当前节点为空，我们还去操作它的 next；<br>② 输出不了结果，一定是指针移动出了问题</p><h4 id="1-3-3-题库列表"><a href="#1-3-3-题库列表" class="headerlink" title="1.3.3 题库列表"></a>1.3.3 题库列表</h4><blockquote>  <p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank">237. 删除链表中的节点</a> ====<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank">面试题 02.03. 删除中间节点</a></p>  <p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank">203. 移除链表元素</a>（虚拟头结点）</p>  <ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank">剑指 Offer 18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank">面试题 02.01. 移除重复节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank">82. 删除排序链表中的重复元素 II</a></li></ul>  <p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank">19. 删除链表的倒数第 N 个结点</a>（双指针经典类型）</p>  <ul><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank">876. 链表的中间结点</a></li><li><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank">328. 奇偶链表</a></li></ul> </blockquote><p><strong>237. 删除链表中的节点</strong></p><p>题目描述：给你一个需要删除的节点 node，但无法访问 第一个节点  head。链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 题目说 node 不是链表中最后一个结点，直接将当前节点的值改为next的值，next指向next.next，实现原地更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>203. 移除链表元素</strong></p><p>题目描述：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><blockquote><p>① 如果删除的节点是中间的节点，则问题似乎非常简单： </p><ul><li>选择要删除节点的前一个结点 prev。 </li><li>将 prev 的 next 设置为要删除结点的 next。</li></ul><p>② 当要删除的一个或多个节点位于链表的头部时，要另外处理</p></blockquote><p><strong>三种方法：</strong></p><blockquote><ul><li>删除头结点时另做考虑（由于头结点没有前一个结点） </li><li>添加一个虚拟头结点，删除头结点就不用另做考虑 </li><li>递归 </li><li>双指针法</li></ul></blockquote><p><strong>1. 对头结点单独考虑</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:<span class="comment"># 找到指定元素</span></span><br><span class="line">                <span class="keyword">if</span> prev:<span class="comment"># 不是头结点</span></span><br><span class="line">                    prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span><span class="comment"># 将删除位置的前一个节点的next指向删除位置的后一个结点</span></span><br><span class="line">                <span class="keyword">else</span>:<span class="comment"># 如果第一个就是删除结点</span></span><br><span class="line">                    head = cur.<span class="built_in">next</span><span class="comment"># 将头指针指向头节点的后一个结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5hja7yiu0cw0.gif#pic_center" width = 48%><p><strong>2. 添加一个虚拟头结点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)<span class="comment"># 创建虚结点</span></span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> prev <span class="keyword">and</span> prev.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> prev.<span class="built_in">next</span>.val == val:</span><br><span class="line">                prev.<span class="built_in">next</span> = prev.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.3b5w9nrdkj80.webp#pic_center" width = 48%><p><strong>3. 递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 因为递归函数返回的是已经删除节点之后的头结点</span></span><br><span class="line">        <span class="comment"># 所以直接接上在 head.next，最后就只剩下判断头结点是否与需要删除的值一致了</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.removeElements(head.<span class="built_in">next</span>, val)</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.r3e3eix9ae.gif#pic_center" width = 48%><p><strong>83. 删除排序链表中的重复元素</strong></p><p>题目描述：给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curr = head     <span class="comment"># 指针节点，这里不会删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:<span class="comment"># 如果两个结点元素值相同，则执行删除</span></span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.1z3s9s43bvi8.gif#pic_center" width = 36%><p>题目解法并不唯一，可以使用递归、双指针、虚拟头结点、栈的方法，详细了解可以阅读：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/342300/83-shan-chu-pai-xu-lian-biao-zhong-de-zhong-fu-21/?orderBy=most_votes">删除排序链表中的重复元素（五种方法）</a></p><p><strong>剑指 Offer 18. 删除链表的节点</strong></p><p>题目描述：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head.val == val:             <span class="comment"># 如果头指针相等，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        prev, cur = head, head.<span class="built_in">next</span>     <span class="comment"># 双指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur <span class="keyword">and</span> cur.val != val): <span class="comment"># 找元素</span></span><br><span class="line">            prev, cur = cur, cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur:                         <span class="comment"># 找到了，进行删除</span></span><br><span class="line">            prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span>        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong>  这里既可以添加虚拟头结点，也可以先判断第一个结点是否满足条件，第二种方法更快，这里就采用先判断再循环的方式。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.48py8rnrn6g0.webp#pic_center" width = 48%><p><strong>面试题 02.01. 移除重复节点</strong></p><p>题目描述：移除未排序链表中的重复节点。保留最开始出现的节点，由于未排序，重复的元素不一定连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head<span class="comment"># 初始化 pre, cur 节点引用（指针）</span></span><br><span class="line">        visited = <span class="built_in">set</span>()<span class="comment"># 初始化 set 用于保存节点值</span></span><br><span class="line">        <span class="keyword">while</span> cur:<span class="comment"># 遍历链表 </span></span><br><span class="line">            <span class="keyword">if</span> cur.val <span class="keyword">in</span> visited:<span class="comment"># 若节点值 cur.val 在 set 中</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span><span class="comment"># 删除节点 cur</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 若节点值 cur.val 不在 set 中</span></span><br><span class="line">                visited.add(cur.val)<span class="comment"># 将 cur.val 添加进 set</span></span><br><span class="line">                pre = cur<span class="comment"># 令 pre 指向 cur ，作为下一轮的前驱节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span><span class="comment"># 遍历下一节点</span></span><br><span class="line">        <span class="keyword">return</span> head<span class="comment"># 删除完成，返回链表头节点 head</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.72m13v2o2rg0.gif#pic_center" width = 48%><p><strong>82. 删除排序链表中的重复元素 II</strong></p><p>题目描述：给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;双指针记录 pre 用 cur 记录相同的数，加虚头节点&#x27;&#x27;&#x27;</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        prev, curr = dummy, dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:<span class="comment"># 如果有奇数个相同的值，就删不完，所以必须用 while 循环</span></span><br><span class="line">                    curr = curr.<span class="built_in">next</span>        <span class="comment"># 找到最后一个相等的数</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.8oxo1amj9zc.gif#pic_center" width = 48%><p><strong>19、删除链表的倒数第 N 个结点</strong></p><p>题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>1. 快慢指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        fast = dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 快指针先走n步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = dummy</span><br><span class="line">        <span class="keyword">while</span> fast:<span class="comment"># 快慢指针同时走，直到 fast 指针到达尾部节点，此时 slow 到达倒数第 N 个节点的前一个节点</span></span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 删除节点，并重新连接</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.401fcoye5po0.gif#pic_center" width = 48%><p><strong>2. 循环迭代 – 找到 length -n 个节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        cur, length = head, <span class="number">0</span> <span class="comment"># step1: 获取链表长度</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">        cur = dummy <span class="comment"># step2: 找到倒数第N个节点的前面一个节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length - n):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># step3: 删除节点，并重新连接</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><strong>3. 递归迭代 – 回溯时，进行节点计数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: </span><br><span class="line">            self.count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> head  </span><br><span class="line">        head.<span class="built_in">next</span> = self.removeNthFromEnd(head.<span class="built_in">next</span>, n) <span class="comment"># 递归调用</span></span><br><span class="line">        self.count += <span class="number">1</span> <span class="comment"># 回溯时进行节点计数</span></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span> <span class="keyword">if</span> self.count == n <span class="keyword">else</span> head </span><br></pre></td></tr></table></figure><p><strong>876、链表的中间结点</strong></p><p>题目描述：给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p><p>（1）若为奇数，指向中间的结点，若为偶数，指向中间靠后的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 如果不加 fast，链表元素个数为偶数时会报空指针异常；</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.4aza639wrhw0.webp#pic_center" width = 48%><p>（2）若为奇数，指向中间的结点，若为偶数，指向中间靠前的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.5096s37l9ow0.gif#pic_center" width = 48%><p><strong>86、分隔链表（两个临时链表）</strong></p><p>题目描述：给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)<span class="comment"># dummy1 存放小于x链表的虚拟头结点，dummy2存放不小于x的虚拟头结点</span></span><br><span class="line">        p, p1, p2 = head, dummy1, dummy2<span class="comment">#  p 负责遍历链表，类似合并两个有序链表的逻辑；p1, p2 指针负责生成结果链表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p </span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            temp = p.<span class="built_in">next</span><span class="comment"># 断开原链表中的每个结点的 next 指针</span></span><br><span class="line">            p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            p = temp</span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span><span class="comment"># 合并两个链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/022.2705dkyftrgg.webp#pic_center" width = 48%><p>这里为什么需要断开 next？</p><p>如果不断开直接 <code>p = p.next</code>，p 是正常往下走了，但是其中有个问题就是会陷入无限循环。以本题为例，由于14325的5在被p2连起来之后，其由于指向 p，因此 <code>p.next</code> 也是被继承过来的，所以后面是2，而 p 直接等于 <code>p.next</code> 后判断为2后，就直接加到 p1 后面了。现在问题就是 p1 中的 第一个2 指向的 第二个2 和 p2 中的 5 指向的 2 是一个指针(地址)，不把他们俩合并还好说，一旦合并，就成了 下图所示.的<code>1--&gt;2--&gt;2--&gt;4--&gt;3--&gt;5--&gt;2|--&gt;4--&gt;3--&gt;5--&gt;2|--&gt;4--&gt;...</code>，看出来了吗？形成了一个环了！</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/023.2ow0749423q0.webp#pic_center" width = 48%><p>因此在每步的赋值结束后，应当对next清除，以防止在最后的时候陷入这种无限循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 断开原链表中的每个结点的 next 指针</span></span><br><span class="line">temp = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span> = <span class="literal">None</span>   </span><br><span class="line">p = temp</span><br></pre></td></tr></table></figure><p>或者，如果不想每个都断开，其实在 p 往下走的时候，每个 p1 和 p2 的 next 都在同时进行着更新，因此只有 p2 的最后一个是存在问题的，因此也可以加一句 <code>p2.next = None</code> 来解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># dummy1 存放小于x链表的虚拟头结点， 度没有 存放不小于x的虚拟头结点</span></span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># p1, p2 指针负责生成结果链表</span></span><br><span class="line">        p1, p2 = dummy1, dummy2</span><br><span class="line">        <span class="comment"># p 负责遍历链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">        <span class="comment"># 这里是将两个链表分解成两个链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p </span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 合并两个链表</span></span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>328. 奇偶链表</strong></p><p>题目描述：给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。&#x3D;&#x3D;这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)</span><br><span class="line">        p, p1, p2 = head, dummy1, dummy2</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            temp = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            p = temp</span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/024.4donvqjwj440.gif#pic_center" width = 48%><h3 id="3-2-反转链表"><a href="#3-2-反转链表" class="headerlink" title="3.2 反转链表"></a>3.2 反转链表</h3><h4 id="3-2-1-题库列表"><a href="#3-2-1-题库列表" class="headerlink" title="3.2.1 题库列表"></a>3.2.1 题库列表</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank">206. 反转链表</a>====<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank">剑指 Offer 24. 反转链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank">92. 反转链表 II</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank">234. 回文链表</a>====<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank">面试题 02.06. 回文链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank">25. K 个一组翻转链表</a></p></blockquote> <p><strong>206、反转链表</strong><br>题目描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>1. 双指针法迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev, cur = <span class="literal">None</span>, head<span class="comment"># 申请两个节点，pre和 cur，pre指向None</span></span><br><span class="line">        <span class="keyword">while</span> cur:<span class="comment"># 遍历链表</span></span><br><span class="line">            temp = cur.<span class="built_in">next</span><span class="comment"># 记录当前节点的下一个节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev<span class="comment"># 然后将当前节点指向pre</span></span><br><span class="line">            prev = cur<span class="comment"># pre和cur节点都前进一位</span></span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/025.6glhs7jiai00.webp#pic_center" width = 48%><p><strong>2. 尾递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># reverse_head 表示 head.next 后面一整段反转之后的头结点，所以最后return reverse_head</span></span><br><span class="line">        reverse_head = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head<span class="comment"># 此时 head.next 指向的已经是反转部分的尾巴</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span><span class="comment"># head 指向 None，表示此时 head 已经是尾巴了</span></span><br><span class="line">        <span class="keyword">return</span> reverse_head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/026.2al8hft9no74.webp#pic_center" width = 48%><p><strong>92. 反转链表 II</strong></p><p>题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span>  head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):     <span class="comment"># 迭代法，先找到起点</span></span><br><span class="line">            prev= prev.<span class="built_in">next</span>         <span class="comment"># 来到 left 节点的前一个节点</span></span><br><span class="line">        curr = prev.<span class="built_in">next</span>            <span class="comment"># cur 是真正反转的指针</span></span><br><span class="line">        tail = curr</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right-left+<span class="number">1</span>):</span><br><span class="line">            node = curr.<span class="built_in">next</span>        <span class="comment"># node 保存 curr.next 的临时指针，保存后面的顺序</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span>   <span class="comment"># 将要反转的节点，接入到 left 节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = curr        </span><br><span class="line">            tail.<span class="built_in">next</span> = node</span><br><span class="line">            curr = node</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/027.6yezj4cz5100.gif#pic_center" width = 48%><p><strong>234. 回文链表</strong></p><p>题目描述：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br><strong>1. 数组模拟</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        prev, val_list = head, []</span><br><span class="line">        <span class="keyword">while</span> prev:</span><br><span class="line">            val_list.append(prev.val)</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> val_list == val_list[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 维持半条翻转链表（双指针）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        p, slow, fast = head, head, head<span class="comment"># p 存储前半段的尾结点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:   <span class="comment"># 快慢指针找到中间节点</span></span><br><span class="line">            p = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        left, right = head, self.reverse_list(slow)     <span class="comment"># 额外维持的半条链表；反转 slow 后面的元素</span></span><br><span class="line">        q = right<span class="comment"># 存储末尾的断点用于恢复原来链表的顺序</span></span><br><span class="line">        <span class="keyword">while</span> right:                                    <span class="comment"># 两个半长链表的比较 遍历两个 半长链表</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = self.reverse_list(q)<span class="comment"># 还原链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_list</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">        prev, curr = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            node = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = node</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p> <strong>温馨提示：</strong> 比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。可以记录前半段的尾结点，将后半部分翻转之后在比较完成之后再次翻转，再让前半段的尾结点指向两次翻转的后半部分即可还原链表。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/028.35rx78p4hwo0.gif#pic_center" width = 48%><p><strong>25. K 个一组翻转链表</strong></p><p>题目描述：给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br><strong>1. 模拟法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> k== <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev1, prev2, curr = dummy, dummy, dummy.<span class="built_in">next</span></span><br><span class="line">        count = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> prev1:        <span class="comment"># 查找节点个数</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            prev1 = prev1.<span class="built_in">next</span></span><br><span class="line">        tail = curr</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count//k):<span class="comment"># K个一组反转</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                prev2 = tail</span><br><span class="line">                tail = curr</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                temp = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev2.<span class="built_in">next</span></span><br><span class="line">                prev2.<span class="built_in">next</span> = curr</span><br><span class="line">                tail.<span class="built_in">next</span> = temp</span><br><span class="line">                curr = temp</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/029.6bao5ag72a80.gif#pic_center" width = 48%><h3 id="3-3-合并链表"><a href="#3-3-合并链表" class="headerlink" title="3.3  合并链表"></a>3.3  合并链表</h3><h4 id="3-3-1-题库列表"><a href="#3-3-1-题库列表" class="headerlink" title="3.3.1 题库列表"></a>3.3.1 题库列表</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank">21. 合并两个有序链表</a></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank">23. 合并K个升序链表</a></p></blockquote> <p><strong>21. 合并两个有序链表</strong><br>题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/030.7ky8cjucdmk0.gif#pic_center" width = 48%><p><strong>23. 合并K个升序链表</strong></p><p>题目描述：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>1. 顺序合并</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> lists[<span class="number">1</span>:]:</span><br><span class="line">            head = self.mergeTwoLists(head, item)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>2. 分治合并</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        n = <span class="built_in">len</span>(lists)                          <span class="comment"># 记录子链表数量</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(lists, <span class="number">0</span>, n - <span class="number">1</span>)  <span class="comment"># 调用归并排序函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode], l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> lists[l]</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        L = self.mergeSort(lists, l, m)         <span class="comment"># 循环的递归部分</span></span><br><span class="line">        R = self.mergeSort(lists, m + <span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(L, R)         <span class="comment"># 调用两链表合并函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/031.510611u0kd40.webp#pic_center" width = 30%><p><strong>3. 优先队列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">priority_queue = []</span><br><span class="line"><span class="keyword">for</span> llist <span class="keyword">in</span> lists: </span><br><span class="line">    <span class="keyword">while</span> llist:</span><br><span class="line">        heapq.heappush(priority_queue, llist.val)       <span class="comment"># 把llist中的数据逐个加到堆中</span></span><br><span class="line">        llist = llist.<span class="built_in">next</span></span><br><span class="line">dummy = ListNode(<span class="number">0</span>)                                     <span class="comment"># 构造虚节点</span></span><br><span class="line">p = dummy</span><br><span class="line"><span class="keyword">while</span> priority_queue:</span><br><span class="line">    p.<span class="built_in">next</span> = ListNode(heapq.heappop(priority_queue))    <span class="comment"># 依次弹出最小堆的数据</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/032.4vepkbla4040.gif#pic_center" width = 48%><h3 id="3-4-排序链表"><a href="#3-4-排序链表" class="headerlink" title="3.4 排序链表"></a>3.4 排序链表</h3><h4 id="3-4-1-解题方法"><a href="#3-4-1-解题方法" class="headerlink" title="3.4.1 解题方法"></a>3.4.1 解题方法</h4><p>在数组排序中，常见的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序等。</p><p>而对于链表排序而言，因为链表不支持随机访问，访问链表后面的节点只能依靠 next 指针从头部顺序遍历，所以相对于数组排序问题来说，链表排序问题会更加复杂一点。</p><p>下面先来总结一下 <strong>适合链表排序与不适合链表排序的算法：</strong></p><ul><li>适合链表的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、桶排序、基数排序。</li><li>不适合链表的排序算法：希尔排序。</li><li>可以用于链表排序但不建议使用的排序算法：堆排序。</li></ul><p> <strong>希尔排序为什么不适合链表排序？</strong><br>希尔排序：希尔排序中经常涉及到对序列中第 <code>i + gap</code> 的元素进行操作，其中<code>gap</code> 是希尔排序中当前的步长。而&#x3D;&#x3D;链表不支持随机访问的特性，导致这种操作不适合链表，因而希尔排序算法不适合进行链表排序。&#x3D;&#x3D;</p><p> <strong>为什么不建议使用堆排序？</strong></p><p>堆排序：堆排序所使用的最大堆 &#x2F; 最小堆结构本质上是一棵完全二叉树。而完全二叉树适合采用顺序存储结构（数组）。因为数组存储的完全二叉树可以很方便的通过下标序号来确定父亲节点和孩子节点，并且可以极大限度的节省存储空间。</p><p>而链表用在存储完全二叉树的时候，因为不支持随机访问的特性，导致其寻找子节点和父亲节点会比较耗时，如果增加指向父亲节点的变量，又会浪费大量存储空间。所以堆排序算法不适合进行链表排序。</p><p>如果一定要对链表进行堆排序，则可以使用额外的数组空间表示堆结构。然后将链表中各个节点的值依次添加入堆结构中，对数组进行堆排序。排序后，再按照堆中元素顺序，依次建立链表节点，构建新的链表并返回新链表头节点。</p><p>需要用到额外的辅助空间进行排序的算法</p><p>刚才我们说到如果一定要对链表进行堆排序，则需要使用额外的数组空间。除此之外，计数排序、桶排序、基数排序都需要用到额外的数组空间。</p><h4 id="3-4-2-题库列表："><a href="#3-4-2-题库列表：" class="headerlink" title="3.4.2 题库列表："></a>3.4.2 题库列表：</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank">147. 对链表进行插入排序</a></p><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank">148. 排序链表</a></p></blockquote> <p><strong>147. 对链表进行插入排序</strong><br>题目描述：给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)                 <span class="comment"># 会移动头结点，这里虚拟头结点</span></span><br><span class="line">        last_sorted, curr = head, head.<span class="built_in">next</span>        <span class="comment"># last_sorted 维护已排序部分的最后一个位置；curr 为遍历的待插入元素</span></span><br><span class="line">        <span class="keyword">while</span> curr:           <span class="comment"># 外层循环遍历完链表所有数；内层循环遍历[head, lastSort]这段位置找插入</span></span><br><span class="line">            <span class="keyword">if</span> curr.val &gt;= last_sorted.val:</span><br><span class="line">                last_sorted = last_sorted.<span class="built_in">next</span>      <span class="comment"># 大，直接后移，或者直接 last_sorted = cur</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummy                        <span class="comment"># 用来遍历已经排序的部分</span></span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val &lt;= curr.val:    <span class="comment"># 从前往后比较，找插入的位置</span></span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                last_sorted.<span class="built_in">next</span> = curr.<span class="built_in">next</span>        <span class="comment"># 找到位置进行插入操作</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            curr = last_sorted.<span class="built_in">next</span>                 <span class="comment"># 指针后移</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/033.74j918hmusw0.gif#pic_center" width = 48%><p><strong>148. 排序链表</strong><br>题目描述：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>插入排序的时间复杂度是 $O(n^2)$，其中 $n$ 是链表的长度。这里考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 $O(nlogn)$ 的时间复杂度和 $O(1)$ 的空间复杂度，时间复杂度是 $O(nlogn)$ 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 $O(n^2)$），其中最适合链表的排序算法是归并排序。</p><p><strong>1. 归并排序-迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]: </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:        <span class="comment"># 空链表直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        length = <span class="number">0</span>          <span class="comment"># 获取链表的长度</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node: </span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        sub_length = <span class="number">1</span>                                <span class="comment"># 归并的有效处理长度，最小为 1</span></span><br><span class="line">        <span class="keyword">while</span> sub_length &lt; length:</span><br><span class="line">            prev, curr = dummy_head, dummy_head.<span class="built_in">next</span>  <span class="comment"># 为了更好的实现迭代，定义 prev, curr 分别指向 dummy_head, dummy_head.next</span></span><br><span class="line">            <span class="keyword">while</span> curr:                               <span class="comment"># 当 cur 不为空时</span></span><br><span class="line">                head1 = curr                          <span class="comment"># 定义当前链表，head1 指向 cur</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sub_length):</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    当 i 等于 1 时, cur 不需要指向后下一个链表其余情况，</span></span><br><span class="line"><span class="string">                    cur 在链表 cur 不为空的情况, 向后移动 sub_length - 1 个位置</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                head2 = curr.<span class="built_in">next</span>   <span class="comment"># 切断链表，第一部分长度为 sub_length</span></span><br><span class="line">                curr.<span class="built_in">next</span> = <span class="literal">None</span>    <span class="comment"># 第二部分为 head 除 head1 以外的部分</span></span><br><span class="line">                curr = head2</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sub_length):  <span class="comment"># 将 cur 在满足 cur.next 不为空的情况下， 又往后移动 sub_length 长度</span></span><br><span class="line">                    <span class="keyword">if</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                remain = <span class="literal">None</span>         <span class="comment"># 定义 remain 链表，指向 null</span></span><br><span class="line">                <span class="keyword">if</span> curr:              <span class="comment"># 当移动完 sub_length 后，仍不为空，remain 等于 cur.next;</span></span><br><span class="line">                    remain = curr.<span class="built_in">next</span></span><br><span class="line">                    curr.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 切断链表， 这时候 head2 的长度与 head1 一致</span></span><br><span class="line">                </span><br><span class="line">                merged = self.merge(head1, head2)   <span class="comment"># merge , 然后 prev 的 next 指针指向将 merge 后的子链表</span></span><br><span class="line">                prev.<span class="built_in">next</span> = merged</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>:        <span class="comment"># 然后将 prev 指向与 merge 完成后的链表位置</span></span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                curr = remain           <span class="comment"># 然后当前节点位置指向 remain 部分链表</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            进入下一批次的归并排序操作，直到将相同 sub_length 的全部处理完，才会退出此处 while</span></span><br><span class="line"><span class="string">            再进入到下轮 sub_length, sub_length 以 1 -&gt; 2 -&gt; 4 -&gt; 8 的方法进行，符合自低向上不断迭代，</span></span><br><span class="line"><span class="string">            直到找到最终答案。其实递归底层本质也是一样的，到最短的1，才开始合并，不断合并，到最终结果</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            sub_length &lt;&lt;= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>)            <span class="comment"># 构建虚拟头结点</span></span><br><span class="line">        temp, temp1, temp2 = dummy_head, head1, head2</span><br><span class="line">        <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:              <span class="comment"># 开始合并操作</span></span><br><span class="line">            <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> temp1:                <span class="comment">#  如 temp1, temp2 还存在不为空的链表，将剩余部分赋值给 temp.next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">        <span class="keyword">elif</span> temp2:</span><br><span class="line">            temp.<span class="built_in">next</span> = temp2</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/034.1zary1lzo8e8.gif#pic_center" width = 48%><p><strong>2. 归并排序-递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">return</span> self.split_list(head) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_list</span>(<span class="params">self, head: ListNode</span>):   </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;处理归并排序的边界问题,下面两种场景都不需要进行分合操作&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        prev, slow, fast = head, head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:   <span class="comment"># 找中点,偶数找的后面那个中点的位置，奇数找到中点</span></span><br><span class="line">            prev = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = head, slow     <span class="comment"># 将链表分割成两个子链表</span></span><br><span class="line">        <span class="keyword">return</span> self.merge_sort(self.split_list(left), self.split_list(right))    <span class="comment"># 分割完后，进行合并部分操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;归并环节&#x27;&#x27;&#x27;</span></span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>)            <span class="comment"># 构建虚拟头结点</span></span><br><span class="line">        temp, temp1, temp2 = dummy_head, head1, head2</span><br><span class="line">        <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:              <span class="comment"># 开始合并操作</span></span><br><span class="line">            <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> temp1:                <span class="comment">#  如 temp1, temp2 还存在不为空的链表，将剩余部分赋值给 temp.next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">        <span class="keyword">elif</span> temp2:</span><br><span class="line">            temp.<span class="built_in">next</span> = temp2</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/035.69mibz76l6s0.gif#pic_center" width = 48%><p>了解更多，请阅读：<a href="https://leetcode.cn/problems/sort-list/solution/by-itcharge-01zg/">排序链表「八大排序算法」「Python 版」「链表、冒泡、选择、插入、归并、桶排序、计数排序、基数排序</a></p><h3 id="3-5-环形链表"><a href="#3-5-环形链表" class="headerlink" title="3.5 环形链表"></a>3.5 环形链表</h3><h4 id="3-5-1-题库列表"><a href="#3-5-1-题库列表" class="headerlink" title="3.5.1 题库列表"></a>3.5.1 题库列表</h4><blockquote> <ul><li> <p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank">160. 相交链表</a></p> </li><li> <p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank">141. 环形链表</a></p> <li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank">142. 环形链表 II</a></li></ul> </li></ul></blockquote> <p><strong>160. 相交链表</strong><br>题目描述：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p1, p2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:<span class="comment"># 退出的关键是：指向同一个指针（不是值相等），或者都指 None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                p1 = headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                p2 = headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p1<span class="comment"># 如果没有相等的那么nodeA==nodeB==null</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/036.6sj6veryvqs0.gif#pic_center" width = 48%><p><strong>141. 环形链表</strong><br>题目描述：给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 快指针在前面，所以只要判断快指针是否达到了队尾就可以</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/037.2x97g491nw60.gif#pic_center" width = 48%><p><strong>142. 环形链表 II</strong><br>题目描述：给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 快慢指针找重合点</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:<span class="comment"># 重合了，这个时候，从头来一个指针遍历</span></span><br><span class="line">                p1 = slow</span><br><span class="line">                p2 = head</span><br><span class="line">                <span class="keyword">while</span> p1 != p2:</span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    p2 = p2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> p2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span><span class="comment"># 没有环，返回 None</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/038.5kfy8p3vjk40.gif#pic_center" width = 48%><p><br></br></p><blockquote><p><font color=#9900CC><strong>终于小结完了，期待下一专题——二叉树，也期待各位小伙伴们一起来学习与交流！</font></strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/039.4anrfsp19o60.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>一文搞定常见的链表问题：<a href="https://leetcode.cn/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/">https://leetcode.cn/problems/linked-list-cycle/</a></li><li>链表常见问题解决思路：<a href="https://blog.csdn.net/weixin_43910851/article/details/105725577">https://blog.csdn.net/weixin_43910851&#x2F;article&#x2F;details&#x2F;105725577</a></li><li>一文通数据结构与算法之——链表+常见题型与解题策略+Leetcode经典题：<a href="https://blog.csdn.net/qq_42647903/article/details/120594925">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594925</a></li><li>两个技巧搞定常见面试链表题：<a href="https://blog.csdn.net/weixin_45750855/article/details/120065894#:~:text=%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7%E6%90%9E%E5%AE%9A%E5%8A%9B%E6%89%A3%E5%B8%B8%E8%A7%81%20%E9%93%BE%E8%A1%A8%20%E9%A2%98%201%201.%20%E6%8E%8C%E6%8F%A1%E5%93%91%E8%8A%82%E7%82%B9%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7%E5%AF%BC%E8%87%B4%E5%9C%A8%E6%88%91%E4%BB%AC%E5%AF%B9%E5%A4%B4%E7%BB%93%E7%82%B9%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%20%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%A4%B4%E8%8A%82%E7%82%B9%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E3%80%82,%E5%92%8C%20slow%EF%BC%8C%E5%88%9D%E5%A7%8B%E6%97%B6%E5%9D%87%E6%8C%87%E5%90%91%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82%20%E9%A6%96%E5%85%88%EF%BC%8C%E5%85%88%E8%AE%A9%20fast%20%E7%A7%BB%E5%8A%A8%20k%20%E6%AC%A1%E3%80%82%20">https://blog.csdn.net/weixin_45750855&#x2F;article&#x2F;details&#x2F;</a></li><li>算法面试题 | 链表问题总结：<a href="https://juejin.cn/post/6882370280946302983">https://juejin.cn/post/6882370280946302983</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇信息量巨大，首先对比链表和数组，接着解决单链表的反转、删除某一节点、插入数据、查找中间节点、求倒数第k个结点、对称链表、单链表是否有环、两个链表是否相交，最后用LeetCode上的真题来实战删除链表结点、反转链表、合并、排序、环形链表常用技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="反转链表" scheme="https://qxienote.com/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
    <category term="合并链表" scheme="https://qxienote.com/tags/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    
    <category term="排序链表" scheme="https://qxienote.com/tags/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    
    <category term="环形链表" scheme="https://qxienote.com/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>《计算机网络-自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</title>
    <link href="https://qxienote.com/article/396f3774.html"/>
    <id>https://qxienote.com/article/396f3774.html</id>
    <published>2023-06-11T03:09:59.000Z</published>
    <updated>2023-06-11T03:43:49.329Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。</p><span id="more"></span><p>要深入理解网络协议，需要仔细观察协议实体之间交换的报文序列。为探究协议操作细节，可使协议实体执行某些动作，观察这些动作及其影响。这些任务可以在仿真环境下或在如因特网这样的真实网络环境中完成。观察在正在运行协议实体间交换报文的基本工具被称为分组嗅探器(<code>packet sniffer</code>)。顾名思义，一个分组嗅探器捕获（嗅探）计算机发送和接收的报文。一般情况下，分组嗅探器将存储和显示出被捕获报文的各协议头部字段内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.6gwpvo7pots0.webp#pic_center" width = 48%><p>上图右边是计算机上正常运行的协议（在这里是因特网协议）和应用程序（如：<code>Web</code> 浏览器和 <code>ftp</code> 客户端）。分组嗅探器（虚线框中的部分）是附加在计算机普通软件上的，主要由两部分组成。分组捕获库接收计算机发送和接收的每一个链路层帧的拷贝。高层协议（如：<code>HTTP</code>、 <code>FTP</code>、 <code>TCP</code>、 <code>UDP</code>、 <code>DNS</code>、 <code>IP</code> 等）交换的报文都被封装在链路层帧(Frame)中，并沿着物理介质（如以太网的电缆）传输。上图假设所使用的物理媒体是以太网，上层协议的报文最终封装在以太网帧中。</p><p>分组嗅探器的第二个组成部分是分析器。分析器用来显示协议报文所有字段的内容。为此，分析器必须能够理解协议所交换的所有报文的结构。例如：我们要显示上图中 HTTP 协议所交换的报文的各个字段。分组分析器理解以太网帧格式，能够识别包含在帧中的 IP 数据报。分组分析器也要理解 IP 数据报的格式，并能从 IP 数据报中提取出 TCP 报文段。然后，它需要理解 TCP 报文段，并能够从中提取出 HTTP 消息。最后，它需要理解 HTTP 消息。</p><p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和Linux&#x2F;Unix计算机上运行，是进行网络实验的理想分组分析器。该软件具有庞大的用户基础，文档支持包括用户指南、手册和常见问题(详见<a href="http://www.wireshark.org/docs">http://www.wireshark.org/docs</a>)，丰富的功能包括分析数百种协议，以及精心设计的用户界面。可以运行在使用以太网、串行(PPP和SLIP)、802.11无线局域网和许多其他链路层技术的计算机上。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.6fvhzc6qeb40.webp#pic_center" width = 48%><p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark。</p><h2 id="1-下载并安装Wireshark软件"><a href="#1-下载并安装Wireshark软件" class="headerlink" title="1 下载并安装Wireshark软件"></a>1 下载并安装Wireshark软件</h2><p>WireShark 是一种可以运行在 Windows，UNIX，Linux 等操作系统上的分组分析器。运行Wireshark，需要有一台支持Wireshark和libpcap或WinPCap分组捕获库的计算机。安装Wireshark时，如果操作系统中未安装libpcap软件，它将会自动安装。支持的操作系统和下载站点的列表，请访问[<a href="http://www.wireshark.org/download.html]">http://www.wireshark.org/download.html]</a>(<a href="http://www.wireshark.org/download.html%E3%80%82%E6%8C%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E6%8C%89%E7%85%A7%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E4%B8%80%E8%B7%AFNext%E5%AE%89%E8%A3%85%E3%80%82">http://www.wireshark.org/download.html。按照系统版本选择下载，下载完成后，按照软件提示一路Next安装。</a></p><p> <strong>温馨提示：</strong> 当您在安装或运行Wireshark时遇到问题时，可以查看Wireshark FAQ，它包含一些有用的提示和信息。如果你是Win10系统，安装完成后，选择抓包但是不显示网卡，下载win10pcap兼容性安装包。下载路径：<a href="http://www.win10pcap.org/download/">下载路径：win10pcap兼容性安装包</a></p><h2 id="2-Wireshark-开始抓包示例"><a href="#2-Wireshark-开始抓包示例" class="headerlink" title="2 Wireshark 开始抓包示例"></a>2 Wireshark 开始抓包示例</h2><p>1、双击桌面上的图标，可启动Wireshark。启动后的用户界面如下图所示，中间列表部分列出了所有网络接口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.38sj0cnbnum0.webp#pic_center" width = 48%><p>2、选择菜单栏上捕获 -&gt; 选项，勾选WLAN网卡（这里需要根据各自电脑网卡使用情况选择，简单的办法可以看使用的IP对应的网卡）。点击Start。启动抓包。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4qe115vaeae0.webp#pic_center" width = 48%><p>3、wireshark启动后，wireshark处于抓包状态中。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.3la44n2lec40.webp#pic_center" width = 48%><p>4、执行需要抓包的操作，如在cmd窗口下执行<code>ping www.baidu.com</code>。</p><p>5、抓取分组操作</p><p>A.单击中间网络接口列表中，某一网络接口如<code>eth0</code>，选中网络接口，通过菜单“捕获”-“开始”或工具栏中的<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 按钮，开始捕获选定接口中的网络分组；B．也可以双击中间网络接口列表中，某一网络接口如<code>eth0</code>，可以开始抓取分组；C．通过菜单“捕获”-“停止”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 停止抓取分组。D．通过菜单“捕获”-“重新开始”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 重新开始抓取。</p><p>6、Wireshark窗口功能</p><p><strong>A．命令菜单和工具栏</strong><br>命令菜单位于窗口的最顶部，是标准的下拉式菜单。最常用菜单命令有两个： 文件、 捕获。 文件 菜单允许你保存捕获的分组数据，或打开一个已被保存的捕获分组数据文件，或退出 WireShark 程序。 捕获 菜单允许你开始捕获分组。</p><p>工具栏位于命令菜单的下方，提供常用功能的快捷方式。如<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：开始捕获、<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：停止捕获、<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：重新抓取分组。</p><p><strong>B．显示过滤规则</strong></p><p>在该字段中，可以填写协议的名称或其他信息，根据此内容可以对分组列表窗口中的分组进行过滤。</p><p><strong>C．捕获分组列表</strong></p><p>按行显示已被捕获的分组内容，其中包括： WireShark 赋予的分组序号、捕获时间、分组的源地址和目的地址、协议类型、分组中所包含的协议说明信息。单击某一列的列名，可以使分组按指定列进行排序。 在该列表中，所显示的协议类型是发送或接收分组的最高层协议的类型。</p><p><strong>D．分组头部明细</strong></p><p>显示捕获分组列表窗口中被选中分组的头部详细信息。包括：与以太网帧有关的信息，与包含在该分组中的 IP 数据报有关的信息。</p><p>单击以太网帧或 IP 数据报所在行左边的向右或向下的箭头可以展开或最小化相关信息。如果利用 TCP 或 UDP 承载分组， WireShark 也会显示 TCP 或 UDP 协议头部信息。分组最高层协议的头部字段也会显示在此窗口中。</p><p><strong>E．分组内容窗口</strong></p><p>以 ASCII 码和十六进制两种格式显示被捕获帧的完整内容。</p><p>7、通常，分组列表窗口中会显示许多类型的分组。即使仅仅是下载了一个网页，但是还有许多其他协议在您的计算机上运行，只是用户所看不见。可以在中间过滤窗口中输入过滤的分组协议如http， 选择应用按钮，就可以只让HTTP分组消息显示在分组列表窗口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.4x7p2hmwhiw0.webp#pic_center" width = 48%><p>8、操作完成后相关数据包就抓取到了。为避免其他无用的数据包影响分析，可以通过在过滤栏设置过滤条件进行数据包列表过滤，获取结果如下。说明：<code>ip.addr == 119.75.217.26 and icmp</code> 表示只显示ICPM协议且源主机IP或者目的主机IP为<code>119.75.217.26</code>的数据包。说明：协议名称icmp要小写。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.sm5aj8usjww.webp#pic_center" width = 48%><h2 id="3-Wireshakr抓包界面介绍"><a href="#3-Wireshakr抓包界面介绍" class="headerlink" title="3 Wireshakr抓包界面介绍"></a>3 Wireshakr抓包界面介绍</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.61b2vxymuhg0.webp#pic_center" width = 36%><p>说明：数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏 视图(View) –&gt; 着色规则(Coloring Rules)。如下所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.4owrci6ggh00.webp#pic_center" width = 48%><ol><li>显示过滤器(Display Filter)，用于设置过滤条件进行数据包列表过滤。菜单路径：分析(Analyze) –&gt; 显示过滤器(Display Filters)。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.726v80qr0vg0.webp#pic_center" width = 48%><ol><li>数据包列表(Packet List Pane)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。</li></ol><p>Time:时间；Source:发送主机IP地址；Destination: 接收主机IP地址；Protocol：分组协议；Length：分组长度；Info：分组内容</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.7829pakw1us0.webp#pic_center" width = 48%><ol><li>数据包详细信息(Packet Details Pane), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为<br>（1）Frame:   物理层的数据帧概况<br>（2）Ethernet II: 数据链路层以太网帧头部信息<br>（3）Internet Protocol Version 4: 互联网层IP包头部信息<br>（4）Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP<br>（5）Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.4xs9wudqaak0.webp#pic_center" width = 48%><p>TCP包的具体内容</p><p>从下图可以看到wireshark捕获到的TCP包中的每个字段。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.2sybmlwvjy00.webp#pic_center" width = 48%><ol><li>数据包字节区(Dissector Pane)。</li></ol><p>在分组内容窗口中，可以显示出该分组内容的16进制和ASCII两种格式的内容。鼠标指向内容窗口，可以将分组中某一字段的内容突出显示。在分组头部信息窗口中，展开选择某一头部信息时，分组内容中相应内容同步突出显示。</p><h2 id="4-Wireshark过滤器设置"><a href="#4-Wireshark过滤器设置" class="headerlink" title="4 Wireshark过滤器设置"></a>4 Wireshark过滤器设置</h2><p>初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己需要抓取的数据包部分。wireshark工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p><p><strong>1) 抓包过滤器</strong></p><p>捕获过滤器的菜单栏路径为Capture –&gt; Capture Filters。用于在抓取数据包前设置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.6uzm0lq7h800.webp#pic_center" width = 48%><p>如何使用？可以在抓取数据包前设置如下。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.5zbhvy2gomw0.webp#pic_center" width = 48%><p><code>ip host 60.207.246.216 and icmp</code> 表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.2k7fnwqaoo20.webp#pic_center" width = 48%><p><strong>（2）显示过滤器</strong></p><p>显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛或者没有设置导致抓取的数据包内容较多时使用显示过滤器设置条件过滤以方便分析。同样上述场景，在捕获时未设置抓包过滤规则直接通过网卡进行抓取所有数据包，如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.1p43gtotb00w.webp#pic_center" width = 48%><p>执行 <code>ping www.baidu.com</code> 获取的数据包列表如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.2hu9htl72eo0.webp#pic_center" width = 48%><p>观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。<code>ip.addr == 14.119.104.254 and icmp</code>。并进行过滤。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.4q6cjmtdeei0.webp#pic_center" width = 48%><p>上述介绍了抓包过滤器和显示过滤器的基本使用方法。在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。下面介绍一下两者间的语法以及它们的区别。</p><h2 id="5-wireshark过滤器表达式的规则"><a href="#5-wireshark过滤器表达式的规则" class="headerlink" title="5 wireshark过滤器表达式的规则"></a>5 wireshark过滤器表达式的规则</h2><p>1、抓包过滤器语法和实例</p><p>抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）</p><p>(1) 协议过滤</p><p>比较简单，直接在抓包过滤框中直接输入协议名即可。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><p>(2) IP过滤</p><ul><li>host 192.168.1.104</li><li>src host 192.168.1.104</li><li>dst host 192.168.1.104</li></ul><p>(3) 端口过滤</p><ul><li>port 80</li><li>src port 80</li><li>dst port 80</li></ul><p>(4) 逻辑运算符 &amp;&amp; 与、|| 或、！非</p><ul><li><code>src host 192.168.1.104 &amp;&amp; dst port 80</code> 抓取主机地址为192.168.1.80、目的端口为80的数据包</li><li><code>host 192.168.1.104 || host 192.168.1.102</code> 抓取主机为192.168.1.104或者192.168.1.102的数据包</li><li><code>!broadcast</code> 不抓取广播数据包</li></ul><p>2、显示过滤器语法和实例<br>(1) 比较操作符</p><p>比较操作符有&#x3D;&#x3D; 等于、！&#x3D; 不等于、&gt; 大于、&lt; 小于、&gt;&#x3D; 大于等于、&lt;&#x3D;小于等于。</p><p>(2) 协议过滤</p><p>比较简单，直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(3) ip过滤</p><ul><li><code>ip.src ==192.168.1.104</code>，显示源地址为192.168.1.104的数据包列表</li><li><code>ip.dst==192.168.1.104</code>，显示目标地址为192.168.1.104的数据包列表</li><li><code>ip.addr == 192.168.1.104</code>，显示源IP地址或目标IP地址为192.168.1.104的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(4) 端口过滤</p><ul><li>tcp.port &#x3D;&#x3D;80,  显示源主机或者目的主机端口为80的数据包列表。</li><li>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的源主机端口为80的数据包列表。</li><li>tcp.dstport &#x3D;&#x3D; 80，只显示TCP协议的目的主机端口为80的数据包列表。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/042.4ni1tou9im80.webp#pic_center" width = 48%><p>(5) Http模式过滤</p><p><code>http.request.method==&quot;GET&quot;</code>, 只显示HTTP GET方法的。</p><p>(6) 逻辑运算符为 and&#x2F;or&#x2F;not</p><p>过滤多个条件组合时，使用and&#x2F;or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为 <code>ip.addr == 14.119.104.254 and icmp</code></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.oe0q389yzmo.webp#pic_center" width = 48%><p>(7) 按照数据包内容过滤。假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.2eq42rto5h34.webp#pic_center" width = 48%><p>右键单击选中后出现如下界面</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.9tlmp06f5y8.webp#pic_center" width = 48%><p>选中Select后在过滤器中显示如下，后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含”abcd”内容的数据流。包含的关键词是contains 后面跟上内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4v5jwne3bpq0.webp#pic_center" width = 48%><p>调整数据包列表中时间戳显示格式。调整方法为View –&gt;Time Display Format –&gt; Date and Time of Day。调整后格式如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.3f70teoime8.webp#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>wireshark 基本使用：<a href="https://www.educoder.net/shixuns/5kuyi2hn/challenges">https://www.educoder.net/shixuns/5kuyi2hn/challenges</a></li><li>wireshark抓包新手使用教程：<a href="https://www.cnblogs.com/linyfeng/p/9496126.html">https://www.cnblogs.com/linyfeng/p/9496126.html</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络-自顶向下方法" scheme="https://qxienote.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Wireshark" scheme="https://qxienote.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法篇（十）-- 链表的实现</title>
    <link href="https://qxienote.com/article/4e528de2.html"/>
    <id>https://qxienote.com/article/4e528de2.html</id>
    <published>2023-06-11T03:09:20.000Z</published>
    <updated>2023-06-11T09:57:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要学习使用Python实现链表，包括链表增加元素、删除元素、扫描、定位、遍历，以及循环单链表和双链表的实现。</p><span id="more"></span><p>实现线性表的另一种常用方式就是基于链接结构，用链接关系显式表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或者链表。</p><p>采用链接方式实现线性表的基本想法如下:</p><ul><li>把表中的元素分别存储在一批独立的存储块（称为表的结点）里。</li><li>保证从组成表结构中的任一个结点可找到与其相关的下一个结点。</li><li>在前一结点里用链接的方式显式地记录与下一结点之间的关联。</li></ul><p>这样，只要能找到组成一个表结构的第一个结点，就能顺序找到属于这个表的其他结点。从这些结点里可以看到这个表中的所有元素。</p><p>链接技术是一类非常灵活的数据组织技术，实现链表有多种不同的方式。下面首先讨论最简单的单链表，其中在每个表结点里记录着存储下一个表元素的结点的标识(引用&#x2F;链接)。后面将介绍另外一些结构的链表，它们各有所长，支持不同的需要。在下面的讨论中，将把“存储着下一个表元素的结点”简称为“下一结点”。</p><h2 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1 单链表"></a>1 单链表</h2><p>单向链接表（下面将简称为单链表或者链表）的结点是一个二元组，形式如下图a所示，其表元素域 elem 保存着作为表元素的数据项（或者数据项的关联信息），链接域 next 里保存同一个表里的下一个结点的标识。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6urmjtr0pm4.webp#pic_center" width = 48%><p>在最常见形式的单链表里，与表里的n个元素对应的n个结点通过链接形成一条结点链，如上图b所示。从引用表中首结点的变量（上图b中变量p）可以找到这个表的首结点，从表中任一结点可以找到保存着该表下一个元素的结点（表中下一结点），这样，从p出发就能找到这个表里的任一个结点。</p><p>要想掌握一个单链表，就需要（也只需要）掌握这个表的首结点，从它出发可以找到这个表里的第一个元素（即在这个表结点里保存的数据，保存在它的 elem域中），还可以找到这个表里的下一结点（有关信息保存在这个结点的 next 域中）。按照同样的方式继续下去，就可以找到表里的所有数据元素。</p><p>也就是说，为了掌握一个表，只需要用一个变量保存着这个表的首结点的引用（标识或称为链接）。今后将把这样的变量称为<font color=#9900CC><strong>表头变量或表头指针</font></strong>。</p><p><strong>小结一下：</strong></p><ul><li>—个单链表由一些具体的表结点构成。</li><li>每个结点是一个对象，有自己的标识，下面也常称其为该结点的链接。</li><li>结点之间通过结点链接建立起单向的顺序联系。</li></ul><p>为了表示一个链表的结束，只需给表的最后结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（称为空链接），在 Python 里自然可以用系统常量 None 表示这种情况，在上图里用接地符号“丄”表示链表结束，下面将一直这样表示。</p><p>通过判断一个（域或变量的）值是否为空链接，可知是否已到链表的结束。在顺序扫描表结点时，应该用这种方法确定操作是否完成。如果一个表头指针的值是空链接，就说明“它所引用的链表已经结束”，这是没有元素就已结束，说明该表是空表。</p><p>在实现链表上的算法时，并不需要关心在某个具体的表里各结点的具体链接值是什么（虽然保存在表结构里的值都是具体的），只需要关心链表的逻辑结构。对链表的操作也只需要根据链表的逻辑结构考虑和实现。</p><p>为方便下面的讨论，现在定义个简单的表结点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, elem=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.elem = elem    </span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h3><p> <strong>创建空链表：</strong> 只需要把相应的表头变量设置为空链接，在Python语言中将其设置为None，在其他语言里也有惯用值，例如有的语言里用0作为这个特殊值。</p><p> <strong>删除链表：</strong> 应丢弃这个链表里的所有结点。这个操作的实现与具体的语言环境有关。在一些语言（如C语言）里，需要通过明确的操作释放一个个结点所用的存储。在Python语言中这个操作很简单，只需简单地将表指针赋值为None，就抛弃了链表原有的所有结点。Python解释器的存储管理系统会自动回收不用的存储。</p><p> <strong>判断表是否为空：</strong> 将表头变量的值与空链接比较。在Python语言中，就是检查相应变量的值是否为None.</p><p> <strong>判断表是否满：</strong> 一般而言链表不会满，除非程序用完了所有可用的存储空间。</p><p><strong>加入元素</strong></p><p>现在考虑给单链表加入元素的操作，同样有插入位置问题，可以做首端插入、尾端插人或者定位插人。不同位置的操作复杂度可能不同。</p><p>首先应该注意，在链表里加入新元素时，并不需要移动已有的数据，只需为新元素安排一个新结点，然后根据操作要求，把新结点连在表中的正确位置。也就是说，插入新元素的操作是通过修改链接，接入新结点，从而改变表结构的方式实现的。</p><p><strong>表首端插入：</strong> 首端插入元素要求把新数据元素插入表中，作为表的第一个元素，这是最简单的情况。这一操作需要通过三步完成：</p><ol><li>创建一个新结点并存入数据（下图a表示要向表头变量 head 的链表加入新首元素13，为它创建了新结点，变量q指着该结点。这是实际插入前的状态）。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.1nk62pq0gjvk.webp#pic_center" width = 48%><ol><li><p>把原链表首结点的链接存入新结点的链接域 next，这一操作将原表的一串结点链接在刚创建的新结点之后。</p></li><li><p>修改表头变量，使之指向新结点，这个操作使新结点实际成为表头变量所指的结点，即表的首结点（上图b表示设置链接的这两步操作完成后的状态，新结点已成为 head 所指链表的首结点，13成为这个表的首元素。注意，示意图中链接指针的长度和形状都不表示任何意义，只有图中的链接指向关系有意义）。</p></li></ol><p>注意，即使在插入前head指向的是空表，上面三步也能正确完成工作。这个插人只是一次安排新存储和几次赋值，操作具有常量时间复杂度。</p><p>示例代码段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = ListNode(<span class="number">13</span>)</span><br><span class="line">q.<span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">head = q</span><br></pre></td></tr></table></figure><p> <strong>一般情况的元素插入：</strong> 要想在单链表里的某位置插入一个新结点，必须先找到该位置之前的那个结点，因为新结点需要插入在它的后面，需要修改它的next 域。如何找到这个结点的问题将在后面讨论，先看已经找到了这个结点之后怎样插入元素。</p><p>设变量pre已指向要插入元素位置的前一结点，操作也分为三步:</p><ol><li>创建一个新结点并存入数据（下图a是实际插入前的状态）。</li><li>把 pre 所指结点 next 域的值存入新结点的链接域 next，这个操作将原表在 pre 所指结点之后的一段链接到新结点之后。</li><li>修改 pre 的 next 域，使之指向新结点，这个操作把新结点链入被操作的表，整个操作完成后的状态如下图b所示。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.4nd11m338680.webp#pic_center" width = 48%><p>注意，即使在插入前 pre 所指结点是表中最后一个结点，上述操作也能将新结点正确接入，作为新的表尾结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = ListNode(<span class="number">13</span>)</span><br><span class="line">q.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">pre.<span class="built_in">next</span> = q</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><p>删除链表中元素，也可通过调整表结构删除表中结点的方式完成。这里也区分两种情况：删除表头结点的操作可以直接完成，删除其他结点也需要掌握其前一结点。</p><p> <strong>删除表首元素：</strong> 删除表中第一个元素对应于删除表的第一个结点，为此只需修改表头指针，令其指向表中第二个结点。丢弃不用的结点将被Python解释器自动回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>一般情况的元素删除：一般情况删除须先找到要删元素所在结点的前一结点，设用变量pre指向，然后修改pre的next域，使之指向被删结点的下一结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>显然，这两个操作都要求被删结点存在。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.11jtua2aafu8.webp#pic_center" width = 48%><p>如果在其他编程语言里删除结点，还可能要自己释放存储。Python的自动存储管理机制能自动处理这方面的问题，使编程工作更简单，也保证了安全性。</p><p><strong>扫描、定位和遍历</strong></p><p>在一般情况下插入和删除元素，都要求找到被删结点的前一结点。另外，程序里也可能需要定位链表中的元素、修改元素、逐个处理其中元素等。这些操作都需要检查链表的内容，实际上是检查表中的一些（或全部）结点。</p><p>由于单链表只有一个方向的链接，开始情况下只有表头变量在掌握中，所以对表内容的一切检查都只能从表头变量开始，沿着表中链接逐步进行。这种操作过程称为链表的扫描，这种过程的基本操作模式是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> 还需继续的其他条件:</span><br><span class="line">    对p所指结点里的数据做所需操作</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>根据Python语言的规定，这里的 <code>p is not None</code> 可以简单地只写一个 <code>p</code>。</p><p>循环的继续（或结束）条件、循环中的操作由具体问题决定。循环中使用的辅助变量p称为<font color=#9900CC><strong>扫描指针</font></strong>。注意，每个扫描循环必须用一个扫描指针作为控制变量，每步迭代前必须检查其值是否为None，保证随后操作的合法性。这与连续表的越界检查类似。</p><p>上面表扫描模式是最一般的链表操作模式，下面介绍几个常用操作的实现。</p><p> <strong>按下标定位：</strong> 按 Python 惯例，链表首结点的元素应看作下标0，其他元素依次排列。确定第i个元素所在结点的操作称为按下标定位，可以参考表扫描模式写出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> NOne <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>假设循环前变量i已有所需的值，循环结束时可能出现两种情况：或者扫描完表中所有结点还没有找到第i个结点，或者p所指结点就是所需。通过检查 p 值是否为None可以区分这两种情况。显然，如果现在需要删除第k个结点，可以先将i设置为k-1，循环后检查i是0且p.next不是None就可以执行删除了。</p><p> <strong>按元素定位：</strong> 假设需要在链表里找到满足谓词pred的元素。同样可以参考上面的表扫描模式，写出的检索循环如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> pred(p.elem):</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>循环结束时或者p是None；或者 <code>pred(p.elem)</code> 是 True，找到了所需元素。</p><p>完整的扫描称为遍历，这样做通常是需要对表中每个元素做一些事情，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(p.elem)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>这个循环依次输出表中各元素。只以条件 <code>p is not None</code> 控制循环，就能完成一遍完整的遍历。同样模式可用于做其他工作。</p><p><strong>链表操作的复杂度</strong><br>总结一下链表操作的时间复杂度。</p><ul><li><p>创建空表：$O(1)$。</p></li><li><p>删除表：在Python里是$O(1)$。当然，Python 解释器做存储管理也需要时间。</p></li><li><p>判断空表：$O(1)$。</p></li><li><p>加入元素（都需要加一个T(分配)的时间）</p><ul><li>首端加入元素：$O(1)$。</li><li>尾端加入元素：$O(n)$、因为需要找到表的最后结点。</li><li>定位加人元素：$O(n)$，平均情况和最坏情况。</li></ul></li><li><p>删除元素:</p><ul><li>首端删除元素：$O(1)$。</li><li>尾端删除元素：$O(n)$。</li><li>定位删除元素：$O(n)$，平均情况和最坏情况。</li><li>其他册除：通常需要扫描整个表或其一部分$O(n)$。</li></ul></li></ul><p>扫描、定位或遍历操作都需要检查一批表结点，其复杂度受到表结点数的约束，都是 $O(n)$ 操作。其他在工作中有此类行为的操作也至少具有 $O(n)$ 时间复杂度。</p><p><strong>求表的长度</strong></p><p>在使用链表时，经常需要求表的长度，为此可以定义一个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, n = head, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p>这个函数采用表扫描模式，遍历表中所有结点完成计数。显然，这个求表长度的算法所用时间与表结点个数成正比，具有 $O(n)$ 时间复杂度。</p><p><strong>实现方式的变化</strong></p><p>以求表的长度为例，如果程序经常需要调用上面函数，$O(n)$ 复杂度就可能成为效率问题。如果表很长，执行该函数就可能造成可察觉的停顿。解决这个问题的一种方法是改造单链表的实现结构，增加一个表长度记录。显然，这个记录不属于任何表元素，是有关表的整体的信息。表示这件事的恰当方法是定义一种链表对象，把表的长度和表中的结点链表都作为这个表对象的数据成分，如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.1og2k56a4zvk.webp#pic_center" width = 48%><p>图中变星p指向表对象，这个对象的一个数据域记录表中元素个数（图中的20表示这个表当时有20个结点），另一个域引用着该表的结点链。采用了这种表示方式，求表长度的操作就可以简单返回元素计数域的值。但另一方面，这种表的每个变动操作都需要维护计数值。从整体看有得有失。这种调整消除了一个线性时间操作，可能在一些应用中很有意义。</p><h3 id="1-2-单链表类的实现"><a href="#1-2-单链表类的实现" class="headerlink" title="1.2 单链表类的实现"></a>1.2 单链表类的实现</h3><p><strong>自定义异常</strong></p><p>为能合理地处理一些链表操作中遇到的错误状态（例如，方法执行时遇到了无法操作的错误参数），首先为链表类定义一个新的异常类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListUnderflow</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里把LinkedListUnderflow定义为标准异常类valueError的子类，准备在空表访问元索等场合抛出这个异常。在这些情况下抛出 valueError 也没问题，但定义了自己的异常类，就可以写专门的异常处理器，在一些情况下可能有用。</p><p><strong>LList类的定义，初始化函数和简单操作</strong></p><p>现在基于结点类 ListNode 定义一个单链表对象的类，在这种表对象里只有一个引用链接结点的_head域，初始化为None表示建立的是一个空表。判断表空的操作检查_head；在表头插入数据的操作是prepend，它把包含新元素的结点链接在最前面；操作 pop 删除表头结点并返回这个结点里的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self, elem</span>):</span><br><span class="line">        self._head = ListNode(elem, self._head)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:      <span class="comment"># 无结点，引发异常</span></span><br><span class="line">            <span class="keyword">raise</span> LinkedListUnorderflow(<span class="string">&quot;in pop&quot;</span>)</span><br><span class="line">        e = self._head.elem</span><br><span class="line">        self._head = self._head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure><p>这里把 LList 对象的 <code>_head</code> 域作为对象的内部表示，不希望外部使用。上面定义里的几个操作都很简单，只有 pop 操作需要检查对象的状态，表中无元素时引发异常。</p><p><strong>后端操作</strong></p><p>在链表的最后插入元素，必须先找到链表的最后一个结点。其实现首先是一个扫描循环，找到相应结点后把包含新元素的结点插入在其后。下面是定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, elem</span>):</span><br><span class="line">    <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._head = ListNone(elem)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    p.<span class="built_in">next</span> = ListNode(elem)</span><br></pre></td></tr></table></figure><p>这里需要区分两种情况：如果原表为空，引用新结点的就应该是表对象的_head域，否则就是已有的最后结点的next域。两种情况下需要修改的数据域不一样。许多链表变动操作都会遇到这个问题，只有表首端插入&#x2F;删除可以统一处理。</p><p>现在考虑删除表中最后元素的操作，也就是要删除最后的结点。前面说过，要从单链表中删除一个结点，就必须找到它的前一结点。在尾端删除操作里，扫描循环应该找到表中倒数第二个结点，也就是找到<code>p.next.next</code>为None的p。下面定义的<code>pop_last</code>函数不仅删去表中最后元素，还把它返回（与pop统一）。</p><p>在开始一般性扫描之前，需要处理两个特殊情况：如果表空没有可返回的元素时应该引发异常。表中只有一个元素的情况需要特殊处理，因为这时应该修改表头指针。一般情况是先通过循环找到位置，取出最后结点的数据后将其删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop_last</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:      <span class="comment"># 空表</span></span><br><span class="line">        <span class="keyword">raise</span> LinkeListUnderflow(<span class="string">&quot;in pop_last&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:          <span class="comment"># 表中只有一个元素</span></span><br><span class="line">        e = p.elem</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 直到p.next是最后结点</span></span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    e = p.<span class="built_in">next</span>.elem</span><br><span class="line">    p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure><p>LList类的下一个方法是找到满足给定条件的表元素。这个方法有一个参数，调用时通过参数提供一个判断谓词，该方法返回第一个满足谓词的表元素。显然，这个操作也需要采用前面的基本扫描模式。定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, pred</span>):</span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> pred(p.elem):</span><br><span class="line">            <span class="keyword">return</span> p.elem</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>最后一个方法非常简单，但实际中可能很有用。在开发一个表类的过程中，人们会经常想看看被操作的表的当时情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_all</span>(<span class="params">self</span>):</span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(p.elem, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;, &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 单链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="comment"># item 存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># next 下一个节点的标识</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkList</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取链表长度&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head        <span class="comment"># cur 初始时指向头结点</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:              <span class="comment"># 尾结点指向None，遍历结束</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>      <span class="comment"># 将cur后移一个节点</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)         <span class="comment"># 先创建一个保存 item 值的节点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self._head          <span class="comment"># 将新节点的链接域 next 指向头节点，即 _head 指向的位置</span></span><br><span class="line">        self._head = node               <span class="comment"># 将链表的头 _head 指向新节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="comment"># 若不为空，则找到尾部，将尾结点的 next 指向新节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向链表指定位置添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">            <span class="comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length() - <span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 找到指定位置</span></span><br><span class="line">            pre = self._head    <span class="comment"># pre 用来指向指定位置pos前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            <span class="keyword">while</span> count &lt; pos-<span class="number">1</span>:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">            node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:            <span class="comment"># 找到指定元素</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:                 <span class="comment"># 如果第一个就是删除节点</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span>   <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>     <span class="comment"># 将删除位置的前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 继续后移节点</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表查找节点是否存在，并返回True或者False&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l1 = SingleLinkList()</span><br><span class="line">    l1.add(<span class="number">1</span>)</span><br><span class="line">    l1.add(<span class="number">2</span>)</span><br><span class="line">    l1.append(<span class="number">3</span>)</span><br><span class="line">    l1.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())<span class="comment"># 4</span></span><br><span class="line">    l1.travel()<span class="comment"># 3 -&gt; 4 -&gt; 1 -&gt; 2</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">3</span>))<span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">5</span>))<span class="comment"># False</span></span><br><span class="line">    l1.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())<span class="comment"># 3</span></span><br><span class="line">    l1.travel()<span class="comment"># 3 -&gt; 4 -&gt; 2</span></span><br></pre></td></tr></table></figure><h2 id="2-循环单链表"><a href="#2-循环单链表" class="headerlink" title="2 循环单链表"></a>2 循环单链表</h2><p>单链表的另一常见变形是循环单链表（简称循环链表），其中最后一个结点的next域不用None，而是指向表的第一个结点，如下图a所示。但如果仔细考虑，就会发现在链表对象里记录表尾结点更合适（如下图b），这样可以同时支持 $O(1)$ 时间的表头&#x2F;表尾插入和 $O(1)$ 时间的表头删除。当然，由于循环链表里的结点连成一个圈，哪个结点算是表头或表尾，主要是概念问题，从表的内部形态上无法区分。</p><p>循环单链表操作与普通单链表的差异就在于扫描循环的结束控制。易见，一些不变操作的实现也要修改，如 printall。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.4t7xsu8n7s00.webp#pic_center" width = 64%><p>这种表对象只需一个数据域 _rear，它在逻辑上始终引用着表的尾结点。前端加入结点，就是在尾结点和首结点之间加人新的首结点，尾结点引用不变。通过尾结点引用很容易实现这个操作。另一方面，尾端加入结点也是在原尾结点之后（与首结点之间）插人新结点，只是插入后要把它作为新的尾结点，因此需要更新尾结点引用。这两个操作都要考虑空表插入的特殊情况。对于输出表元素的操作，关键在于循环结束的控制。下面实现中比较扫描指针与表头结点的标识，到达了表头结点就结束。前端弹出操作也很容易实现，后端弹出操作需要通过一个扫描循环确定位置。</p><p>下面循环单链表类定义只实现了几个典型方法，供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 单向循环链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinCycLinkedList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():     <span class="comment"># 如果链表长度为空，返回长度0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="built_in">print</span>(cur.item)</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部添加节点&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head      <span class="comment"># 添加的节点指向_head </span></span><br><span class="line">            cur = self._head            <span class="comment"># 移到链表尾部，将尾部的节点的 next指向node</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="comment"># _head 指向添加的node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部添加节点&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head        <span class="comment"># 移到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node         <span class="comment"># 将尾结点指向node</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head  <span class="comment"># 将node指向头节点_head</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除一个节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():     <span class="comment"># 若链表为空直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head        <span class="comment"># 将cur指向头节点</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:    <span class="comment"># 若头结点的元素就是要查找的元素item</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> != self._head:  </span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:   <span class="comment"># 先找到尾结点，将尾结点的next指向第二个节点</span></span><br><span class="line">                    cur = cur.<span class="built_in">next</span>      </span><br><span class="line">                cur.<span class="built_in">next</span> = self._head.<span class="built_in">next</span>      <span class="comment"># cur指向了尾结点</span></span><br><span class="line">                self._head = self._head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._head = <span class="literal">None</span>               <span class="comment"># 链表只有一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:        <span class="comment"># 第一个节点不是要删除的</span></span><br><span class="line">                <span class="keyword">if</span> cur.item == item:             <span class="comment"># 找到了要删除的元素</span></span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>          <span class="comment"># 删除</span></span><br><span class="line">                    <span class="keyword">return</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:                <span class="comment"># cur 指向尾结点</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>             <span class="comment"># 尾部删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l1 = SinCycLinkedList()</span><br><span class="line">    l1.add(<span class="number">1</span>)</span><br><span class="line">    l1.add(<span class="number">2</span>)</span><br><span class="line">    l1.append(<span class="number">3</span>)</span><br><span class="line">    l1.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    l1.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    l1.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())      <span class="comment"># 6</span></span><br><span class="line">    l1.travel()                         <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 6</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">3</span>))                 <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">7</span>))                 <span class="comment"># False</span></span><br><span class="line">    l1.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())      <span class="comment"># 5</span></span><br><span class="line">    l1.travel()                         <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 6</span></span><br></pre></td></tr></table></figure><h2 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3 双向链表"></a>3 双向链表</h2><p>单链表只有一个方向的链接，只能做一个方向的扫描和逐步操作。即使增加了尾结点引用，也只能支持 $O(1)$ 时间的首端元素加入&#x2F;删除和尾端加入。如果希望两端插入和删除操作都能高效完成，就必须修改结点（从而也是链表）的基本设计，加入另一方向的链接。这样就得到了双向链接表，简称双链表。有了结点之间的双向链接，不仅能支持两端的高效操作，一般结点操作也会更加方便。当然，这样做也需要付出代价：每个结点都需要增加一个链接域,增加的空间开销与结点数成正比，是 $O(n)$。如果每个表结点里的数据规模比较大，新增加的开销可能就显得不太重要了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.29pfjm7l0fr4.webp#pic_center" width = 48%><p>为了支持首尾两端的高效操作，双链表应该采用下图所示的结构，包含一个尾结点引用域。易见，从双链表中任一结点出发，可以直接找到其前后的相邻结点（都是 $O(1)$ 操作）。而对单链表而言，只能方便地找到下一个结点，要找前一结点，就必须从表头开始逐一检查（通过一次扫描）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.585qz3u8lv40.webp#pic_center" width = 36%><p>可以直接找到当前结点的前后结点，使得双链表的许多操作都很容易地进行。下面假定结点的下一结点引用域是next，前一结点引用域是prev。</p><p><strong>结点操作</strong></p><p>先考虑结点删除。实际上，只要掌握着双链表里一个结点，就可以把它从表中取下，并把其余结点正确链接好。下图说明了这个操作。示例代码是：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.6tfs63p4fuk0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.prev.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span>.prev = p.prev</span><br></pre></td></tr></table></figure><p>这两个语句使p所指结点从表中退出，其余结点保持顺序和链接。如果要考虑前后可能无结点的情况，只需增加适当的条件判断。</p><p>在任一结点的前后加入结点的操作也很容易局部完成，只需掌握确定加入位置的这个结点。易见，加入一个结点需要做四次引用赋值。</p><p><strong>指定位置插入节点</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.73x3h4o7cyg0.webp#pic_center" width = 48%><p><strong>完整代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 双向链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部插入元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node           <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head      <span class="comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            self._head.prev = node      <span class="comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head = node           <span class="comment"># 将_head 指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部插入元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node       <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head        <span class="comment"># 移动到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node         <span class="comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            node.prev = cur         <span class="comment"># 将node的prev指向cur</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):      <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.prev = cur             <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span>        <span class="comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = node        <span class="comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node             <span class="comment"># 将cur的next指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> == <span class="literal">None</span>:            <span class="comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                    self._head = <span class="literal">None</span>           <span class="comment"># 如果链表只有这一个节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span>.prev = <span class="literal">None</span>        <span class="comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span>       <span class="comment"># 将_head指向第二个节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span>    <span class="comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.<span class="built_in">next</span>.prev = cur.prev    <span class="comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, ll.length())   <span class="comment"># 6 </span></span><br><span class="line">    ll.travel()                     <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 6</span></span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">3</span>))             <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">4</span>))             <span class="comment"># True</span></span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, ll.length())   <span class="comment"># 5</span></span><br><span class="line">    ll.travel()                     <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要学习使用Python实现链表，包括链表增加元素、删除元素、扫描、定位、遍历，以及循环单链表和双链表的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://qxienote.com/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://qxienote.com/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="https://qxienote.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="循环单链表" scheme="https://qxienote.com/tags/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双链表" scheme="https://qxienote.com/tags/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
