<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组（四）-- LC[1574] 删除最短的子数组使剩余数组有序</title>
      <link href="/article/830ec474.html"/>
      <url>/article/830ec474.html</url>
      
        <content type="html"><![CDATA[<p>LC[1574] 删除最短的子数组使剩余数组有序，通过题目深入理解滑动窗口的思想</p><span id="more"></span><h2 id="1-删除最短的子数组使剩余数组有序"><a href="#1-删除最短的子数组使剩余数组有序" class="headerlink" title="1  删除最短的子数组使剩余数组有序"></a>1  删除最短的子数组使剩余数组有序</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/009.1b99zv7n25og.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/</a></p><h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><p><strong>1. 枚举左端点，移动右端点</strong></p><p>核心思路：枚举 $\textit{left}$，增大 $\textit{right}$ 直到 $\textit{arr}[\textit{left}]\le\textit{arr}[\textit{right}]$，此时更新子数组长度的最小值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/010.2wx6zs4lrs60.gif#pic_center" width = 36%><p><strong>解疑答惑：</strong></p><p>问：为什么枚举一个新的 $\textit{left}$ 时，$\textit{right}$ 不会往左移？或者说，是否需要再次枚举之前枚举过的 $\textit{arr}[\textit{right}]$？</p><p>答：在向右移动时，由于 $\textit{arr}[\textit{left}]$ 和 $\textit{arr}[\textit{right}]$ 都是非递减的，所以 $\textit{right}$ 左侧之前枚举过的元素必然小于 $\textit{arr}[\textit{left}]$，无需再次枚举。这也是本题可以使用同向双指针（不定长滑动窗口）的前提。</p><p>问：在计算子数组长度时，我经常分不清下标是否要 +1 或 −1，请问如何解决？</p><p>答：第一，时刻把握住 $\textit{left}$ 和 $\textit{right}$ 的含义，对于本题来说是开区间 $(\textit{left},\textit{right})$，这两个指针指向的元素不能删除。第二，可以代入一些数据来验证，比如代入 $\textit{left}&#x3D;1, \textit{right}&#x3D;3$，此时只需要删除一个 $\textit{arr}[2]$，所以公式 $\textit{right}-\textit{left}-1$ 才是符合要求的。</p><p>问：为什么不用判断$\textit{left}&lt;\textit{right}$，难道不会出现 $\textit{left}\ge\textit{right}$ 的情况吗？</p><p>答：由于提前判断了 $\textit{arr}$ 是非递减数组的情况，后面的循环 $\textit{left}$ 必定小于 $\textit{right}$。反证：如果某个时刻 $\textit{left}$ 达到了 $\textit{right}$，就说明整个数组是有序的，但这种情况已经提前判断了。</p><p>问：能不能先把 $\textit{left}$ 的最大值算出来，然后再去枚举 $\textit{left}$ 或 $\textit{right}$？</p><p>答：可以。根据对称性，这种做法和先算 $\textit{right}$ 的最小值的做法是一样的，只不过枚举的顺序相反而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> arr[right - <span class="number">1</span>] &lt;= arr[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span>:  <span class="comment"># arr 已经是非递减数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 此时 arr[right-1] &gt; arr[right]</span></span><br><span class="line">        ans = right  <span class="comment"># 删除 arr[:right]</span></span><br><span class="line">        left = <span class="number">0</span>  <span class="comment"># 枚举 left</span></span><br><span class="line">        <span class="keyword">while</span> left == <span class="number">0</span> <span class="keyword">or</span> arr[left - <span class="number">1</span>] &lt;= arr[left]:</span><br><span class="line">            <span class="keyword">while</span> right &lt; n <span class="keyword">and</span> arr[right] &lt; arr[left]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时 arr[left] &lt;= arr[right]，删除 arr[left+1:right]</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, right - left - <span class="number">1</span>)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为 $\textit{nums}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{right}$ 加一的总执行次数不会超过 $n$ 次，所以总的时间复杂度为 $O(n)$。</li><li>空间复杂度：$O(1)$，仅用到若干额外变量。</li></ul><p><strong>2. 枚举右端点，移动左端点</strong></p><p>核心思路：枚举 $\textit{right}$，增大 $\textit{left}$ 直到 $\textit{arr}[\textit{left}]&gt;\textit{arr}[\textit{right}]$。在增大过程中去更新子数组长度的最小值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/011.1pr1dt5dsy0w.gif#pic_center" width = 36%><p>问：为什么枚举一个新的 $\textit{right}$ 时，$\textit{left}$ 不会往左移？或者说，是否需要再次枚举之前枚举过的 $\textit{arr}[\textit{left}]$？</p><p>答：在向右移动时，由于 $\textit{arr}[\textit{left}]$ 和 $\textit{arr}[\textit{right}]$ 都是非递减的，所以 $\textit{left}$ 左侧之前枚举过的元素必然小于等于 $\textit{arr}[\textit{right}]$，由于这样的子数组长度更长，无需再次枚举。这也是本题可以使用同向双指针（不定长滑动窗口）的前提。</p><p>问：为什么循环一定会结束？</p><p>答：代码中提前判断了 $\textit{arr}$ 已经是非递减数组的情况，所以后面的循环一定存在 $\textit{left}$，使得 $\textit{arr}[\textit{left}]&gt;\textit{arr}[\textit{left}+1]$ 成立。</p><p>注：最坏情况下，当 $\textit{right}&#x3D;n$ 时才会去移动 $\textit{left}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> arr[right - <span class="number">1</span>] &lt;= arr[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="number">0</span>:  <span class="comment"># arr 已经是非递减数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 此时 arr[right-1] &gt; arr[right]</span></span><br><span class="line">        ans = right  <span class="comment"># 删除 arr[:right]</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 枚举 right</span></span><br><span class="line">            <span class="keyword">while</span> right == n <span class="keyword">or</span> arr[left] &lt;= arr[right]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right - left - <span class="number">1</span>)  <span class="comment"># 删除 arr[left+1:right]</span></span><br><span class="line">                <span class="keyword">if</span> arr[left] &gt; arr[left + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为 $\textit{nums}$ 的长度。虽然写了个二重循环，但是内层循环中对 $\textit{left}$ 加一的总执行次数不会超过 $n$ 次，所以总的时间复杂度为 $O(n)$。</li><li>空间复杂度：$O(1)$，仅用到若干额外变量。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>删除最短的子数组使剩余数组有序：<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/2189149/dong-hua-yi-xie-jiu-cuo-liang-chong-xie-iijwz/">https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/2189149/dong-hua-yi-xie-jiu-cuo-liang-chong-xie-iijwz/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组（三）-- LC[370]&amp;[1109]&amp;[1094] 区间加法</title>
      <link href="/article/29a8c889.html"/>
      <url>/article/29a8c889.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要以LeetCode[370]区间加法、LeetCode[1109]航班预定统计、LeetCode[1094]拼车为例，讲解差分数组的思想和应用。</p><span id="more"></span><h2 id="1-区间加法"><a href="#1-区间加法" class="headerlink" title="1 区间加法"></a>1 区间加法</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/001.186b44op9p9c.webp#pic_center" width = 64%><h3 id="1-2-求解思路"><a href="#1-2-求解思路" class="headerlink" title="1.2 求解思路"></a>1.2 求解思路</h3><p>常规的思路很容易，给区间 nums[i: j] 加上 val，那就⼀个 for 循环给它们都加上呗，但这种思路的时间复杂度是 $O(N)$，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。</p><p>这⾥就需要差分数组的技巧，差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。</p><p>差分数组的性质是：当我们希望对原数组的某一个区间[i, j]施加一个增量 inc 时，差分数组d对应的变化是：d[i]增加inc，d[j+1]减少inc，并且这种操作是可以叠加的。</p><p>下面举个例子：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.o2smmp2nbps.webp#pic_center" width = 64%><p>差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。</p><p>还是上面那个表里的例子，我们需要进行以下操作：</p><ol><li>将区间[1，4]的数值全部加上3</li><li>将区间[3，5]的数值全部减去5</li></ol><p>很简单对吧，你可以进行枚举。但是如果给你的数据量是1e5，操作量1e5，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。</p><p>其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。</p><p>利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.26qp336md6ow.webp#pic_center" width = 64%><p>进行下一个操作，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.5fbtn7ubb500.webp#pic_center" width = 64%><p>这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。</p><p>本部分参考自：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分详解+例题</a></p><p>也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。</p><p><strong>代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (length+<span class="number">1</span>)  <span class="comment"># 末尾多个0，防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end + <span class="number">1</span>] -= inc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            diff[i] += diff[i - <span class="number">1</span>]            <span class="comment"># 对差分数组求前缀和便可得到原数组</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> diff[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="2-航班预订统计"><a href="#2-航班预订统计" class="headerlink" title="2 航班预订统计"></a>2 航班预订统计</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.7jqt4ty7a0o0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>题⽬说的 n 是从 1 开始计数的，⽽数组索引从 0 开始，在构造差分数组时，需要相应的调整数组下标对应关系，这里在前面添加0，和三元组 (i, j, k) 依次对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            start, end, inc = booking[<span class="number">0</span>], booking[<span class="number">1</span>], booking[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            <span class="keyword">if</span> end &lt; n:             <span class="comment"># 没在末尾添加0，要判断一下边界</span></span><br><span class="line">                diff[end+<span class="number">1</span>] -= inc</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n+m)$，其中 $n$ 为要求的数组长度，$m$ 为预定记录的数量。我们需要对于每一条预定记录处理一次差分数组，并最后对差分数组求前缀和。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="3-拼车"><a href="#3-拼车" class="headerlink" title="3 拼车"></a>3 拼车</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.2mzdjelg76k0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/car-pooling/">https://leetcode.cn/problems/car-pooling/</a></p><h3 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h3><ol><li><p>首先大致可以看出这也是数组子区间增减问题，使用数组画出来看一下，是否能用差分数组</p></li><li><p>定义数组保存每一站车上人数，接客是对子区间全部元素加 n 运算，多次上下车后，看最终数组每一站人数是否超过capacity，超过则说明有乘客上不来</p></li><li><p>注意：</p></li></ol><ul><li>接人影响的子区间为[start, end-1]，因为这批乘客在下车站已经下车了</li><li>0 &lt;&#x3D; trips[i][1] &lt; trips[i][2] &lt;&#x3D; 1000，可以看出trips中start&#x2F;end就是数组下标，这里可以直接定义差分数组大小，也可以使用循环找到最多有几站</li></ul><p>以trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4为例，数组变化：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/007.6bjq9cr5fw00.webp#pic_center" width = 64%><ol><li>说明：</li></ol><ul><li>数组长度为8，表示全程 0~7 共8个站点，元素值表示在第i站车上人数</li><li>没有接人时为原数组，接人是对数组的修改</li><li>最后看每站人数是否超过capacity</li><li>因为3&#x2F;4站人数超过capacity，说明到第3站有乘客上不来</li></ul><ol start="5"><li>观察上面数组变化，可以看出是子区间内元素全部加 n，多次修改后求修改后数组的问题——典型的差分数组求解，对应差分数组变化：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/008.mm47mmjjymo.webp#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="number">1001</span>)      <span class="comment"># 题目中最多有1001个车站</span></span><br><span class="line">        max_station = <span class="number">0</span>          <span class="comment"># 找到车站数</span></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            inc, start, end = trip[<span class="number">0</span>], trip[<span class="number">1</span>], trip[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end] -= inc      <span class="comment"># 第end站乘客已经下车，这里就不用end+1</span></span><br><span class="line">            max_station = <span class="built_in">max</span>(max_station, end)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_station+<span class="number">1</span>): <span class="comment"># 进行区间求和</span></span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(diff[:max_station]) &gt; capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组（二）-- LC[303]&amp;[304] 区域和检索 - 数组不可变</title>
      <link href="/article/a991eb96.html"/>
      <url>/article/a991eb96.html</url>
      
        <content type="html"><![CDATA[<p>做这种初始化一次、检索多次的题目的秘诀：在初始化的时候做预处理，前缀和技巧就适⽤于快速、频繁地计算⼀个索引区间内的元素之和。本节主要学习区域和检索在数组和矩阵不可变情况下的，如何使用前缀和技巧提高效率。</p><span id="more"></span><h2 id="1-区域和检索-数组不可变"><a href="#1-区域和检索-数组不可变" class="headerlink" title="1 区域和检索 - 数组不可变"></a>1 区域和检索 - 数组不可变</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/016.16tdea598mkg.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>最朴素的想法是存储数组 nums 的值，每次调用 sumRange 时，通过循环的方法计算数组 nums 从下标 $i$ 到下标 $j$ 范围内的元素和，需要计算 $j−i+1$ 个元素的和。由于每次检索的时间和检索的下标范围有关，因此检索的时间复杂度较高，如果检索次数较多，则会超出时间限制。</p><p>由于会进行多次检索，即多次调用 sumRange，因此为了降低检索的总时间，应该降低 sumRange 的时间复杂度，最理想的情况是时间复杂度 $O(1)$。为了将检索的时间复杂度降到 $O(1)$，需要在初始化的时候进行预处理。</p><p>注意到当 $i≤j$ 时，sumRange(i,j) 可以写成如下形式：</p><p>$$\begin{aligned} &amp; \operatorname{sum} \operatorname{Range}(i, j) \ &#x3D; &amp; \sum_{k&#x3D;i}^j n u m s[k] \ &#x3D; &amp; \sum_{k&#x3D;0}^j n u m s[k]-\sum_{k&#x3D;0}^{i-1} n u m s[k]\end{aligned}$$</p><p>由此可知，要计算 sumRange(i,j)，则需要计算数组 nums 在下标 $j$ 和下标 $i−1$ 的前缀和，然后计算两个前缀和的差。</p><p>如果可以在初始化的时候计算出数组 nums 在每个下标处的前缀和 pre_sum，即可满足每次调用 sumRange 的时间复杂度都是 $O(1)$。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.pre_sum = [<span class="number">0</span>]            <span class="comment"># 便于计算累加和，若直接分配数组空间，计算效率更高</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.pre_sum.append(self.pre_sum[i] + nums[i])  <span class="comment"># 计算nums累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.pre_sum[right+<span class="number">1</span>] - self.pre_sum[left]</span><br></pre></td></tr></table></figure><p>下面以数组 [1, 12, -5, -6, 50, 3] 为例，展示了求 pre_sum 的过程。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/017.4h0ovjbmi640.gif#pic_center" width = 64%><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：初始化 $O(n)$，每次检索 $O(1)$，其中 $n$ 是数组 nums 的长度。初始化需要遍历数组 nums 计算前缀和，时间复杂度是 $O(n)$。每次检索只需要得到两个下标处的前缀和，然后计算差值，时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(n)$，其中 $n$ 是数组 nums 的长度。需要创建一个长度为 $n+1$ 的前缀和数组。</li></ul><hr><h2 id="2-二维区域和检索-矩阵不可变"><a href="#2-二维区域和检索-矩阵不可变" class="headerlink" title="2 二维区域和检索 - 矩阵不可变"></a>2 二维区域和检索 - 矩阵不可变</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/018.60fo4kdbbs00.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">https://leetcode.cn/problems/range-sum-query-2d-immutable/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>这部分借鉴自：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/er-wei-qian-zhui-he-jian-dan-tui-dao-tu-sqekv/">笨猪爆破组的题解————从暴力法开始优化 「二维前缀和」做了什么事 | leetcode.304</a></p><p><strong>1. 暴力法</strong></p><p>对二维矩阵，求子矩阵 $(n*m)$ 的和。两重循环，累加求和。</p><p>每次查询时间复杂度 $O(n∗m)$，n和m是子矩阵的行数和列数。查询的代价大。</p><p><strong>2. 第一步优化</strong></p><p>上面的暴力法其实也分了 n 步：第一行的求和，到第 n 行的求和，它们是 n 个一维数组。</p><p>昨天我们学习了一维前缀和，我们可以对这n个一维数组求前缀和，得到n个一维pre_sum数组。</p><p>为了节省查询的时间，我们求出整个矩阵每一行的一维pre_sum数组</p><p>根据前缀和定义：${pre}_{sum}[i]&#x3D;nums[0]+nums[1]+\cdots+nums[i]$，求出前缀和（下图红字）：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/019.3u6m52tef9s0.webp#pic_center" width = 48%><p>然后套用通式：$nums[i]+\cdots+nums[j]&#x3D;pre_sum[j]-pre_sum[i-1]$</p><p>即可求出粉色子阵列的和，计算情况如下图。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/020.hj2lugpi4p4.webp#pic_center" width = 48%><p>可见，如果想多次查询子阵列的和，我们可以提前求出每一行数组的一维前缀和。</p><p>那么查询阶段，求出一行子数组的求和，就只是 $O(1)$，查询 n 行的子阵列，每次就查询花费 $O(n)$，比 $O(n^2)$ 好</p><p><strong>3. 示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])          <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i].append(self.pre_sum[i][j]+matrix[i][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([self.pre_sum[i][col2+<span class="number">1</span>]-self.pre_sum[i][col1] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2+<span class="number">1</span>)])</span><br></pre></td></tr></table></figure><p><strong>4. 第二步优化</strong><br>还可以继续优化吗？</p><p>我们引入一个概念：二维前缀和，定义式如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/021.2ysqnsk7mj40.webp#pic_center" width = 48%><p><code>pre_sum[i][j]</code> 表示：左上角为 <code>arr[0][0]</code>，右下角为 <code>arr[i][j]</code> 的阵列的求和.</p><p>我们把这个阵列拆分成四个部分，如图中的色块。</p><p>要想求出 <code>pre_sum[i][j]</code>，根据上图，由容斥原理，有：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/022.8w4fiqsxvew.webp#pic_center" width = 48%><p>移项后：</p><p>$$arr[i][j] &#x3D; pre_sum[i][j] + pre_sum[i-1][j-1] - pre_sum[i-1][j] - pre_sum[i][j-1]$$</p><p>现在想求：行 从 a 到 A，列 从 b 到 B 的子阵列的和。叠加上式，各种相消后。得：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/023.6dkvz3kmwdc0.webp#pic_center" width = 48%><p>回到粉色子阵列，求她的和，就是如下图的 4 个 pre_sum 矩阵元素相加减。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/024.79mvkez7230.webp#pic_center" width = 48%><p>问题来了，怎么求出 pre_sum 二维阵列的每一项？</p><p>就是用遍历原矩阵，两层循环，套下图的公式。</p><p>注意到上图黄字，在 -1 位置上预置了 0，只是为了让处于边界的 preSum 元素，也能套用下面的通式。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/025.5ybgixgg7ds0.webp#pic_center" width = 48%><p>两个关键式 <code>pre_sum[i][j]</code> 的定义式如下，并且预置 <code>pre-sum[-1][j]</code> 和 <code>pre_sum[i][-1]</code> 为 0：</p><p>$$<br>\operatorname{preSum}[i][j]&#x3D;\sum_{x&#x3D;0}^i \sum_{y&#x3D;0}^j \operatorname{arr}[x][y]<br>$$</p><p>求：行从 a 到 A，列从 b 到 B 的子阵列的和的通式：<br>$$<br>\sum_{i&#x3D;a}^A \sum_{i&#x3D;b}^B \operatorname{arr}[i][j]&#x3D;\operatorname{pre_sum}[A][B]+\operatorname{pre_sum}[a-1][b-1]-\operatorname{pre_sum}[A][b-1]-\operatorname{pre_sum}[a-1][B]<br>$$</p><p>查询的时间复杂度降下来了<br>因此子阵列的求和，都只需要访问二维 pre_sum 数组的四个值。</p><p>预处理阶段，求出二维 pre_sum 数组，需要花费 $O(n∗m)$，n和m是子矩阵的行数和列数。</p><p>但之后每次查询，就都是 $O(1)$ 的时间复杂度</p><p><strong>5. 调整 pre_sum 矩阵</strong></p><p>为了减少特判的代码，我们调整一下 pre_sum 矩阵，原先 <code>arr[i][j]</code> 对应 <code>pre_sum[i][j]</code></p><p>现在错开，<code>arr[i][j]</code> 对应 <code>pre_sum[i+1][j+1]</code>。</p><p>如下图所示，pre_sum 阵列会比原矩阵多一行一列，为了让 pre_sum 的 -1 列 -1 行变成 0 行 0 列</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/026.20ie8zlewqps.webp#pic_center" width = 48%><p>现在 preSum[i][j] 的定义式，改一下</p><p>$$<br>\operatorname{pre_sum}[i+1][j+1]&#x3D;\sum_{x&#x3D;0}^i \sum_{y&#x3D;0}^j \operatorname{arr}[x][y]<br>$$</p><p>并且预置 <code>pre_sum[0][j]</code> 和 <code>pre_sum[i][0]</code> 为 0</p><p>求：行从 a 到 A，列从 b 到 B 的子阵列的和，的通式，改一下：<br>$$<br>\sum_{i&#x3D;a}^A \sum_{i&#x3D;b}^B \operatorname{arr}[i][j]&#x3D;\operatorname{pre_sum}[A+1][B+1]+\operatorname{pre_sum}[a][b]-\operatorname{pre_sum}[A+1][b]-\operatorname{pre_sum}[a][B+1]<br>$$</p><p><strong>6. 示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])          <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.pre_sum[i+<span class="number">1</span>][j] + self.pre_sum[i][j+<span class="number">1</span>] - self.pre_sum[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.pre_sum[row1][col2+<span class="number">1</span>] - self.pre_sum[row2+<span class="number">1</span>][col1] + self.pre_sum[row1][col1])</span><br></pre></td></tr></table></figure><p><strong>7. 复杂度分析</strong></p><ul><li>时间复杂度：初始化 $O(mn)$，每次检索 $O(1)$，其中 m 和 n 分别是矩阵 matrix 的行数和列数。初始化需要遍历矩阵 matrix 计算二维前缀和，时间复杂度是 $O(mn)$。每次检索的时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(mn)$，其中m和n分别是矩阵 matrix 的行数和列数。需要创建一个 m＋1 行 n+1 列的二维前缀和数组 pre_sum。</li></ul><blockquote><p>做题心得：以后会不会延伸到张量呢，更高维数的也是总结通式，就比如三维是一个立方体，依然是计算每个小立方体的和。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 区域和检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组（一）-- LC[26]&amp;[80] 删除有序数组中的重复元素</title>
      <link href="/article/cce29ffb.html"/>
      <url>/article/cce29ffb.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode[26] 删除有序数组中的重复元素，原地删除重复出现的元素，使每个元素 只出现1&#x2F;2次，返回删除后数组的新长度。元素的 相对顺序应该保持一致。使用双指针的通用解法</p><span id="more"></span><h2 id="1-删除有序数组中的重复项"><a href="#1-删除有序数组中的重复项" class="headerlink" title="1 删除有序数组中的重复项"></a>1 删除有序数组中的重复项</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给你一个 <strong>升序排列</strong> 的数组 nums ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong>，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><blockquote><p>示例 1：<br>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><blockquote><p>示例 2：<br>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>已知数组 nums 是有序的，而且我们只能在原地修改 nums 数组，不能创建新的数组空间来存储删除重复出现的元素后的结果。我们需要一边遍历数组查找相同元素，一边在对比发现不同元素时修改数组元素，那么我们可以考虑双指针法的快慢指针了，定义 p 和 q 作为指针，初始化时指针 p 指向数组的起始位置（nums[0]），指针 q 指向指针 p 的后一个位置（nums[1]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；</li></ul><p>图示：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/014.7ehk7ns70rk0.webp#pic_center" width = 36%></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>复杂度分析：时间复杂度：$O(n)$。 空间复杂度：$O(1)$。</p><p>进一步优化：</p><p>考虑如下数组：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/015.1pxc8t12z3gg.webp#pic_center" width = 36%><p>此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p><p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p]:</span><br><span class="line">                <span class="keyword">if</span> q - p &gt; <span class="number">1</span>:</span><br><span class="line">                    nums[p+<span class="number">1</span>] = nums[q]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-删除有序数组中的重复项-II"><a href="#2-删除有序数组中的重复项-II" class="headerlink" title="2 删除有序数组中的重复项 II"></a>2 删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><blockquote><p>示例 1：<br>输入：nums &#x3D; [1,1,1,2,2,3]<br>输出：5, nums &#x3D; [1,1,2,2,3]<br>解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</p></blockquote><blockquote><p>示例 2：<br>输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]<br>输出：7, nums &#x3D; [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>思路和上面的类似，改变的地方是：初始化时指针 p 指向数组的起始位置（nums[1]），指针 q 指向指针 p 的后一个位置（nums[2]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p-1]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p, q = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> q &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[q] != nums[p-<span class="number">1</span>]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>通用解法：</strong><br>为了让解法更具有一般性，我们将原问题的「最多保留 1 位」修改为「最多保留 k 位」。<br>对于此类问题，我们应该进行如下考虑：</p><ul><li>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。</li><li>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。</li></ul><p>此时，初始化时指针 p 指向数组的起始位置（nums[k-1]），指针 q 指向指针 p 的后一个位置（nums[k]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：</p><ul><li>如果nums[q] ≠ nums[p-k+1]，那么nums[p + 1] &#x3D; nums[q]；</li><li>如果nums[q] &#x3D; nums[p]，那么指针q继续向后查找；</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串（二）-- LC[17] 电话号码的字母组合</title>
      <link href="/article/6b74a168.html"/>
      <url>/article/6b74a168.html</url>
      
        <content type="html"><![CDATA[<p>LC[17] 电话号码的字母组合，本题主要考察字符串的操作，回溯和递归的理解，以及队列的使用</p><span id="more"></span><h2 id="1-电话号码的字母组合"><a href="#1-电话号码的字母组合" class="headerlink" title="1 电话号码的字母组合"></a>1 电话号码的字母组合</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.434zi36fo760.webp#pic_center" width = 80%><p>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p><h3 id="1-2-回溯解法"><a href="#1-2-回溯解法" class="headerlink" title="1.2 回溯解法"></a>1.2 回溯解法</h3><p>这道题的解法是用回溯的方式，在循环里面套了递归调用。本来递归就不好理解了，再加上循环的递归，就更难理解了。 我们先不考虑递归，先看看下面这个问题怎么解决。 假设输入是2，只有一个字符，那么应该怎么解呢？ 按照题目要求2&#x3D;“abc”，所以结果应该是<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>先不用想着怎么去写递归，只思考下怎么打印出这个结果。 这个太简单了，一个循环就搞定了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    result.append(ch)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上面是伪代码，一个循环就搞定了。 如果输入的是23，应该怎么做呢？23的结果是<code>[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]</code>，我们仍然不考虑怎么去写递归，只是考虑怎么把这个结果给弄出来。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        result.append(ch1+ch2)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>也就是说23这样的长度为2的字符串可以用两层循环搞定。 如果输入的是234呢，仍然不要考虑怎么去写递归，而是想怎么把结果打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> <span class="string">&quot;ghi&quot;</span>:</span><br><span class="line">            result.append(ch1+ch2+ch3)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这次用了三层循环。 如果输入的是2345，那么代码可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> ch1 <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> ch2 <span class="keyword">in</span> <span class="string">&quot;def&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> ch3 <span class="keyword">in</span> <span class="string">&quot;ghi&quot;</span>:</span><br><span class="line">            <span class="keyword">for</span> ch4 <span class="keyword">in</span> <span class="string">&quot;jkl&quot;</span>:</span><br><span class="line">                result.append(ch1+ch2+ch3+ch4)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这次是用了四层循环。现在是不是能看出一些门道了？对的。循环的嵌套层数，就是输入的字符串长度。输入的字符串长度是1，循环只有1层。 输入的字符串长度是3，循环就是3层。如果输入的字符串长度是10，那么循环就是10层。 可是输入的字符串长度是不固定的，对应的循环的嵌套层数也是不固定的，那这种情况怎么解决呢？这时候递归就派上用场了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.55ctnj0dzeg0.webp#pic_center" width = 36%><p>对于打印”2345”这样的字符串： 第一次递归就是上图中最下面的方格，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数 第二次递归处理3，将字符串改变成”45”后再次递归 第三次递归处理4，将字符串改变成”5”后继续递归 第四次递归处理5，将字符串改变成””后继续递归 最后发现字符串为空了，将结果放到列表中并返回 上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是 $O(3^n)$ 这个级别的，空间复杂度是 $O(n)$</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.ivt8h2jae5c.webp#pic_center" width = 36%><p>动图如下：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.3kyeb4smemw0.gif#pic_center" width = 48%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type digits: str</span></span><br><span class="line"><span class="string">:rtype: List[str]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 注意边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="comment"># 一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">d = [<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line"><span class="comment"># 最终输出结果的list</span></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">tmp, index</span>):</span><br><span class="line"><span class="comment"># 递归的终止条件，注意这里的终止条件看上去跟动态演示图有些不同，主要是做了点优化</span></span><br><span class="line"><span class="comment"># 动态图中是每次截取字符串的一部分，&quot;234&quot;，变成&quot;23&quot;，再变成&quot;3&quot;，最后变成&quot;&quot;，这样性能不佳</span></span><br><span class="line"><span class="comment"># 而用index记录每次遍历到字符串的位置，这样性能更好</span></span><br><span class="line"><span class="keyword">if</span> index==<span class="built_in">len</span>(digits):</span><br><span class="line">res.append(tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment"># 获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line"><span class="comment"># 第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line"><span class="comment"># subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line">c = digits[index]</span><br><span class="line"><span class="comment"># map_string的下表是从0开始一直到9， ord(c)-48 是获取c的ASCII码然后-48, 48是0的ASCII</span></span><br><span class="line"><span class="comment"># 比如c=2时候，2-&#x27;0&#x27;，获取下标为2, letter_map[2]就是&quot;abc&quot;</span></span><br><span class="line">letters = d[<span class="built_in">ord</span>(c)-<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字符串，比如第一次得到的是2，页就是遍历&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> letters:</span><br><span class="line"><span class="comment"># 调用下一层递归，用文字很难描述，请配合动态图理解</span></span><br><span class="line">backtrack(tmp+i, index+<span class="number">1</span>)</span><br><span class="line">backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1-3-队列"><a href="#1-3-队列" class="headerlink" title="1.3 队列"></a>1.3 队列</h3><p>我们也可以使用队列，先将输入的 digits 中第一个数字对应的每一个字母入队，然后将出队的元素与第二个数字对应的每一个字母组合后入队…直到遍历到 digits 的结尾。最后队列中的元素就是所求结果。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/007.solwru43pr4.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type digits: str</span></span><br><span class="line"><span class="string">:rtype: List[str]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="comment"># 一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">d = [<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line"><span class="comment"># 先往队列中加入一个空字符</span></span><br><span class="line">res = [<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">size = <span class="built_in">len</span>(res)</span><br><span class="line"><span class="comment"># 由当前遍历到的字符，取字典表中查找对应的字符串</span></span><br><span class="line">letters = d[<span class="built_in">ord</span>(i)-<span class="number">48</span>]</span><br><span class="line"><span class="comment"># 计算出队列长度后，将队列中的每个元素挨个拿出来</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> xrange(size):</span><br><span class="line"><span class="comment"># 每次都从队列中拿出第一个元素</span></span><br><span class="line">tmp = res.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 然后跟&quot;def&quot;这样的字符串拼接，并再次放到队列中</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> letters:</span><br><span class="line">res.append(tmp+j)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>通俗易懂+动画演示 17. 电话号码的字母组合：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/44182/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/44182/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/</a></li><li>回溯+队列 图解：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串（一）-- LC[3] 无重复字符的最长子串</title>
      <link href="/article/284005f2.html"/>
      <url>/article/284005f2.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode[3] 无重复字符的最长子串使用滑动窗口，就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。</p><span id="more"></span><h2 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1 无重复字符的最长子串"></a>1 无重复字符的最长子串</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><blockquote><p>示例 1:<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><blockquote><p>示例 2:<br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><blockquote><p>示例 3:<br>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p> <strong>滑动窗口法：其实用一句话描述就是使用两个指针，指针头和指针尾依次遍历，当指针尾遍历到的字母包含在指针头和指针尾的字符串里，就把指针头移动到当前字母出现的位置，重新构成一个子串，并判断当前子串的长度与原来记录的最大长度作比较，并更新最大长度。</strong> 示意图如下面：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.4aq0ytbcaeq0.webp#pic_center" width = 48%><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>思路一：滑动窗口法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 思路一：滑动窗口法</span></span><br><span class="line">        temp_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len, current_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> temp_str:</span><br><span class="line">                temp_str += s[i]</span><br><span class="line">                current_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = temp_str.index(s[i])</span><br><span class="line">                temp_str = temp_str[index+<span class="number">1</span>:]</span><br><span class="line">                temp_str += s[i]</span><br><span class="line">                current_len = <span class="built_in">len</span>(temp_str)</span><br><span class="line">            <span class="keyword">if</span> max_len &lt; current_len:</span><br><span class="line">                max_len = current_len</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学(四) -- LC[29]&amp;[166] 两数相除与分数到小数</title>
      <link href="/article/77d95398.html"/>
      <url>/article/77d95398.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要学习LeetCode两数相除里面用到的快速乘和二分查找的算法进行两数的相除，同时学习长除法的解题技巧</p><span id="more"></span><h2 id="1-分数到小数"><a href="#1-分数到小数" class="headerlink" title="1 分数到小数"></a>1 分数到小数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/010.7da1gbtbx5c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/description/">https://leetcode.cn/problems/fraction-to-recurring-decimal/description/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>1. 长除法</strong></p><p>题目要求根据给定的分子和分母，将分数转成整数或小数。由于给定的分子和分母的取值范围都是 $[-2^{31}, 2^{31}-1]$，为了防止计算过程中产生溢出，需要将分子和分母转成 64 位整数表示。</p><p>将分数转成整数或小数，做法是计算分子和分母相除的结果。可能的结果有三种：整数、有限小数、无限循环小数。</p><p>如果分子可以被分母整除，则结果是整数，将分子除以分母的商以字符串的形式返回即可。</p><p>如果分子不能被分母整除，则结果是有限小数或无限循环小数，需要通过模拟长除法的方式计算结果。为了方便处理，首先根据分子和分母的正负决定结果的正负（注意此时分子和分母都不为 0），然后将分子和分母都转成正数，再计算长除法。</p><p>计算长除法时，首先计算结果的整数部分，将以下部分依次拼接到结果中：</p><ol><li>如果结果是负数则将负号拼接到结果中，如果结果是正数则跳过这一步；</li><li>将整数部分拼接到结果中；</li><li>将小数点拼接到结果中。</li></ol><p>完成上述拼接之后，根据余数计算小数部分。</p><p>计算小数部分时，每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。</p><ul><li>如果余数变成 0，则结果是有限小数，将小数部分拼接到结果中。</li><li>如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。</li></ul><p>如何判断是否找到循环节？注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的，因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。</p><p>假设在计算小数部分的第 $i$ 位之前，余数为 $\textit{remainder}<em>i$，则在计算小数部分的第 $i$ 位之后，余数为 $\textit{remainder}</em>{i+1}$。</p><p>假设存在下标 $j$ 和 $k$，满足 $j \le k$ 且 $\textit{remainder}<em>j &#x3D; \textit{remainder}</em>{k+1}$，则小数部分的第 $k+1$ 位和小数部分的第 $j$ 位相同，因此小数部分的第 $j$ 位到第 $k$ 位是一个循环节。在计算小数部分的第 $k$ 位之后就会发现这个循环节的存在，因此在小数部分的第 $j$ 位之前加上左括号，在小数部分的末尾（即第 $k$ 位之后）加上右括号。</p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/011.1g836fzb4800.webp#pic_left" width = "50%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/012.1ysut58coneo.webp#pic_left"  width = "48%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fractionToDecimal</span>(<span class="params">self, numerator: <span class="built_in">int</span>, denominator: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果本身能够整除，直接返回计算结果</span></span><br><span class="line">        <span class="keyword">if</span> numerator % denominator == <span class="number">0</span>: <span class="keyword">return</span> <span class="built_in">str</span>(numerator//denominator)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> numerator * denominator &lt; <span class="number">0</span>:             <span class="comment"># 如果其一为负数，先追加负号</span></span><br><span class="line">            res.append(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        numerator, denominator = <span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator)</span><br><span class="line">        res.append(<span class="built_in">str</span>(numerator//denominator))     <span class="comment">#  计算整数部分，并将余数赋值给 remainder</span></span><br><span class="line">        res.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        remainder = numerator % denominator</span><br><span class="line">        index_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> remainder <span class="keyword">and</span> remainder <span class="keyword">not</span> <span class="keyword">in</span> index_map:</span><br><span class="line">            index_map[remainder] = <span class="built_in">len</span>(res)         <span class="comment"># 记录当前余数所在答案的位置，并继续模拟除法运算</span></span><br><span class="line">            remainder *= <span class="number">10</span></span><br><span class="line">            res.append(<span class="built_in">str</span>(remainder//denominator))</span><br><span class="line">            remainder %= denominator</span><br><span class="line">        <span class="keyword">if</span> remainder:                   <span class="comment"># 当前余数之前出现过，则将出现位置和最后位置添加&#x27;()&#x27;</span></span><br><span class="line">            ind = index_map[remainder]</span><br><span class="line">            res.insert(ind, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            res.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(l)$，其中 $l$ 是答案字符串的长度，这道题中 $l \le 10^4$。对于答案字符串中的每一个字符，计算时间都是 $O(1)$。</li><li>空间复杂度：$O(l)$，其中 $l$ 是答案字符串的长度，这道题中 $l \le 10^4$。空间复杂度主要取决于答案字符串和哈希表，哈希表中的每个键值对所对应的下标各不相同，因此键值对的数量不会超过 $l$。</li></ul><h2 id="2-两数相除"><a href="#2-两数相除" class="headerlink" title="2 两数相除"></a>2 两数相除</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/013.6o6qc5moj0c0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/divide-two-integers/description/">https://leetcode.cn/problems/divide-two-integers/description/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p><strong>1. 二分查找</strong></p><p>如果除法结果溢出，那么我们需要返回 $2^{31}-1$ 作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：</p><ul><li>当被除数为 32 位有符号整数的最小值 $-2^{31}$ 时：<ul><li>如果除数为 1，那么我们可以直接返回答案 $-2^{31}$；</li><li>如果除数为 −1，那么答案为 $2^{31}$，产生了溢出。此时我们需要返回 $2^{31} - 1$。</li></ul></li><li>当除数为 32 位有符号整数的最小值 $s-2^{31}$ 时：<ul><li>如果被除数同样为 $-2^{31}$，那么我们可以直接返回答案 111；</li><li>对于其余的情况，我们返回答案 0。</li></ul></li><li>当被除数为 0 时，我们可以直接返回答案 0。</li></ul><p>对于一般的情况，根据除数和被除数的符号，我们需要考虑 444 种不同的可能性。因此，为了方便编码，我们可以将被除数或者除数取相反数，使得它们符号相同。</p><p>如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 $-2^{31}$ 时，它的相反数 $2^{31}$ 产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 1 种情况了。</p><p>如果我们将被除数和除数的其中（恰好）一个变为了正数，那么在返回答案之前，我们需要对答案也取相反数。</p><p><strong>方法一：二分查找</strong></p><p>根据「前言」部分的讨论，我们记被除数为 X，除数为 Y，并且 X 和 Y 都是负数。我们需要找出 X&#x2F;Y 的结果 Z。Z 一定是正数或 0。</p><p>根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：</p><p>$$Z\times Y \geq X \geq (Z+1) \times Y$$</p><p>因此，我们可以使用二分查找的方法得到 ZZZ，即找出最大的 ZZZ 使得 Z×Y≥XZ \times Y \geq XZ×Y≥X 成立。</p><p>由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 $Z \times Y$ 的值。</p><p>由于我们只能使用 32 位整数，因此二分查找中会有很多细节。</p><p>首先，二分查找的下界为 1，上界为 $2^{31} - 1$。唯一可能出现的答案为 $2^{31}$ 的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 $2^{31} - 1$。如果二分查找失败，那么答案一定为 0。</p><p>在实现「快速乘」时，我们需要使用加法运算，然而较大的 Z 也会导致加法运算溢出。例如我们要判断 A + B 是否小于 C 时（其中 A,B,C 均为负数），A + B 可能会产生溢出，因此我们必须将判断改为 $A &lt; C - B$ 是否成立。由于任意两个负数的差一定在 $[-2^{31} + 1, 2^{31} - 1]$ 范围内，这样就不会产生溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        INT_MIN, INT_MAX = -<span class="number">2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == INT_MIN:</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MIN</span><br><span class="line">            <span class="keyword">if</span> divisor == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MAX</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == INT_MIN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> dividend == INT_MIN <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment"># 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        rev = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> dividend &gt; <span class="number">0</span>:</span><br><span class="line">            dividend = -dividend</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line">        <span class="keyword">if</span> divisor &gt; <span class="number">0</span>:</span><br><span class="line">            divisor = -divisor</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 快速乘</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickAdd</span>(<span class="params">y: <span class="built_in">int</span>, z: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment"># 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            result, add = <span class="number">0</span>, y</span><br><span class="line">            <span class="keyword">while</span> z &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> result &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    result += add</span><br><span class="line">                <span class="keyword">if</span> z != <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> add &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    add += add</span><br><span class="line">                <span class="comment"># 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        left, right, ans = <span class="number">1</span>, INT_MAX, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 注意溢出，并且不能使用除法</span></span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            check = quickAdd(divisor, mid, dividend)</span><br><span class="line">            <span class="keyword">if</span> check:</span><br><span class="line">                ans = mid</span><br><span class="line">                <span class="comment"># 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> mid == INT_MAX:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -ans <span class="keyword">if</span> rev <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：$O(\log^2 C)$，其中 $C$ 表示 32 位整数的范围。二分查找的次数为 $O(\log C)$，其中的每一步我们都需要 $O(\log C)$ 使用「快速乘」算法判断 $Z \times Y \geq X$ 是否成立，因此总时间复杂度为 $O(\log^2 C)$。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>2. 减法试除</strong><br><strong>思路一</strong><br>首先需要考虑正负号，处理为分子分母全是正数， 其次在返回的时候要注意是否溢出，如果溢出要判断。</p><p>核心是div函数怎么写？例如方法1中的div函数， 利用二进制搜索的思想就是， 每次利用加法，将当前的 divisor 乘以两倍，并同时用 multiple 记录下乘以了 2 的多少次方， multiple 的变化过程是1，2，4，8，16 。。。</p><p>因为任何一个数都可以用二进制的方法得到，所以我们可以利用二进制的思想来代表乘数 multiple， 最终能够得到一个 <code>divisor * multiple = dividend</code> 的multiple。</p><p>举例：算 $63 &#x2F; 8$ 过程为：$63 &#x2F; 8 &#x3D; (63-32) &#x2F; 8 + 4 &#x3D; (63-32-16) &#x2F; 8 + 2 + 4 &#x3D; (63-32-16-8) &#x2F; 8 + 1+ 2 + 4 &#x3D; 7$ 其中 $(63-32-16-8) &#x2F; 8 &#x3D; 7 &#x2F; 8 &#x3D; 0$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN_INT, MAX_INT = -<span class="number">2147483648</span>, <span class="number">2147483647</span>  <span class="comment"># [−2**31, 2**31−1]</span></span><br><span class="line">        flag = <span class="number">1</span>                                    <span class="comment"># 存储正负号，并将分子分母转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>: flag, dividend = -flag, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>: flag, divisor  = -flag, -divisor </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">dividend, divisor</span>):                 <span class="comment"># 例：1023 / 1 = 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 1</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cur = divisor</span><br><span class="line">            multiple = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur + cur &lt; dividend:             <span class="comment"># 用加法求出保证divisor * multiple &lt;= dividend的最大multiple</span></span><br><span class="line">                cur += cur                          <span class="comment"># 即cur分别乘以1, 2, 4, 8, 16...2^n，即二进制搜索</span></span><br><span class="line">                multiple += multiple</span><br><span class="line">            <span class="keyword">return</span> multiple + div(dividend - cur, divisor)</span><br><span class="line">        res = div(dividend, divisor)</span><br><span class="line"></span><br><span class="line">        res = res <span class="keyword">if</span> flag &gt; <span class="number">0</span> <span class="keyword">else</span> -res             <span class="comment"># 恢复正负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN_INT:                           <span class="comment"># 根据是否溢出返回结果</span></span><br><span class="line">            <span class="keyword">return</span> MIN_INT</span><br><span class="line">        <span class="keyword">elif</span> MIN_INT &lt;= res &lt;= MAX_INT:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN_INT, MAX_INT = -<span class="number">2147483648</span>, <span class="number">2147483647</span>  <span class="comment"># [−2**31, 2**31−1]</span></span><br><span class="line">        flag = <span class="number">1</span>                                    <span class="comment"># 存储正负号，并将分子分母转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>: flag, dividend = -flag, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>: flag, divisor  = -flag, -divisor </span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:                  <span class="comment"># 例：1023 / 1 = 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 1</span></span><br><span class="line">            cur = divisor</span><br><span class="line">            multiple = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur + cur &lt; dividend:             <span class="comment"># 用加法求出保证divisor * multiple &lt;= dividend的最大multiple</span></span><br><span class="line">                cur += cur                          <span class="comment"># 即cur分别乘以1, 2, 4, 8, 16...2^n，即二进制搜索</span></span><br><span class="line">                multiple += multiple</span><br><span class="line">            dividend -= cur                         <span class="comment"># 辗转相减法</span></span><br><span class="line">            res += multiple</span><br><span class="line">        </span><br><span class="line">        res = res <span class="keyword">if</span> flag &gt; <span class="number">0</span> <span class="keyword">else</span> -res             <span class="comment"># 恢复正负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN_INT:                           <span class="comment"># 根据是否溢出返回结果</span></span><br><span class="line">            <span class="keyword">return</span> MIN_INT</span><br><span class="line">        <span class="keyword">elif</span> MIN_INT &lt;= res &lt;= MAX_INT:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br></pre></td></tr></table></figure><p><strong>思路二</strong></p><p>用 $2^i$ 去作为乘法基数, $x * 2^i &#x3D; x &lt;&lt; i$。 从 $2^{31}$ 试到 $2^0$ 直到被除数被减到比除数小， 每个能满足除出来的最大的 2 的幂都加入答案, 也可以理解为每次计算出答案的 32 位中的某一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> dividend == -<span class="number">2147483648</span> <span class="keyword">and</span> divisor == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">        a, b, res = <span class="built_in">abs</span>(dividend), <span class="built_in">abs</span>(divisor), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 2^i * b &lt;= a 换句话说 a/b = 2^i + (a-2^i*b)/b</span></span><br><span class="line">            <span class="keyword">if</span> (b &lt;&lt; i) &lt;= a:</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">                a -= b &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>两数相除——官方题解：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/">https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/</a></li><li>减法试除：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/1042741/pythonjavajavascript-jian-fa-shi-chu-by-amrow/">https://leetcode.cn/problems/divide-two-integers/solutions/1042741/pythonjavajavascript-jian-fa-shi-chu-by-amrow/</a></li><li>二进制搜索的思想：<a href="https://leetcode.cn/problems/divide-two-integers/solutions/458026/29-python3-li-yong-er-jin-zhi-sou-suo-de-si-xiang-/">https://leetcode.cn/problems/divide-two-integers/solutions/458026/29-python3-li-yong-er-jin-zhi-sou-suo-de-si-xiang-/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 长除法 </tag>
            
            <tag> 快速乘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学(三) -- LC[1010]&amp;[1015] 可被 K 整除的最小整数</title>
      <link href="/article/e0f9f6cf.html"/>
      <url>/article/e0f9f6cf.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要结合LeetCode上的题目分析常用的取模运算、带余除法、鸽巢定理、组合数学的解题技巧。</p><span id="more"></span><h2 id="1-可被-K-整除的最小整数"><a href="#1-可被-K-整除的最小整数" class="headerlink" title="1 可被 K 整除的最小整数"></a>1 可被 K 整除的最小整数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/004.4r4wqioa0sk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/">https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>模运算</strong></p><p>如果让你计算 $1234 \cdot 6789$ 的个位数，你会如何计算？</p><p>由于只有个位数会影响到乘积的个位数，那么 $4\cdot 9&#x3D;36$ 的个位数 $6$ 就是答案。</p><p>对于 $1234+6789$ 的个位数，同理，$4+9&#x3D;13$ 的个位数 $3$ 就是答案。</p><p>你能把这个结论抽象成数学等式吗？</p><p>一般地，涉及到取模的题目，通常会用到如下等式(上面计算的是 $m&#x3D;10$):</p><p>$$<br>(a+b)\bmod m &#x3D; ((a\bmod m) + (b\bmod m)) \bmod m \<br>(a\cdot b) \bmod m&#x3D;((a\bmod m)\cdot  (b\bmod m)) \bmod m<br>$$</p><p>证明：根据<a href="https://zhuanlan.zhihu.com/p/147079013">带余除法</a>，任意整数 $a$ 都可以表示为 $a&#x3D;km+r$，这里 $r$ 相当于 $a mod m$。那么设 $a&#x3D;k_1m+r_1,\ b&#x3D;k_2m+r_2$。</p><p><strong>第一个等式：</strong><br>$$<br>\begin{aligned}<br>&amp;(a+b) \bmod m\<br>&#x3D;&amp;((k_1+k_2) m+r_1+r_2)\bmod m\<br>&#x3D;&amp;(r_1+r_2)\bmod m\<br>&#x3D;&amp;((a\bmod m) + (b\bmod m)) \bmod m<br>\end{aligned}<br>$$</p><p>即：两个数相加对某个数求余等于两个数分别求余相加之后再求余。</p><p><strong>第二个等式：</strong><br>$$<br>\begin{aligned}<br>&amp;(a\cdot b) \bmod m\<br>&#x3D;&amp;(k_1k_2m^2+(k_1r_2+k_2r_1)m+r_1r_2)\bmod m\<br>&#x3D;&amp;(r_1r_2)\bmod m\<br>&#x3D;&amp;((a\bmod m)\cdot  (b\bmod m)) \bmod m<br>\end{aligned}<br>$$</p><p><strong>举例一: $k &#x3D; 7$</strong></p><p>从小到大枚举$n$，第一个能被 $k$ 整除的数的长度即为答案。</p><p>$$1 \rightarrow 11 \rightarrow 111 \rightarrow 1111 \rightarrow 11111 \rightarrow 111111$$</p><p>根据前置知识，设 $x$ 是上一次运算的结果(初始为1)，则下一个 $n$ 模 $k$ 的结果为 $(10x + 1) mod k$，看它是否为0。</p><p>$$1 \rightarrow 4 \longrightarrow 6 \longrightarrow 5 \longrightarrow 2 \longrightarrow 0$$</p><p><strong>举例二: $k&#x3D;24$</strong></p><p>如果计算结果和之前的某个数相同，由于计算规则不变，后面会无限重复下去，无法得到0。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/005.54n4hhi87cg0.webp#pic_center" width = 48%><p><strong>方法一：哈希表</strong></p><p>用哈希表记录计算结果。如果在算出0之前就遇到了在哈希表中的数字，则返回-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">1</span> % k           <span class="comment">#  x 为余数</span></span><br><span class="line">        seen = <span class="built_in">set</span>()        <span class="comment">#  创建一个无序集合，用于存储余数</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> seen:      <span class="comment"># 当余数为0或者余数重复出现，退出循环</span></span><br><span class="line">            seen.add(x)</span><br><span class="line">            x = (<span class="number">10</span> * x + <span class="number">1</span>) % k</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> x <span class="keyword">else</span> <span class="built_in">len</span>(seen) + <span class="number">1</span>   <span class="comment"># 余数不为0，返回-1，余数为0，返回len(seen)+1    </span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(k)$。</li><li>空间复杂度：$\mathcal{O}(k)$。</li></ul><p><strong>方法二：抽屉原理</strong></p><p>循环 $k$ 次，如果没有算出0，则返回-1。为什么？模 $k$ 的结果在 $[0, k-1]$ 中，这有 $k$ 个数字。如果循环 $k$ 次还没有找到0,根据<a href="https://oi-wiki.org/math/number-theory/fermat/#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">鸽巢原理(抽屉原理)</a>，必然有重复的数字。这也同时说明算法一的时间复杂度为 $O(k)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> k % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        x = <span class="number">1</span> % k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">1</span>):              <span class="comment"># 一定有解</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            x = (x * <span class="number">10</span> + <span class="number">1</span>) % k</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(k)$。</li><li>空间复杂度：$\mathcal{O}(1)$，仅用到若干额外变量。</li></ul><p><code>itertools.count(start=0, step=1)</code></p><p>创建一个迭代器，它从 start 值开始，返回均匀间隔的值。常用于 <code>map()</code> 中的实参来生成连续的数据点。此外，还用于 <code>zip()</code> 来添加序列号。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">start=<span class="number">0</span>, step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) --&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure><p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如：<code>(start + step * i for i in count())</code>。</p><p><strong>方法三：数学推导</strong></p><p>设 $n$ 的长度为 $x$，那么 $n&#x3D;\frac{10^x-1}{9}$。$n$ 是 $k$ 的倍数，等价于 $10^x-1$ 是 $9k$ 的倍数，即 $10^x \equiv 1(mod 9k)$ 。</p><ul><li>结论：最小的 $x$ 必然是 $\phi(9k)$ 的因子。</li><li>反证：如果 $\phi(9k) &#x3D; px + r (0 &lt; r &lt;x)$，根据欧拉定理，$10^{\phi(9k)}&#x3D;(10)P﹒10”&#x3D;10”&#x3D; 1(mod 9k)$，这说明有一个比 $x$ 更小的 $r$，矛盾。</li></ul><p>那么计算 $\phi(9k)$ 并枚举其因子 $d$，用快速幂判断 $10^d mod (9k)$ 是否等于1。这一做法只需要 $(\sqrt(k)log k )$ 的时间。</p><p><strong>一点优化</strong></p><p>由于 $n$ 的个位数是1，所以必然不是 2 的倍数和 5 的倍数。如果 $k$ 是 2 的倍数或 5 的倍数，那么必然无解，返回 —1。否则一定有解。</p><p>证明：根据算法二，在计算过程中必然会出现两个数模 $k$ 同余。设这两个数为 $a&#x3D;\frac{10^x-1}{9}$ 和 $b&#x3D;\frac{10^y-1}{9}$，且 $a &gt; b$。那么 $a-b$ 是 $k$ 的倍数。</p><p>注意 $a-b&#x3D;\frac{10^x-10^y}{9}&#x3D;10^y\cdot\frac{10^{x-y}-1}{9}$。$k$在没有因子 2 和 5 的情况下，要想整除上式，必须要整除 $\frac{10^{x-y}-1}{9}$，这说明 $n$ 的长度可以是 $x-y$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算欧拉函数（n 以内的与 n 互质的数的个数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phi</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = n</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            res = res // i * (i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n //= i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        res = res // n * (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestRepunitDivByK</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> k % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        m = phi(k * <span class="number">9</span>)</span><br><span class="line">        <span class="comment"># 从小到大枚举不超过 sqrt(m) 的因子</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt;= m:</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">10</span>, i, k * <span class="number">9</span>) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从小到大枚举不低于 sqrt(m) 的因子</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">10</span>, m // i, k * <span class="number">9</span>) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> m // i</span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(\sqrt{k}\log k)$。计算 $\phi(9k)$ 和枚举 $\phi(9k)$ 的因子都需要 $\mathcal{O}(\sqrt{k})$ 的时间，对每个因子计算快速幂需要 $\mathcal{O}(\log k)$ 的时间，所以时间复杂度为 $\mathcal{O}(\sqrt{k}\log k)$。</li><li>空间复杂度：$\mathcal{O}(1)$。仅用到若干额外变量。</li></ul><h2 id="2-总持续时间可被-60-整除的歌曲"><a href="#2-总持续时间可被-60-整除的歌曲" class="headerlink" title="2 总持续时间可被 60 整除的歌曲"></a>2 总持续时间可被 60 整除的歌曲</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/006.3bcoupelrdk0.webp#pic_center" width = 64%><p>题目链接：<a href="https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/">https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/</a></p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p><strong>1. 组合数学</strong></p><p>遍历数组的同时用一个哈希表（或者数组）记录元素的出现次数。</p><p>遍历 $\textit{time}$：</p><ul><li>举例，如果 $\textit{time}[i]&#x3D;1$，那么需要知道左边有多少个模 60 余数是 59 的数。</li><li>举例，如果 $\textit{time}[i]&#x3D;62$，那么需要知道左边有多少个模 60 余数是 58 的数。</li><li>一般地，对于 $\textit{time}[i]$，需要知道左边有多少个模 60 余数是 $60-\textit{time}[i] mod 60$ 的数。<br>特别地，如果 $\textit{time}[i]$ 模 60 的余数是 0，那么需要知道左边有多少个模 60 余数也是 0 的数。<br>这两种情况可以合并为：累加左边 $(60-\textit{time}[i] mod 60) mod 60$ 的出现次数。</li></ul><p>代码实现时，用一个长为 60 的数组 $\textit{cnt}$ 维护 $\textit{time}[i] mod 60$ 的出现次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numPairsDivisibleBy60</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">60</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">            <span class="comment"># 先查询 cnt，再更新 cnt，因为题目要求 i&lt;j</span></span><br><span class="line">            <span class="comment"># 如果先更新，再查询，就把 i=j 的情况也考虑进去了</span></span><br><span class="line">            ans += cnt[(<span class="number">60</span> - t % <span class="number">60</span>) % <span class="number">60</span>]</span><br><span class="line">            cnt[t % <span class="number">60</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(n+U)$，其中 $n$ 为 $\textit{nums}$ 的长度，$U&#x3D;60$。</li><li>空间复杂度：$\mathcal{O}(U)$。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>三种算法+优化：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/">https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/</a></li><li>「两数之和」的本质是什么？：<a href="https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2259343/liang-shu-zhi-he-de-ben-zhi-shi-shi-yao-bd0r1/">https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2259343/liang-shu-zhi-he-de-ben-zhi-shi-shi-yao-bd0r1/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学（二）-- LC[204] 计数质数</title>
      <link href="/article/d3e16ec0.html"/>
      <url>/article/d3e16ec0.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode[204] 计数质数，涉及的知识主要有质数的判断、枚举法、厄拉多塞筛算法</p><span id="more"></span><h2 id="1-计数质数"><a href="#1-计数质数" class="headerlink" title="1 计数质数"></a>1 计数质数</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。</p><blockquote><p>示例 1：<br>输入：n &#x3D; 10<br>输出：4<br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p></blockquote><blockquote><p>示例 2：<br>输入：n &#x3D; 0<br>输出：0</p></blockquote><blockquote><p>示例 3：<br>输入：n &#x3D; 1<br>输出：0</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/count-primes/">https://leetcode.cn/problems/count-primes</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><strong>方法一：枚举法（计算超时）</strong></p><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 $x$，我们可以从小到大枚举 $[2, −1]$ 中的每个数 $y$，判断 $y$ 是否为 $x$ 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 $O(n)$，无法通过所有测试数据。</p><p>考虑到如果 $y$ 是 $x$ 的因数，那么 $\frac{x}{y}$ 也必然是 $x$ 的因数，因此我们只要校验 $y$ 或者 $\frac{x}{y}$ 即可。而如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在 $[2, \sqrt(x)]$ 的区间中，因此我们只需要枚举  $[2, \sqrt(x)]$  中的所有数即可，这样单次检查的时间复杂度从 $O(n)$ 降低至了 $O(\sqrt(n))$。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">if</span> is_prime(i):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(n\sqrt(n))$。单个数检查的时间复杂度为$O(\sqrt(n))$，一共要检查 $O(n)$ 个数，因此总时间复杂度为：$O(n\sqrt(n))$。</li><li>空间复杂度：$O(1)$。</li></ul><p>做进一步的优化，首先素数的判断，没必要去除以 $[2, \sqrt(x)]$ 之间的所有数，寻找质数时，质数里除了2以外都是奇数，只需要遍历小于 $n$ 的奇数即可，虽然提高程序运行效率，但依然超时，毕竟复杂度的数量级没降下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">number</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;优化对素数的判断&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> number == <span class="number">2</span> <span class="keyword">or</span> number == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> number % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="built_in">int</span>(sqrt(number))+<span class="number">2</span>, <span class="number">6</span>):  </span><br><span class="line">                <span class="keyword">if</span> number % (i-<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">or</span> number % (i+<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n, <span class="number">2</span>):    <span class="comment"># 偶数除了2肯定不能是质数，只判断奇数</span></span><br><span class="line">            <span class="keyword">if</span> is_prime(i):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>方法二：厄拉多塞筛算法</strong></p><p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出，简称埃氏筛，也称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt(n)$以内的素数的倍数标记为 <strong>合数</strong>，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。厄拉多塞筛算法具体步骤如下：</p><ol><li>读取输入的数 n，将 2 到 n 的所有整数记录在表中</li><li>从 $i&#x3D;2$ 开始，划去表中所有 2 的倍数</li><li>由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数</li><li>重复第（3）步，直到找到的 $i$ 大于$\sqrt(n)$为止</li><li>表中所有未被划去的整数均为素数</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/001.4amrzpcmi3q0.webp#pic_center" width = 48%><p><strong>算法流程图：</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/002.4erghtl420w0.webp#pic_center" width = 36%><blockquote><p>一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。</p></blockquote><p>下面以所有不超过100的素数为例，因为小于等于10的所有素数为2、3、5、7，所以依次删除2、3、5、7的倍数。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/003.2bbbtx0zzuqs.gif#pic_center" width = 36%><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span>                  <span class="comment"># 不存在小于 2 的素数</span></span><br><span class="line">        flag_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        flag_list[:<span class="number">2</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):   <span class="comment">#  遍历 i=2 到 根号 n</span></span><br><span class="line">            <span class="keyword">if</span> flag_list[i]:                 <span class="comment"># 筛去 i 的倍数</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i*i, n, i):</span><br><span class="line">                    flag_list[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(flag_list)</span><br></pre></td></tr></table></figure><p>这里在筛去 $i$ 的倍数的时候，第一个数是 $i \times i$ 而不是 $i$，这是因为对于所有 $k\times i$，$k&lt;i$，都在前面被筛过，故可以跳过这些数。<code>return sum(flag_list)</code> 这里列表中每个质数位的值均为 1 ，其余合数位的值均为 0 ，<code>sum(flag_list)</code> 的结果就是 n 以内质数的个数。</p><p>进一步优化，第二个<code>for</code>循环是可以直接用列表的索引把质数的所有倍数所在的位置赋值为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        flag_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        flag_list[:<span class="number">2</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> flag_list[i]:</span><br><span class="line">                flag_list[i*i:n:i] = [<span class="number">0</span>] * ((n - i * i - <span class="number">1</span>) // i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(flag_list)</span><br></pre></td></tr></table></figure><p> <code>flag_list[i*i:n:i] = [0] * ((n - i * i - 1) // i + 1)</code> 指定步长参数，进行列表切片赋值，这里要计算好列表切片取出多少个值。</p><p> <strong>温馨提示：</strong> 使用 python 时间和空间效率都较低，对于标记素数，可以采用 c++ 的 bitset，bitset 是以比特为单位标记的，会极大降低存储消耗。可以参考：<a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-bao-li-fa-ji-you-hua-shai-fa-ji-you/">运用比特表（Bitmap）算法对筛法进行内存优化</a></p><p><strong>小结：</strong> 厄拉多塞筛算法的核心就是要得到自然数 n 以内的全部质数，必须把不大于 根号n 的所有质数的倍数剔除，剩下的就是质数。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（十五）-- 二叉树的遍历：深度优先搜索与广度优先搜索</title>
      <link href="/article/49dac87b.html"/>
      <url>/article/49dac87b.html</url>
      
        <content type="html"><![CDATA[<p>本篇带你走进二叉树，使用深度优先搜索和广度优先搜索思想进行二叉树的顺序遍历和层序遍历，带你刷遍LeetCode上的二叉树遍历题目。</p><span id="more"></span><p>本篇开始总结二叉树的常用解题技巧，二叉树的顺序遍历和层序遍历刚好对应深度优先搜索和广度优先搜索。</p><h2 id="1-顺序遍历"><a href="#1-顺序遍历" class="headerlink" title="1 顺序遍历"></a>1 顺序遍历</h2><p><strong>题目列表</strong></p><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank">144. 前序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank">145. 二叉树的后序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">94. 二叉树的中序遍历</a></p></li></ul></blockquote> <p><strong>144. 二叉树的前序遍历</strong><br>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.6ualntxoeg80.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><p>递归算法三要素：确定递归函数的参数和返回值、确定终止条件、确定单层递归的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            result.append(root.val)                 <span class="comment"># 先将根节点值加入结果</span></span><br><span class="line">            <span class="keyword">if</span> root.left: traversal(root.left)      <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">if</span> root.right: traversal(root.right)    <span class="comment"># 右</span></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result </span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.f5i9bhxllkg.gif#pic_center" width = 48%><p><strong>94. 二叉树的中序遍历</strong></p><p>给你二叉树的根节点 root ，返回它节点值的 中序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.5jrflywetw00.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traversal(root.left)    <span class="comment"># 左</span></span><br><span class="line">            result.append(root.val) <span class="comment"># 中序</span></span><br><span class="line">            traversal(root.right)   <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:    <span class="keyword">return</span> []   <span class="comment"># 空树</span></span><br><span class="line">        stack = []                  <span class="comment"># 不能提前将root结点加入stack中&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:                 <span class="comment"># 先迭代访问最底层左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 到达最左节点后处理栈顶结点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right     <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.6tugbwc3y2s0.gif#pic_center" width = 48%><p><strong>145. 二叉树的后序遍历</strong><br>给你二叉树的根节点 root ，返回它节点值的 后序 遍历。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.25hp5m11l5s0.webp#pic_center" width = 30%><blockquote><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p><p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>1. 递归实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            self.traversal(root.left)               <span class="comment"># 左</span></span><br><span class="line">            self.traversal(root.right)              <span class="comment"># 右</span></span><br><span class="line">            self.result.append(root.val)            <span class="comment"># 中</span></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>2. 迭代实现</strong></p><p>后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.3e8o26ewkj20.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="3-层序遍历"><a href="#3-层序遍历" class="headerlink" title="3 层序遍历"></a>3 层序遍历</h2><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank">102. 二叉树的层序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank">107. 二叉树的层次遍历II</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank">199. 二叉树的右视图</a></p></li><li><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank">637.二叉树的层平均值</a></p></li><li><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank">429. N叉树的层序遍历/a></p></li><li><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank">515. 在每个树行中找最大值</a></p></li><li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank">116. 填充每个节点的下一个右侧节点指针</a></p></li><li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank">117.填充每个节点的下一个右侧节点指针II</a></a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank">104. 二叉树的最大深度</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank">111. 二叉树的最小深度</a></p></li></ul></blockquote> <p><strong>102. 二叉树的层序遍历</strong></p><p>给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.6wjqhxodwm80.webp#pic_center" width = 48%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p></blockquote><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.6gyzeourbyc0.gif#pic_center" width = 64%><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 二叉树层序遍历迭代解法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):       <span class="comment"># 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的</span></span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><p>用广度优先处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.96gmi09otqg.webp#pic_center" width = 36%><p>我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个 list。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.ka118nd4zgw.webp#pic_center" width = 36%><p>按照深度优先的处理顺序，会先访问节点 1，再访问节点 2，接着是节点 3。 之后是第二列的 4 和 5，最后是第三列的 6。</p><p>每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。</p><p>动态演示如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.26ehjiwrja80.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 假设 res 是 [[1], [2,3]]， level 是 3，就再插入一个 [root.val] 放到 res 中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将当前节点的值加入到res中，level 代表当前层，假设 level 是 3，节点值是 99</span></span><br><span class="line">    <span class="comment"># res 是 [[1], [2,3], [4]]，加入后 res 就变为 [[1], [2,3], [4,99]]</span></span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            <span class="comment"># 递归的处理左子树，右子树，同时将层数 level+1</span></span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>107. 二叉树的层次遍历II</strong></p><p>给你二叉树的根节点 root ，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5xg8urhe4hw0.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        results.reverse()</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>) </span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>199. 二叉树的右视图</strong></p><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.17zbfv1u8sqo.webp#pic_center" width = 36%><blockquote><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># deque 相比list的好处是，list的 pop(0) 是 O(n) 复杂度，deque 的 popleft() 是 O(1) 复杂度</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            res.append(que[-<span class="number">1</span>].val)         <span class="comment"># 每次都取最后一个node就可以</span></span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):           <span class="comment"># 执行这个遍历的目的是获取下一层所有的node</span></span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>637. 二叉树的层平均值</strong></p><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.57u4p7etgy40.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><p>从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p><p>如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：</p><ul><li>初始时，将根节点加入队列；</li><li>每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。</li></ul><p>由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。</p><p>具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 $\textit{size}$，遍历时只遍历 $\textit{size}$ 个节点，即可满足每一轮遍历的是同一层的全部节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                total += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">            result.append(total/size)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><p>使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，$\textit{counts}$ 用于存储二叉树的每一层的节点数，$\textit{sums}$ 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 $i$ 层，则将 $\textit{counts}[i]$ 的值加 1，并将该节点的值加到 $\textit{sums}[i]$。</p><p>遍历结束之后，第 $i$ 层的平均值即为 $\textit{sums}[i] &#x2F; \textit{counts}[i]$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode], level: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(total) &lt; level:          </span><br><span class="line">                total.append(root.val)</span><br><span class="line">                count.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total[level-<span class="number">1</span>] += root.val</span><br><span class="line">                count[level-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        count, total = [], []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> [t/c <span class="keyword">for</span> t, c <span class="keyword">in</span> <span class="built_in">zip</span>(total, count)]</span><br></pre></td></tr></table></figure><p><strong>429. N叉树的层序遍历</strong></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.6di4q19r8ac0.webp#pic_center" width = 36%><blockquote><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="comment"># cur.children 是 Node 对象组成的列表，也可能为 None</span></span><br><span class="line">                <span class="keyword">if</span> node.children:</span><br><span class="line">                    que.extend(node.children)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>].append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                dfs(child, level+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>515. 在每个树行中找最大值</strong></p><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.6b1t4g5prm40.webp#pic_center" width = 36%><blockquote><p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p></blockquote><p><strong>方法一：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">             size = <span class="built_in">len</span>(que)</span><br><span class="line">             max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">             <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                 node = que.popleft()</span><br><span class="line">                 max_value = <span class="built_in">max</span>(max_value, node.val)</span><br><span class="line">                 <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                 <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line">             res.append(max_value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>方法二：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># DFS</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, level</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[level-<span class="number">1</span>] = (<span class="built_in">max</span>(root.val, res[level-<span class="number">1</span>]))</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>116. 填充每个节点的下一个右侧节点指针</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.29xb4d83sgis.webp#pic_center" width = 64%><p><strong>方法一：层序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span>        <span class="comment"># 这里空树，直接返回None</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>: <span class="keyword">break</span>          <span class="comment"># 遍历到最右边，结束本行循环</span></span><br><span class="line">                cur.<span class="built_in">next</span> = que[<span class="number">0</span>]           <span class="comment"># 指向同一行的右边节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>117. 填充每个节点的下一个右侧节点指针 II</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.2g4tll9f5pxc.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size =  <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> i == size-<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">                cur.<span class="built_in">next</span> = que[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>104. 二叉树的最大深度</strong></p><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><ul><li>说明: 叶子节点是指没有子节点的节点。</li><li>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></li></ul><p>返回它的最大深度 3。</p><p><strong>方法一：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        que = deque([root])</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left: que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: que.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><strong>方法二：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># DFS 自底向上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 感受一下这里是将最底层的结果往上抛</span></span><br><span class="line">        <span class="comment"># 因为这里的递归边界条件是叶子节点</span></span><br><span class="line">        left_height = self.maxDepth(root.left)</span><br><span class="line">        right_height = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># DFS 自顶向下</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, depth</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res = <span class="built_in">max</span>(res, depth)</span><br><span class="line">            dfs(root.left, depth+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, depth+<span class="number">1</span>)</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>自顶向下：直接return 函数调用自身下一级实现，比如 <code>return Fibonacci(n-1) + Fibonacci(n-2)</code>;</li><li>自底向上：先递归到最小单位(叶子节点)，再从最小单位往上抛结果，传递结果</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.2dn4dh1cdzms.gif#pic_center" width = 49%> <p><strong>111. 二叉树的最小深度</strong></p><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><ul><li>说明：叶子节点是指没有子节点的节点。</li><li>示例 1：</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.69r8h85mqxc0.webp#pic_center" width = 48%><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p></blockquote><p><strong>方法一：深度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_depth = <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.left), min_depth)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.right), min_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>方法二：广度优先搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        que = collections.deque([(root, <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            node, depth = que.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                que.append((node.left, depth + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                que.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>二叉树遍历暂时告一段落，但还有很多自己不满意的地方，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.58rb9k1endc0.gif#pic_center" width = 48%><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（十四）-- 冒泡排序算法</title>
      <link href="/article/234fdd80.html"/>
      <url>/article/234fdd80.html</url>
      
        <content type="html"><![CDATA[<p>冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p><span id="more"></span><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p><p>当一趟操作完成时，序列中最大的未排序元素就被放置到了所有未排序的元素中最后的位置上，它就像水中的石块一样沉到了水底。而其它较小的元素则被移动到了序列的前面，就像水中的气泡冒到了水面一样。这就是为什么该算法被叫做冒泡排序的原因。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/028.3mbc0z7sie60.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/028.3mbc0z7sie60.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图1  冒泡排序的基本原理</div> </center><hr><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1.1 算法原理"></a>1.1 算法原理</h3><p>图1展示了冒泡排序的基本原理。假设一个序列中共有 n 个元素，那么上面的比较和交换过程一共需要进行$n-1$趟：</p><ul><li>第一趟需要比较序列中的所有元素，它的效果是将整个序列中最大的元素放置到了序列最后一个位置上。</li><li>第二趟只需要比较前面$n-1$个元素，因为前一趟中已经将最大的元素移到了它最终的位置上了。这一趟结束时，整个序列中第二大的元素就被放置到了倒数第二个位置上。</li><li>同样的，第三趟只需要比较前面$n-2$个元素。该趟结束时，序列中第三大的元素就被放到了倒数第三个位置上。<br>当进行第$i$趟的时候，需要比较的是前面$n-(i-1)$个元素，因为序列中最大的$i-1$个元素已经在前面的$i-1$趟排序中被排好了。注意，比较 $n-(i-1)$个元素需要进行$n-i$次比较。</li><li>当最终到达第$n-1$趟的时候，只需要比较序列中最前面的两个数而已。该趟结束时，序列中第二小的数就被放置到了顺数第二个位置上。同时，序列中最小的数也被放到了第一个位置上。整个排序过程完成。</li></ul><p>从以上对算法原理的讲解中，我们首先可以知道冒泡排序是一种交换排序，它需要进行大量的交换操作。其次，因为当两个元素相等时它们不会被交换，所以相等元素的相对位置在排序前后不会改变，因此冒泡排序又是一种稳定的排序算法。</p><p>假设待排序序列为[5,1,4,2,8]，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：</p><ol><li><p>第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图2所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.6dqaxm0x0p40.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/029.6dqaxm0x0p40.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图2  第一轮排序（白色字体表示参与比较的一对相邻元素）</div> </center>从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。</li><li><p>第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图3所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.8ij9ffq6n24.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/030.8ij9ffq6n24.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图3  第二轮排序</div> </center></li></ol><p>可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol><li>第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图4所示。<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.5aimida0q180.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/031.5aimida0q180.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图4  第三轮排序</div> </center></li></ol><p>经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol><li><p>第四轮排序，此时待排序序列包含前 2 个元素，对其进行冒泡排序的整个过程如图5所示。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.6ptwpdge2h00.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/032.6ptwpdge2h00.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图5  第四轮排序</div> </center>经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。</li><li><p>当进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列（如图6所示）。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.4t75fyuqob60.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/033.4t75fyuqob60.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图6  冒泡排序好的序列</div> </center></li></ol><p><strong>代码一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]        <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)     <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面n-(i-1)个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><h3 id="1-2-性能分析"><a href="#1-2-性能分析" class="headerlink" title="1.2 性能分析"></a>1.2 性能分析</h3><p>由上面的排序步骤可知：$N$个数字要排序完成，总共进行$N-1$趟排序，每$i$趟的排序次数为$(N-i)$次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><p>冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，每进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p><p>时间复杂度：1）如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数$C$和记录移动次数$M$均达到最小值，即：$C_{min}&#x3D;n-1; M_{min}&#x3D;0$；所以，冒泡排序最好的时间复杂度为$O(n)$；2）如果很不幸我们的数据是反序的，则需要进行$n-1$趟排序。每趟排序要进行$n-i$次比较($1≤i≤n-1$)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$$C_{max}&#x3D;\frac{n(n-1)}{2}&#x3D;O(n^2)\<br>M_{max}&#x3D;\frac{3n(n-1)}{2}&#x3D;O(n^2)$$</p><p>综上所述：冒泡排序总的平均时间复杂度为：$O(n^2)$时间复杂度和数据状况无关。</p><hr><h2 id="2-算法优化"><a href="#2-算法优化" class="headerlink" title="2 算法优化"></a>2 算法优化</h2><h3 id="2-1-第一次优化"><a href="#2-1-第一次优化" class="headerlink" title="2.1 第一次优化"></a>2.1 第一次优化</h3><p>因为冒泡排序必须要在最终位置找到之前不断交换数据项，所以它经常被认为是最低效的排序方法。这些“浪费式”的交换操作消耗了许多时间。比如序列中的元素有可能出现这样的情况，即经过前面几趟的排序后整个序列就已经排好序了，那么后面的那几趟排序就不需要再执行了。但是我们上面的第一版的冒泡排序即便是在这种情况下，仍然会执行所有的$n-1$趟的排序。即使后面几趟排序只进行比较而不需交换元素，但是当数据量很大的时候，这依旧会造成整体性能的明显下降。</p><p>因此，我们首先想到的优化方案就是当某一趟排序之后，如果整个序列已排好序了，那么就立即退出函数。这要怎么实现呢？其实很简单，只要在某一趟的排序中没有进行任何一次的元素交换，那么此时整个序列就排好序了。</p><p>因此，在每一趟排序的开始将一个标记<code>swapped</code>设置为<code>False</code>。在这一趟排序过程中，如果发生了数据交换，那么就将<code>swapped</code>设置为<code>True</code>。当这一趟排序结束，我们通过检查该<code>swapped</code>的值就可以知道整个序列是否已经排好序了。</p><p>假设我们有一个序列，它的元素分别为整数9、4、6、15、13。那么图7至图8则展示了经本次优化后的冒泡排序的完整执行过程。注意，虽然第一趟排序后整个序列就排好序了，但在第一趟排序中进行了元素交换（<code>swapped</code>被设置为<code>True</code>），算法此时并不知道整个序列已经排好了，所以还要进行第二趟排序。在第二趟排序中，不会进行任何元素交换（<code>swapped</code>最终为<code>False</code>），此时算法才知道整个序列已经是排好序了的。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.2rojc9iqteg0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/034.2rojc9iqteg0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%>  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图7  [9,4,6,15,13] 第1趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.33chi518g6e0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/035.33chi518g6e0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图8  [9,4,6,15,13] 第2趟排序</div> </center><p>综上，如果一个列表只需要几次遍历就可排好，冒泡排序就占有优势：它可以在发现列表已排好时立刻结束。代码二就是改良版冒泡排序。它通常被称作“短路冒泡排序”。<br><strong>代码二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;第一次优化&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False，False表示为交换，True表示交换</span></span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面n-(i-1)个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>在最好的情况下，第二版冒泡排序只需进行$n-1$次比较和0次元素移动；在最坏的情况下，还是进行$n(n-1)&#x2F;2$次比较和$3n(n-1)&#x2F;2$次元素移动。虽然这一版的冒泡排序的时间复杂度依旧是$O(n^2)$，但是和第一版相比肯定性能上更好。</p><h3 id="2-2-第二次优化"><a href="#2-2-第二次优化" class="headerlink" title="2.2 第二次优化"></a>2.2 第二次优化</h3><p>在我们之前的想法中，当进行第$i$趟排序时，序列中只有最大的$i-1$个元素已经排好序了。因为那时我们认为每一趟仅排好一个元素，即它比较的所有元素中最大的那一个。因此第$i$趟排序的时候，需要对前面$n-(i-1)$个元素进行比较和交换。但其实此时这前$n-(i-1)$个元素中可能最大的那几个元素已经在它们最终的位置上了，这时第$i$趟实际需要比较的元素个数就可以小于$n-(i-1)$。</p><p>比如有一个序列24、30、12、40、50，那么第1趟排序之后的结果为24、12、30、40、50。在原来的想法中，第2趟需要比较前面4个数。但此时前4个数中最大的两个30和40已经在它们最终的位置上了，不需要再对它们进行位置上的调整。因此，第2趟可以只比较前两个数。</p><p>注意这个例子中，虽然在序列的初始状态中40和50就已经在它们最终的位置上了，但第1趟排序还是需要比较全部的5个数。因为此时没有任何信息可以将序列的这种特殊状态告知算法，某一趟是否可以执行比它原本理论上更少的比较次数，需要前一趟排序对序列状态的了解。</p><p>在每一趟排序中，我们都用一个变量<code>last_index</code>记录下本趟排序最后一次元素交换中前一个元素的下标。在该下标之后没有发生交换，说明该下标之后的所有元素都已经排好序了。那么下一趟排序就只需要对该下标及其之前的元素进行比较而已。这样下一趟排序需要比较的次数可能比原本需要的次数更少，也就在一定程度上提升了算法的效率。<br><strong>代码三：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_bubble_sort</span>(<span class="params">items</span>):</span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    last_index = length - <span class="number">1</span><span class="comment"># 记录每一趟中最后一次交换中前一个元素的下标，他的初值为n-1</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False，False表示为交换，True表示交换</span></span><br><span class="line">        <span class="comment"># 内层循环用于第i趟时，对前面last_index+1个元素进行比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(last_index):</span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">                last_index = j  <span class="comment"># 记录本次交换中前一个元素的下标</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>图9至图11详细展示了经过第二次优化后的冒泡排序对[24, 30, 12, 40, 50]这个序列的执行情况。该例子中另一个值得注意的问题是，虽然在第2趟排序后整个序列就已经排好序了，但是第2趟中进行了一次元素交换而导致<code>swapped</code>等于<code>True</code>。因此第2趟后并不会立即退出函数，还要进行第3趟排序。在第3趟中内层循环不会执行而立即退出，因为此时<code>last_index</code>等于0，<code>j</code>（此时也等于0）小于<code>last_index</code>的条件不满足。在第3趟最后<code>swapped</code>为<code>False</code>，此时才退出算法。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.47232a8lqkq0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/036.47232a8lqkq0.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图9  [24, 30, 12, 40, 50] 第1趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3yaeqpkaep40.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/037.3yaeqpkaep40.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图10  [24, 30, 12, 40, 50] 第2趟排序</div> </center><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.jbnxksu0sxk.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/038.jbnxksu0sxk.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZW_6Lev5ryr5ryrMjAyMQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=45%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图11  [24, 30, 12, 40, 50] 第3趟排序</div> </center><h3 id="2-3-鸡尾酒排序"><a href="#2-3-鸡尾酒排序" class="headerlink" title="2.3 鸡尾酒排序"></a>2.3 鸡尾酒排序</h3><p><a href="https://baike.baidu.com/item/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/7515196#:~:text=%E9%B8%A1%E5%B0%BE%E9%85%92%20%E6%8E%92%E5%BA%8F%E5%8F%88%E7%A7%B0%E5%8F%8C%E5%90%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%B8%A1%E5%B0%BE%E9%85%92%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F%E3%80%81%E6%90%85%E6%8B%8C%E6%8E%92%E5%BA%8F%E3%80%81%E6%B6%9F%E6%BC%AA%E6%8E%92%E5%BA%8F%E3%80%81%E6%9D%A5%E5%9B%9E%E6%8E%92%E5%BA%8F%E6%88%96%E5%BF%AB%E4%B9%90%E5%B0%8F%E6%97%B6%E6%8E%92%E5%BA%8F,,%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%98%E5%BD%A2%E3%80%82%20%E8%AF%A5%E7%AE%97%E6%B3%95%E4%B8%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E5%9C%A8%E4%BA%8E%E6%8E%92%E5%BA%8F%E6%97%B6%E6%98%AF%E4%BB%A5%E5%8F%8C%E5%90%91%E5%9C%A8%E5%BA%8F%E5%88%97%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E3%80%82%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%9C%AC%E6%98%AF%E6%97%A0%E8%A7%84%E5%BE%8B%E7%9A%84%E6%8E%92%E6%94%BE%EF%BC%8C%E5%85%88%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E6%8A%8A%E4%BB%96%E6%94%BE%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%E6%94%BE%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E3%80%82">鸡尾酒排序</a>又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。因此，根据名字可以看到搅拌排序的原理，每次都是从左往右，交换相邻的元素，从而达到循环一边可以把最大的元素放在右边。而双向冒泡排序，在完成一次从左往右的冒泡排序后，再从右往左进行冒泡，从而把小的元素放在左边。<br>下面这张图可以很好地表达：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.5othrnnkxjg0.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230614/039.5othrnnkxjg0.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图12 双向排序动图演示</div> </center><p><strong>代码四：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cocktail_sort</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;搅拌排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制原序列</span></span><br><span class="line">    length = <span class="built_in">len</span>(items)  <span class="comment"># 序列中元素的数量</span></span><br><span class="line">    <span class="comment"># 外层循环控制第1至第(n-1)趟排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(length/<span class="number">2</span>)):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 每一趟开始时，将swapped设为False</span></span><br><span class="line">        <span class="comment"># 正向：把当前循环最大的放到最右边</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素，则交换他们</span></span><br><span class="line">            <span class="keyword">if</span> items[j] &gt; items[j + <span class="number">1</span>]:</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span>  <span class="comment"># 标记发生了元素交换</span></span><br><span class="line">        <span class="keyword">if</span> swapped:</span><br><span class="line">            swapped = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 反向：把当前循环最小的放到最右边</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(length-i-<span class="number">1</span>, i-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> items[k-<span class="number">1</span>] &gt; items[k]:</span><br><span class="line">                    items[k], items[k-<span class="number">1</span>] = items[k-<span class="number">1</span>], items[k]</span><br><span class="line">                    swapped = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 每一趟结束后，检查是否发生了交换，如果没有发生交换，则提前退出整个算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><hr><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h3><ul><li>图文详解冒泡排序：<a href="https://baijiahao.baidu.com/s?id=1662238914941980592&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1662238914941980592&wfr=spider&for=pc</a></li><li>Python 冒泡排序：<a href="https://www.runoob.com/python3/python-bubble-sort.html">https://www.runoob.com/python3/python-bubble-sort.html</a></li><li>冒泡排序算法：<a href="http://c.biancheng.net/view/6506.html">http://c.biancheng.net/view/6506.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 搅拌排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（十三）-- 位运算与使用技巧</title>
      <link href="/article/e701713c.html"/>
      <url>/article/e701713c.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要学习Python中的二进制运算，通过位运算实现乘除法、交换两数、判断奇偶数、交换符号、求绝对值、二进制逆序、统计二进制中1的个数，最后结合LeetCode常见题目进行练习。</p><span id="more"></span><p>计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。</p><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1 操作符"></a>1 操作符</h2><h3 id="1-1-基本运算"><a href="#1-1-基本运算" class="headerlink" title="1.1 基本运算"></a>1.1 基本运算</h3><ul><li>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">&amp;  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">------------------------------   </span><br><span class="line">   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><ul><li>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">|   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">------------------------------   </span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><ul><li>^ 异或运算，两个位相同则为 0，不同则为 1，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">^   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">-----------------------------   </span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><ul><li>~ 取反运算，0 则变为 1，1 则变为 0，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">-----------------------------   </span><br><span class="line">   <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ​</span><br></pre></td></tr></table></figure><h3 id="1-2-左移操作-lt-lt-与-右移操作-gt-gt"><a href="#1-2-左移操作-lt-lt-与-右移操作-gt-gt" class="headerlink" title="1.2 左移操作&lt;&lt; 与 右移操作&gt;&gt;"></a>1.2 左移操作&lt;&lt; 与 右移操作&gt;&gt;</h3><p><strong>左移操作</strong><br>左移操作，左移一位相当于乘以 b，<code>a&lt;&lt;b, a&#39; = a*(2^b)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&lt;&lt;<span class="number">3</span>)     <span class="comment"># 2*2^3 = 16，2的二进制10，向左移动3位后10000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&lt;&lt;<span class="number">1</span>)     <span class="comment"># 2*2^1 = 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&lt;&lt;<span class="number">4</span>)     <span class="comment"># 3*2^4 = 48,3的二进制为11，向左移动四位后110000</span></span><br></pre></td></tr></table></figure><p><strong>右移操作</strong><br>右移操作，右移一位相当于除以 b，<code>a&gt;&gt;b, a&#39; = a//(2^b)</code>注意这里是整除，当向右移动位数大于能移动的位数时，置为0【可以理解为会将尾巴截掉】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&gt;&gt;<span class="number">3</span>)     <span class="comment"># 2//2^3 = 0，2的二进制10，向右最多移动2位后，所以多移动无疑为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>&gt;&gt;<span class="number">1</span>)     <span class="comment"># 2//2^1 = 1，向右移动一位为 01,</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&gt;&gt;<span class="number">4</span>)     <span class="comment"># 3//2^4 = 0, 3 的二进制为11，向右移动四位后00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>&gt;&gt;<span class="number">1</span>)     <span class="comment"># 3//2^1 = 1, 3 的二进制为11，向右移动一位后为01</span></span><br></pre></td></tr></table></figure><blockquote><p>$&gt;&gt;$ 和 $&lt;&lt;$ 都是位运算，对二进制数进行移位操作。$&lt;&lt;$ 是左移，末位补 0，类比十进制数在末尾添 0 相当于原数乘以 10，$x&lt;&lt;1$ 是将 $x$ 的二进制表示左移一位，相当于原数 $x$ 乘 2。比如整数 4 在二进制下是100，$4&lt;&lt;1$ 左移1位变成1000(二进制)，结果是 8。$&gt;&gt;$ 是右移，右移1位相当于除以2。<br><br></br><br>而 $&gt;&gt;&#x3D;$ 和 $&lt;&lt;&#x3D;$，就是对变量进行位运算移位之后的结果再赋值给原来的变量，可以类比赋值运算符 $+&#x3D;$ 和 $-&#x3D;$ 可以理解。比如 $x&gt;&gt;&#x3D;2$， 就是把变量 $x$ 右移2位，再保留x操作后的值。</p></blockquote><h2 id="2-常见位运算问题"><a href="#2-常见位运算问题" class="headerlink" title="2 常见位运算问题"></a>2 常见位运算问题</h2><h3 id="2-1-位操作实现乘除法"><a href="#2-1-位操作实现乘除法" class="headerlink" title="2.1 位操作实现乘除法"></a>2.1 位操作实现乘除法</h3><p>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">a &gt;&gt; <span class="number">1</span>  <span class="comment"># 1</span></span><br><span class="line">a &lt;&lt; <span class="number">1</span>  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h3 id="2-2-位操作交换两数"><a href="#2-2-位操作交换两数" class="headerlink" title="2.2 位操作交换两数"></a>2.2 位操作交换两数</h3><p>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a         <span class="comment"># 普通操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位操作</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li>第一步：a ^&#x3D; b —&gt; a &#x3D; (a^b)</li><li>第二步：b ^&#x3D; a —&gt; b &#x3D; b^(a^b) —&gt; b &#x3D; (b^b)^a &#x3D; a</li><li>第三步：a ^&#x3D; b —&gt; a &#x3D; (a^b)^a &#x3D; (a^a)^b &#x3D; b</li></ul><h3 id="2-3-位操作判断奇偶数"><a href="#2-3-位操作判断奇偶数" class="headerlink" title="2.3 位操作判断奇偶数"></a>2.3 位操作判断奇偶数</h3><p>要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;偶数&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-位操作交换符号"><a href="#2-4-位操作交换符号" class="headerlink" title="2.4 位操作交换符号"></a>2.4 位操作交换符号</h3><p>交换符号将正数变成负数，负数变成正数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversal</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> ~a + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><h3 id="2-5-位操作求绝对值"><a href="#2-5-位操作求绝对值" class="headerlink" title="2.5 位操作求绝对值"></a>2.5 位操作求绝对值</h3><p>正数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1，即 <code>0xffffffff</code>），然后根据符号进行相应的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">a</span>):</span><br><span class="line">    i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> (~a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面的操作可以进行优化，可以将 i &#x3D;&#x3D; 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i &#x3D; 0 为正，i &#x3D; -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 <code>0xffffffff</code> 进行异或就相当于对此数进行取反，因此可以将上面三目元算符转换为 <code>((a^i)-i)</code>，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 <code>0xffffffff</code> 异或将 a 进行取反，然后在加上 1，即减去 i(i &#x3D;-1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs2</span>(<span class="params">a</span>):</span><br><span class="line">     i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">     <span class="keyword">return</span> ((a^i)-i)</span><br></pre></td></tr></table></figure><h3 id="2-6-位操作进行高低位交换"><a href="#2-6-位操作进行高低位交换" class="headerlink" title="2.6 位操作进行高低位交换"></a>2.6 位操作进行高低位交换</h3><p>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">将其高<span class="number">8</span>位与低<span class="number">8</span>位进行交换，得到一个新的二进制数：</span><br><span class="line"><span class="number">11011000</span> <span class="number">10000110</span></span><br><span class="line">其十进制为<span class="number">55430</span></span><br></pre></td></tr></table></figure><p>从上面移位操作我们可以知道，只要将无符号数 <code>a &gt;&gt; 8</code> 即可得到其高 8 位移到低 8 位，高位补 0；将 <code>a &lt;&lt; 8</code> 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 <code>a &gt;&gt; 8</code> 和 <code>a &lt;&lt; 8</code> 进行或操作既可求得交换后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34520</span></span><br><span class="line">a = (a &gt;&gt; <span class="number">8</span>) | (a &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-位操作进行二进制逆序"><a href="#2-7-位操作进行二进制逆序" class="headerlink" title="2.7 位操作进行二进制逆序"></a>2.7 位操作进行二进制逆序</h3><p>将无符号数的二进制表示进行逆序，求取逆序后的结果，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数<span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">逆序后则为：</span><br><span class="line">00011011 01100001</span><br><span class="line">它的十进制为<span class="number">7009</span></span><br></pre></td></tr></table></figure><p>在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。</p><ul><li>第一步：以每 2 位为一组，组内进行高低位交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">10</span> <span class="number">00</span> 01 <span class="number">10</span> <span class="number">11</span> 01 <span class="number">10</span> <span class="number">00</span></span><br><span class="line">交换后： 01 <span class="number">00</span> <span class="number">10</span> 01 <span class="number">11</span> <span class="number">10</span> 01 <span class="number">00</span></span><br></pre></td></tr></table></figure></li><li>第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">0</span>100 <span class="number">1001</span> <span class="number">1110</span> <span class="number">0</span>100</span><br><span class="line">交换后： 0001 0110 <span class="number">1011</span> 0001</span><br></pre></td></tr></table></figure></li><li>第三步：以每 8 位为一组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">000</span>10110 <span class="number">10110001</span></span><br><span class="line">交换后： 01100001 00011011</span><br></pre></td></tr></table></figure></li><li>第四步：以每16位为一组，组内高低位进行交换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： 0110000100011011</span><br><span class="line">交换后： 0001101101100001</span><br></pre></td></tr></table></figure></li></ul><p>对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原数：  <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位： <span class="number">10000010</span> <span class="number">10001000</span></span><br><span class="line">偶数位： <span class="number">00000</span>100 <span class="number">0</span>1010000</span><br></pre></td></tr></table></figure><p>再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原数：  <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位右移一位： <span class="number">0</span> <span class="number">10000010</span> <span class="number">1000100</span></span><br><span class="line">偶数位左移一位：<span class="number">0000</span>100 <span class="number">0</span>1010000 <span class="number">0</span></span><br><span class="line">两数相或得到： <span class="number">0</span>1001001 <span class="number">11100100</span></span><br></pre></td></tr></table></figure><p>上面的方法用位操作可以表示为：</p><ul><li>取 a 的奇数位并用 0 进行填充可以表示为：<code>a &amp; 0xAAAA</code></li><li>取 a 的偶数为并用 0 进行填充可以表示为：<code>a &amp; 0x5555</code> 因此，上面的第一步可以表示为：<br><code>a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1)</code></li></ul><p>同理，可以得到其第二、三和四步为：</p><ul><li>a &#x3D; ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2)</li><li>a &#x3D; ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4)</li><li>a &#x3D; ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8)</li></ul><p>因此整个操作为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34520</span>;</span><br><span class="line">a = ((a &amp; <span class="number">0xAAAA</span>) &gt;&gt; <span class="number">1</span>) | ((a &amp; <span class="number">0x5555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xCCCC</span>) &gt;&gt; <span class="number">2</span>) | ((a &amp; <span class="number">0x3333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xF0F0</span>) &gt;&gt; <span class="number">4</span>) | ((a &amp; <span class="number">0x0F0F</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">a = ((a &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) | ((a &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="2-8-位操作统计二进制中-1-的个数"><a href="#2-8-位操作统计二进制中-1-的个数" class="headerlink" title="2.8 位操作统计二进制中 1 的个数"></a>2.8 位操作统计二进制中 1 的个数</h3><p>统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &amp;&#x3D; (a-1)的结果：</p><ul><li>第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000</li><li>第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000</li><li>第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000</li></ul><p>我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(a):</span><br><span class="line">    a = a &amp; (a-<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.3l5z91u11180.webp#pic_center" width = 36%><h3 id="2-9-原码、反码、补码"><a href="#2-9-原码、反码、补码" class="headerlink" title="2.9 原码、反码、补码"></a>2.9 原码、反码、补码</h3><p>机器数：一个数在计算机中的二进制表示形式，机器数带符号，在计算机用一个数的最高位存放符号，正数为0，负数为1</p><blockquote><p>例如： 十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011。其中，00000011 和 10000011就是机器数</p></blockquote><p>真值：将带符号位的机器数对应的真正数值称为机器数的真值。</p><p><strong>1. 原码</strong></p><p>原码就是符号位加上真值的绝对值，即用第一位表示符号, 其余位表示值。例如：如果是8位二进制，那么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>]原 = <span class="number">0000</span> 0001</span><br><span class="line">[-<span class="number">1</span>]原 = <span class="number">1000</span> 0001</span><br></pre></td></tr></table></figure><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1111</span> <span class="number">1111</span>, 0111 <span class="number">1111</span>]</span><br><span class="line">[-<span class="number">127</span>, <span class="number">127</span>]</span><br></pre></td></tr></table></figure><p><font color=#9900CC><strong>原码在展示上是与机器数相同的</font></strong></p><p><strong>2. 反码</strong></p><p>反码的表示方法是:</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [00000001]原 = [00000001]反</span><br><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反</span><br></pre></td></tr></table></figure><p><strong>3. 补码</strong></p><p>补码的表示方法是:</p><ul><li>正数的补码就是其本身</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。(即在反码的基础上+1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-<span class="number">1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。不管 n 是正数还是负数，只需要下面的语句便可得到此数的补码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(n &amp; <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><p>了解更多，请移步：<a href="https://zhuanlan.zhihu.com/p/106535460">原码反码补码的通俗解释</a></p><h3 id="2-10-进制之间的转换"><a href="#2-10-进制之间的转换" class="headerlink" title="2.10 进制之间的转换"></a>2.10 进制之间的转换</h3><p>二进制、八进制、十进制、十六进制转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(-<span class="number">10</span>))         <span class="comment"># &#x27;-0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0o12&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">10</span>))          <span class="comment"># &#x27;0xa&#x27;</span></span><br><span class="line">a = <span class="number">0b1010</span></span><br><span class="line">b = <span class="number">0x11</span></span><br><span class="line">x = <span class="string">&#x27;1010&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;11&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)                <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(x, <span class="number">2</span>))        <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(b)                <span class="comment"># 17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(y, <span class="number">16</span>))       <span class="comment"># 17</span></span><br></pre></td></tr></table></figure><h3 id="2-11-加一减一"><a href="#2-11-加一减一" class="headerlink" title="2.11 加一减一"></a>2.11 加一减一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">n = -~n             <span class="comment"># +1</span></span><br><span class="line"><span class="built_in">print</span>(n)            <span class="comment"># 11</span></span><br><span class="line">n = ~-n             <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(n)            <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断两个数是否异号</span></span><br><span class="line">x, y = -<span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>((x^y)&lt;<span class="number">0</span>)          <span class="comment"># True</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>((x^y)&lt;<span class="number">0</span>)          <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3 常见题型"></a>3 常见题型</h2><h3 id="3-1-题库列表"><a href="#3-1-题库列表" class="headerlink" title="3.1 题库列表"></a>3.1 题库列表</h3><div style="text-align: center;"><table border="1" style="margin: auto；" width='60%'><tr><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/reverse-bits/" target="_blank">190. 颠倒二进制位</a></p></td><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/number-of-1-bits/" target="_blank">191. 位1的个数</a></p></td><td style="text-align: center;"><p><a href="https://leetcode.cn/problems/hamming-distance/" target="_blank">461. 汉明距离</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/missing-number/" target="_blank">268. 丢失的数字</a></p></td><td><p><a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字</a></p></td><td><p><a href="https://leetcode.cn/problems/single-number-ii/" target="_blank">137. 只出现一次的数字 II</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/single-number-iii/" target="_blank">260. 只出现一次的数字 III</a></p></td><td><p><a href="https://leetcode.cn/problems/power-of-two/" target="_blank">231. 2 的幂</a></p></td><td><p><a href="https://leetcode.cn/problems/counting-bits/" target="_blank">338. 比特位计数</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/sum-of-two-integers/" target="_blank">371. 两整数之和</a></p></td><td><p><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/" target="_blank">405. 数字转换为十六进制数</a></p></td><td><p><a href="https://leetcode.cn/problems/number-complement/" target="_blank">476. 数字的补数</a></p></td></tr><tr><td><p><a href="https://leetcode.cn/problems/total-hamming-distance/" target="_blank">477. 汉明距离总和</a></p></td><td><p><a href="https://leetcode.cn/problems/beautiful-arrangement/" target="_blank">526. 优美的排列</a></p></td><td><p><a href="https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/" target="_blank">1178. 猜字谜</a></p></td></tr></table></div><h3 id="3-2-真题演练"><a href="#3-2-真题演练" class="headerlink" title="3.2 真题演练"></a>3.2 真题演练</h3><p><strong>190. 颠倒二进制位</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        res = 0</span></span><br><span class="line"><span class="string">        for _ in range(32):</span></span><br><span class="line"><span class="string">            res = (res &lt;&lt; 1) | (n &amp; 1)</span></span><br><span class="line"><span class="string">            n &gt;&gt;= 1</span></span><br><span class="line"><span class="string">        return res</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p><strong>191. 位1的个数</strong><br>题目描述：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p><strong>1. 消除二进制末尾的 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>2. 右移 32 次</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            count += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>3. 库函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>461. 汉明距离</strong></p><p>题目描述：两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p><p><strong>1. 异或速解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x^y).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>2. 统计1的个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        z = x ^ y           <span class="comment"># 异或运算，二进制位不同的位置为1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> z:            <span class="comment"># 统计运算之后结果中 1 的个数</span></span><br><span class="line">            z = z &amp; (z-<span class="number">1</span>)   </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>3. 字符串解题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        bx, by = <span class="built_in">bin</span>(x)[<span class="number">2</span>:].zfill(<span class="number">32</span>), <span class="built_in">bin</span>(y)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> bx[i] != by[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>268. 丢失的数字</strong></p><p>题目描述：给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p>思路分析：以示例 1 为例 nums &#x3D; [3,0,1]，其长度为3，不难看出其不缺失的原数组为 [0, 1, 2, 3]。如果将nums与其原数组异或会发生什么呢？异或满足交互律 即 (a^b)^c &#x3D; a^(b^c)。我们不妨将其调整一下位置，即<br>nums    原数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   ^    <span class="number">0</span>     =&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   ^    <span class="number">1</span>     =&gt; <span class="number">0</span></span><br><span class="line">无 <span class="number">2</span> =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   ^    <span class="number">3</span>     =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所有一样的数全部异或之后成了0，最后所剩下的2与0异或即为本身，也就是所缺失的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  <span class="comment"># 此处 num 代表nums， i 代表原数组</span></span><br><span class="line">            ans ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> ans ^ <span class="built_in">len</span>(nums)          <span class="comment"># 因为原数组比nums长度多1, 所有这里多异或了一次</span></span><br></pre></td></tr></table></figure><p><strong>136. 只出现一次的数字</strong></p><p>题目描述：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p><ul><li>任何数和 0 做异或运算，结果仍然是原来的数，即 $a⊕0&#x3D;a$。</li><li>任何数和其自身做异或运算，结果是 0，即 $a⊕a&#x3D;0$。</li><li>异或运算满足交换律和结合律，即 $a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b$。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.6tbqu4dvz7w0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;异或运算&#x27;&#x27;&#x27;</span></span><br><span class="line">        re = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            re ^= num</span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure><p><strong>137. 只出现一次的数字 II</strong></p><p>题目描述：给你一个整数数组 nums，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/022.3jilsm2r0jg0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:’</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 数学运算</span></span><br><span class="line"><span class="string">        return (sum(set(nums))*3-sum(nums)) // 2</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):             <span class="comment"># nums[i] 是32位整数，</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span>                     <span class="comment"># 针对每一位的对应二进制数值求和</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="built_in">sum</span> += (num &gt;&gt; i) &amp; <span class="number">1</span>   <span class="comment"># 提取从右往左数第i位的数值，将所有nums[i], 二进制下的第i位数值进行求和</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">3</span> == <span class="number">1</span>:            <span class="comment"># 如果没办法被3整除，那么说明落单的那个数的第i位是 1 不是 0</span></span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i           <span class="comment"># 恢复第 i 位的值到 ans</span></span><br><span class="line">        <span class="keyword">return</span> ~(ans^<span class="number">0xffffffff</span>) <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">else</span> ans   <span class="comment"># 这里最后的sum是符号位，可以判断最后输出的数字是否是负数</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 由于 Python 的存储负数的特殊性，需要先将 0-32 位取反（即 <code>res^0xffffffff </code>），再将所有位取反（即 ~ ）。两个组合操作实质上是将数字 32 以上位取反，0-32位不变。</p><p><strong>260. 只出现一次的数字 III</strong></p><p>题目描述：给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        mask = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 异或运算，目的是找到两个落单数值的不同，便于后面分类</span></span><br><span class="line">            mask ^= num</span><br><span class="line">        mask  &amp;= (-mask)            <span class="comment"># 直接获取 mask 二进制表示的最低位的 1</span></span><br><span class="line">        type1, type2 = <span class="number">0</span>, <span class="number">0</span>         </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 把数组分为两部分，每部分再分别异或</span></span><br><span class="line">            <span class="keyword">if</span> mask &amp; num:          <span class="comment"># 对于 num，如果 mask 为1，分类为 type1，对这个 type1 进行异或，可以找到落单的数值</span></span><br><span class="line">                type1 ^= num</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 如果 num 的 mask 对应的是0，那么异或找到另一个落单的数值</span></span><br><span class="line">                type2 ^= num</span><br><span class="line">        <span class="keyword">return</span> [type1, type2] </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/023.27s42my22s9w.webp#pic_center" width = 36%><p><strong>231. 2 的幂</strong><br>题目描述：给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true；否则，返回 false。如果存在一个整数 x 使得 $n &#x3D;&#x3D; 2^x$ ，则认为 n 是 2 的幂次方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return n&gt;0 and n&amp;(-n)==n   </span></span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> n&amp;(n-<span class="number">1</span>)==<span class="number">0</span>   </span><br></pre></td></tr></table></figure><p><strong>338. 比特位计数</strong></p><p>题目描述：给你一个整数 $n$ ，对于 $0 &lt;&#x3D; i &lt;&#x3D; n$ 中的每个 $i$ ，计算其二进制表示中 1 的个数 ，返回一个长度为 $n + 1$ 的数组 ans 作为答案。</p><p>思路分析：对于正整数 $x$，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 $⌊\frac{x}{2}⌋$。如果 $bits[⌊\frac{x}{2}⌋]$ 的值已知，则可以得到 $bits[x]$ 的值：</p><ul><li>如果 $x$ 是偶数，则 $bits[x]&#x3D;bits[⌊\frac{x}{2}⌋]$；</li><li>如果 $x$ 是奇数，则 $bits[x]&#x3D;bits[⌊\frac{x}{2}⌋]+1$。</li></ul><p>上述两种情况可以合并成: $bits[x]$ 的值等于 $bits[⌊\frac{x}{2}⌋]$ 的值加上 $x$ 除以 2 的余数。由于$⌊\frac{x}{2}⌋$ 可以通过 $x &gt;&gt;1$ 得到，$x$ 除以 2 的余数可以通过 $x &amp; 1$ 得到，因此有: $bits[x] &#x3D; bits[x &gt;&gt; 1]+(x &amp; 1)$。</p><p>另一种思路：令 $y &#x3D; x &amp;(x —1)$，则 $y$ 为将 $x$ 的最低设置位从 1 变成 0 之后的数，显然 $0≤y&lt;x$, $bits[x]&#x3D; bits[y]＋+1$。因此对任意正整数 $x$，都有 $bits[x]&#x3D; bits[x &amp; (x-1)]+1$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 遍历与统计</span></span><br><span class="line"><span class="string">        return [bin(i).count(&#x27;1&#x27;) for i in range(n+1)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        ans = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            ans[i] = ans[i&gt;&gt;<span class="number">1</span>] + (i&amp;<span class="number">1</span>)      <span class="comment"># ans[i] = ans[i&amp;(i-1)]+1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>342. 4的幂</strong></p><p>题目描述：给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false。整数 n 是 4 的幂次方需满足：存在整数 x 使得 $n &#x3D;&#x3D; 4^x$</p><p>思路分析：如果 n 是 4 的幂，那么 n 一定也是 2 的幂。因此我们可以首先判断 n 是否是 2 的幂，在此基础上再判断 n 是否是 4 的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1，并且这个 1 出现在从低位开始的第偶数个二进制位上（这是因为这个 1 后面必须有偶数个0）。因此我们可以构造一个整数 mask，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。这样一来，我们将 n 和 mask 进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。</p><p>思路二：如果 n 是 4 的幂，可以发现它除以 3 的余数一定为 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return n &gt; 0 and n&amp;(n-1) == 0 and (n%3) == 1</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n&amp;(n-<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> (n&amp;<span class="number">0xaaaaaaaa</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>371. 两整数之和</strong></p><p>题目描述：给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSum</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mask1 = <span class="number">0xffffffff</span></span><br><span class="line">        a &amp;= mask1</span><br><span class="line">        b &amp;= mask1</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>        <span class="comment"># 将存在进位的位置置1</span></span><br><span class="line">            a ^= b                      <span class="comment"># 计算无进位的结果</span></span><br><span class="line">            b = carry</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt; <span class="number">0x80000000</span> <span class="keyword">else</span> ~(a^mask1)  <span class="comment"># 考虑负数时的输出</span></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/024.6nw71yc5zds0.webp#pic_center" width = 48%><p><strong>405. 数字转换为十六进制数</strong></p><p>题目描述：给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p><strong>1. 精简版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># return hex(num&amp;0xffffffff)[2:]       </span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;模拟法&#x27;&#x27;&#x27;</span></span><br><span class="line">        CONV = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            num = <span class="number">2</span> ** <span class="number">32</span> + num             </span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            num, res = <span class="built_in">divmod</span>(num, <span class="number">16</span>)</span><br><span class="line">            ans += CONV[res]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 详细版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        CONV = <span class="string">&quot;0123456789abcdef&quot;</span></span><br><span class="line">        ans = []    </span><br><span class="line">        <span class="comment"># 32位2进制数，转换成16进制 -&gt; 4个一组，一共八组</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="comment"># 当输入值num为-1 ，第一次进入循环</span></span><br><span class="line">            ans.append(num % <span class="number">16</span>)    <span class="comment"># num % 16 = 15</span></span><br><span class="line">            num //= <span class="number">16</span>              <span class="comment"># num // 16 = -1</span></span><br><span class="line">            <span class="comment"># Python中的//运算取整除：向下取接近商的整数</span></span><br><span class="line">            <span class="comment"># % 取模运算返回整除的余数 （余数 = 被除数 - 除数 * 商）</span></span><br><span class="line">            <span class="comment"># 负整数 // 正整数 的最大值为-1</span></span><br><span class="line">            <span class="comment"># -1 // 16 = -1</span></span><br><span class="line">            <span class="comment"># -1 % 16 = 15</span></span><br><span class="line">            <span class="comment"># 即如num为负数，则一定会跑满for的8次循环</span></span><br><span class="line">            <span class="comment"># 正整数 // 正整数 的最小值为0</span></span><br><span class="line">            <span class="comment"># 1 // 16 = 0</span></span><br><span class="line">            <span class="comment"># 1 % 16 = 1</span></span><br><span class="line">            <span class="comment"># 即num为正数时，有可能触发下面的if语句，提前结束for循环</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num:     <span class="comment"># 如果num不为0则继续下一次for循环</span></span><br><span class="line">                <span class="keyword">break</span>       <span class="comment"># 如果num为0则终止for循环</span></span><br><span class="line">            <span class="comment"># 正整数 // 负整数 的最大值为-1，如1 // -16 = -1; 1 % -16 = -15</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(CONV[n] <span class="keyword">for</span> n <span class="keyword">in</span> ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>476. 数字补数</strong></p><p>题目描述：对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。例如，整数 5 的二进制表示是 “101”，取反后得到 “010”，再转回十进制表示得到补数 2。给你一个整数 num ，输出它的补数。</p><p><strong>1. 与运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num &amp; <span class="number">1</span>):           <span class="comment"># 该位为0</span></span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>2. 异或运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_copy = num</span><br><span class="line">        num_1 = <span class="number">1</span>              </span><br><span class="line">        <span class="keyword">while</span> num_copy:</span><br><span class="line">            num_1 &lt;&lt;= <span class="number">1</span> </span><br><span class="line">            num_copy &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num ^ (num_1-<span class="number">1</span>)          <span class="comment"># num_1 二进制位数比num多一位，减1后与num二进制位数相同，且各位均为1</span></span><br></pre></td></tr></table></figure><p><strong>3. 遍历字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> bt <span class="keyword">in</span> <span class="built_in">bin</span>(num)[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> bt == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                result.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(result), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>477. 汉明距离的总和</strong><br>题目描述：两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。</p><p>对于某个 nums[i] 我们只关心在 nums 中有多少数的第 $x$ 位的与其不同，而不关心具体是哪些数与其不同，同时二进制表示中非 0 即 1。</p><p>这样我们可以建立两个集合 $s_0$ 和 $s_1$，分别统计出 nums 中所有数的第 $x$ 位中 0 的个数和 1 的个数，集合中的每次计数代表了 nums 中的某一元素，根据所在集合的不同代表了其第 $x$ 位的值。那么要找到在 nums 中有多少数与某一个数的第 $x$ 位不同，只需要读取另外一个集合的元素个数即可，变成了 $O(1)$ 操作。那么要求得「第 $x$ 位所有不同数」的对数的个数，只需要应用乘法原理，将两者元素个数相乘即可。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/025.2f84rabei5c0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalHammingDistance</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            temp = <span class="built_in">sum</span>((num &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line">            ans += temp * (<span class="built_in">len</span>(nums) - temp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>526. 优美的排列</strong></p><p>题目描述：假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：</p><ul><li>perm[i] 能够被 i 整除</li><li>i 能够被 perm[i] 整除</li></ul><p>给你一个整数 n ，返回可以构造的 优美排列 的 数量 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countArrangement</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        canFill = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j % i == <span class="number">0</span> <span class="keyword">or</span> i % j == <span class="number">0</span>:        <span class="comment"># 每个位置可以填入哪些数</span></span><br><span class="line">                    canFill[i].append(j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        order = <span class="built_in">sorted</span>(canFill.keys(), key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(canFill[x]))    <span class="comment"># 根据可填入数字的个数排序，优先填入个数少的</span></span><br><span class="line">        end = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">state</span>):</span><br><span class="line">            <span class="keyword">if</span> state == end:                    <span class="comment"># 全部填入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            cnts = ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):                  <span class="comment"># 当前该填第几个位置</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i) &amp; state:</span><br><span class="line">                    cnts += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> canFill[order[cnts]]:      <span class="comment"># 当前位置可以填哪些数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((<span class="number">1</span> &lt;&lt; i) &amp; state):      <span class="comment"># 哪些数还没被填</span></span><br><span class="line">                    ans += dfs(state ^ (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>1178. 猜字谜</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/026.7959elkbflg0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumOfValidWords</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], puzzles: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        frequency = collections.Counter()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(mask)).count(<span class="string">&quot;1&quot;</span>) &lt;= <span class="number">7</span>:</span><br><span class="line">                frequency[mask] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> puzzle <span class="keyword">in</span> puzzles:</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举子集方法一</span></span><br><span class="line">            <span class="comment"># for choose in range(1 &lt;&lt; 6):</span></span><br><span class="line">            <span class="comment">#     mask = 0</span></span><br><span class="line">            <span class="comment">#     for i in range(6):</span></span><br><span class="line">            <span class="comment">#         if choose &amp; (1 &lt;&lt; i):</span></span><br><span class="line">            <span class="comment">#             mask |= (1 &lt;&lt; (ord(puzzle[i + 1]) - ord(&quot;a&quot;)))</span></span><br><span class="line">            <span class="comment">#     mask |= (1 &lt;&lt; (ord(puzzle[0]) - ord(&quot;a&quot;)))</span></span><br><span class="line">            <span class="comment">#     if mask in frequency:</span></span><br><span class="line">            <span class="comment">#         total += frequency[mask]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举子集方法二</span></span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">            </span><br><span class="line">            subset = mask</span><br><span class="line">            <span class="keyword">while</span> subset:</span><br><span class="line">                s = subset | (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> frequency:</span><br><span class="line">                    total += frequency[s]</span><br><span class="line">                subset = (subset - <span class="number">1</span>) &amp; mask</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在枚举子集的过程中，要么会漏掉全集 mask，要么会漏掉空集</span></span><br><span class="line">            <span class="comment"># 这里会漏掉空集，因此需要额外判断空集</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))) <span class="keyword">in</span> frequency:</span><br><span class="line">                total += frequency[<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(puzzle[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))]</span><br><span class="line"></span><br><span class="line">            ans.append(total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>位运算和使用技巧暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/027.4jw2tcniyw80.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python位运算——左移操作（＜＜）右移操作＞＞：<a href="https://blog.csdn.net/qq_45769063/article/details/118618810">https://blog.csdn.net/qq_45769063&#x2F;article&#x2F;details&#x2F;118618810</a></li><li>Python异或运算：<a href="https://www.jianshu.com/p/ffa9fdf192a5">https://www.jianshu.com/p/ffa9fdf192a5</a></li><li>位运算技巧：<a href="https://www.zhihu.com/question/38206659">https://www.zhihu.com/question/38206659</a></li><li>位运算：<a href="http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting">http://graphics.stanford.edu/~seander&#x2F;bithacks.html#OperationCounting</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 二进制逆序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（十二）-- 树和二叉树</title>
      <link href="/article/48fcde60.html"/>
      <url>/article/48fcde60.html</url>
      
        <content type="html"><![CDATA[<p>终于学到了二叉树，LeetCode里面三分之一都是关于二叉树，俗话说打铁还需自身硬，本节学习树的基本概念，二叉树的实现、遍历、转换二叉树等。</p><span id="more"></span><h2 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1 树的概念"></a>1 树的概念</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 $n$（$n\geq 1$）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.7c11iupwauk0.webp#pic_center" width = 48%><h3 id="1-2-树的术语"><a href="#1-2-树的术语" class="headerlink" title="1.2 树的术语"></a>1.2 树的术语</h3><ul><li>节点的度：一个节点含有的子树的个数称为该节点的度；</li><li>树的度：一棵树中，最大的节点的度称为树的度；</li><li>叶节点或终端节点：度为零的节点；</li><li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li><li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li></ul><p>如下图，A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.7d6hue0pbm00.webp#pic_center" width = 48%><ul><li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>树的高度或深度：树中节点的最大层次；</li><li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li><li>节点的祖先：从根到该节点所经分支上的所有节点；</li><li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙；</li><li>森林：由 $m$（$m\geq 0$）棵互不相交的树的集合称为森林。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.5sez1y8lbt40.webp#pic_center" width = 48%><ul><li>深度：对于任意节点n, n 的深度为从根到 n 的唯一路径长，根的深度为0；</li><li>高度：对于任意节点n, n的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0；</li><li>结点的层次：规定根结点在1层，其它任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列 $n_1, n_2, \cdots, n_k, n_i$ 是 $n_{i+1}$ 的父结点。路径所包含边的个数为路径的长度。</li></ul><h3 id="1-3-树的种类"><a href="#1-3-树的种类" class="headerlink" title="1.3 树的种类"></a>1.3 树的种类</h3><ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li><li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul><li>二叉树：每个节点最多含有两个子树的树称为二叉树；<ul><li>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</li><li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li>排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</li></ul></li><li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li><li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li></ul></li></ul><p>用图片来展示什么是完全二叉树，请看下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.1b9h32y2iji8.webp#pic_center" width = 48%><p>下面这两棵树都是搜索树</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.5ku881wu4to0.webp#pic_center" width = 48%><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.5fiprv9i92w0.webp#pic_center" width = 48%><h4 id="1-4-树的存储和表示"><a href="#1-4-树的存储和表示" class="headerlink" title="1.4 树的存储和表示"></a>1.4 树的存储和表示</h4><p><strong>1. 链式存储法</strong></p><p>一种基于指针或者引用的二叉链式存储法，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。结构如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.6kxybgrn4pg0.webp#pic_center" width = 48%><p><strong>2. 顺序存储法</strong></p><p>顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。我们把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。即如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.vvpo3mca8g0.webp#pic_center" width = 48%><p>不过上图是一颗完全二叉树，所以数组仅仅浪费了下标为0的存储位置，如果是非完全二叉树，则可能会浪费比较多的数组内存空间。所以当要存储的树是一颗完全二叉树时，数组才是最合适的选择。所以，二叉树通常以链式存储。</p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2 二叉树"></a>2 二叉树</h2><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”(left subtree)和“右子树”(right subtree)。</p><h3 id="2-1-二叉树的性质"><a href="#2-1-二叉树的性质" class="headerlink" title="2.1 二叉树的性质"></a>2.1 二叉树的性质</h3><p><strong>1.层结点</strong><br>在二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点(i&gt;&#x3D;1)</p><p><strong>2.总结点</strong><br>深度为 $k$ 的二叉树最多有 $2^{k+1}-1$ 个结点(k&gt;&#x3D;1)</p><p><strong>3.深度</strong><br>具有 $n$ 个结点的完全二叉树的深度为 $\lfloor \log_{2}n \rfloor$</p><p><strong>4. 结点数</strong></p><p>对于任意一棵二叉树，度为 0 的结点数等于度为 2 的结点数 +1。</p><p><strong>5. 孩子结点</strong></p><p>对完全二叉树，若从上至下、从左至右编号，则编号为 $i$ 的结点，其左孩子编号必为 $2i$，其右孩子编号必为 $2i＋1$ ；其双亲的编号必为i&#x2F;2（i＝1 时为根，除外）</p><blockquote><p>完全二叉树————若设二叉树的高度为$h$，除第 $h$ 层外，其它各层 $(1~h-1)$ 的结点数都达到最大个数，第 $h$ 层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.1fabcfnlkitc.webp#pic_center" width = 48%><blockquote><p>满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.4pofeqgfk9s0.webp#pic_center" width = 48%><h3 id="2-2-二叉树的实现"><a href="#2-2-二叉树的实现" class="headerlink" title="2.2 二叉树的实现"></a>2.2 二叉树的实现</h3><p><strong>1. 列表实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/27</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 树的列表实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_tree</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">return</span> [r, [], []]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">root, new_branch</span>):</span><br><span class="line">    t = root.pop(<span class="number">1</span>)     <span class="comment"># 取出左子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:      <span class="comment"># 左子树已存在</span></span><br><span class="line">        root.insert(<span class="number">1</span>, [new_branch, t, []])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">1</span>, [new_branch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">root, new_branch</span>):</span><br><span class="line">    t = root.pop(<span class="number">2</span>)     <span class="comment"># 取出右子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:      <span class="comment"># 右子树已存在</span></span><br><span class="line">        root.insert(<span class="number">2</span>, [new_branch, [], t])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>, [new_branch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_root_val</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_root_val</span>(<span class="params">root, new_val</span>):</span><br><span class="line">    root[<span class="number">0</span>] = new_val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_left_child</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_right_child</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">r = binary_tree(<span class="number">3</span>)</span><br><span class="line">insert_left(r, <span class="number">4</span>)</span><br><span class="line">insert_left(r, <span class="number">5</span>)</span><br><span class="line">insert_right(r, <span class="number">6</span>)</span><br><span class="line">insert_right(r, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">l = get_left_child(r)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line">set_root_val(l, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line">insert_left(l, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(get_right_child(get_right_child(r)))</span><br></pre></td></tr></table></figure><p><strong>2. 链表实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_obj</span>):</span><br><span class="line">        self.key = root_obj</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">self, new_node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.left_child == <span class="literal">None</span>:</span><br><span class="line">            self.left_child = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(new_node)</span><br><span class="line">            t.left_child = self.left_child</span><br><span class="line">            self.left_child = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">self, new_node</span>):</span><br><span class="line">        <span class="keyword">if</span> self.right_child == <span class="literal">None</span>:</span><br><span class="line">            self.right_child = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(new_node)</span><br><span class="line">            t.right_child = self.right_child</span><br><span class="line">            self.right_child = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_right_child</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.right_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_left_child</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.left_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_root_val</span>(<span class="params">self, obj</span>):</span><br><span class="line">        self.key = obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root_val</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure><h3 id="2-3-二叉树的遍历"><a href="#2-3-二叉树的遍历" class="headerlink" title="2.3 二叉树的遍历"></a>2.3 二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p><ul><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ul><p>从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.46af021h4fo0.webp#pic_center" width = 48%><p>下面以LeetCode为例，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="2-3-1-前序遍历"><a href="#2-3-1-前序遍历" class="headerlink" title="2.3.1 前序遍历"></a>2.3.1 前序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5qei5gwywa80.webp#pic_center" width = 48%><ul><li>遍历顺序：根结点-&gt;左子树-&gt;右子树</li><li>动态图解：和上面的动态图一样，先序遍历就像一个小人从根结点开始，围绕二叉树的外圈开始跑（遇到缝隙就钻进去），按照跑的顺序，依次输出序列</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归实现</span></span><br><span class="line">        self.result = []                <span class="comment"># 使用布局变量存储结果</span></span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.result.append(root.val)    <span class="comment"># 前序</span></span><br><span class="line">        self.traverse(root.left)        <span class="comment"># 左</span></span><br><span class="line">        self.traverse(root.right)       <span class="comment"># 右</span></span><br></pre></td></tr></table></figure><p><strong>2. 迭代遍历</strong></p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.5m8n41fvngc0.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)         <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)    <span class="comment"># 右子树先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)     <span class="comment"># 左子树先入栈</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-3-2-中序遍历"><a href="#2-3-2-中序遍历" class="headerlink" title="2.3.2 中序遍历"></a>2.3.2 中序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.zoh9hj3411s.webp#pic_center" width = 48%><ul><li>遍历顺序：左子树-&gt;根结点-&gt;右子树</li><li>动态图解：中序遍历就像投影仪一样，将二叉树从最左侧到最右侧依次投影到同一水平线上面，得到的从左到右的相关序列就是二叉树的中序遍历</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.result = []</span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        self.traversal(root.left)               <span class="comment"># 前</span></span><br><span class="line">        self.result.append(root.val)            <span class="comment"># 中</span></span><br><span class="line">        self.traversal(root.right)              <span class="comment"># 后</span></span><br></pre></td></tr></table></figure><p><strong>2. 顺序遍历</strong></p><p>分析一下为什么前面写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.a7oiu182jww.gif#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = []                      <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:         </span><br><span class="line">            <span class="keyword">if</span> cur:                     <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 到达最左节点后处理栈顶结点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                cur = cur.right         <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-3-3-后序遍历"><a href="#2-3-3-后序遍历" class="headerlink" title="2.3.3 后序遍历"></a>2.3.3 后序遍历</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.4w5738j4umi0.webp#pic_center" width = 48%><ul><li>遍历顺序：左子树-&gt;右子树-&gt;根结点</li><li>动态图解： 后序遍历也是按照先序遍历的顺序输出，不过后序遍历就像剪葡萄，只能一个个剪，不能让超过1个的葡萄一起掉下来，那就错了。例如上图中的 B，剪去 B 后面的 D、E、H、I、J 都会掉下来，而 H 剪去只会掉下 H，规律就是这个规律</li></ul><p><strong>1. 递归遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.result = []</span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.traversal(root.left)               <span class="comment"># 左</span></span><br><span class="line">        self.traversal(root.right)              <span class="comment"># 右</span></span><br><span class="line">        self.result.append(root.val)            <span class="comment"># 中</span></span><br></pre></td></tr></table></figure><p><strong>2. 顺序遍历</strong></p><p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.6ln5rgj5w0w0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 迭代遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)                     <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)       <span class="comment"># 左子树先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)     <span class="comment"># 右子树后入栈</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]                             <span class="comment"># 将最终数组反转</span></span><br></pre></td></tr></table></figure><h4 id="2-3-4-层序遍历"><a href="#2-3-4-层序遍历" class="headerlink" title="2.3.4 层序遍历"></a>2.3.4 层序遍历</h4><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.5in2a4wgs600.gif#pic_center" width = 36%><p><strong>1. 迭代法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">        <span class="comment"># 二叉树层序遍历迭代解法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        results = []</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):       <span class="comment"># 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的</span></span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><p><strong>2. 递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 递归法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.res = []</span><br><span class="line">        self.helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], depth</span>) -&gt; <span class="type">Optional</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.res) == depth: self.res.append([])</span><br><span class="line">        self.res[depth].append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.left: self.helper(root.left, depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right: self.helper(root.right, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>二叉树基础部分已整理完毕，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.32u2n6vhr4o0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>树结构详解：<a href="http://c.biancheng.net/data_structure/tree/">http://c.biancheng.net/data_structure&#x2F;tree&#x2F;</a></li><li>树和二叉树全面总结：<a href="https://juejin.cn/post/7065513748789723150">https://juejin.cn/post/7065513748789723150</a></li><li>数据结构与算法————二叉树：<a href="https://www.cnblogs.com/jasonbourne3/p/17143620.html">https://www.cnblogs.com/jasonbourne3/p/17143620.html</a></li><li>二叉树入门和刷题：<a href="https://zhuanlan.zhihu.com/p/136758152">https://zhuanlan.zhihu.com/p/136758152</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（十一）-- 链表的应用与常见题型</title>
      <link href="/article/ae2fd3ce.html"/>
      <url>/article/ae2fd3ce.html</url>
      
        <content type="html"><![CDATA[<p>本篇信息量巨大，首先对比链表和数组，接着解决单链表的反转、删除某一节点、插入数据、查找中间节点、求倒数第k个结点、对称链表、单链表是否有环、两个链表是否相交，最后用LeetCode上的真题来实战删除链表结点、反转链表、合并、排序、环形链表常用技巧。</p><span id="more"></span><p>这一部分的内容，前面的大佬总结的挺多，这里进行汇总，方便和大家一起学习和回顾，欢迎大家继续补充。</p><h2 id="1-链表和数组"><a href="#1-链表和数组" class="headerlink" title="1 链表和数组"></a>1 链表和数组</h2><p>作为线性表的两种存储方式————链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。</p><p>数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。</p><p>但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 $O(n)$。增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/001.22jcviirxk5c.gif#pic_center" width = 48%><p>删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/002.60mgplwxlw40.gif#pic_center" width = 48%><p> <strong>总结一下数组的优缺点：</strong></p><ul><li>优点：可以根据偏移实现快速的随机读写。</li><li>缺点：扩容，增删元素极慢。</li></ul><p>上面对数组增删元素的操作表明使用数组需要注意的东西真的很多很多，这样一来，我们就开始说说链表，链表也是一种数据结构，它弥补了数组带来的诸多不便，让我们可以任意为一些数据进行空间的分配，根据需要进行内存单元的开辟。</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，由若干个结点组成，在每一个结点里存到下一个结点的指针(Next)。采用动态分配存储单元方式。它能够有效地节省存储空间（同数组比较）。结点结构如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/003.35g0aiddrry0.webp#pic_center" width = 48%><p>一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/004.55ls7z5t19g0.webp#pic_center" width = 48%><p>对于链表而言，分为静态链表和动态链表，根据处理数据的方向又分为单向链表和双向链表。对于链表的更多操作，请阅读 <a href="https://blog.csdn.net/xq151750111/article/details/129130524?spm=1001.2014.3001.5501">Python数据结构与算法篇（四）– 链表的实现</a></p><p><strong>小结：</strong> 从本质上来讲，<font color=#9900CC><strong>链表与数组的确有相似之处，他们的相同点是都是线性数据结构，这与树和图不同，而它们的不同之处在于数组是一块连续的内存，而链表可以不是连续内存，链表的节点与节点之间通过指针来联系。</font></strong></p><hr><h2 id="2-常见链表问题解决思路"><a href="#2-常见链表问题解决思路" class="headerlink" title="2 常见链表问题解决思路"></a>2 常见链表问题解决思路</h2><h3 id="2-1-单链表的反转"><a href="#2-1-单链表的反转" class="headerlink" title="2.1 单链表的反转"></a>2.1 单链表的反转</h3><p><strong>方法一：头插法（迭代法）</strong><br>算法思想：&#x3D;&#x3D;逆置链表初始为空，表中节点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），&#x3D;&#x3D; 使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空。</p><p><strong>方法二：递归法：</strong><br>算法思想：从后向前改变指向，可以理解成向后的箭头变成了向前的箭头</p><p><strong>方法三：三指针法</strong><br>算法思想：从前向后改变指向，可以理解成向后的箭头变成了向前的箭头</p><h3 id="2-2-单链表的删除某一结点"><a href="#2-2-单链表的删除某一结点" class="headerlink" title="2.2 单链表的删除某一结点"></a>2.2 单链表的删除某一结点</h3><p><strong>方法一：遍历</strong><br>思路：查找到所要删除的节点，以及其前驱节点，让其前驱节点，指向其后继节点</p><p><strong>方法二：置换法（移花接木）</strong><br>思路：明确要删除的节点后，把其后继节点复制到该节点上，然后删除那个后继节点，也等于变相的删除节点（注意如果删除的是尾节点 删除的链表只有一个节点）</p><h3 id="2-3-在当前节点前插入一个数据"><a href="#2-3-在当前节点前插入一个数据" class="headerlink" title="2.3 在当前节点前插入一个数据"></a>2.3 在当前节点前插入一个数据</h3><p><strong>方法一：遍历</strong><br>思路：找出当前结点的前驱节点，完成插入；</p><p><strong>方法二：置换法</strong><br>思路：把插入节点的数据放到新节点上，把新节点的数据放到插入节点的数据上，这样我们就可以实现在当前节点前插入一个节点了。</p><h3 id="2-4-查找链表的中间结点"><a href="#2-4-查找链表的中间结点" class="headerlink" title="2.4 查找链表的中间结点"></a>2.4 查找链表的中间结点</h3><p><strong>快慢指针法</strong><br>思路：给一个快指针，让快指针每次移动两步，给一个慢指针，让慢指针每次移动一步，最后结果就是快指针移动到最后一个节点，慢指针最后移动到了中间的节点上。</p><p>设有两个指针 fast 和 slow，&#x3D;&#x3D;初始时指向头节点&#x3D;&#x3D;。每次移动时，fast 向后走两次，slow 向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n&#x2F;2 轮。&#x3D;&#x3D;当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠后一个。&#x3D;&#x3D;</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/005.6wtkyvc1a1g0.webp#pic_center" width = 48%><h3 id="2-5-单链表的倒数第k个结点"><a href="#2-5-单链表的倒数第k个结点" class="headerlink" title="2.5 单链表的倒数第k个结点"></a>2.5 单链表的倒数第k个结点</h3><p><strong>方法一：正数转换法</strong><br>思路：遍历一遍单链表，记录单链表的长度，倒数第k个，即正数 length-k+1 个，在重头遍历一次便能够找到</p><p><strong>方法二：快慢指针法</strong><br>思路：一个指针先走k步，然后两个指针同时走，当先走的那个指针指向空的时候，后面的指针所指即为倒数第K个节点。</p><p>设有两个指针 p 和 q，&#x3D;&#x3D;初始时均指向头结点&#x3D;&#x3D;。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1 个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/006.4g7u9ztqez20.webp#pic_center" width = 48%><h3 id="2-6-对称单链表"><a href="#2-6-对称单链表" class="headerlink" title="2.6 对称单链表"></a>2.6 对称单链表</h3><p><strong>1. 知道链表的长度</strong><br>思路：根据对称来确定两个指针的位置，对所指向的元素进行判断，不断前进指针</p><p><strong>2. 链表长度未知</strong><br>思路1：将前一半的节点压入栈中，并将当前节点继续遍历，每遍历一个都与栈弹出的节点相比较，若不同则不是。额外空间复杂度 O(N&#x2F;2)。</p><p>思路2：不使用辅助空间 两个指针，一个指向头 first，指向头的后继节点 last；first 走一步，last走两步；直到 last 为空或 last 的后继节点为空，此时 first 指向（链表长度为奇数，指向中间；为偶数，指向一半）；然后 fisrt 向后走，再申请一个节点指向头，不断进行比较，直到 first 指向空。</p><h3 id="2-7-单链表是否有环"><a href="#2-7-单链表是否有环" class="headerlink" title="2.7 单链表是否有环"></a>2.7 单链表是否有环</h3><p><strong>方法一：map表法</strong><br>算法思想：每走一步将走过的节点使用map表存储起来，当遇到第一个在map中存在的节点时，就说明回到了出发点，即链表有环，同时也找到了环的入口。</p><p><strong>方法二：快慢指针法</strong><br>算法思想：一个指针走两步；一个指针走一步；如果存在环，两个指针最终会指向同一个元素；如果不存在环，走两步的会最终走向空节点。</p><p>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/007.2t8k9zey8280.gif#pic_center" width = 24%><p><strong>确定有环后求环的长度</strong></p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/008.safh0w2cugw.webp#pic_left" width = "45%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/009.580tqn3izyk0.webp#pic_left"  width = "50%"></center></p><p>通过公式的推导我们发现 $L&#x3D;kc-n$（这里的 $k$ 是倍数，有可能快指针在环里转了 $k$ 圈），即<font color=#9900CC><strong>相遇节点到入环点的距离等于链表的头到入环点的距离</font></strong>。写代码的时候只需要找到相遇节点，再让一个指针从头开始走即可。</p><h3 id="2-8-判断两个链表是否相交"><a href="#2-8-判断两个链表是否相交" class="headerlink" title="2.8 判断两个链表是否相交"></a>2.8 判断两个链表是否相交</h3><p><strong>1. 相交则求交点（链表不带环）</strong><br>思路：若两个不带环的链表相交，则他们的尾节点必相同；若要求交点，则需要比较两个链表的长度，让较长的链表先向后遍历至和较短的链表长度相等，然后两个链表同时向后遍历，并比较节点是否相同，当遇到第一个相同的节点时，则为两个链表的交点。</p><p><strong>2. 相交则求交点（链表可能带环）</strong><br>情况分析：<br>若有两个链表，则他们的带环情况有以下三种可能：<br>（1）两个链表都不带环<br>直接采用上述思路即可；<br>（2）一个链表带环一个链表不带环<br>必定不想交；<br>（3）两个链表都带环<br>下面详细讨论：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/010.6rl0uys7mkc0.webp#pic_center" width = 48%><ul><li>当出现①情况时，两个链表不相交。</li><li>当出现②情况时，两个链表的交点在环外，那么我们可以转化为不带环链表判断相交即可。</li><li>当出现③情况时，两个链表的交点在环内，那么我们可以遍历其中一个链表的环，若在环内与另一个链表环的入口点相交，则两个链表相交，相遇点即为两个链表的交点。</li><li>要判断为情况②还是情况③，只需判断两个链表环的入口点是否相同即可。</li></ul><p><strong>链表的 <code>.next</code> 指向问题</strong></p><p>如果放在左边就表示是自己的指向，如果放在右边就表示是它的下一个节点。类似于代码中的这三行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="built_in">next</span> = head.<span class="built_in">next</span>;</span><br><span class="line">head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">node.<span class="built_in">next</span>.<span class="built_in">next</span> = head;</span><br></pre></td></tr></table></figure><p>这种就代表等号左边指向右边，左边的是指向，右边就代表确切的下一个节点。</p><p>如果类似于后两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = node.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">head = head.<span class="built_in">next</span>;</span><br></pre></td></tr></table></figure><p>像这样，左边不带 <code>.next</code> 的是类似于赋值语句，自己的指针指向右边位置。</p><hr><h2 id="3-LeetCode"><a href="#3-LeetCode" class="headerlink" title="3 LeetCode"></a>3 LeetCode</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/011.394jgp0avbs0.webp#pic_center" width = 100%><p>俗话说一图胜千言，接下来主要通过图片展示解决思路，通过代码展示实现的细节。</p><h3 id="3-1-删除结点"><a href="#3-1-删除结点" class="headerlink" title="3.1 删除结点"></a>3.1 删除结点</h3><h4 id="3-1-1-题解方法"><a href="#3-1-1-题解方法" class="headerlink" title="3.1.1 题解方法"></a>3.1.1 题解方法</h4><p> <strong>1. 画草图：</strong> 理解指针的变动与思考逻辑！！(重要！实用！)<br> <strong>2. 边界条件：</strong> 怎么处理不会有空指针异常？在循环里放什么停止条件</p><blockquote><ul><li>如果是遍历链表元素，<code>while(node!=null)</code> </li><li>如果是删除某个元素，需要，<code>while(node.next!=null)</code></li><li>需要考虑的仅仅是被改变 next 指针的部分，并且循环之后哪个指针在最后的节点处，就判断谁</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如快慢指针，输出中间节点，slow 和 fast 的指针都在变，但是 fast 先指向链表尾巴，所以判断 fast</span></span><br><span class="line"><span class="comment"># 同时每个判断 next.next 的都必须先判断，next，才能保证 奇偶链长 中不会出现空指针异常</span></span><br><span class="line"><span class="keyword">while</span>(fast.<span class="built_in">next</span>!=null &amp;&amp; fast.<span class="built_in">next</span>.<span class="built_in">next</span>!=null)&#123;</span><br><span class="line">            slow = slow.<span class="built_in">next</span>;</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><font color=#9900CC><strong>3. 只要会删除头结点，都要进行 dummy虚指针，有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性</font></strong><br><strong>4. 特殊的需求可以考虑结合各种工具类，比如删除重复里面，利用HashSet，删除倒数第k个，利用栈LinkedList</strong></p><h4 id="1-3-2-可能出现的问题"><a href="#1-3-2-可能出现的问题" class="headerlink" title="1.3.2 可能出现的问题"></a>1.3.2 可能出现的问题</h4><p>① NullPointerException，就是当前节点为空，我们还去操作它的 next；<br>② 输出不了结果，一定是指针移动出了问题</p><h4 id="1-3-3-题库列表"><a href="#1-3-3-题库列表" class="headerlink" title="1.3.3 题库列表"></a>1.3.3 题库列表</h4><blockquote>  <p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank">237. 删除链表中的节点</a> ====<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank">面试题 02.03. 删除中间节点</a></p>  <p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank">203. 移除链表元素</a>（虚拟头结点）</p>  <ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank">剑指 Offer 18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank">面试题 02.01. 移除重复节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank">82. 删除排序链表中的重复元素 II</a></li></ul>  <p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank">19. 删除链表的倒数第 N 个结点</a>（双指针经典类型）</p>  <ul><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank">876. 链表的中间结点</a></li><li><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank">328. 奇偶链表</a></li></ul> </blockquote><p><strong>237. 删除链表中的节点</strong></p><p>题目描述：给你一个需要删除的节点 node，但无法访问 第一个节点  head。链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 题目说 node 不是链表中最后一个结点，直接将当前节点的值改为next的值，next指向next.next，实现原地更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>203. 移除链表元素</strong></p><p>题目描述：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><blockquote><p>① 如果删除的节点是中间的节点，则问题似乎非常简单： </p><ul><li>选择要删除节点的前一个结点 prev。 </li><li>将 prev 的 next 设置为要删除结点的 next。</li></ul><p>② 当要删除的一个或多个节点位于链表的头部时，要另外处理</p></blockquote><p><strong>三种方法：</strong></p><blockquote><ul><li>删除头结点时另做考虑（由于头结点没有前一个结点） </li><li>添加一个虚拟头结点，删除头结点就不用另做考虑 </li><li>递归 </li><li>双指针法</li></ul></blockquote><p><strong>1. 对头结点单独考虑</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:<span class="comment"># 找到指定元素</span></span><br><span class="line">                <span class="keyword">if</span> prev:<span class="comment"># 不是头结点</span></span><br><span class="line">                    prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span><span class="comment"># 将删除位置的前一个节点的next指向删除位置的后一个结点</span></span><br><span class="line">                <span class="keyword">else</span>:<span class="comment"># 如果第一个就是删除结点</span></span><br><span class="line">                    head = cur.<span class="built_in">next</span><span class="comment"># 将头指针指向头节点的后一个结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/012.5hja7yiu0cw0.gif#pic_center" width = 48%><p><strong>2. 添加一个虚拟头结点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)<span class="comment"># 创建虚结点</span></span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> prev <span class="keyword">and</span> prev.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> prev.<span class="built_in">next</span>.val == val:</span><br><span class="line">                prev.<span class="built_in">next</span> = prev.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/013.3b5w9nrdkj80.webp#pic_center" width = 48%><p><strong>3. 递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 因为递归函数返回的是已经删除节点之后的头结点</span></span><br><span class="line">        <span class="comment"># 所以直接接上在 head.next，最后就只剩下判断头结点是否与需要删除的值一致了</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.removeElements(head.<span class="built_in">next</span>, val)</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/014.r3e3eix9ae.gif#pic_center" width = 48%><p><strong>83. 删除排序链表中的重复元素</strong></p><p>题目描述：给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curr = head     <span class="comment"># 指针节点，这里不会删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:<span class="comment"># 如果两个结点元素值相同，则执行删除</span></span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/015.1z3s9s43bvi8.gif#pic_center" width = 36%><p>题目解法并不唯一，可以使用递归、双指针、虚拟头结点、栈的方法，详细了解可以阅读：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/342300/83-shan-chu-pai-xu-lian-biao-zhong-de-zhong-fu-21/?orderBy=most_votes">删除排序链表中的重复元素（五种方法）</a></p><p><strong>剑指 Offer 18. 删除链表的节点</strong></p><p>题目描述：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head.val == val:             <span class="comment"># 如果头指针相等，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        prev, cur = head, head.<span class="built_in">next</span>     <span class="comment"># 双指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur <span class="keyword">and</span> cur.val != val): <span class="comment"># 找元素</span></span><br><span class="line">            prev, cur = cur, cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur:                         <span class="comment"># 找到了，进行删除</span></span><br><span class="line">            prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span>        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong>  这里既可以添加虚拟头结点，也可以先判断第一个结点是否满足条件，第二种方法更快，这里就采用先判断再循环的方式。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/016.48py8rnrn6g0.webp#pic_center" width = 48%><p><strong>面试题 02.01. 移除重复节点</strong></p><p>题目描述：移除未排序链表中的重复节点。保留最开始出现的节点，由于未排序，重复的元素不一定连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head<span class="comment"># 初始化 pre, cur 节点引用（指针）</span></span><br><span class="line">        visited = <span class="built_in">set</span>()<span class="comment"># 初始化 set 用于保存节点值</span></span><br><span class="line">        <span class="keyword">while</span> cur:<span class="comment"># 遍历链表 </span></span><br><span class="line">            <span class="keyword">if</span> cur.val <span class="keyword">in</span> visited:<span class="comment"># 若节点值 cur.val 在 set 中</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span><span class="comment"># 删除节点 cur</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 若节点值 cur.val 不在 set 中</span></span><br><span class="line">                visited.add(cur.val)<span class="comment"># 将 cur.val 添加进 set</span></span><br><span class="line">                pre = cur<span class="comment"># 令 pre 指向 cur ，作为下一轮的前驱节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span><span class="comment"># 遍历下一节点</span></span><br><span class="line">        <span class="keyword">return</span> head<span class="comment"># 删除完成，返回链表头节点 head</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/017.72m13v2o2rg0.gif#pic_center" width = 48%><p><strong>82. 删除排序链表中的重复元素 II</strong></p><p>题目描述：给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;双指针记录 pre 用 cur 记录相同的数，加虚头节点&#x27;&#x27;&#x27;</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        prev, curr = dummy, dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:<span class="comment"># 如果有奇数个相同的值，就删不完，所以必须用 while 循环</span></span><br><span class="line">                    curr = curr.<span class="built_in">next</span>        <span class="comment"># 找到最后一个相等的数</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/018.8oxo1amj9zc.gif#pic_center" width = 48%><p><strong>19、删除链表的倒数第 N 个结点</strong></p><p>题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>1. 快慢指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        fast = dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 快指针先走n步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = dummy</span><br><span class="line">        <span class="keyword">while</span> fast:<span class="comment"># 快慢指针同时走，直到 fast 指针到达尾部节点，此时 slow 到达倒数第 N 个节点的前一个节点</span></span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 删除节点，并重新连接</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/019.401fcoye5po0.gif#pic_center" width = 48%><p><strong>2. 循环迭代 – 找到 length -n 个节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        cur, length = head, <span class="number">0</span> <span class="comment"># step1: 获取链表长度</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">        cur = dummy <span class="comment"># step2: 找到倒数第N个节点的前面一个节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length - n):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># step3: 删除节点，并重新连接</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><strong>3. 递归迭代 – 回溯时，进行节点计数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: </span><br><span class="line">            self.count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> head  </span><br><span class="line">        head.<span class="built_in">next</span> = self.removeNthFromEnd(head.<span class="built_in">next</span>, n) <span class="comment"># 递归调用</span></span><br><span class="line">        self.count += <span class="number">1</span> <span class="comment"># 回溯时进行节点计数</span></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span> <span class="keyword">if</span> self.count == n <span class="keyword">else</span> head </span><br></pre></td></tr></table></figure><p><strong>876、链表的中间结点</strong></p><p>题目描述：给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p><p>（1）若为奇数，指向中间的结点，若为偶数，指向中间靠后的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 如果不加 fast，链表元素个数为偶数时会报空指针异常；</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/020.4aza639wrhw0.webp#pic_center" width = 48%><p>（2）若为奇数，指向中间的结点，若为偶数，指向中间靠前的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/021.5096s37l9ow0.gif#pic_center" width = 48%><p><strong>86、分隔链表（两个临时链表）</strong></p><p>题目描述：给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)<span class="comment"># dummy1 存放小于x链表的虚拟头结点，dummy2存放不小于x的虚拟头结点</span></span><br><span class="line">        p, p1, p2 = head, dummy1, dummy2<span class="comment">#  p 负责遍历链表，类似合并两个有序链表的逻辑；p1, p2 指针负责生成结果链表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p </span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            temp = p.<span class="built_in">next</span><span class="comment"># 断开原链表中的每个结点的 next 指针</span></span><br><span class="line">            p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            p = temp</span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span><span class="comment"># 合并两个链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/022.2705dkyftrgg.webp#pic_center" width = 48%><p>这里为什么需要断开 next？</p><p>如果不断开直接 <code>p = p.next</code>，p 是正常往下走了，但是其中有个问题就是会陷入无限循环。以本题为例，由于14325的5在被p2连起来之后，其由于指向 p，因此 <code>p.next</code> 也是被继承过来的，所以后面是2，而 p 直接等于 <code>p.next</code> 后判断为2后，就直接加到 p1 后面了。现在问题就是 p1 中的 第一个2 指向的 第二个2 和 p2 中的 5 指向的 2 是一个指针(地址)，不把他们俩合并还好说，一旦合并，就成了 下图所示.的<code>1--&gt;2--&gt;2--&gt;4--&gt;3--&gt;5--&gt;2|--&gt;4--&gt;3--&gt;5--&gt;2|--&gt;4--&gt;...</code>，看出来了吗？形成了一个环了！</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/023.2ow0749423q0.webp#pic_center" width = 48%><p>因此在每步的赋值结束后，应当对next清除，以防止在最后的时候陷入这种无限循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 断开原链表中的每个结点的 next 指针</span></span><br><span class="line">temp = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span> = <span class="literal">None</span>   </span><br><span class="line">p = temp</span><br></pre></td></tr></table></figure><p>或者，如果不想每个都断开，其实在 p 往下走的时候，每个 p1 和 p2 的 next 都在同时进行着更新，因此只有 p2 的最后一个是存在问题的，因此也可以加一句 <code>p2.next = None</code> 来解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># dummy1 存放小于x链表的虚拟头结点， 度没有 存放不小于x的虚拟头结点</span></span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># p1, p2 指针负责生成结果链表</span></span><br><span class="line">        p1, p2 = dummy1, dummy2</span><br><span class="line">        <span class="comment"># p 负责遍历链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">        <span class="comment"># 这里是将两个链表分解成两个链表</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p </span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 合并两个链表</span></span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>328. 奇偶链表</strong></p><p>题目描述：给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。&#x3D;&#x3D;这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy1, dummy2 = ListNode(-<span class="number">1</span>), ListNode(-<span class="number">1</span>)</span><br><span class="line">        p, p1, p2 = head, dummy1, dummy2</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                p1.<span class="built_in">next</span> = p</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.<span class="built_in">next</span> = p</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            temp = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            p = temp</span><br><span class="line">        p1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/024.4donvqjwj440.gif#pic_center" width = 48%><h3 id="3-2-反转链表"><a href="#3-2-反转链表" class="headerlink" title="3.2 反转链表"></a>3.2 反转链表</h3><h4 id="3-2-1-题库列表"><a href="#3-2-1-题库列表" class="headerlink" title="3.2.1 题库列表"></a>3.2.1 题库列表</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank">206. 反转链表</a>====<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank">剑指 Offer 24. 反转链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank">92. 反转链表 II</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank">234. 回文链表</a>====<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank">面试题 02.06. 回文链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank">25. K 个一组翻转链表</a></p></blockquote> <p><strong>206、反转链表</strong><br>题目描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>1. 双指针法迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev, cur = <span class="literal">None</span>, head<span class="comment"># 申请两个节点，pre和 cur，pre指向None</span></span><br><span class="line">        <span class="keyword">while</span> cur:<span class="comment"># 遍历链表</span></span><br><span class="line">            temp = cur.<span class="built_in">next</span><span class="comment"># 记录当前节点的下一个节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev<span class="comment"># 然后将当前节点指向pre</span></span><br><span class="line">            prev = cur<span class="comment"># pre和cur节点都前进一位</span></span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/025.6glhs7jiai00.webp#pic_center" width = 48%><p><strong>2. 尾递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># reverse_head 表示 head.next 后面一整段反转之后的头结点，所以最后return reverse_head</span></span><br><span class="line">        reverse_head = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head<span class="comment"># 此时 head.next 指向的已经是反转部分的尾巴</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span><span class="comment"># head 指向 None，表示此时 head 已经是尾巴了</span></span><br><span class="line">        <span class="keyword">return</span> reverse_head</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/026.2al8hft9no74.webp#pic_center" width = 48%><p><strong>92. 反转链表 II</strong></p><p>题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span>  head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):     <span class="comment"># 迭代法，先找到起点</span></span><br><span class="line">            prev= prev.<span class="built_in">next</span>         <span class="comment"># 来到 left 节点的前一个节点</span></span><br><span class="line">        curr = prev.<span class="built_in">next</span>            <span class="comment"># cur 是真正反转的指针</span></span><br><span class="line">        tail = curr</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right-left+<span class="number">1</span>):</span><br><span class="line">            node = curr.<span class="built_in">next</span>        <span class="comment"># node 保存 curr.next 的临时指针，保存后面的顺序</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span>   <span class="comment"># 将要反转的节点，接入到 left 节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = curr        </span><br><span class="line">            tail.<span class="built_in">next</span> = node</span><br><span class="line">            curr = node</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/027.6yezj4cz5100.gif#pic_center" width = 48%><p><strong>234. 回文链表</strong></p><p>题目描述：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br><strong>1. 数组模拟</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        prev, val_list = head, []</span><br><span class="line">        <span class="keyword">while</span> prev:</span><br><span class="line">            val_list.append(prev.val)</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> val_list == val_list[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 维持半条翻转链表（双指针）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        p, slow, fast = head, head, head<span class="comment"># p 存储前半段的尾结点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:   <span class="comment"># 快慢指针找到中间节点</span></span><br><span class="line">            p = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        left, right = head, self.reverse_list(slow)     <span class="comment"># 额外维持的半条链表；反转 slow 后面的元素</span></span><br><span class="line">        q = right<span class="comment"># 存储末尾的断点用于恢复原来链表的顺序</span></span><br><span class="line">        <span class="keyword">while</span> right:                                    <span class="comment"># 两个半长链表的比较 遍历两个 半长链表</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = self.reverse_list(q)<span class="comment"># 还原链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_list</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">        prev, curr = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            node = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = node</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p> <strong>温馨提示：</strong> 比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。可以记录前半段的尾结点，将后半部分翻转之后在比较完成之后再次翻转，再让前半段的尾结点指向两次翻转的后半部分即可还原链表。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/028.35rx78p4hwo0.gif#pic_center" width = 48%><p><strong>25. K 个一组翻转链表</strong></p><p>题目描述：给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br><strong>1. 模拟法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> k== <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev1, prev2, curr = dummy, dummy, dummy.<span class="built_in">next</span></span><br><span class="line">        count = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> prev1:        <span class="comment"># 查找节点个数</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            prev1 = prev1.<span class="built_in">next</span></span><br><span class="line">        tail = curr</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count//k):<span class="comment"># K个一组反转</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                prev2 = tail</span><br><span class="line">                tail = curr</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                temp = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev2.<span class="built_in">next</span></span><br><span class="line">                prev2.<span class="built_in">next</span> = curr</span><br><span class="line">                tail.<span class="built_in">next</span> = temp</span><br><span class="line">                curr = temp</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/029.6bao5ag72a80.gif#pic_center" width = 48%><h3 id="3-3-合并链表"><a href="#3-3-合并链表" class="headerlink" title="3.3  合并链表"></a>3.3  合并链表</h3><h4 id="3-3-1-题库列表"><a href="#3-3-1-题库列表" class="headerlink" title="3.3.1 题库列表"></a>3.3.1 题库列表</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank">21. 合并两个有序链表</a></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank">23. 合并K个升序链表</a></p></blockquote> <p><strong>21. 合并两个有序链表</strong><br>题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/030.7ky8cjucdmk0.gif#pic_center" width = 48%><p><strong>23. 合并K个升序链表</strong></p><p>题目描述：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>1. 顺序合并</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> lists[<span class="number">1</span>:]:</span><br><span class="line">            head = self.mergeTwoLists(head, item)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>2. 分治合并</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        n = <span class="built_in">len</span>(lists)                          <span class="comment"># 记录子链表数量</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(lists, <span class="number">0</span>, n - <span class="number">1</span>)  <span class="comment"># 调用归并排序函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode], l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> lists[l]</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        L = self.mergeSort(lists, l, m)         <span class="comment"># 循环的递归部分</span></span><br><span class="line">        R = self.mergeSort(lists, m + <span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(L, R)         <span class="comment"># 调用两链表合并函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">        prev = prehead          <span class="comment"># 指针节点</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/031.510611u0kd40.webp#pic_center" width = 30%><p><strong>3. 优先队列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">priority_queue = []</span><br><span class="line"><span class="keyword">for</span> llist <span class="keyword">in</span> lists: </span><br><span class="line">    <span class="keyword">while</span> llist:</span><br><span class="line">        heapq.heappush(priority_queue, llist.val)       <span class="comment"># 把llist中的数据逐个加到堆中</span></span><br><span class="line">        llist = llist.<span class="built_in">next</span></span><br><span class="line">dummy = ListNode(<span class="number">0</span>)                                     <span class="comment"># 构造虚节点</span></span><br><span class="line">p = dummy</span><br><span class="line"><span class="keyword">while</span> priority_queue:</span><br><span class="line">    p.<span class="built_in">next</span> = ListNode(heapq.heappop(priority_queue))    <span class="comment"># 依次弹出最小堆的数据</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/032.4vepkbla4040.gif#pic_center" width = 48%><h3 id="3-4-排序链表"><a href="#3-4-排序链表" class="headerlink" title="3.4 排序链表"></a>3.4 排序链表</h3><h4 id="3-4-1-解题方法"><a href="#3-4-1-解题方法" class="headerlink" title="3.4.1 解题方法"></a>3.4.1 解题方法</h4><p>在数组排序中，常见的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序等。</p><p>而对于链表排序而言，因为链表不支持随机访问，访问链表后面的节点只能依靠 next 指针从头部顺序遍历，所以相对于数组排序问题来说，链表排序问题会更加复杂一点。</p><p>下面先来总结一下 <strong>适合链表排序与不适合链表排序的算法：</strong></p><ul><li>适合链表的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、桶排序、基数排序。</li><li>不适合链表的排序算法：希尔排序。</li><li>可以用于链表排序但不建议使用的排序算法：堆排序。</li></ul><p> <strong>希尔排序为什么不适合链表排序？</strong><br>希尔排序：希尔排序中经常涉及到对序列中第 <code>i + gap</code> 的元素进行操作，其中<code>gap</code> 是希尔排序中当前的步长。而&#x3D;&#x3D;链表不支持随机访问的特性，导致这种操作不适合链表，因而希尔排序算法不适合进行链表排序。&#x3D;&#x3D;</p><p> <strong>为什么不建议使用堆排序？</strong></p><p>堆排序：堆排序所使用的最大堆 &#x2F; 最小堆结构本质上是一棵完全二叉树。而完全二叉树适合采用顺序存储结构（数组）。因为数组存储的完全二叉树可以很方便的通过下标序号来确定父亲节点和孩子节点，并且可以极大限度的节省存储空间。</p><p>而链表用在存储完全二叉树的时候，因为不支持随机访问的特性，导致其寻找子节点和父亲节点会比较耗时，如果增加指向父亲节点的变量，又会浪费大量存储空间。所以堆排序算法不适合进行链表排序。</p><p>如果一定要对链表进行堆排序，则可以使用额外的数组空间表示堆结构。然后将链表中各个节点的值依次添加入堆结构中，对数组进行堆排序。排序后，再按照堆中元素顺序，依次建立链表节点，构建新的链表并返回新链表头节点。</p><p>需要用到额外的辅助空间进行排序的算法</p><p>刚才我们说到如果一定要对链表进行堆排序，则需要使用额外的数组空间。除此之外，计数排序、桶排序、基数排序都需要用到额外的数组空间。</p><h4 id="3-4-2-题库列表："><a href="#3-4-2-题库列表：" class="headerlink" title="3.4.2 题库列表："></a>3.4.2 题库列表：</h4><blockquote> <p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank">147. 对链表进行插入排序</a></p><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank">148. 排序链表</a></p></blockquote> <p><strong>147. 对链表进行插入排序</strong><br>题目描述：给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, head)                 <span class="comment"># 会移动头结点，这里虚拟头结点</span></span><br><span class="line">        last_sorted, curr = head, head.<span class="built_in">next</span>        <span class="comment"># last_sorted 维护已排序部分的最后一个位置；curr 为遍历的待插入元素</span></span><br><span class="line">        <span class="keyword">while</span> curr:           <span class="comment"># 外层循环遍历完链表所有数；内层循环遍历[head, lastSort]这段位置找插入</span></span><br><span class="line">            <span class="keyword">if</span> curr.val &gt;= last_sorted.val:</span><br><span class="line">                last_sorted = last_sorted.<span class="built_in">next</span>      <span class="comment"># 大，直接后移，或者直接 last_sorted = cur</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummy                        <span class="comment"># 用来遍历已经排序的部分</span></span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val &lt;= curr.val:    <span class="comment"># 从前往后比较，找插入的位置</span></span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                last_sorted.<span class="built_in">next</span> = curr.<span class="built_in">next</span>        <span class="comment"># 找到位置进行插入操作</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            curr = last_sorted.<span class="built_in">next</span>                 <span class="comment"># 指针后移</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/033.74j918hmusw0.gif#pic_center" width = 48%><p><strong>148. 排序链表</strong><br>题目描述：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>插入排序的时间复杂度是 $O(n^2)$，其中 $n$ 是链表的长度。这里考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 $O(nlogn)$ 的时间复杂度和 $O(1)$ 的空间复杂度，时间复杂度是 $O(nlogn)$ 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 $O(n^2)$），其中最适合链表的排序算法是归并排序。</p><p><strong>1. 归并排序-迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]: </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:        <span class="comment"># 空链表直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        length = <span class="number">0</span>          <span class="comment"># 获取链表的长度</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node: </span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        sub_length = <span class="number">1</span>                                <span class="comment"># 归并的有效处理长度，最小为 1</span></span><br><span class="line">        <span class="keyword">while</span> sub_length &lt; length:</span><br><span class="line">            prev, curr = dummy_head, dummy_head.<span class="built_in">next</span>  <span class="comment"># 为了更好的实现迭代，定义 prev, curr 分别指向 dummy_head, dummy_head.next</span></span><br><span class="line">            <span class="keyword">while</span> curr:                               <span class="comment"># 当 cur 不为空时</span></span><br><span class="line">                head1 = curr                          <span class="comment"># 定义当前链表，head1 指向 cur</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sub_length):</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    当 i 等于 1 时, cur 不需要指向后下一个链表其余情况，</span></span><br><span class="line"><span class="string">                    cur 在链表 cur 不为空的情况, 向后移动 sub_length - 1 个位置</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                head2 = curr.<span class="built_in">next</span>   <span class="comment"># 切断链表，第一部分长度为 sub_length</span></span><br><span class="line">                curr.<span class="built_in">next</span> = <span class="literal">None</span>    <span class="comment"># 第二部分为 head 除 head1 以外的部分</span></span><br><span class="line">                curr = head2</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sub_length):  <span class="comment"># 将 cur 在满足 cur.next 不为空的情况下， 又往后移动 sub_length 长度</span></span><br><span class="line">                    <span class="keyword">if</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                remain = <span class="literal">None</span>         <span class="comment"># 定义 remain 链表，指向 null</span></span><br><span class="line">                <span class="keyword">if</span> curr:              <span class="comment"># 当移动完 sub_length 后，仍不为空，remain 等于 cur.next;</span></span><br><span class="line">                    remain = curr.<span class="built_in">next</span></span><br><span class="line">                    curr.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 切断链表， 这时候 head2 的长度与 head1 一致</span></span><br><span class="line">                </span><br><span class="line">                merged = self.merge(head1, head2)   <span class="comment"># merge , 然后 prev 的 next 指针指向将 merge 后的子链表</span></span><br><span class="line">                prev.<span class="built_in">next</span> = merged</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>:        <span class="comment"># 然后将 prev 指向与 merge 完成后的链表位置</span></span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                curr = remain           <span class="comment"># 然后当前节点位置指向 remain 部分链表</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            进入下一批次的归并排序操作，直到将相同 sub_length 的全部处理完，才会退出此处 while</span></span><br><span class="line"><span class="string">            再进入到下轮 sub_length, sub_length 以 1 -&gt; 2 -&gt; 4 -&gt; 8 的方法进行，符合自低向上不断迭代，</span></span><br><span class="line"><span class="string">            直到找到最终答案。其实递归底层本质也是一样的，到最短的1，才开始合并，不断合并，到最终结果</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            sub_length &lt;&lt;= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>)            <span class="comment"># 构建虚拟头结点</span></span><br><span class="line">        temp, temp1, temp2 = dummy_head, head1, head2</span><br><span class="line">        <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:              <span class="comment"># 开始合并操作</span></span><br><span class="line">            <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> temp1:                <span class="comment">#  如 temp1, temp2 还存在不为空的链表，将剩余部分赋值给 temp.next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">        <span class="keyword">elif</span> temp2:</span><br><span class="line">            temp.<span class="built_in">next</span> = temp2</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/034.1zary1lzo8e8.gif#pic_center" width = 48%><p><strong>2. 归并排序-递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">return</span> self.split_list(head) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_list</span>(<span class="params">self, head: ListNode</span>):   </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;处理归并排序的边界问题,下面两种场景都不需要进行分合操作&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        prev, slow, fast = head, head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:   <span class="comment"># 找中点,偶数找的后面那个中点的位置，奇数找到中点</span></span><br><span class="line">            prev = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = head, slow     <span class="comment"># 将链表分割成两个子链表</span></span><br><span class="line">        <span class="keyword">return</span> self.merge_sort(self.split_list(left), self.split_list(right))    <span class="comment"># 分割完后，进行合并部分操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;归并环节&#x27;&#x27;&#x27;</span></span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>)            <span class="comment"># 构建虚拟头结点</span></span><br><span class="line">        temp, temp1, temp2 = dummy_head, head1, head2</span><br><span class="line">        <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:              <span class="comment"># 开始合并操作</span></span><br><span class="line">            <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> temp1:                <span class="comment">#  如 temp1, temp2 还存在不为空的链表，将剩余部分赋值给 temp.next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">        <span class="keyword">elif</span> temp2:</span><br><span class="line">            temp.<span class="built_in">next</span> = temp2</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/035.69mibz76l6s0.gif#pic_center" width = 48%><p>了解更多，请阅读：<a href="https://leetcode.cn/problems/sort-list/solution/by-itcharge-01zg/">排序链表「八大排序算法」「Python 版」「链表、冒泡、选择、插入、归并、桶排序、计数排序、基数排序</a></p><h3 id="3-5-环形链表"><a href="#3-5-环形链表" class="headerlink" title="3.5 环形链表"></a>3.5 环形链表</h3><h4 id="3-5-1-题库列表"><a href="#3-5-1-题库列表" class="headerlink" title="3.5.1 题库列表"></a>3.5.1 题库列表</h4><blockquote> <ul><li> <p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank">160. 相交链表</a></p> </li><li> <p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank">141. 环形链表</a></p> <li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank">142. 环形链表 II</a></li></ul> </li></ul></blockquote> <p><strong>160. 相交链表</strong><br>题目描述：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p1, p2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:<span class="comment"># 退出的关键是：指向同一个指针（不是值相等），或者都指 None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                p1 = headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                p2 = headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p1<span class="comment"># 如果没有相等的那么nodeA==nodeB==null</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/036.6sj6veryvqs0.gif#pic_center" width = 48%><p><strong>141. 环形链表</strong><br>题目描述：给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 快指针在前面，所以只要判断快指针是否达到了队尾就可以</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/037.2x97g491nw60.gif#pic_center" width = 48%><p><strong>142. 环形链表 II</strong><br>题目描述：给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># 快慢指针找重合点</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:<span class="comment"># 重合了，这个时候，从头来一个指针遍历</span></span><br><span class="line">                p1 = slow</span><br><span class="line">                p2 = head</span><br><span class="line">                <span class="keyword">while</span> p1 != p2:</span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    p2 = p2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> p2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span><span class="comment"># 没有环，返回 None</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/038.5kfy8p3vjk40.gif#pic_center" width = 48%><p><br></br></p><blockquote><p><font color=#9900CC><strong>终于小结完了，期待下一专题——二叉树，也期待各位小伙伴们一起来学习与交流！</font></strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/039.4anrfsp19o60.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>一文搞定常见的链表问题：<a href="https://leetcode.cn/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/">https://leetcode.cn/problems/linked-list-cycle/</a></li><li>链表常见问题解决思路：<a href="https://blog.csdn.net/weixin_43910851/article/details/105725577">https://blog.csdn.net/weixin_43910851&#x2F;article&#x2F;details&#x2F;105725577</a></li><li>一文通数据结构与算法之——链表+常见题型与解题策略+Leetcode经典题：<a href="https://blog.csdn.net/qq_42647903/article/details/120594925">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594925</a></li><li>两个技巧搞定常见面试链表题：<a href="https://blog.csdn.net/weixin_45750855/article/details/120065894#:~:text=%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7%E6%90%9E%E5%AE%9A%E5%8A%9B%E6%89%A3%E5%B8%B8%E8%A7%81%20%E9%93%BE%E8%A1%A8%20%E9%A2%98%201%201.%20%E6%8E%8C%E6%8F%A1%E5%93%91%E8%8A%82%E7%82%B9%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7%E5%AF%BC%E8%87%B4%E5%9C%A8%E6%88%91%E4%BB%AC%E5%AF%B9%E5%A4%B4%E7%BB%93%E7%82%B9%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%20%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%A4%B4%E8%8A%82%E7%82%B9%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E3%80%82,%E5%92%8C%20slow%EF%BC%8C%E5%88%9D%E5%A7%8B%E6%97%B6%E5%9D%87%E6%8C%87%E5%90%91%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82%20%E9%A6%96%E5%85%88%EF%BC%8C%E5%85%88%E8%AE%A9%20fast%20%E7%A7%BB%E5%8A%A8%20k%20%E6%AC%A1%E3%80%82%20">https://blog.csdn.net/weixin_45750855&#x2F;article&#x2F;details&#x2F;</a></li><li>算法面试题 | 链表问题总结：<a href="https://juejin.cn/post/6882370280946302983">https://juejin.cn/post/6882370280946302983</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反转链表 </tag>
            
            <tag> 合并链表 </tag>
            
            <tag> 排序链表 </tag>
            
            <tag> 环形链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络-自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</title>
      <link href="/article/396f3774.html"/>
      <url>/article/396f3774.html</url>
      
        <content type="html"><![CDATA[<p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和LinuxUnix计算机上运行，是进行网络实验的理想分组分析器。本篇主要通过该软件进行抓包实验。</p><span id="more"></span><p>要深入理解网络协议，需要仔细观察协议实体之间交换的报文序列。为探究协议操作细节，可使协议实体执行某些动作，观察这些动作及其影响。这些任务可以在仿真环境下或在如因特网这样的真实网络环境中完成。观察在正在运行协议实体间交换报文的基本工具被称为分组嗅探器(<code>packet sniffer</code>)。顾名思义，一个分组嗅探器捕获（嗅探）计算机发送和接收的报文。一般情况下，分组嗅探器将存储和显示出被捕获报文的各协议头部字段内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.6gwpvo7pots0.webp#pic_center" width = 48%><p>上图右边是计算机上正常运行的协议（在这里是因特网协议）和应用程序（如：<code>Web</code> 浏览器和 <code>ftp</code> 客户端）。分组嗅探器（虚线框中的部分）是附加在计算机普通软件上的，主要由两部分组成。分组捕获库接收计算机发送和接收的每一个链路层帧的拷贝。高层协议（如：<code>HTTP</code>、 <code>FTP</code>、 <code>TCP</code>、 <code>UDP</code>、 <code>DNS</code>、 <code>IP</code> 等）交换的报文都被封装在链路层帧(Frame)中，并沿着物理介质（如以太网的电缆）传输。上图假设所使用的物理媒体是以太网，上层协议的报文最终封装在以太网帧中。</p><p>分组嗅探器的第二个组成部分是分析器。分析器用来显示协议报文所有字段的内容。为此，分析器必须能够理解协议所交换的所有报文的结构。例如：我们要显示上图中 HTTP 协议所交换的报文的各个字段。分组分析器理解以太网帧格式，能够识别包含在帧中的 IP 数据报。分组分析器也要理解 IP 数据报的格式，并能从 IP 数据报中提取出 TCP 报文段。然后，它需要理解 TCP 报文段，并能够从中提取出 HTTP 消息。最后，它需要理解 HTTP 消息。</p><p>Wireshark是一种免费的网络协议分析器，可在Windows，Mac和Linux&#x2F;Unix计算机上运行，是进行网络实验的理想分组分析器。该软件具有庞大的用户基础，文档支持包括用户指南、手册和常见问题(详见<a href="http://www.wireshark.org/docs">http://www.wireshark.org/docs</a>)，丰富的功能包括分析数百种协议，以及精心设计的用户界面。可以运行在使用以太网、串行(PPP和SLIP)、802.11无线局域网和许多其他链路层技术的计算机上。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.6fvhzc6qeb40.webp#pic_center" width = 48%><p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark。</p><h2 id="1-下载并安装Wireshark软件"><a href="#1-下载并安装Wireshark软件" class="headerlink" title="1 下载并安装Wireshark软件"></a>1 下载并安装Wireshark软件</h2><p>WireShark 是一种可以运行在 Windows，UNIX，Linux 等操作系统上的分组分析器。运行Wireshark，需要有一台支持Wireshark和libpcap或WinPCap分组捕获库的计算机。安装Wireshark时，如果操作系统中未安装libpcap软件，它将会自动安装。支持的操作系统和下载站点的列表，请访问[<a href="http://www.wireshark.org/download.html]">http://www.wireshark.org/download.html]</a>(<a href="http://www.wireshark.org/download.html%E3%80%82%E6%8C%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E6%8C%89%E7%85%A7%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E4%B8%80%E8%B7%AFNext%E5%AE%89%E8%A3%85%E3%80%82">http://www.wireshark.org/download.html。按照系统版本选择下载，下载完成后，按照软件提示一路Next安装。</a></p><p> <strong>温馨提示：</strong> 当您在安装或运行Wireshark时遇到问题时，可以查看Wireshark FAQ，它包含一些有用的提示和信息。如果你是Win10系统，安装完成后，选择抓包但是不显示网卡，下载win10pcap兼容性安装包。下载路径：<a href="http://www.win10pcap.org/download/">下载路径：win10pcap兼容性安装包</a></p><h2 id="2-Wireshark-开始抓包示例"><a href="#2-Wireshark-开始抓包示例" class="headerlink" title="2 Wireshark 开始抓包示例"></a>2 Wireshark 开始抓包示例</h2><p>1、双击桌面上的图标，可启动Wireshark。启动后的用户界面如下图所示，中间列表部分列出了所有网络接口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.38sj0cnbnum0.webp#pic_center" width = 48%><p>2、选择菜单栏上捕获 -&gt; 选项，勾选WLAN网卡（这里需要根据各自电脑网卡使用情况选择，简单的办法可以看使用的IP对应的网卡）。点击Start。启动抓包。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4qe115vaeae0.webp#pic_center" width = 48%><p>3、wireshark启动后，wireshark处于抓包状态中。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.3la44n2lec40.webp#pic_center" width = 48%><p>4、执行需要抓包的操作，如在cmd窗口下执行<code>ping www.baidu.com</code>。</p><p>5、抓取分组操作</p><p>A.单击中间网络接口列表中，某一网络接口如<code>eth0</code>，选中网络接口，通过菜单“捕获”-“开始”或工具栏中的<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 按钮，开始捕获选定接口中的网络分组；B．也可以双击中间网络接口列表中，某一网络接口如<code>eth0</code>，可以开始抓取分组；C．通过菜单“捕获”-“停止”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 停止抓取分组。D．通过菜单“捕获”-“重新开始”或工具栏中的按钮<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt=""> 重新开始抓取。</p><p>6、Wireshark窗口功能</p><p><strong>A．命令菜单和工具栏</strong><br>命令菜单位于窗口的最顶部，是标准的下拉式菜单。最常用菜单命令有两个： 文件、 捕获。 文件 菜单允许你保存捕获的分组数据，或打开一个已被保存的捕获分组数据文件，或退出 WireShark 程序。 捕获 菜单允许你开始捕获分组。</p><p>工具栏位于命令菜单的下方，提供常用功能的快捷方式。如<img src="https://data.educoder.net/api/attachments/448948" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448948" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：开始捕获、<img src="https://data.educoder.net/api/attachments/448957" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448957" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：停止捕获、<img src="https://data.educoder.net/api/attachments/448959" class="lazyload placeholder" data-srcset="https://data.educoder.net/api/attachments/448959" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=2% alt="">：重新抓取分组。</p><p><strong>B．显示过滤规则</strong></p><p>在该字段中，可以填写协议的名称或其他信息，根据此内容可以对分组列表窗口中的分组进行过滤。</p><p><strong>C．捕获分组列表</strong></p><p>按行显示已被捕获的分组内容，其中包括： WireShark 赋予的分组序号、捕获时间、分组的源地址和目的地址、协议类型、分组中所包含的协议说明信息。单击某一列的列名，可以使分组按指定列进行排序。 在该列表中，所显示的协议类型是发送或接收分组的最高层协议的类型。</p><p><strong>D．分组头部明细</strong></p><p>显示捕获分组列表窗口中被选中分组的头部详细信息。包括：与以太网帧有关的信息，与包含在该分组中的 IP 数据报有关的信息。</p><p>单击以太网帧或 IP 数据报所在行左边的向右或向下的箭头可以展开或最小化相关信息。如果利用 TCP 或 UDP 承载分组， WireShark 也会显示 TCP 或 UDP 协议头部信息。分组最高层协议的头部字段也会显示在此窗口中。</p><p><strong>E．分组内容窗口</strong></p><p>以 ASCII 码和十六进制两种格式显示被捕获帧的完整内容。</p><p>7、通常，分组列表窗口中会显示许多类型的分组。即使仅仅是下载了一个网页，但是还有许多其他协议在您的计算机上运行，只是用户所看不见。可以在中间过滤窗口中输入过滤的分组协议如http， 选择应用按钮，就可以只让HTTP分组消息显示在分组列表窗口。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.4x7p2hmwhiw0.webp#pic_center" width = 48%><p>8、操作完成后相关数据包就抓取到了。为避免其他无用的数据包影响分析，可以通过在过滤栏设置过滤条件进行数据包列表过滤，获取结果如下。说明：<code>ip.addr == 119.75.217.26 and icmp</code> 表示只显示ICPM协议且源主机IP或者目的主机IP为<code>119.75.217.26</code>的数据包。说明：协议名称icmp要小写。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.sm5aj8usjww.webp#pic_center" width = 48%><h2 id="3-Wireshakr抓包界面介绍"><a href="#3-Wireshakr抓包界面介绍" class="headerlink" title="3 Wireshakr抓包界面介绍"></a>3 Wireshakr抓包界面介绍</h2><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.61b2vxymuhg0.webp#pic_center" width = 36%><p>说明：数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏 视图(View) –&gt; 着色规则(Coloring Rules)。如下所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.4owrci6ggh00.webp#pic_center" width = 48%><ol><li>显示过滤器(Display Filter)，用于设置过滤条件进行数据包列表过滤。菜单路径：分析(Analyze) –&gt; 显示过滤器(Display Filters)。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.726v80qr0vg0.webp#pic_center" width = 48%><ol><li>数据包列表(Packet List Pane)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。</li></ol><p>Time:时间；Source:发送主机IP地址；Destination: 接收主机IP地址；Protocol：分组协议；Length：分组长度；Info：分组内容</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.7829pakw1us0.webp#pic_center" width = 48%><ol><li>数据包详细信息(Packet Details Pane), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为<br>（1）Frame:   物理层的数据帧概况<br>（2）Ethernet II: 数据链路层以太网帧头部信息<br>（3）Internet Protocol Version 4: 互联网层IP包头部信息<br>（4）Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP<br>（5）Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.4xs9wudqaak0.webp#pic_center" width = 48%><p>TCP包的具体内容</p><p>从下图可以看到wireshark捕获到的TCP包中的每个字段。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.2sybmlwvjy00.webp#pic_center" width = 48%><ol><li>数据包字节区(Dissector Pane)。</li></ol><p>在分组内容窗口中，可以显示出该分组内容的16进制和ASCII两种格式的内容。鼠标指向内容窗口，可以将分组中某一字段的内容突出显示。在分组头部信息窗口中，展开选择某一头部信息时，分组内容中相应内容同步突出显示。</p><h2 id="4-Wireshark过滤器设置"><a href="#4-Wireshark过滤器设置" class="headerlink" title="4 Wireshark过滤器设置"></a>4 Wireshark过滤器设置</h2><p>初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己需要抓取的数据包部分。wireshark工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p><p><strong>1) 抓包过滤器</strong></p><p>捕获过滤器的菜单栏路径为Capture –&gt; Capture Filters。用于在抓取数据包前设置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.6uzm0lq7h800.webp#pic_center" width = 48%><p>如何使用？可以在抓取数据包前设置如下。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.5zbhvy2gomw0.webp#pic_center" width = 48%><p><code>ip host 60.207.246.216 and icmp</code> 表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.2k7fnwqaoo20.webp#pic_center" width = 48%><p><strong>（2）显示过滤器</strong></p><p>显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛或者没有设置导致抓取的数据包内容较多时使用显示过滤器设置条件过滤以方便分析。同样上述场景，在捕获时未设置抓包过滤规则直接通过网卡进行抓取所有数据包，如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.1p43gtotb00w.webp#pic_center" width = 48%><p>执行 <code>ping www.baidu.com</code> 获取的数据包列表如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.2hu9htl72eo0.webp#pic_center" width = 48%><p>观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。<code>ip.addr == 14.119.104.254 and icmp</code>。并进行过滤。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.4q6cjmtdeei0.webp#pic_center" width = 48%><p>上述介绍了抓包过滤器和显示过滤器的基本使用方法。在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。下面介绍一下两者间的语法以及它们的区别。</p><h2 id="5-wireshark过滤器表达式的规则"><a href="#5-wireshark过滤器表达式的规则" class="headerlink" title="5 wireshark过滤器表达式的规则"></a>5 wireshark过滤器表达式的规则</h2><p>1、抓包过滤器语法和实例</p><p>抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）</p><p>(1) 协议过滤</p><p>比较简单，直接在抓包过滤框中直接输入协议名即可。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><p>(2) IP过滤</p><ul><li>host 192.168.1.104</li><li>src host 192.168.1.104</li><li>dst host 192.168.1.104</li></ul><p>(3) 端口过滤</p><ul><li>port 80</li><li>src port 80</li><li>dst port 80</li></ul><p>(4) 逻辑运算符 &amp;&amp; 与、|| 或、！非</p><ul><li><code>src host 192.168.1.104 &amp;&amp; dst port 80</code> 抓取主机地址为192.168.1.80、目的端口为80的数据包</li><li><code>host 192.168.1.104 || host 192.168.1.102</code> 抓取主机为192.168.1.104或者192.168.1.102的数据包</li><li><code>!broadcast</code> 不抓取广播数据包</li></ul><p>2、显示过滤器语法和实例<br>(1) 比较操作符</p><p>比较操作符有&#x3D;&#x3D; 等于、！&#x3D; 不等于、&gt; 大于、&lt; 小于、&gt;&#x3D; 大于等于、&lt;&#x3D;小于等于。</p><p>(2) 协议过滤</p><p>比较简单，直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。</p><ul><li>tcp，只显示TCP协议的数据包列表</li><li>http，只查看HTTP协议的数据包列表</li><li>icmp，只显示ICMP协议的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(3) ip过滤</p><ul><li><code>ip.src ==192.168.1.104</code>，显示源地址为192.168.1.104的数据包列表</li><li><code>ip.dst==192.168.1.104</code>，显示目标地址为192.168.1.104的数据包列表</li><li><code>ip.addr == 192.168.1.104</code>，显示源IP地址或目标IP地址为192.168.1.104的数据包列表</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/040.6fo7o8vomq80.webp#pic_center" width = 48%><p>(4) 端口过滤</p><ul><li>tcp.port &#x3D;&#x3D;80,  显示源主机或者目的主机端口为80的数据包列表。</li><li>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的源主机端口为80的数据包列表。</li><li>tcp.dstport &#x3D;&#x3D; 80，只显示TCP协议的目的主机端口为80的数据包列表。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/042.4ni1tou9im80.webp#pic_center" width = 48%><p>(5) Http模式过滤</p><p><code>http.request.method==&quot;GET&quot;</code>, 只显示HTTP GET方法的。</p><p>(6) 逻辑运算符为 and&#x2F;or&#x2F;not</p><p>过滤多个条件组合时，使用and&#x2F;or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为 <code>ip.addr == 14.119.104.254 and icmp</code></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.oe0q389yzmo.webp#pic_center" width = 48%><p>(7) 按照数据包内容过滤。假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.2eq42rto5h34.webp#pic_center" width = 48%><p>右键单击选中后出现如下界面</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.9tlmp06f5y8.webp#pic_center" width = 48%><p>选中Select后在过滤器中显示如下，后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含”abcd”内容的数据流。包含的关键词是contains 后面跟上内容。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4v5jwne3bpq0.webp#pic_center" width = 48%><p>调整数据包列表中时间戳显示格式。调整方法为View –&gt;Time Display Format –&gt; Date and Time of Day。调整后格式如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.3f70teoime8.webp#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>wireshark 基本使用：<a href="https://www.educoder.net/shixuns/5kuyi2hn/challenges">https://www.educoder.net/shixuns/5kuyi2hn/challenges</a></li><li>wireshark抓包新手使用教程：<a href="https://www.cnblogs.com/linyfeng/p/9496126.html">https://www.cnblogs.com/linyfeng/p/9496126.html</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络-自顶向下方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（十）-- 链表的实现</title>
      <link href="/article/4e528de2.html"/>
      <url>/article/4e528de2.html</url>
      
        <content type="html"><![CDATA[<p>本文主要学习使用Python实现链表，包括链表增加元素、删除元素、扫描、定位、遍历，以及循环单链表和双链表的实现。</p><span id="more"></span><p>实现线性表的另一种常用方式就是基于链接结构，用链接关系显式表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或者链表。</p><p>采用链接方式实现线性表的基本想法如下:</p><ul><li>把表中的元素分别存储在一批独立的存储块（称为表的结点）里。</li><li>保证从组成表结构中的任一个结点可找到与其相关的下一个结点。</li><li>在前一结点里用链接的方式显式地记录与下一结点之间的关联。</li></ul><p>这样，只要能找到组成一个表结构的第一个结点，就能顺序找到属于这个表的其他结点。从这些结点里可以看到这个表中的所有元素。</p><p>链接技术是一类非常灵活的数据组织技术，实现链表有多种不同的方式。下面首先讨论最简单的单链表，其中在每个表结点里记录着存储下一个表元素的结点的标识(引用&#x2F;链接)。后面将介绍另外一些结构的链表，它们各有所长，支持不同的需要。在下面的讨论中，将把“存储着下一个表元素的结点”简称为“下一结点”。</p><h2 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1 单链表"></a>1 单链表</h2><p>单向链接表（下面将简称为单链表或者链表）的结点是一个二元组，形式如下图a所示，其表元素域 elem 保存着作为表元素的数据项（或者数据项的关联信息），链接域 next 里保存同一个表里的下一个结点的标识。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6urmjtr0pm4.webp#pic_center" width = 48%><p>在最常见形式的单链表里，与表里的n个元素对应的n个结点通过链接形成一条结点链，如上图b所示。从引用表中首结点的变量（上图b中变量p）可以找到这个表的首结点，从表中任一结点可以找到保存着该表下一个元素的结点（表中下一结点），这样，从p出发就能找到这个表里的任一个结点。</p><p>要想掌握一个单链表，就需要（也只需要）掌握这个表的首结点，从它出发可以找到这个表里的第一个元素（即在这个表结点里保存的数据，保存在它的 elem域中），还可以找到这个表里的下一结点（有关信息保存在这个结点的 next 域中）。按照同样的方式继续下去，就可以找到表里的所有数据元素。</p><p>也就是说，为了掌握一个表，只需要用一个变量保存着这个表的首结点的引用（标识或称为链接）。今后将把这样的变量称为<font color=#9900CC><strong>表头变量或表头指针</font></strong>。</p><p><strong>小结一下：</strong></p><ul><li>—个单链表由一些具体的表结点构成。</li><li>每个结点是一个对象，有自己的标识，下面也常称其为该结点的链接。</li><li>结点之间通过结点链接建立起单向的顺序联系。</li></ul><p>为了表示一个链表的结束，只需给表的最后结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（称为空链接），在 Python 里自然可以用系统常量 None 表示这种情况，在上图里用接地符号“丄”表示链表结束，下面将一直这样表示。</p><p>通过判断一个（域或变量的）值是否为空链接，可知是否已到链表的结束。在顺序扫描表结点时，应该用这种方法确定操作是否完成。如果一个表头指针的值是空链接，就说明“它所引用的链表已经结束”，这是没有元素就已结束，说明该表是空表。</p><p>在实现链表上的算法时，并不需要关心在某个具体的表里各结点的具体链接值是什么（虽然保存在表结构里的值都是具体的），只需要关心链表的逻辑结构。对链表的操作也只需要根据链表的逻辑结构考虑和实现。</p><p>为方便下面的讨论，现在定义个简单的表结点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, elem=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.elem = elem    </span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h3><p> <strong>创建空链表：</strong> 只需要把相应的表头变量设置为空链接，在Python语言中将其设置为None，在其他语言里也有惯用值，例如有的语言里用0作为这个特殊值。</p><p> <strong>删除链表：</strong> 应丢弃这个链表里的所有结点。这个操作的实现与具体的语言环境有关。在一些语言（如C语言）里，需要通过明确的操作释放一个个结点所用的存储。在Python语言中这个操作很简单，只需简单地将表指针赋值为None，就抛弃了链表原有的所有结点。Python解释器的存储管理系统会自动回收不用的存储。</p><p> <strong>判断表是否为空：</strong> 将表头变量的值与空链接比较。在Python语言中，就是检查相应变量的值是否为None.</p><p> <strong>判断表是否满：</strong> 一般而言链表不会满，除非程序用完了所有可用的存储空间。</p><p><strong>加入元素</strong></p><p>现在考虑给单链表加入元素的操作，同样有插入位置问题，可以做首端插入、尾端插人或者定位插人。不同位置的操作复杂度可能不同。</p><p>首先应该注意，在链表里加入新元素时，并不需要移动已有的数据，只需为新元素安排一个新结点，然后根据操作要求，把新结点连在表中的正确位置。也就是说，插入新元素的操作是通过修改链接，接入新结点，从而改变表结构的方式实现的。</p><p><strong>表首端插入：</strong> 首端插入元素要求把新数据元素插入表中，作为表的第一个元素，这是最简单的情况。这一操作需要通过三步完成：</p><ol><li>创建一个新结点并存入数据（下图a表示要向表头变量 head 的链表加入新首元素13，为它创建了新结点，变量q指着该结点。这是实际插入前的状态）。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.1nk62pq0gjvk.webp#pic_center" width = 48%><ol><li><p>把原链表首结点的链接存入新结点的链接域 next，这一操作将原表的一串结点链接在刚创建的新结点之后。</p></li><li><p>修改表头变量，使之指向新结点，这个操作使新结点实际成为表头变量所指的结点，即表的首结点（上图b表示设置链接的这两步操作完成后的状态，新结点已成为 head 所指链表的首结点，13成为这个表的首元素。注意，示意图中链接指针的长度和形状都不表示任何意义，只有图中的链接指向关系有意义）。</p></li></ol><p>注意，即使在插入前head指向的是空表，上面三步也能正确完成工作。这个插人只是一次安排新存储和几次赋值，操作具有常量时间复杂度。</p><p>示例代码段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = ListNode(<span class="number">13</span>)</span><br><span class="line">q.<span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">head = q</span><br></pre></td></tr></table></figure><p> <strong>一般情况的元素插入：</strong> 要想在单链表里的某位置插入一个新结点，必须先找到该位置之前的那个结点，因为新结点需要插入在它的后面，需要修改它的next 域。如何找到这个结点的问题将在后面讨论，先看已经找到了这个结点之后怎样插入元素。</p><p>设变量pre已指向要插入元素位置的前一结点，操作也分为三步:</p><ol><li>创建一个新结点并存入数据（下图a是实际插入前的状态）。</li><li>把 pre 所指结点 next 域的值存入新结点的链接域 next，这个操作将原表在 pre 所指结点之后的一段链接到新结点之后。</li><li>修改 pre 的 next 域，使之指向新结点，这个操作把新结点链入被操作的表，整个操作完成后的状态如下图b所示。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.4nd11m338680.webp#pic_center" width = 48%><p>注意，即使在插入前 pre 所指结点是表中最后一个结点，上述操作也能将新结点正确接入，作为新的表尾结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = ListNode(<span class="number">13</span>)</span><br><span class="line">q.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">pre.<span class="built_in">next</span> = q</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><p>删除链表中元素，也可通过调整表结构删除表中结点的方式完成。这里也区分两种情况：删除表头结点的操作可以直接完成，删除其他结点也需要掌握其前一结点。</p><p> <strong>删除表首元素：</strong> 删除表中第一个元素对应于删除表的第一个结点，为此只需修改表头指针，令其指向表中第二个结点。丢弃不用的结点将被Python解释器自动回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>一般情况的元素删除：一般情况删除须先找到要删元素所在结点的前一结点，设用变量pre指向，然后修改pre的next域，使之指向被删结点的下一结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>显然，这两个操作都要求被删结点存在。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.11jtua2aafu8.webp#pic_center" width = 48%><p>如果在其他编程语言里删除结点，还可能要自己释放存储。Python的自动存储管理机制能自动处理这方面的问题，使编程工作更简单，也保证了安全性。</p><p><strong>扫描、定位和遍历</strong></p><p>在一般情况下插入和删除元素，都要求找到被删结点的前一结点。另外，程序里也可能需要定位链表中的元素、修改元素、逐个处理其中元素等。这些操作都需要检查链表的内容，实际上是检查表中的一些（或全部）结点。</p><p>由于单链表只有一个方向的链接，开始情况下只有表头变量在掌握中，所以对表内容的一切检查都只能从表头变量开始，沿着表中链接逐步进行。这种操作过程称为链表的扫描，这种过程的基本操作模式是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> 还需继续的其他条件:</span><br><span class="line">    对p所指结点里的数据做所需操作</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>根据Python语言的规定，这里的 <code>p is not None</code> 可以简单地只写一个 <code>p</code>。</p><p>循环的继续（或结束）条件、循环中的操作由具体问题决定。循环中使用的辅助变量p称为<font color=#9900CC><strong>扫描指针</font></strong>。注意，每个扫描循环必须用一个扫描指针作为控制变量，每步迭代前必须检查其值是否为None，保证随后操作的合法性。这与连续表的越界检查类似。</p><p>上面表扫描模式是最一般的链表操作模式，下面介绍几个常用操作的实现。</p><p> <strong>按下标定位：</strong> 按 Python 惯例，链表首结点的元素应看作下标0，其他元素依次排列。确定第i个元素所在结点的操作称为按下标定位，可以参考表扫描模式写出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> NOne <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>假设循环前变量i已有所需的值，循环结束时可能出现两种情况：或者扫描完表中所有结点还没有找到第i个结点，或者p所指结点就是所需。通过检查 p 值是否为None可以区分这两种情况。显然，如果现在需要删除第k个结点，可以先将i设置为k-1，循环后检查i是0且p.next不是None就可以执行删除了。</p><p> <strong>按元素定位：</strong> 假设需要在链表里找到满足谓词pred的元素。同样可以参考上面的表扫描模式，写出的检索循环如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> pred(p.elem):</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>循环结束时或者p是None；或者 <code>pred(p.elem)</code> 是 True，找到了所需元素。</p><p>完整的扫描称为遍历，这样做通常是需要对表中每个元素做一些事情，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(p.elem)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>这个循环依次输出表中各元素。只以条件 <code>p is not None</code> 控制循环，就能完成一遍完整的遍历。同样模式可用于做其他工作。</p><p><strong>链表操作的复杂度</strong><br>总结一下链表操作的时间复杂度。</p><ul><li><p>创建空表：$O(1)$。</p></li><li><p>删除表：在Python里是$O(1)$。当然，Python 解释器做存储管理也需要时间。</p></li><li><p>判断空表：$O(1)$。</p></li><li><p>加入元素（都需要加一个T(分配)的时间）</p><ul><li>首端加入元素：$O(1)$。</li><li>尾端加入元素：$O(n)$、因为需要找到表的最后结点。</li><li>定位加人元素：$O(n)$，平均情况和最坏情况。</li></ul></li><li><p>删除元素:</p><ul><li>首端删除元素：$O(1)$。</li><li>尾端删除元素：$O(n)$。</li><li>定位删除元素：$O(n)$，平均情况和最坏情况。</li><li>其他册除：通常需要扫描整个表或其一部分$O(n)$。</li></ul></li></ul><p>扫描、定位或遍历操作都需要检查一批表结点，其复杂度受到表结点数的约束，都是 $O(n)$ 操作。其他在工作中有此类行为的操作也至少具有 $O(n)$ 时间复杂度。</p><p><strong>求表的长度</strong></p><p>在使用链表时，经常需要求表的长度，为此可以定义一个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, n = head, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p>这个函数采用表扫描模式，遍历表中所有结点完成计数。显然，这个求表长度的算法所用时间与表结点个数成正比，具有 $O(n)$ 时间复杂度。</p><p><strong>实现方式的变化</strong></p><p>以求表的长度为例，如果程序经常需要调用上面函数，$O(n)$ 复杂度就可能成为效率问题。如果表很长，执行该函数就可能造成可察觉的停顿。解决这个问题的一种方法是改造单链表的实现结构，增加一个表长度记录。显然，这个记录不属于任何表元素，是有关表的整体的信息。表示这件事的恰当方法是定义一种链表对象，把表的长度和表中的结点链表都作为这个表对象的数据成分，如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.1og2k56a4zvk.webp#pic_center" width = 48%><p>图中变星p指向表对象，这个对象的一个数据域记录表中元素个数（图中的20表示这个表当时有20个结点），另一个域引用着该表的结点链。采用了这种表示方式，求表长度的操作就可以简单返回元素计数域的值。但另一方面，这种表的每个变动操作都需要维护计数值。从整体看有得有失。这种调整消除了一个线性时间操作，可能在一些应用中很有意义。</p><h3 id="1-2-单链表类的实现"><a href="#1-2-单链表类的实现" class="headerlink" title="1.2 单链表类的实现"></a>1.2 单链表类的实现</h3><p><strong>自定义异常</strong></p><p>为能合理地处理一些链表操作中遇到的错误状态（例如，方法执行时遇到了无法操作的错误参数），首先为链表类定义一个新的异常类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListUnderflow</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里把LinkedListUnderflow定义为标准异常类valueError的子类，准备在空表访问元索等场合抛出这个异常。在这些情况下抛出 valueError 也没问题，但定义了自己的异常类，就可以写专门的异常处理器，在一些情况下可能有用。</p><p><strong>LList类的定义，初始化函数和简单操作</strong></p><p>现在基于结点类 ListNode 定义一个单链表对象的类，在这种表对象里只有一个引用链接结点的_head域，初始化为None表示建立的是一个空表。判断表空的操作检查_head；在表头插入数据的操作是prepend，它把包含新元素的结点链接在最前面；操作 pop 删除表头结点并返回这个结点里的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self, elem</span>):</span><br><span class="line">        self._head = ListNode(elem, self._head)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:      <span class="comment"># 无结点，引发异常</span></span><br><span class="line">            <span class="keyword">raise</span> LinkedListUnorderflow(<span class="string">&quot;in pop&quot;</span>)</span><br><span class="line">        e = self._head.elem</span><br><span class="line">        self._head = self._head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure><p>这里把 LList 对象的 <code>_head</code> 域作为对象的内部表示，不希望外部使用。上面定义里的几个操作都很简单，只有 pop 操作需要检查对象的状态，表中无元素时引发异常。</p><p><strong>后端操作</strong></p><p>在链表的最后插入元素，必须先找到链表的最后一个结点。其实现首先是一个扫描循环，找到相应结点后把包含新元素的结点插入在其后。下面是定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, elem</span>):</span><br><span class="line">    <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._head = ListNone(elem)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    p.<span class="built_in">next</span> = ListNode(elem)</span><br></pre></td></tr></table></figure><p>这里需要区分两种情况：如果原表为空，引用新结点的就应该是表对象的_head域，否则就是已有的最后结点的next域。两种情况下需要修改的数据域不一样。许多链表变动操作都会遇到这个问题，只有表首端插入&#x2F;删除可以统一处理。</p><p>现在考虑删除表中最后元素的操作，也就是要删除最后的结点。前面说过，要从单链表中删除一个结点，就必须找到它的前一结点。在尾端删除操作里，扫描循环应该找到表中倒数第二个结点，也就是找到<code>p.next.next</code>为None的p。下面定义的<code>pop_last</code>函数不仅删去表中最后元素，还把它返回（与pop统一）。</p><p>在开始一般性扫描之前，需要处理两个特殊情况：如果表空没有可返回的元素时应该引发异常。表中只有一个元素的情况需要特殊处理，因为这时应该修改表头指针。一般情况是先通过循环找到位置，取出最后结点的数据后将其删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop_last</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="literal">None</span>:      <span class="comment"># 空表</span></span><br><span class="line">        <span class="keyword">raise</span> LinkeListUnderflow(<span class="string">&quot;in pop_last&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:          <span class="comment"># 表中只有一个元素</span></span><br><span class="line">        e = p.elem</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 直到p.next是最后结点</span></span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    e = p.<span class="built_in">next</span>.elem</span><br><span class="line">    p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure><p>LList类的下一个方法是找到满足给定条件的表元素。这个方法有一个参数，调用时通过参数提供一个判断谓词，该方法返回第一个满足谓词的表元素。显然，这个操作也需要采用前面的基本扫描模式。定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, pred</span>):</span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> pred(p.elem):</span><br><span class="line">            <span class="keyword">return</span> p.elem</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>最后一个方法非常简单，但实际中可能很有用。在开发一个表类的过程中，人们会经常想看看被操作的表的当时情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_all</span>(<span class="params">self</span>):</span><br><span class="line">    p = self._head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(p.elem, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;, &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 单链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="comment"># item 存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># next 下一个节点的标识</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkList</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取链表长度&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head        <span class="comment"># cur 初始时指向头结点</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:              <span class="comment"># 尾结点指向None，遍历结束</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>      <span class="comment"># 将cur后移一个节点</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)         <span class="comment"># 先创建一个保存 item 值的节点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self._head          <span class="comment"># 将新节点的链接域 next 指向头节点，即 _head 指向的位置</span></span><br><span class="line">        self._head = node               <span class="comment"># 将链表的头 _head 指向新节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="comment"># 若不为空，则找到尾部，将尾结点的 next 指向新节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向链表指定位置添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">            <span class="comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length() - <span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 找到指定位置</span></span><br><span class="line">            pre = self._head    <span class="comment"># pre 用来指向指定位置pos前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            <span class="keyword">while</span> count &lt; pos-<span class="number">1</span>:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">            node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:            <span class="comment"># 找到指定元素</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:                 <span class="comment"># 如果第一个就是删除节点</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span>   <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>     <span class="comment"># 将删除位置的前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 继续后移节点</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表查找节点是否存在，并返回True或者False&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l1 = SingleLinkList()</span><br><span class="line">    l1.add(<span class="number">1</span>)</span><br><span class="line">    l1.add(<span class="number">2</span>)</span><br><span class="line">    l1.append(<span class="number">3</span>)</span><br><span class="line">    l1.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())<span class="comment"># 4</span></span><br><span class="line">    l1.travel()<span class="comment"># 3 -&gt; 4 -&gt; 1 -&gt; 2</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">3</span>))<span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">5</span>))<span class="comment"># False</span></span><br><span class="line">    l1.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())<span class="comment"># 3</span></span><br><span class="line">    l1.travel()<span class="comment"># 3 -&gt; 4 -&gt; 2</span></span><br></pre></td></tr></table></figure><h2 id="2-循环单链表"><a href="#2-循环单链表" class="headerlink" title="2 循环单链表"></a>2 循环单链表</h2><p>单链表的另一常见变形是循环单链表（简称循环链表），其中最后一个结点的next域不用None，而是指向表的第一个结点，如下图a所示。但如果仔细考虑，就会发现在链表对象里记录表尾结点更合适（如下图b），这样可以同时支持 $O(1)$ 时间的表头&#x2F;表尾插入和 $O(1)$ 时间的表头删除。当然，由于循环链表里的结点连成一个圈，哪个结点算是表头或表尾，主要是概念问题，从表的内部形态上无法区分。</p><p>循环单链表操作与普通单链表的差异就在于扫描循环的结束控制。易见，一些不变操作的实现也要修改，如 printall。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.4t7xsu8n7s00.webp#pic_center" width = 64%><p>这种表对象只需一个数据域 _rear，它在逻辑上始终引用着表的尾结点。前端加入结点，就是在尾结点和首结点之间加人新的首结点，尾结点引用不变。通过尾结点引用很容易实现这个操作。另一方面，尾端加入结点也是在原尾结点之后（与首结点之间）插人新结点，只是插入后要把它作为新的尾结点，因此需要更新尾结点引用。这两个操作都要考虑空表插入的特殊情况。对于输出表元素的操作，关键在于循环结束的控制。下面实现中比较扫描指针与表头结点的标识，到达了表头结点就结束。前端弹出操作也很容易实现，后端弹出操作需要通过一个扫描循环确定位置。</p><p>下面循环单链表类定义只实现了几个典型方法，供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 单向循环链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinCycLinkedList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():     <span class="comment"># 如果链表长度为空，返回长度0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="built_in">print</span>(cur.item)</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部添加节点&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head      <span class="comment"># 添加的节点指向_head </span></span><br><span class="line">            cur = self._head            <span class="comment"># 移到链表尾部，将尾部的节点的 next指向node</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="comment"># _head 指向添加的node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部添加节点&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.<span class="built_in">next</span> = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head        <span class="comment"># 移到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node         <span class="comment"># 将尾结点指向node</span></span><br><span class="line">            node.<span class="built_in">next</span> = self._head  <span class="comment"># 将node指向头节点_head</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除一个节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():     <span class="comment"># 若链表为空直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head        <span class="comment"># 将cur指向头节点</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:    <span class="comment"># 若头结点的元素就是要查找的元素item</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> != self._head:  </span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:   <span class="comment"># 先找到尾结点，将尾结点的next指向第二个节点</span></span><br><span class="line">                    cur = cur.<span class="built_in">next</span>      </span><br><span class="line">                cur.<span class="built_in">next</span> = self._head.<span class="built_in">next</span>      <span class="comment"># cur指向了尾结点</span></span><br><span class="line">                self._head = self._head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._head = <span class="literal">None</span>               <span class="comment"># 链表只有一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:        <span class="comment"># 第一个节点不是要删除的</span></span><br><span class="line">                <span class="keyword">if</span> cur.item == item:             <span class="comment"># 找到了要删除的元素</span></span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>          <span class="comment"># 删除</span></span><br><span class="line">                    <span class="keyword">return</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:                <span class="comment"># cur 指向尾结点</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>             <span class="comment"># 尾部删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self._head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l1 = SinCycLinkedList()</span><br><span class="line">    l1.add(<span class="number">1</span>)</span><br><span class="line">    l1.add(<span class="number">2</span>)</span><br><span class="line">    l1.append(<span class="number">3</span>)</span><br><span class="line">    l1.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    l1.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    l1.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())      <span class="comment"># 6</span></span><br><span class="line">    l1.travel()                         <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 6</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">3</span>))                 <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(l1.search(<span class="number">7</span>))                 <span class="comment"># False</span></span><br><span class="line">    l1.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, l1.length())      <span class="comment"># 5</span></span><br><span class="line">    l1.travel()                         <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 6</span></span><br></pre></td></tr></table></figure><h2 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3 双向链表"></a>3 双向链表</h2><p>单链表只有一个方向的链接，只能做一个方向的扫描和逐步操作。即使增加了尾结点引用，也只能支持 $O(1)$ 时间的首端元素加入&#x2F;删除和尾端加入。如果希望两端插入和删除操作都能高效完成，就必须修改结点（从而也是链表）的基本设计，加入另一方向的链接。这样就得到了双向链接表，简称双链表。有了结点之间的双向链接，不仅能支持两端的高效操作，一般结点操作也会更加方便。当然，这样做也需要付出代价：每个结点都需要增加一个链接域,增加的空间开销与结点数成正比，是 $O(n)$。如果每个表结点里的数据规模比较大，新增加的开销可能就显得不太重要了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.29pfjm7l0fr4.webp#pic_center" width = 48%><p>为了支持首尾两端的高效操作，双链表应该采用下图所示的结构，包含一个尾结点引用域。易见，从双链表中任一结点出发，可以直接找到其前后的相邻结点（都是 $O(1)$ 操作）。而对单链表而言，只能方便地找到下一个结点，要找前一结点，就必须从表头开始逐一检查（通过一次扫描）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.585qz3u8lv40.webp#pic_center" width = 36%><p>可以直接找到当前结点的前后结点，使得双链表的许多操作都很容易地进行。下面假定结点的下一结点引用域是next，前一结点引用域是prev。</p><p><strong>结点操作</strong></p><p>先考虑结点删除。实际上，只要掌握着双链表里一个结点，就可以把它从表中取下，并把其余结点正确链接好。下图说明了这个操作。示例代码是：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.6tfs63p4fuk0.webp#pic_center" width = 36%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.prev.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">p.<span class="built_in">next</span>.prev = p.prev</span><br></pre></td></tr></table></figure><p>这两个语句使p所指结点从表中退出，其余结点保持顺序和链接。如果要考虑前后可能无结点的情况，只需增加适当的条件判断。</p><p>在任一结点的前后加入结点的操作也很容易局部完成，只需掌握确定加入位置的这个结点。易见，加入一个结点需要做四次引用赋值。</p><p><strong>指定位置插入节点</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.73x3h4o7cyg0.webp#pic_center" width = 48%><p><strong>完整代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: CarpeDiem</span></span><br><span class="line"><span class="string">@date: 23/2/25</span></span><br><span class="line"><span class="string">@version: 0.1</span></span><br><span class="line"><span class="string">@description: 双向链表的实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;头部插入元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node           <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self._head      <span class="comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            self._head.prev = node      <span class="comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head = node           <span class="comment"># 将_head 指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部插入元素&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node       <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head        <span class="comment"># 移动到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node         <span class="comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            node.prev = cur         <span class="comment"># 将node的prev指向cur</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):      <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            node.prev = cur             <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span>        <span class="comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            cur.<span class="built_in">next</span>.prev = node        <span class="comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node             <span class="comment"># 将cur的next指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> == <span class="literal">None</span>:            <span class="comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                    self._head = <span class="literal">None</span>           <span class="comment"># 如果链表只有这一个节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span>.prev = <span class="literal">None</span>        <span class="comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    self._head = cur.<span class="built_in">next</span>       <span class="comment"># 将_head指向第二个节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span>    <span class="comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.<span class="built_in">next</span>.prev = cur.prev    <span class="comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, ll.length())   <span class="comment"># 6 </span></span><br><span class="line">    ll.travel()                     <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 6</span></span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">3</span>))             <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">4</span>))             <span class="comment"># True</span></span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, ll.length())   <span class="comment"># 5</span></span><br><span class="line">    ll.travel()                     <span class="comment"># 5 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
            <tag> 循环单链表 </tag>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（九）--单调栈与单调队列</title>
      <link href="/article/933f1d8e.html"/>
      <url>/article/933f1d8e.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要以LeetCode上题目为例，合适的数据结构可以有效地降低算法的复杂度，本文分析单调栈和单调队列的使用技巧，以及如何在题目中灵活应用。</p><span id="more"></span><h2 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1 单调栈"></a>1 单调栈</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。</p><p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>用简洁的话来说就是：单调栈就是<font color=#9900CC><strong>栈内元素单调递增或者单调递减</strong></font>的栈，单调栈只能在栈顶操作。</p><p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。</p><p>比如说给一个数组 <code>arr = &#123; 5，4，6，7，2，3，0，1 &#125;</code>，我想知道每一个元素左边比该元素大且离得最近的元素和右边比该元素大且离得最近的元素都是什么。</p><p>如果数组有 $N$ 个元素，经典解法就是来到 $i$ 位置，左边遍历直到比 arr[i] 大的元素为止，右边遍历直到比 arr[i] 大的元素为止。确定一个位置的时间复杂度为 $O(N)$，确定 $N$ 个位置的时间复杂度就是 $O(N^2)$。</p><p>能不能将确定 $N$ 个位置的时间复杂度降到 $O(N)$？单调栈结构。</p><p>同样，如果使用单调栈能够找到每一个元素左边和右边比该元素大且离得最近的元素，同样也能找到每个元素左边和右边比该元素小且离得最近的元素。</p><h3 id="1-2-流程（无重复）"><a href="#1-2-流程（无重复）" class="headerlink" title="1.2 流程（无重复）"></a>1.2 流程（无重复）</h3><p>单调栈本身是支持数组中有重复值的，但是我们为了讲清原理，举得例子中数组是没有重复值的。</p><p>首先，准备一个栈。</p><p> &#x3D;&#x3D; 栈中存储的是数组中元素的下标。为什么不存储元素？是因为下标不仅仅能够表示元素，还能表示元素在数组中的位置，携带的信息更多。&#x3D;&#x3D;</p><p><font color=#9900CC><strong>如果要找到数组中每一个元素左右两边比该元素大且离得最近的元素，那么单调栈要保证从栈底到栈顶存储的下标对应的元素是从大到小的。</strong></font></p><p><font color=#9900CC><strong>如果要找到数组中每一个元素左右两边比该元素小且离得最近的元素，那么单调栈要保证从栈底到栈顶存储的下标对应的元素是从小到大的。</strong></font></p><p>本案例只找比该元素大且离得最近的元素。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6frutsjjfw80.webp#pic_center" width = 64%><p>从头开始遍历数组：</p><ul><li>如果栈中没有元素，直接将元素的下标压栈。</li><li>如果栈中有元素，当前元素和栈顶的下标所指向的元素进行比较：<ul><li>当前元素比栈顶的下标所指向的元素小，将当前元素的下标压栈。</li><li>当前元素比栈顶的下标所指向的元素大，栈顶的下标弹栈，同时记录原栈顶下标对应的元素的信息。原栈顶下标对应的元素左边比该元素大且离得最近的元素就是在栈中原栈顶下标压在下面的相邻下标对应的元素；原栈顶下标对应的元素右边比该元素大且离得最近的元素就是让它的下标弹栈的下标对应的元素。记录完之后，当前元素继续和新栈顶下标对应的元素进行比较。如果栈中只有一个下标，则该下标左边没有比该下标对应的元素大且离得最近的元素，右边正常。</li></ul></li></ul><p>当数组遍历完后，如果栈中还有下标，则进入清算阶段：</p><ul><li>如果不是最后一个下标，依次弹出栈顶下标，原栈顶下标对应的元素左边比该元素大的且离得最近的元素就是在栈中原栈顶下标压在下面的相邻下标；原栈顶下标对应的元素右边没有比该元素大的且离得最近的元素。</li><li>是最后一个下标，弹出该下标，该下标对应的元素没有左边比该元素大的且离得最近的元素，也没有右边没有比该元素大的且离得最近的元素。</li></ul><blockquote><p>设计这种规则实际上就是在严格维护单调栈的单调性。</p></blockquote><h3 id="1-3-流程（有重复）"><a href="#1-3-流程（有重复）" class="headerlink" title="1.3 流程（有重复）"></a>1.3 流程（有重复）</h3><p>假设数组中有重复值，那么单调栈中存储的元素就不能只是一个下标了，可能会存储多个下标，这多个下标对应的数组中的值是一样的。</p><p>因此在实现上，我们偏向去使用一个链表来作为单调栈的元素类型，<font color=#9900CC><strong>同一个链表中所有下标指向的元素值是一样的</font></strong>。</p><p>这种结构可以处理有重复值的数组，也可以处理无重复值的数组，是万能的。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.52rh9uys4zc0.webp#pic_center" width = 64%><p>流程上和无重复的大致相同，区别在于：</p><ul><li>当前元素比栈顶的下标链表所指向的元素大，栈顶的下标链表弹栈，同时记录原栈顶下标链表中每一个下标对应的元素的信息。原栈顶下标链表中每一个下标对应的元素左边比该元素大且离得最近的元素都是在栈中原栈顶下标链表压在下边的相邻下标链表的最后一个下标对应的元素；原栈顶下标链表中每一个下标对应的元素有右边比该元素大且离得最近的元素就是让它的下标链表弹栈的下标链表中的下标对应的元素（此时下标链表中只会有一个元素）。如果栈中只有一个下标链表，则该链表中所有下标左边没有比该下标对应的元素大且离得最近的元素，右边正常。</li><li>当前元素与栈顶的下标链表所指向的元素相等，将该元素对应的下标连接到栈顶的下标链表的末尾。</li></ul><blockquote><p>为什么说使用单调栈可以将时间复杂度降低至 $O(N)$？<br>假设有数组中有 N 个元素，在我们计算出了所有元素的左右边比该元素大或者小且离得最近的元素的整个过程中，无论是使用有重复的模型还是无重复的模型，每一个元素都只进栈一次，出栈一次。</p></blockquote><h3 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h3><p>单调栈最经典的应用，就是在一个数列里寻找距离元素最近的比其大&#x2F;小的元素位置。</p><p>比如以下问题：</p><p>对数列中的每个元素，寻找其左侧第一个比它大的元素位置。</p><p>显而易见的，我们可以遍历每个元素，然后从其位置往左寻找，这样的暴力做法时间复杂度是 $O(n^2)$。</p><p>但单调栈可以将时间复杂度降到 $O(n)$ ————</p><p>我们只需从右往左遍历数列，依次将元素加入单调栈中，维护一个从栈底到栈顶递减的单调栈；</p><p>当某个元素被从栈内弹出时，代表它遇到了一个比它更大的元素，因为是从右往左遍历，所以该元素就是第一个比它大的元素，即所求。</p><p>如果最后仍在栈内，则说明该元素左侧没有比它更大的元素。</p><p>遍历的时间复杂度是 $O(n)$，每个元素最多被加入单调栈一次、弹出来一次，所以总时间复杂度是 $O(n)$。</p><p>对于要求解的这类问题，我们可以列一个简单的表格——</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>求解的问题</th><th>遍历方向</th><th>维护单调性（栈底-&gt;栈顶）</th></tr><tr><td>左侧第一个更大</td><td>从右到左</td><td>单调递减</td></tr><tr><td>左侧第一个更小</td><td>从右到左</td><td>单调递增</td></tr><tr><td>右侧第一个更大</td><td>从左到右</td><td>单调递减</td></tr><tr><td>右侧第一个更小</td><td>从左到右</td><td>单调递增</td></tr></tbody></table><h3 id="1-5-维护单调栈"><a href="#1-5-维护单调栈" class="headerlink" title="1.5 维护单调栈"></a>1.5 维护单调栈</h3><p>单调栈：栈内的元素按照某种方式排序下单调递增或单调递减，如果新入栈的元素破坏的单调性，就弹出栈内元素，直到满足单调性。</p><p>单调栈分为单调递增栈和单调递减栈：</p><ul><li>单调递增栈：栈中数据出栈的序列为单调递减序列；</li><li>单调递减栈：栈中数据出栈的序列为单调递增序列。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.2p0tvz21vwo0.webp#pic_center" width = 48%><p><strong>(1) 维护单调递增栈</strong></p><ul><li>遍历数组中每一个元素，执行入栈：每次入栈前先检验栈顶元素和进栈元素的大小。</li><li>如果栈空或进栈元素大于栈顶元素则直接入栈；如果进栈元素小于等于栈顶元素，则出栈，直至进栈元素大于栈顶元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monostoneStack</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = 定义一个长度和 arr 一样长的数组，并初始化为 -<span class="number">1</span></span><br><span class="line">        循环 i <span class="keyword">in</span>  arr:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &lt; arr[栈顶元素]:</span><br><span class="line">                peek = 弹出栈顶元素</span><br><span class="line">                ans[peek] = i - peek</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>(2) 维护单调递减栈</strong></p><ul><li>遍历数组中每一个元素，执行入栈：每次入栈前先检验栈顶元素和进栈元素的大小。</li><li>如果栈空或进栈元素小于栈顶元素则直接入栈；如果进栈元素大于等于栈顶元素，则出栈，直至进栈元素小于栈顶元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monostoneStack</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = 定义一个长度和 arr 一样长的数组，并初始化为 -<span class="number">1</span></span><br><span class="line">        循环 i <span class="keyword">in</span>  arr:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &gt; arr[栈顶元素]:</span><br><span class="line">                peek = 弹出栈顶元素</span><br><span class="line">                ans[peek] = i - peek</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h2 id="2-单调队列"><a href="#2-单调队列" class="headerlink" title="2 单调队列"></a>2 单调队列</h2><p>单调队列：队列中元素之间的关系具有单调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。</p><p>队尾入队的时候维护单调性：</p><ul><li>对于单调递增队列，设当前准备入队的元素为 e，从队尾开始把队列中的元素逐个与 e 对比，把比 e 大或者与 e 相等的元素逐个删除，直到遇到一个比 e 小的元素或者队列为空为止，然后把当前元素 e 插入到队尾。</li><li>对于单调递减队列也是同样道理，只不过从队尾删除的是比 e 小或者与 e 相等的元素。</li></ul><p>若队列有大小限制，则每次插入新元素的时候，需要从队头开始弹出元素，直到队列至少有一个空间留给当前元素。</p><p>举例来说，nums&#x3D;[3,2,8,4,5,7,6,4]，初始时，deque&#x3D;[]，限制队列长度不能超过 3，维护一个单增队列，</p><ul><li>3入队：$deque&#x3D;[3]$；</li><li>3从队尾出队，2 入队：deque&#x3D;[2]；</li><li>8入队：ddeque&#x3D;[2,8]；</li><li>8从队尾出队，4入队：deque&#x3D;[2,4]；</li><li>5入队：deque&#x3D;[2,4,5]；</li><li>2从队头出队，7入队：deque&#x3D;[4,5,7]；</li><li>7从队尾出队，6入队：deque&#x3D;[4,5,6]；</li><li>6从队尾出队，5从队尾出队，4从队尾出队，4入队：deque&#x3D;[4]。</li></ul><p>单调队列的作用：区间最小（最大）值问题、优化动态规划、优化多重背包</p><p><strong>单调栈和单调队列的区别和联系</strong></p><p><strong>相同点</strong></p><ul><li>单调队列和单调栈的“头部”都是最先添加的元素，“尾部”都是最后添加的元素。</li><li>递增和递减的判断依据是：从栈底（队尾）到栈顶（队首），元素大小的变化情况。队列和栈是相反的。</li><li>操作非常相似。当队列长度为无穷大时，递增的单调队列和递减的单调栈，排列是一样的！这是因为，长度为无穷大的的队列不会在“头部”有出队操作，而在“尾部”的操作是一模一样的：数据都从“尾部”进入，并按照相同的规则进行比较。</li><li>两者维护的时间复杂度都是O(n)，因为每个元素都只操作一次。</li></ul><p><strong>区别</strong></p><ul><li>队列可以从队列头弹出元素，可以方便地根据入队的时间顺序（访问的顺序）删除元素。这样导致了单调队列和单调栈维护的区间不同。当访问到第i个元素时，单调栈维护的区间为[0, i)，而单调队列维护的区间为(lastpop, i)</li><li>单调队列可以访问“头部”和“尾部”，而单调栈只能访问栈顶（也就是“尾部”）。这导致单调栈无法获取[0, i)的区间最大值&#x2F;最小值。</li></ul><p>综上所述，单调队列实际上是单调栈的的升级版。单调栈只支持访问尾部，而单调队列两端都可以。</p><hr><h2 id="3-真题演练"><a href="#3-真题演练" class="headerlink" title="3 真题演练"></a>3 真题演练</h2><h3 id="3-1-单调栈"><a href="#3-1-单调栈" class="headerlink" title="3.1 单调栈"></a>3.1 单调栈</h3><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>496</td><td><a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank">下一个更大元素 I</a>（简单）</td></tr><tr><td>503</td><td><a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank">下一个更大元素 II</a>（中等）</td></tr><tr><td>739</td><td><a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank">每日温度</a>（中等）</td></tr><tr><td>901</td><td><a href="https://leetcode.cn/problems/online-stock-span/description/?orderBy=most_votes" target="_blank">股票价格跨度</a>（中等）</td></tr><tr><td>962</td><td><a href="https://leetcode.cn/problems/online-stock-span/description/?orderBy=most_votes" target="_blank">最大宽度坡</a>（中等）</td></tr><tr><td>1019</td><td><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/description/?orderBy=most_votes" target="_blank">链表中的下一个更大节点</a>（中等）</td></tr><tr><td>42</td><td><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank">接雨水</a>（困难）</td></tr><tr><td>84</td><td><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank">柱状图中最大的矩形</a>（困难）</td></tr><tr><td>402</td><td><a href="https://leetcode.cn/problems/remove-k-digits/" target="_blank">移掉 K 位数字</a>（中等）</td></tr><tr><td>316</td><td><a href="https://leetcode.cn/problems/remove-duplicate-letters/" target="_blank">去除重复字母</a>（中等）</td></tr><tr><td>321</td><td><a href="https://leetcode.cn/problems/create-maximum-number/" target="_blank">拼接最大数</a>（困难）</td></tr></tbody></table><p><strong>496. 下一个更大元素 I</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.asr38dfoh7s.webp#pic_center" width = 64%><p><strong>1. 暴力法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        res = [<span class="number">0</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            j = nums2.index(nums1[i])</span><br><span class="line">            k = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; n <span class="keyword">and</span> nums2[k] &lt; nums2[j]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            res[i] = nums2[k] <span class="keyword">if</span> k &lt; n <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>2. 单调栈 + 哈希表</strong></p><p><strong>方式一：借助栈，正序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        <span class="comment"># 因为题目说了没有重复元素，因此可以使用字典来维护元素的下一个更大元素：key-元素，value-下一个更大的元素</span></span><br><span class="line">        hash_map, stack = &#123;&#125;, []        <span class="comment"># 单调递减栈：用于找到下一个更大的元素</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:       <span class="comment"># 单调栈</span></span><br><span class="line">                    hash_map[stack.pop()] = num</span><br><span class="line">                stack.append(num)                          </span><br><span class="line">        <span class="keyword">return</span> [hash_map.get(num, -<span class="number">1</span>) <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.123pvd91gnjk.gif#pic_center" width = 48%><p><strong>方式二：借助栈，逆序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res, stack = &#123;&#125;, []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2):         <span class="comment"># 由于是逆序遍历，所以栈中元素不可能是其之前某个元素的，下一个更大元素，所以将栈中元素清空</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            res[num] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(num)</span><br><span class="line">        <span class="keyword">return</span> [res[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.5kieuxflzjs0.gif#pic_center" width = 48%><p><strong>503. 下一个更大元素 II</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.6e436x1e73k0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span>]*length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length*<span class="number">2</span>):       <span class="comment"># 变为2倍模拟循环数组</span></span><br><span class="line">            ind = i % length</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[-<span class="number">1</span>]] &lt; nums[ind]:</span><br><span class="line">                res[stack.pop()] = nums[ind]</span><br><span class="line">            stack.append(ind)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.6092mqg90qo0.gif#pic_center" width = 48%><p><strong>739. 每日温度</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.2c0qd4k0b8lc.webp#pic_center" width = 64%><p><strong>方式一：单调栈 正序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []           <span class="comment"># 这里定义一个栈就不用说了</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(T)   <span class="comment"># 这里是最后要返回的result，因为题目中说没有匹配的就返回0，</span></span><br><span class="line">                             <span class="comment"># 所以这里初始化一个全是0的list，然后把那些有匹配的替换掉即可。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):  <span class="comment"># 下面是关键</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> t &gt; T[stack[-<span class="number">1</span>]]:       <span class="comment"># 当stack为空时，运行stack.append(idx)，则stack=[0]</span></span><br><span class="line">                                                    <span class="comment"># 然后仅当遍历元素 t 小于stack顶端的值时append进去，</span></span><br><span class="line">                                                    <span class="comment"># 这会导致stack中idx代表的元素是单调递减的，</span></span><br><span class="line">                                                    <span class="comment"># 如果此时遍历到一个 t，大于stack顶端的值，那这个t就是离stack</span></span><br><span class="line">                                                    <span class="comment"># 顶端值最近的那个大值。</span></span><br><span class="line">                res[stack.pop()] = idx-stack[-<span class="number">1</span>]    <span class="comment"># 然后pop出来，还是要注意stack.pop出来的是idx，这样res这</span></span><br><span class="line">                                                    <span class="comment"># 一串0里对应位置的0就会被替换成应有的值。                                        </span></span><br><span class="line">                                                    <span class="comment"># 再进入while循环判断t和stack.pop后的新的顶端值哪个大。</span></span><br><span class="line">                                                    <span class="comment"># 如此反复。</span></span><br><span class="line">            stack.append(idx)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.3274dsdu1j4.gif#pic_center" width = 48%><p><strong>901. 股票价格跨度</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.1rw1cbbrzygw.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 单调递减栈：存放元素及其跨度</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>] &lt;= price:</span><br><span class="line">            <span class="comment"># 找到了一个递增对，将其出栈（因为其历史跨度已经记录在了下一个元素中），并将其跨度叠加</span></span><br><span class="line">            cnt += self.stack.pop()[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        self.stack.append((price, cnt))     <span class="comment"># 保持元素及其跨度，便于下一次直接计算历史跨度</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.2i81r4pw2cm0.webp#pic_center" width = 48%><p><strong>962. 最大宽度坡</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.5xowsdt924k0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxWidthRamp</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> A[stack[-<span class="number">1</span>]] &gt; A[i]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="built_in">print</span>(stack)</span><br><span class="line">        i0 = stack[<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># while i &gt; res:  # 当res大于等于i时没必要继续遍历了 </span></span><br><span class="line">        <span class="keyword">while</span> i-i0 &gt; res:  <span class="comment"># 这样更快一点 </span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[stack[-<span class="number">1</span>]] &lt;= A[i]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - stack[-<span class="number">1</span>])</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="comment"># print(i,res)</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1019. 链表中的下一个更大节点</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.3b25ki2y4rw0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextLargerNodes</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        st = []  <span class="comment"># 单调栈（节点值，节点下标）</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> st[-<span class="number">1</span>][<span class="number">0</span>] &lt; head.val:</span><br><span class="line">                ans[st.pop()[<span class="number">1</span>]] = head.val  <span class="comment"># 用当前节点值更新答案</span></span><br><span class="line">            st.append((head.val, <span class="built_in">len</span>(ans)))  <span class="comment"># 当前 ans 的长度就是当前节点的下标</span></span><br><span class="line">            ans.append(<span class="number">0</span>)  <span class="comment"># 占位</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>42. 接雨水</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.2o5f4lad8ua0.webp#pic_center" width = 64%><p><strong>方法一：单调栈</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">while</span>  stack <span class="keyword">and</span> height[stack[-<span class="number">1</span>]] &lt; height[i]:</span><br><span class="line">                cur_ind = stack.pop()</span><br><span class="line">                <span class="comment"># 如果栈顶元素一直相等，那么全都pop出去，只留第一个。</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[-<span class="number">1</span>]] == height[cur_ind]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">if</span>  stack:</span><br><span class="line">                    stack_top = stack[-<span class="number">1</span>] <span class="comment"># stack_top 此时指向的是此次接住的雨水的左边界的位置。右边界是当前的柱体，即i。</span></span><br><span class="line">                    <span class="comment"># i - stack_top - 1 是雨水的宽度, min(height[stack_top], height[i]) 是左右柱子高度的min，减去height[cur_ind]就是雨水的高度。</span></span><br><span class="line">                    ans += (<span class="built_in">min</span>(height[stack_top], height[i])-height[cur_ind])*(i-stack_top-<span class="number">1</span>)</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.54qo3f432j40.gif#pic_center" width = 48%><p><strong>84. 柱状图中最大的矩形</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.21wii559t5xc.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [n] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                right[mono_stack[-<span class="number">1</span>]] = i</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.19msfwnlxcu8.gif#pic_center" width = 48%><p><strong>402. 移掉 K 位数字</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.1jfahdm1bgao.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num, k</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        remain = <span class="built_in">len</span>(num) - k</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>316. 去除重复字母</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.3hso6bvmdlk0.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        remain_counter = collections.Counter(s)         <span class="comment"># 第 1 步：记录每个字符出现的次数</span></span><br><span class="line">        stack = []      <span class="comment"># 第 2 步：使用栈得到题目要求字典序最小的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> ch &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            remain_counter[ch] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)       <span class="comment"># 第 3 步：此时 stack 就是题目要求字典序最小的字符串</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.1g9rfsqh3gow.webp#pic_center" width = 48%><p><strong>321. 拼接最大数</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.2w1oos6zxni0.webp#pic_center" width = 64%><p><strong>方式一：单调栈合并 &amp;&amp; 比较</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumber</span>(<span class="params">self, nums1, nums2, k</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pick_max</span>(<span class="params">nums, k</span>):</span><br><span class="line">            stack = []</span><br><span class="line">            drop = <span class="built_in">len</span>(nums) - k</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    drop -= <span class="number">1</span></span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">return</span> stack[:k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, B</span>):</span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">                bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">                ans.append(bigger.pop(<span class="number">0</span>))           <span class="comment"># 把最大的取出来</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(merge(pick_max(nums1, i), pick_max(nums2, k-i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>) <span class="keyword">if</span> i &lt;= <span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i &lt;= <span class="built_in">len</span>(nums2))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.179bmzpcvvb4.gif#pic_center" width = 48%><p><strong>456. 132 模式</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.3qnau6nfxqo0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find132pattern</span>(<span class="params">self, nums</span>):</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        left_min = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            left_min[i] = <span class="built_in">min</span>(left_min[i - <span class="number">1</span>], nums[i - <span class="number">1</span>])</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            mask = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; nums[j]:</span><br><span class="line">                mask = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> left_min[j] &lt; mask:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            stack.append(nums[j])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.777nasb9srs0.gif#pic_center" width = 48%><h3 id="3-2-单调队列"><a href="#3-2-单调队列" class="headerlink" title="3.2 单调队列"></a>3.2 单调队列</h3><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>面试题 59-II</td><td><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank"> 队列的最大值</a>（单调队列模板题）</td></tr><tr><td>239</td><td><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank">滑动窗口最大值</a></td></tr><tr><td>862</td><td><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" target="_blank">和至少为 K 的最短子数组</a></td></tr><tr><td>1438</td><td><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank">绝对差不超过限制的最长连续子数组</a></td></tr></tbody></table><p><strong>面试题 59-II. 队列的最大值</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.22t7cg39y7nk.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line">        self.deque = queue.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.deque[<span class="number">0</span>] <span class="keyword">if</span> self.deque <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_back</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue.put(value)</span><br><span class="line">        <span class="keyword">while</span> self.deque <span class="keyword">and</span> self.deque[-<span class="number">1</span>] &lt; value:</span><br><span class="line">            self.deque.pop()</span><br><span class="line">        self.deque.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.queue.empty(): <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        val = self.queue.get()</span><br><span class="line">        <span class="keyword">if</span> val == self.deque[<span class="number">0</span>]:</span><br><span class="line">            self.deque.popleft()</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.5teiox96nts0.gif#pic_center" width = 48%><p><strong>239. 滑动窗口最大值</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.6zsm28b3g5s0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line"></span><br><span class="line">        ans = [nums[q[<span class="number">0</span>]]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            ans.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.1hwxt0mbht28.gif#pic_center" width = 48%><hr><blockquote><p><font color=#9900CC><strong>单调栈和单调队列暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.njs5lj3nf8.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>【数据结构与算法】单调栈详解：<a href="https://juejin.cn/post/7019648593694818334">https://juejin.cn/post/7019648593694818334</a></li><li>数据结构-单调栈：<a href="https://zhuanlan.zhihu.com/p/344988226">https://zhuanlan.zhihu.com/p/344988226</a></li><li>leetcode-屡试不爽的单调（递增\递减）栈：<a href="https://www.jianshu.com/p/f593d56adee7">https://www.jianshu.com/p/f593d56adee7</a></li><li>单调栈与单调队列算法详解及LeetCode经典题目（Python）：<a href="https://blog.csdn.net/Hanx09/article/details/108434955">https://blog.csdn.net/Hanx09/article/details/108434955</a></li><li>单调队列&#x2F;栈从入门到入土：<a href="https://www.cnblogs.com/wsyunine/p/14851199.html">https://www.cnblogs.com/wsyunine/p/14851199.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（八）-- 队列的实现与应用</title>
      <link href="/article/1515a7fd.html"/>
      <url>/article/1515a7fd.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要介绍Python数据结构篇队列和双端队列的定义与实现，最后用经典的约瑟夫问题和回文词判定来演示队列的应用。</p><span id="more"></span><h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1 队列"></a>1 队列</h2><h3 id="1-1-简单队列"><a href="#1-1-简单队列" class="headerlink" title="1.1 简单队列"></a>1.1 简单队列</h3><p>队列是一种有次序的数据集合，其特征是新数据项的添加总发生在一端（通常称为“尾rear”端）；而现存数据项的移除总发生在另一端（通常称为“首front”端）。当一个元素被加入到队列之后，它就从队尾开始向队首前进，直到它成为下一个即将被移出队列的元素。</p><p>最新被加入的元素必须处于队尾，在队列停留最长时间的元素处于队首。这种原则有时候叫做“先进先出”（FIFO, first-in first-out），有时候也叫做“先到先服务”。</p><h3 id="1-2-双端队列"><a href="#1-2-双端队列" class="headerlink" title="1.2 双端队列"></a>1.2 双端队列</h3><p>双端队列（deque 或 double-ended queue）与队列类似，也是一系列元素的有序组合。其两端称为队首（front）和队尾（rear），元素在到达两端之前始终位于双端队列中。与队列不同的是，双端队列对元素添加和删除的限制不那么严格，元素可以从两端插入，也可以从两端删除。可以说，双端队列这种混合的线性数据结构拥有栈和队列各自拥有的所有功能。图3是一个由Python数据对象构成的双端队列。 应当指出，&#x3D;&#x3D;双端队列虽然具备栈和队列的许多特征，但其中的数据项不满足严格的“后进先出”或“先进先出”顺序，这使得插入和删除操作的规律性需要由用户自己维持。&#x3D;&#x3D;</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.11q15o2dt6y8.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.11q15o2dt6y8.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=48%><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图3 一个由 Python 数据对象构成的双端队列</div> </center><h2 id="2-队列的抽象数据类型"><a href="#2-队列的抽象数据类型" class="headerlink" title="2 队列的抽象数据类型"></a>2 队列的抽象数据类型</h2><h3 id="2-1-简单队列"><a href="#2-1-简单队列" class="headerlink" title="2.1 简单队列"></a>2.1 简单队列</h3><p>抽象数据类型队列通过以下的一些结构和操作来定义。如前文所述，一个队列由一系列有序的元素构成，它们从叫做“队尾”的一端进入队列，再从叫做“队首”的另一端被移出队列。队列保持“先进先出”的特性。下面是队列的一些操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue()：创建一个空队列对象，返回值为Queue对象；</span><br><span class="line">enqueue(item)：将数据项item添加到队尾，无返回值；</span><br><span class="line">dequeue()：从队首移除数据项，返回值为队首数据项，队列被修改；</span><br><span class="line">isEmpty()：测试是否空队列，返回值为布尔值</span><br><span class="line">size()：返回队列中数据项的个数。</span><br></pre></td></tr></table></figure><p>我们需要决定列表的哪一端做队尾，哪一端用来做队首。下面的一段代码设定队列的队尾在列表的0位置。这使得我们能够利用列表的insert 功能来向队列的队尾添加新的元素。而pop操作则可以用来移除队首的元素（也就是列表的最后一个元素）。这也意味着enqueue的复杂度是O(n)，而dequeue的复杂度是O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, item</span>):        <span class="comment"># 复杂度O(n)</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):      <span class="comment"># 复杂度O(1)</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><h2 id="2-2-双端队列"><a href="#2-2-双端队列" class="headerlink" title="2.2 双端队列"></a>2.2 双端队列</h2><p>双端队列的定义的操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque()：创建一个空双端队列</span><br><span class="line">addFront(item)：将item加入队首</span><br><span class="line">addRear(item)：将item加入队尾</span><br><span class="line">removeFront()：从队首移除数据项，返回值为移除的数据项</span><br><span class="line">removeRear()：从队尾移除数据项，返回值为移除的数据项</span><br><span class="line">isEmpty()：返回deque是否为空</span><br><span class="line">size()：返回deque中包含数据项的个数</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><h2 id="3-队列的应用"><a href="#3-队列的应用" class="headerlink" title="3 队列的应用"></a>3 队列的应用</h2><h3 id="3-1-热土豆问题"><a href="#3-1-热土豆问题" class="headerlink" title="3.1 热土豆问题"></a>3.1 热土豆问题</h3><p>首先，让我们来考虑一个叫做热土豆的儿童游戏。在这个游戏中（见图1）小孩子们围成一个圆圈并以最快的速度接连传递物品，并在游戏的一个特定时刻停止传递，这时手中拿着物品的小孩就离开圆圈，游戏进行至只剩下一个小孩。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.43fpvi3k4ju0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.43fpvi3k4ju0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图1 六人传土豆游戏</div> </center><p>现在，我们也将热土豆问题称作Josephus问题。这个故事是关于公元1世纪著名历史学家Flavius Josephus 的，传说在犹太民族反抗罗马统治的战争中，Josephus 和他的39个同胞在一个洞穴中与罗马人相对抗。当注定的失败即将来临之时，他们决定宁可死也不投降罗马。于是他们围成一个圆圈，其中一个人被指定为第一位然后他们按照顺时针进行计数，每数到第七个人就把他杀死。传说中Josephus 除了熟知历史之外还是一个精通于数学的人。他迅速找出了那个能留到最后的位置。最后一刻，他没有选择自杀而是加入了罗马的阵营。这个故事还有许多不同的版本。有些是以三为单位进行计数，有些则是让最后一个留下的骑马逃走。但不管是哪个版本，其核心原理都是一致的。</p><p>求解思路：1）模拟程序采用队列来存放所有参加游戏的人名，按照传递土豆方向从队首排到队尾；游戏时，队首始终是持有土豆的人。2）模拟游戏开始，只需要将队首的人出队，随即再到队尾入队，算是土豆的一次传递；传递了num次后，将队首的人移除，不再入队如此反复，直到队列中剩余1人。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.18ra4wy738n4.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.18ra4wy738n4.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">图2 用队列模拟热土豆问题</div> </center><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hot_potato</span>(<span class="params">namelist, nums</span>):</span><br><span class="line">    sim_queue = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> namelist:</span><br><span class="line">        sim_queue.enqueue(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> sim_queue.size() &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">            sim_queue.enqueue(sim_queue.dequeue())</span><br><span class="line">        sim_queue.dequeue()</span><br><span class="line">    <span class="keyword">return</span> sim_queue.dequeue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hot_potato([<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Susan&quot;</span>, <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Kent&quot;</span>, <span class="string">&quot;Brad&quot;</span>], <span class="number">7</span>))</span><br></pre></td></tr></table></figure><h3 id="3-2-回文词判定"><a href="#3-2-回文词判定" class="headerlink" title="3.2 回文词判定"></a>3.2 回文词判定</h3><p>一个能用双端队列数据结构轻松解决的问题是经典的“回文词”问题。回文词指的是正读和反读都一样的词，如：radar、toot 和madam。我们想要编写一个算法来检查放入的字符串是否为回文词。</p><p>这个问题的解决方案是用一个双端队列来存储这个字符串。我们遍历这个字符串并把它的每个字母添加到双端队列的尾端。现在这个双端队列看起来非常像一个普通队列，但我们可以利用双端队列两端的对称性。双端队列的首端用来存储第一个字符，尾端用来存储最后一个字符。(如下图所示)<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.1utvwd5eu35s.webp#pic_center" width = 36%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palchecker</span>(<span class="params">aString</span>):</span><br><span class="line">    chardeque = Deque()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> aString:</span><br><span class="line">        chardeque.addRear(ch)</span><br><span class="line">    stillEqual = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> chardeque.size() &gt; <span class="number">1</span> <span class="keyword">and</span> stillEqual:</span><br><span class="line">        first = chardeque.removeFront()</span><br><span class="line">        last = chardeque.removeRear()</span><br><span class="line">        <span class="keyword">if</span> first != last:</span><br><span class="line">            stillEqual = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stillEqual</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(palchecker(<span class="string">&quot;lsdkjfskf&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(palchecker(<span class="string">&quot;radar&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（七）-- 栈的实现与应用</title>
      <link href="/article/fa4199ab.html"/>
      <url>/article/fa4199ab.html</url>
      
        <content type="html"><![CDATA[<p>本节主要学习栈的抽象数据类型，主要包括出栈、进栈、栈的大小、栈顶元素、栈是否为空，最后实现括号匹配和十进制转换为二进制来理解栈的反转次序、先进后出的特性。</p><span id="more"></span><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h2><p>堆栈是一种特殊的抽象数据结构或者组合，其主要的操作为将元素从头部加入栈中，称为进栈和将头部元素移除，称为出栈。</p><p>一个栈（有时称“叠加栈”）是一个项的有序集合。添加项和移除项都发生在同一“端”。这一端通常被称为“顶”。另一端的顶部被称为“底”。</p><p>栈的“底”是有标志性的，因为存储在栈中更靠近“底”的项就是栈中储存时间最长的项。最新添加的项在移除项时也会第一个被移除。这种排序原则有时也称为LIFO(LIFO-Last-In-First-Out)法，也就是“后进先出”。项的排序基于它在集合中存在的时间长度。越新的项越靠近“顶”，越老的项越靠近“底”。如下图所示，堆栈是一种LIFO的数据结构。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.4iakphln4ws0.gif#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.4iakphln4ws0.gif#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%><p><strong>小结：</strong> 栈Stack ：栈顶和栈底，栈的特性：反转次序，后进先出（主要应用：网页、word编辑）</p><h2 id="2-栈的抽象数据类型"><a href="#2-栈的抽象数据类型" class="headerlink" title="2 栈的抽象数据类型"></a>2 栈的抽象数据类型</h2><p>栈的抽象数据类型是由以下结构和操作定义的。抽象数据类型“栈”定义为如下的操作：（默认左端为栈底，右端为栈顶）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack( )：创建一个空栈，不包含任何数据项</span><br><span class="line">push(item)：将item加入栈顶，无返回值，append()</span><br><span class="line">pop( )：将栈顶数据项移除，并返回，栈被修改pop()</span><br><span class="line">peek( )：“窥视” 栈顶数据项，返回栈顶的数据项但不移除，栈不被修改。</span><br><span class="line">isEmpty( )：返回栈是否为空栈</span><br><span class="line">size( )：返回栈中有多少个数据项。不需要参数，返回一个整数。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化栈为空列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 出栈</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;pop from an empty stack&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 是否为空栈，返回布尔值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回栈顶元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回元素数目</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化一个栈对象</span></span><br><span class="line">    my_stack = Stack()</span><br><span class="line">    my_stack.push(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    my_stack.push(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(my_stack.size())</span><br><span class="line">    <span class="built_in">print</span>(my_stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(my_stack.peek())</span><br></pre></td></tr></table></figure><h2 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3 栈的应用"></a>3 栈的应用</h2><h3 id="3-1-括号匹配"><a href="#3-1-括号匹配" class="headerlink" title="3.1 括号匹配"></a>3.1 括号匹配</h3><p>问题描述：括号的使用必须遵循“平衡”规则，即每个开括号要恰好对应一个闭括号，其次每对开闭括号要正确的嵌套。如下：</p><ul><li>正确的括号：(()()()())，(((())))，(()((())()))</li><li>错误的括号：((((((())，()))，(()()(()</li></ul><p>思考：从左到右扫描括号串，最新打开的左括号，应该匹配最先遇到的右括号，这样，第一个左括号（最早打开），就应该匹配最后一个右括号（最后遇到），体现了次序反转的识别，正好符合栈的特性。</p><p>实现流程如下：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.2lczj1z4wg80.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.2lczj1z4wg80.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">算法流程图</div> </center><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">par_checker</span>(<span class="params">symbol_string</span>):</span><br><span class="line">    new_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> symbol_string:</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            new_stack.push(item)</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> new_stack.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            new_stack.pop()</span><br><span class="line">    <span class="keyword">return</span> new_stack.is_empty()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;((()))&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;((())&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;(()))&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;())&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在实际的应用里，我们会碰到更多种括号，如python中列表所用的方括号“[]”，字典所用的花括号“{}”，元组和表达式所用的圆括号“()”。这些不同的括号有可能混合在一起使用，要注意各自的开闭匹配问题。</p><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">par_checker</span>(<span class="params">symbol_string</span>):</span><br><span class="line">    par_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> symbol_string:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> <span class="string">&#x27;([&#123;&#x27;</span>:</span><br><span class="line">            par_stack.push(item)</span><br><span class="line">        <span class="keyword">elif</span> item <span class="keyword">in</span> <span class="string">&#x27;)]&#125;&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> par_stack.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                close = par_stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matches(close, item):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> par_stack.is_empty()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matches</span>(<span class="params"><span class="built_in">open</span>, close</span>):</span><br><span class="line">    opens = <span class="string">&#x27;([&#123;&#x27;</span></span><br><span class="line">    closers = <span class="string">&#x27;)]&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> opens.index(<span class="built_in">open</span>) == closers.index(close)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;&#123;&#123;([][])&#125;()&#125;&#x27;</span>))          <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(par_checker(<span class="string">&#x27;[&#123;()]&#x27;</span>))                 <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="3-2-进制转换"><a href="#3-2-进制转换" class="headerlink" title="3.2 进制转换"></a>3.2 进制转换</h3><p>十进制转换为二进制，采用的是“除以2求余数”的算法，将整数不断除以2，每次得到的余数就是由低到高的二进制位，“除以2”的过程，得到的余数是从低到高的次序，而输出则是从高到低，所以需要一个栈来反转次序。<br><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.5fau748xve40.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.5fau748xve40.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%></p><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_by_2</span>(<span class="params">dec_number</span>):</span><br><span class="line">    number_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">while</span> dec_number:</span><br><span class="line">        number_stack.push(dec_number % <span class="number">2</span>)</span><br><span class="line">        dec_number = dec_number // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    output_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> number_stack.is_empty():</span><br><span class="line">        output_string += <span class="built_in">str</span>(number_stack.pop())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(divide_by_2(<span class="number">42</span>))          <span class="comment"># 101010</span></span><br><span class="line">    <span class="built_in">print</span>(divide_by_2(<span class="number">156</span>))         <span class="comment"># 10011100</span></span><br><span class="line">    <span class="built_in">print</span>(divide_by_2(<span class="number">463</span>))         <span class="comment"># 111001111</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>十进制转换为二进制的算法，很容易可以扩展为转换到任意N进制，只需要将“除以2求余数”算法改为“除以N求余数”算法就可以。</p><p><strong>参考代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">base_converter</span>(<span class="params">dec_number, base</span>):</span><br><span class="line">    digits = <span class="string">&#x27;0123456789ABCDEF&#x27;</span></span><br><span class="line">    number_stack = stack.Stack()</span><br><span class="line">    <span class="keyword">while</span> dec_number:</span><br><span class="line">        number_stack.push(dec_number % base)</span><br><span class="line">        dec_number = dec_number // base</span><br><span class="line"></span><br><span class="line">    output_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> number_stack.is_empty():</span><br><span class="line">        output_string += digits[number_stack.pop()]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(base_converter(<span class="number">152</span>, <span class="number">2</span>))       <span class="comment"># 10011000</span></span><br><span class="line">    <span class="built_in">print</span>(base_converter(<span class="number">152</span>, <span class="number">8</span>))       <span class="comment"># 230</span></span><br><span class="line">    <span class="built_in">print</span>(base_converter(<span class="number">152</span>, <span class="number">16</span>))      <span class="comment"># 98</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（六）-- 哈希表</title>
      <link href="/article/83d55e57.html"/>
      <url>/article/83d55e57.html</url>
      
        <content type="html"><![CDATA[<p>散列表（hash table），又名‘hash表’，它用的是数组支持按照下标随机访问数据（时间复杂度O(1)）的特性，散列表其实就是基于数组结构的一种扩展。散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据，所以我们常常会将散列表和链表（或者跳表）结合在一起使用。</p><span id="more"></span><h2 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1 哈希表"></a>1 哈希表</h2><p>散列表（hash table），又名‘hash表’，它用的是数组支持按照下标随机访问数据（时间复杂度O(1)）的特性，所以散列表其实就是基于数组结构的一种扩展。简单的来说，就是把键值通过散列函数求得hash值之后，对数组容量进行取模运算，得到存放在数组位置的下标值，当我们按照键值查询元素时，我们用同样的方法将键值转化数组下标，从对应的数组下标的位置取数据。散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们常常会将散列表和链表（或者跳表）结合在一起使用。</p><h3 id="1-1-什么是哈希表"><a href="#1-1-什么是哈希表" class="headerlink" title="1.1 什么是哈希表"></a>1.1 什么是哈希表</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key和value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><ul><li>哈希函数（Hash Function）：将哈希表中元素的关键键值映射为元素存储位置的函数。</li><li>哈希冲突（Hash Collision）：不同的关键字通过同一个哈希函数可能得到同一哈希地址。</li></ul><p>哈希表的两个核心问题是：「哈希函数的构建」 和 「哈希冲突的解决方法」。</p><p>常用的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。</p><p>常用的哈希冲突的解决方法有两种：开放地址法和链地址法。</p><p>有两种不同类型的哈希表：哈希集合和哈希映射。</p><ul><li>哈希集合是集合数据结构的实现之一，用于存储非重复值。</li><li>哈希映射是映射数据结构的实现之一，用于存储(key, value)键值对。</li></ul><p>在标准模板库的帮助下，哈希表是易于使用的。大多数常见语言（如Java，C ++ 和 Python）都支持哈希集合和哈希映射。通过选择合适的哈希函数，哈希表可以在插入和搜索方面实现出色的性能。</p><blockquote><p>Python 将哈希表用于字典和集合。 哈希表是键值对的无序集合，其中每个键都是唯一的。 哈希表提供了有效的查找，插入和删除操作的组合。 这些是数组和链接列表的最佳属性。<font color=#9900CC><strong>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。</font></strong></p></blockquote><h3 id="1-2-哈希表的原理"><a href="#1-2-哈希表的原理" class="headerlink" title="1.2 哈希表的原理"></a>1.2 哈希表的原理</h3><p>哈希表是一种数据结构，它使用哈希函数组织数据，以支持快速插入和搜索。哈希表的核心思想就是使用哈希函数将键映射到存储桶。更确切地说：</p><ul><li>当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；</li><li>当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</li></ul><p>下面举一个简单的例子，我们来理解下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.6c1crf69aic0.webp#pic_center" width = 48%><p>在示例中，我们使用 $y &#x3D; x ％ 5$ 作为哈希函数。让我们使用这个例子来完成插入和搜索策略：</p><ul><li>插入：我们通过哈希函数解析键，将它们映射到相应的桶中。 例如，1987 分配给桶 2，而 24 分配给桶 4。</li><li>搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索。 例如，如果我们搜索 23，将映射 23 到 3，并在桶 3 中搜索。我们发现 23 不在桶 3 中，这意味着 23 不在哈希表中。</li></ul><h3 id="1-2-设计哈希函数"><a href="#1-2-设计哈希函数" class="headerlink" title="1.2 设计哈希函数"></a>1.2 设计哈希函数</h3><p>哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。在之前的示例中，我们使用 $y &#x3D; x % 5$ 作为散列函数，其中 $x$ 是键值，$y$ 是分配的桶的索引。</p><p>散列函数将取决于键值的范围和桶的数量。下面是一些哈希函数的示例：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.577abu1923s0.webp#pic_center" width = 48%><p>哈希函数的设计是一个开放的问题。其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射。然而，在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。</p><p>当然，我们也可以自定义一些哈希函数。一般的方法有：</p><ul><li>直接定制法。哈希函数为关键字到地址的线性函数。如，$H(key) &#x3D; a * key + b$。这里，a 和 b 是设置好的常数。</li><li>数字分析法。假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。</li><li>平方取中法。如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li><li>折叠法。如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li><li>除留余数法。预先设置一个数 p，然后对关键字进行取余运算。即地址为 key % p。</li></ul><h3 id="1-3-解决哈希冲突"><a href="#1-3-解决哈希冲突" class="headerlink" title="1.3 解决哈希冲突"></a>1.3 解决哈希冲突</h3><p>理想情况下，如果我们的哈希函数是完美的一对一映射，我们将不需要处理冲突。不幸的是，在大多数情况下，冲突几乎是不可避免的。例如，在我们之前的哈希函数（y &#x3D; x ％ 5）中，1987 和 2 都分配给了桶 2，这就是一个哈希冲突。</p><p>解决哈希冲突应该要思考以下几个问题：</p><ul><li>如何组织在同一个桶中的值？</li><li>如果为同一个桶分配了太多的值，该怎么办？</li><li>如何在特定的桶中搜索目标值？</li></ul><p>那么一旦发生冲突，我们该如何解决呢？常用的方法有两种：开放定址法和链地址法。</p><p><strong>1. 开放定址法</strong><br>即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。</p><p>常用的探测方法是线性探测法。 比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key % 11。当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 % 11 &#x3D; 1。</p><p>然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.tk0bq8gxag.gif#pic_center" width = 48%><p><strong>2. 链地址法</strong></p><p>将哈希地址相同的记录存储在一张线性链表中。例如，有一组关键字 {12,13,25,23,38,84,6,91,34}，采用的哈希函数为 key % 11。如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.ze52i3l6k5s.gif#pic_center" width = 48%><h3 id="1-4-哈希表的应用"><a href="#1-4-哈希表的应用" class="headerlink" title="1.4 哈希表的应用"></a>1.4 哈希表的应用</h3><p><strong>1. 哈希表的基本操作</strong></p><p>在很多高级语言中，哈希函数、哈希冲突都已经在底层完成了黑盒化处理，是不需要开发者自己设计的。也就是说，哈希表完成了关键字到地址的映射，可以在常数级时间复杂度内通过关键字查找到数据。</p><p>至于实现细节，比如用了哪个哈希函数，用了什么冲突处理，甚至某个数据记录的哈希地址是多少，都是不需要开发者关注的。接下来，我们从实际的开发角度，来看一下哈希表对数据的增删查操作。</p><p>哈希表中的增加和删除数据操作，不涉及增删后对数据的挪移问题（数组需要考虑），因此处理就可以了。</p><p>哈希表查找的细节过程是：对于给定的 key，通过哈希函数计算哈希地址 H (key)。</p><p>如果哈希地址对应的值为空，则查找不成功。反之，则查找成功。虽然哈希表查找的细节过程还比较麻烦，但因为一些高级语言的黑盒化处理，开发者并不需要实际去开发底层代码，只要调用相关的函数就可以了。</p><p><strong>2. 哈希表的优缺点</strong></p><p>优势：它可以提供非常快速的插入-删除-查找操作，无论多少数据，<font color=#9900CC><strong>插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</font></strong></p><p>不足：哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。<font color=#9900CC><strong>在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。</font></strong></p><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote><ul> <li><p><a href="https://leetcode.cn/problems/design-hashset/" target="_blank">705. 设计哈希集合</a></p></li><li><p><a href="https://leetcode.cn/problems/design-hashmap/" target="_blank">706. 设计哈希映射</a></p></li><li><p><a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字</a></p></li><li><p><a href="https://leetcode.cn/problems/single-number-ii/" target="_blank">137. 只出现一次的数字 II</a></p></li><li><p><a href="https://leetcode.cn/problems/single-number-iii/" target="_blank">260. 只出现一次的数字 III</a></p></li><li><p><a href="https://leetcode.cn/problems/contains-duplicate/description/" target="_blank">217. 存在重复元素</a></p></li><li><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/" target="_blank">219. 存在重复元素 II</a></p></li><li><p><a href="https://leetcode.cn/problems/contains-duplicate-iii/" target="_blank">220. 存在重复元素 III</a></p></li><li><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank">349. 两个数组的交集</a></p></li><li><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/" target="_blank">350. 两个数组的交集 II</a></p></li><li><p><a href="https://leetcode.cn/problems/valid-sudoku/" target="_blank">36. 有效的数独</a></p></li><li><p><a href="https://leetcode.cn/problems/find-the-difference/description/" target="_blank">389. 找不同</a></p></li><li><p><a href="https://leetcode.cn/problems/next-greater-element-i/description/" target="_blank">496. 下一个更大元素 I</a></p></li></ul></blockquote> <p><strong>705. 设计哈希集合</strong></p><p><strong>题目描述</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.200knowlms2o.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个一维长度为 buckets 的二维数组 table。第一维度用于计算哈希函数，为 key 分桶。</span></span><br><span class="line"><span class="comment"># 第二个维度用于寻找 key 存放的具体位置。第二维度的数组会根据 key 值动态增长，模拟真正的链表。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.buckets = <span class="number">1009</span></span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.buckets)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> key % self.buckets           <span class="comment"># 用取余数的方法实现集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key</span>):<span class="comment"># 向哈希集合中插入一个值</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.table[hashkey].append(key)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key</span>):<span class="comment"># 将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.table[hashkey].remove(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, key</span>):<span class="comment"># 返回哈希集合中是否存在这个值</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.table[hashkey]</span><br></pre></td></tr></table></figure><p><strong>706. 设计哈希映射</strong></p><p><strong>题目描述</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.l7i8ezupap8.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单的思路就是用模运算作为哈希方法，为了降低哈希碰撞的概率，通常取素数的模，例如 模 1009或2069</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.buckets = <span class="number">1009</span></span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.buckets)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>):                <span class="comment"># 哈希映射关系</span></span><br><span class="line">        <span class="keyword">return</span> key % self.buckets</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:<span class="comment"># 向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">                item[<span class="number">1</span>] = value</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        self.table[hashkey].append([key, value])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:<span class="comment"># 返回给定的键所对应的值，如果映射中不包含这个键，返回-1</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.table[hashkey]:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">                <span class="keyword">return</span> item[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:<span class="comment"># 如果映射中存在这个键，删除这个数值对</span></span><br><span class="line">        hashkey = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.table[hashkey]):</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">                self.table[hashkey].pop(i)</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>136. 只出现一次的数字</strong></p><p>题目描述：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#一、用字典统计元素个数</span></span><br><span class="line">        <span class="comment"># hash_map = Counter(nums)</span></span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#方法一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hash_map[i] = hash_map.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">#方法二</span></span><br><span class="line">        <span class="comment"># for i in nums:</span></span><br><span class="line">        <span class="comment">#     if i not in hash_map:</span></span><br><span class="line">        <span class="comment">#         hash_map[i] = 1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         hash_map[i] += 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#二、找出只出现一次的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#方法一</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(hash_map.keys())[<span class="built_in">list</span>(hash_map.values()).index(<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#方法二</span></span><br><span class="line">        <span class="comment"># new_hash_map = &#123;v:k for k,v in hash_map.items()&#125;</span></span><br><span class="line">        <span class="comment"># return new_hash_map[1]</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#方法三</span></span><br><span class="line">        <span class="comment"># return [key for key, value in hash_map.items() if value == 1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 或</span></span><br><span class="line">        <span class="comment"># for key,value in hash_map.items():</span></span><br><span class="line">        <span class="comment">#     if value == 1:</span></span><br><span class="line">        <span class="comment">#         return key</span></span><br></pre></td></tr></table></figure><p><strong>137. 只出现一次的数字 II</strong></p><p>题目描述：给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        hash_map = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(hash_map.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>260. 只出现一次的数字 III</strong></p><p>题目描述：给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = collections.Counter(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> hash_map.items():</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>217. 存在重复元素</strong></p><p>题目描述：给你一个整数数组 nums。如果任一值在数组中出现 至少两次，返回 true；如果数组中每个元素互不相同，返回 false。</p><p><strong>1. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> hash_map:</span><br><span class="line">            <span class="keyword">if</span> hash_map[index] &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>2. 哈希集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hash_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_set.add(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>3. 集合的性质</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return sum(nums) != sum(set(nums)) or nums.count(0) &gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums) != <span class="built_in">len</span>(<span class="built_in">set</span>(nums))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.61ov593ay3k0.gif#pic_center" width = 48%><p><strong>219. 存在重复元素 II</strong></p><p>题目描述：给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个不同的索引 i 和 j ，满足 nums[i] &#x3D;&#x3D; nums[j] 且 $abs(i - j) &lt;&#x3D; k$。如果存在，返回 true；否则，返回 false 。</p><p><strong>1. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到重复元素和其索引</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 已经存在重复的情况</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> hash_map <span class="keyword">and</span> <span class="built_in">abs</span>(i - hash_map[nums[i]]) &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>2. 哈希集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 维护一个长度为 k 的集合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hash_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 存在重复元素</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> hash_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            hash_set.add(nums[i])</span><br><span class="line">            <span class="comment"># 及时删除超出数组长度的元素</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hash_set) &gt; k:</span><br><span class="line">                hash_set.remove(nums[i - k])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.1ezhfejilodc.gif#pic_center" width = 64%><p><strong>220. 存在重复元素 III</strong></p><p>题目描述：给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 $abs(nums[i] - nums[j]) &lt;&#x3D; t$，同时又满足 $abs(i - j) &lt;&#x3D; k$。如果存在则返回 true，不存在返回 false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        bucket_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 将nums[i]划分到大小为 t + 1 的不同桶中，分桶操作</span></span><br><span class="line">            num = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># print(num)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果桶中已经有元素，有相同的分桶结果，表示存在相同元素</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> bucket_dict:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 将 nums[i] 放入桶中</span></span><br><span class="line">            bucket_dict[num] = nums[i]</span><br><span class="line">            <span class="comment"># print(bucket_dict)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num - <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 将 i - k 之前的旧桶清除，因为之前的桶已经不满足条件了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                bucket_dict.pop(nums[i-k] // (t + <span class="number">1</span>))  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>349. 两个数组的交集</strong></p><p>题目描述：给定两个数组 nums1 和 nums2，返回它们的交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序。<br><strong>1. 集合的交集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        l2 = <span class="built_in">set</span>(nums2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(l1 &amp; l2)</span><br></pre></td></tr></table></figure><p><strong>2. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> num1 <span class="keyword">not</span> <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[num1] = <span class="number">1</span>         <span class="comment"># 只做一次计数</span></span><br><span class="line">        <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> num2 <span class="keyword">in</span> hash_map <span class="keyword">and</span> hash_map[num2] != <span class="number">0</span>:</span><br><span class="line">                hash_map[num2] -= <span class="number">1</span>        <span class="comment"># 及时对结果进行处理  </span></span><br><span class="line">                result.append(num2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>350. 两个数组的交集 II</strong></p><p>题目描述：给你两个整数数组 nums1 和 nums2，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> num1 <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[num1] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[num1] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> num2 <span class="keyword">in</span> hash_map <span class="keyword">and</span> hash_map[num2] != <span class="number">0</span>:</span><br><span class="line">                hash_map[num2] -= <span class="number">1</span></span><br><span class="line">                result.append(num2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>36. 有效的数独</strong></p><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 记录行数据、列数据、3x3格子数据，用于标记 1-9 共10个数字</span></span><br><span class="line">        rows = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        columns = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        boxes = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 1-9数字是否重复出现</span></span><br><span class="line">                    num = <span class="built_in">int</span>(board[i][j])</span><br><span class="line">                    board_index = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>  <span class="comment"># 方格角标的计算用 box[(i/3)*3+(j/3)][n] 来表示</span></span><br><span class="line">                    <span class="keyword">if</span> rows[i][num] &gt; <span class="number">0</span> <span class="keyword">or</span> columns[j][num] &gt; <span class="number">0</span> <span class="keyword">or</span> boxes[board_index][num] &gt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    rows[i][num] = <span class="number">1</span></span><br><span class="line">                    columns[j][num] = <span class="number">1</span></span><br><span class="line">                    boxes[board_index][num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>389. 找不同</strong></p><p>题目描述：给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。</p><p><strong>1. 哈希字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(Counter(t) - Counter(s))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 异或运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(reduce(xor, <span class="built_in">map</span>(<span class="built_in">ord</span>, s + t)))</span><br></pre></td></tr></table></figure><p><strong>496. 下一个更大元素 I</strong></p><p><strong>题目描述</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.xl93xw5xua8.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_map = &#123;&#125;                       <span class="comment"># 字典存储结果</span></span><br><span class="line">        stack = []                          <span class="comment"># 列表模拟栈，单调栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):         <span class="comment"># 遍历每个字符串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:                   <span class="comment"># 如果当前栈为空，则直接入栈</span></span><br><span class="line">                stack.append(nums2[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums2[i] &lt; stack[-<span class="number">1</span>]:    <span class="comment"># 当前值小于栈顶元素，则入栈</span></span><br><span class="line">                    stack.append(nums2[i])</span><br><span class="line">                <span class="keyword">elif</span> nums2[i] &gt; stack[-<span class="number">1</span>]:  <span class="comment"># 当前值大于栈顶元素，不停出栈，把所有栈顶key值的value赋值为当前值</span></span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; nums2[i]:</span><br><span class="line">                        hash_map[stack[-<span class="number">1</span>]] = nums2[i]</span><br><span class="line">                        stack.pop()</span><br><span class="line">                    stack.append(nums2[i])  <span class="comment"># 当前值入队列</span></span><br><span class="line">        <span class="keyword">while</span> stack:                        <span class="comment"># 如果栈中还有元素，则全部赋值为-1，表示右边没有更大值</span></span><br><span class="line">            hash_map[stack[-<span class="number">1</span>]] = -<span class="number">1</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:                     <span class="comment"># 返回每个key值对应的value</span></span><br><span class="line">            result.append(hash_map[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>哈希表暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.29t68rsqty80.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>哈希表：<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8">https://www.programmercarl.com/哈希表理论基础.html#哈希表</a></li><li>Python数据结构-哈希表（Hash Table）：<a href="https://www.jianshu.com/p/093346ca7f38">https://www.jianshu.com/p/093346ca7f38</a></li><li>数据结构（Python实现）—— 哈希表：<a href="https://blog.csdn.net/Avery123123/article/details/103583115">https://blog.csdn.net/Avery123123/article/details/103583115</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 哈希算法 </tag>
            
            <tag> 哈希冲突 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（五）-- 二分查找与二分答案</title>
      <link href="/article/25d31d17.html"/>
      <url>/article/25d31d17.html</url>
      
        <content type="html"><![CDATA[<p>二分查找是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码和常见的解题技巧，带大家学透二分算法</p><span id="more"></span><h2 id="1-二分法介绍"><a href="#1-二分法介绍" class="headerlink" title="1 二分法介绍"></a>1 二分法介绍</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>二分查找又称折半查找、二分搜索、折半搜索等，是一种在静态查找表中查找特定元素的算法。</p><blockquote><p>所谓静态查找表，即只能对表内的元素做查找和读取操作，不允许插入或删除元素。</p></blockquote><p>使用二分查找算法，必须保证查找表中存放的是有序序列（升序或者降序）。换句话说，存储无序序列的静态查找表，除非先对数据进行排序，否则不能使用二分查找算法。它针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。下图对比了顺序查找和二分查找的不同：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.39e6uepbps80.gif#pic_center" width = 48%><p>二分查找的最基本问题是在有序数组里查找一个特定的元素，还可以应用在：</p><ol><li>在半有序（旋转有序或者是山脉）数组里查找元素；</li><li>确定一个有范围的整数；</li><li>需要查找的目标元素满足某个特定的性质。</li></ol><p>二分查找算法的时间复杂度可以用  $O(log_2n)$ 表示（$n$ 为查找表中的元素数量，底数 2 可以省略）。和顺序查找算法的 $O(n)$ 相比，显然二分查找算法的效率更高，且查找表中的元素越多，二分查找算法效率高的优势就越明显。</p><h3 id="1-2-二分法的三种写法"><a href="#1-2-二分法的三种写法" class="headerlink" title="1.2 二分法的三种写法"></a>1.2 二分法的三种写法</h3><p><strong>1. 模板一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 特殊用例判断</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 在 [left, right] 区间里查找target</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 为了防止 left + right 整形溢出，写成如下形式</span></span><br><span class="line">            <span class="comment"># Python 使用 BigInteger，所以不用担心溢出，但还是推荐使用如下方式</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                <span class="comment"># 下一轮搜索区间：[left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 此时：nums[mid] &lt; target</span></span><br><span class="line">                <span class="comment"># 下一轮搜索区间：[mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>许多刚刚写的朋友，经常在写 <code>left = mid + 1</code>；还是写 <code>right = mid - 1</code>; 感到困惑，一个行之有效的思考策略是：<font color=#9900CC><strong>永远去想下一轮目标元素应该在哪个区间里：</font></strong><ul><li>如果目标元素在区间 <code>[left, mid - 1]</code> 里，就需要设置设置 <code>right = mid - 1</code>；</li><li>如果目标元素在区间 <code>[mid + 1, right]</code> 里，就需要设置设置 <code>left = mid + 1</code>；</li></ul></li></ul><p>考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义。</p><ul><li>二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的；</li><li>循环可以继续的条件是 <code>while (left &lt;= right)</code>，特别地，当 <code>left == right</code> 即当待搜索区间里只有一个元素的时候，查找也必须进行下去；</li><li><code>mid = (left + right) // 2</code>；在 <code>left + right</code> 整形溢出的时候，mid 会变成负数，回避这个问题的办法是写成 <code>mid = left + (right - left) // 2</code>。</li></ul><p><strong>2. 模板二</strong></p><p><strong>版本一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid]</span></span><br><span class="line">            right = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br></pre></td></tr></table></figure><p><strong>版本二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时上取整</span></span><br><span class="line">        mid = left + (right - left + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid, right]</span></span><br><span class="line">            left = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br></pre></td></tr></table></figure><p>理解模板代码的要点：</p><ul><li>核心思想：虽然模板有两个，但是核心思想只有一个，那就是：<font color=#9900CC><strong>把待搜索的目标元素放在最后判断，每一次循环排除掉不存在目标元素的区间，目的依然是确定下一轮搜索的区间；</font></strong></li><li>特征：<code>while (left &lt; right):</code>，这里使用严格小于 <code>&lt;</code> 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 <code>left == right</code>成立，这一点在定位元素下标的时候极其有用；</li><li>在循环体中，先考虑 <code>nums[mid]</code> 在满足什么条件下不是目标元素，进而考虑两个区间 <code>[left, mid - 1]</code> 以及 <code>[mid + 1, right]</code> 里元素的性质，目的依然是确定下一轮搜索的区间； <strong>注意 1：</strong> 先考虑什么时候不是解，是一个经验，在绝大多数情况下不易出错，重点还是确定下一轮搜索的区间，由于这一步不容易出错，它的反面（也就是 <code>else</code> 语句的部分），就不用去考虑对应的区间是什么，直接从上一个分支的反面区间得到，进而确定边界如何设置；</li><li>根据边界情况，看取中间数的时候是否需要上取整； <strong>注意 2：</strong> 这一步也依然是根据经验，建议先不要记住结论，在使用这个思想解决问题的过程中，去思考可能产生死循环的原因，进而理解什么时候需要在括号里加 1 ，什么时候不需要；</li><li>在退出循环以后，根据情况看是否需要对下标为 <code>left</code> 或者 <code>right</code> 的元素进行单独判断，这一步叫「后处理」。在有些问题中，排除掉所有不符合要求的元素以后，剩下的那 1 个元素就一定是目标元素。如果根据问题的场景，目标元素一定在搜索区间里，那么退出循环以后，可以直接返回 left（或者 right）。</li></ul><p>以上是这两个模板写法的所有要点，并且是高度概括的。请读者一定先抓住这个模板的核心思想，在具体使用的过程中，不断地去体会这个模板使用的细节和好处。只要把中间最难理解的部分吃透，几乎所有的二分问题就都可以使用这个模板来解决，因为「减治思想」是通用的。好处在这一小节的开篇介绍过了，需要考虑的细节最少。</p><p>学习建议：一定需要多做练习，体会这（两）个模板的使用。</p><p><strong>注意事项：</strong></p><ul><li>先写分支，再决定中间数是否上取整；</li><li>在使用多了以后，就很容易记住，只要看到 left &#x3D; mid ，它对应的取中位数的取法一定是 <code>mid = left + (right - left + 1) // 2</code>。</li></ul><p><strong>3. 模板三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>这一版代码和模板二没有本质区别，一个显著的标志是：循环可以继续的条件是 <code>while (left + 1 &lt; right):</code>，这说明在退出循环的时候，一定有 <code>left + 1 == right</code> 成立，也就是退出循环以后，区间有 2 个元素，即 <code>[left, right]</code>；</li><li>这种写法的优点是：不用理解上一个版本在分支出现 left &#x3D; mid 的时候中间数上取整的行为；</li><li>缺点是显而易见的：<ul><li><code>while (left + 1 &lt; right):</code> 写法相对于 <code>while (left &lt; right):</code> 和 <code>while (left &lt;= right):</code> 来说并不自然；</li><li>由于退出循环以后，区间一定有两个元素，需要思考哪一个元素才是需要找的，即「后处理」一定要做，有些时候还会有先考虑 <code>left</code> 还是 <code>right</code> 的区别。</li></ul></li></ul><p><strong>小结：</strong></p><ul><li>模板一：最好理解的版本，但是在刷题的过程中，需要处理一些边界的问题，一不小心容易出错；</li><li>模板二：强烈推荐掌握的版本，应先理解思想，再通过实际应用去体会这个模板的细节，熟练使用以后就会觉得非常自然；</li><li>模板三：可以认为是模板二的避免踩坑版本，只要深刻理解了模板二，模板三就不在话下。</li></ul><p> &#x3D;&#x3D;实际应用中，选择最好理解的版本即可。&#x3D;&#x3D;</p><p>这里有一个提示：模板二考虑的细节最少，可以用于解决一些相对复杂的问题。缺点是：学习成本较高，初学的时候比较容易陷入死循环，建议大家通过多多使用，并且尝试 debug，找到死循环的原因，进而掌握。</p><p>题解核心内容：所有模板都一样，不可以套模板，而应该<font color=#9900CC><strong>仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。一定要分析清楚题目的意思，分析清楚要找的答案需要满足什么性质。应该清楚模板具体的用法，明白需要根据题意灵活处理、需要变通的地方，不可以认为每一行代码都是模板规定死的写法，不可以盲目套用、死记硬背。</font></strong></p><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-二分求下标（在数组中查找符合条件的元素的下标）"><a href="#2-1-二分求下标（在数组中查找符合条件的元素的下标）" class="headerlink" title="2.1 二分求下标（在数组中查找符合条件的元素的下标）"></a>2.1 二分求下标（在数组中查找符合条件的元素的下标）</h3><p><strong>题库列表</strong></p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>704</td><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank">二分查找</a>（简单）</td></tr><tr><td>35</td><td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank">搜索插入位置</a>（简单）</td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank">最长上升子序列</a>（中等）</td></tr><tr><td>34</td><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank">在排序数组中查找元素的第一个和最后一个位置</a>（简单）</td></tr><tr><td>611</td><td><a href="https://leetcode-cn.com/problems/valid-triangle-number/" target="_blank">有效三角形的个数</a></td></tr><tr><td>436</td><td><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank">寻找右区间</a>（中等）</td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank">寻找两个有序数组的中位数</a>（困难）</td></tr></tbody></table><h3 id="2-2-完全有序"><a href="#2-2-完全有序" class="headerlink" title="2.2 完全有序"></a>2.2 完全有序</h3><p><strong>704. 二分查找</strong><br>题目描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lower_bound 返回最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class="line"><span class="comment"># 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span></span><br><span class="line"><span class="comment"># 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 闭区间 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left-1] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right+1] &gt;= target</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>      <span class="comment"># 范围缩小到 [mid+1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span>     <span class="comment"># 范围缩小到 [left, mid-1]</span></span><br><span class="line">    <span class="keyword">return</span> left                 <span class="comment"># 或者 right+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左闭右开区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound2</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 左闭右开区间 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left-1] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right] &gt;= target</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 范围缩小到 [mid+1, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 范围缩小到 [left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 或者 right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开区间写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound3</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 开区间 (left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 循环不变量：</span></span><br><span class="line">        <span class="comment"># nums[left] &lt; target</span></span><br><span class="line">        <span class="comment"># nums[right] &gt;= target</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid  <span class="comment"># 范围缩小到 (mid, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 范围缩小到 (left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> right  <span class="comment"># 或者 left+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = lower_bound(nums, target)  <span class="comment"># 选择其中一种写法即可</span></span><br><span class="line">        <span class="keyword">return</span> i <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.47omstlu8nc0.gif#pic_center" width = 64%><p><strong>35. 搜索插入位置</strong></p><p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.3nhyvtn9ruw0.gif#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)          <span class="comment"># 采用左闭右开区间[left,right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:                 <span class="comment"># 右开所以不能有=,区间不存在</span></span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span>  <span class="comment"># 防止溢出, //表示整除</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:          <span class="comment"># 中点小于目标值,在右侧,可以得到相等位置</span></span><br><span class="line">                left = mid + <span class="number">1</span>              <span class="comment"># 左闭, 所以要+1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid                 <span class="comment"># 右开, 真正右端点为mid-1</span></span><br><span class="line">        <span class="keyword">return</span> left                         <span class="comment"># 此算法结束时保证left = right, 返回谁都一样</span></span><br></pre></td></tr></table></figure><p><strong>300. 最长上升子序列</strong><br>题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>1. 动态规划 + 二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dynamic programming + Dichotomy.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tails, res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            i, j = <span class="number">0</span>, res</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tails[m] &lt; num: </span><br><span class="line">                    i = m + <span class="number">1</span>           <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    j = m</span><br><span class="line">            tails[i] = num</span><br><span class="line">            <span class="keyword">if</span> j == res: </span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.1xoae36xmhc0.gif#pic_center" width = 48%><p><strong>2. 动态规划</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]: <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/021.e4s3129neio.gif#pic_center" width = 48%><p><strong>34. 在排序数组中查找元素的第一个和最后一个位置</strong></p><p>题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> target <span class="keyword">not</span> <span class="keyword">in</span> nums:          <span class="comment"># 特例，二分查找失败</span></span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [self.lower_bound(nums, target), self.upper_bound(nums, target)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">upper_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):    <span class="comment"># 寻找上边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:     <span class="comment"># 移动左指针</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 移动右指针</span></span><br><span class="line">                right = mid -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):    <span class="comment"># 寻找下边界</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:         <span class="comment"># 当nums[mid]大于等于目标值时，继续在左区间检索，找到第一个数</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:           <span class="comment"># nums[mid]小于目标值时，则在右区间继续检索，找到第一个等于目标值的数</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/022.7fkctqmkt4w0.gif#pic_center" width = 48%><p><strong>611. 有效三角形的个数</strong><br>题目描述：给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。</p><p>将数组 nums 进行升序排序，随后使用二重循环枚举 a 和 b。设 $a&#x3D;nums[i], b&#x3D;nums[j]$，为了防止重复统计答案，我们需要保证 $i&lt;j$。剩余的边 c 需要满足 $c&lt;nums[i]+nums[j]$，我们可以在 $[j+1,n−1]$ 的下标范围内使用二分查找（其中 $n$ 是数组 nums 的长度），找出最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标 $k$，这样一来，在 $[j+1, k]$ 范围内的下标都可以作为边 $c$ 的下标，我们将该范围的长度 $k−j$ 累加入答案。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/023.1j77tet7j800.webp#pic_center" width = 45%><p><strong>1. 排序+二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                left, right = j+<span class="number">1</span>, length              </span><br><span class="line">                <span class="keyword">while</span> left &lt; right:             <span class="comment"># 找边界，</span></span><br><span class="line">                    mid = (left + right)//<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> nums[mid] &lt; nums[i] + nums[j]:</span><br><span class="line">                        left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right = mid</span><br><span class="line">                ans += left - <span class="number">1</span> - j</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>2. 排序+双指针</strong></p><p>我们将当 $a&#x3D;nums[i], b&#x3D;nums[j]$ 时，最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标 $k$ 记为 $k_{i,j}$。可以发现，如果我们固定 $i$，那么随着 $j$ 的递增，不等式右侧 $nums[i]+nums[j]$ 也是递增的，因此 $k_{i,j}$ 也是递增的。</p><p>这样一来，我们就可以将 $j$ 和 $k$ 看成两个同向（递增）移动的指针，将方法一进行如下的优化：</p><ul><li>我们使用一重循环枚举 $i$。当 $i$ 固定时，我们使用双指针同时维护 $j$ 和 $k$，它们的初始值均为 $i$；</li><li>我们每一次将 $j$ 向右移动一个位置，即 $j←j+1$，并尝试不断向右移动 $k$，使得 $k$ 是最大的满足 $nums[k]&lt;nums[i]+nums[j]$ 的下标。我们将 $max(k−j, 0)$ 累加入答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            k = i + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                <span class="keyword">while</span> k+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[i] + nums[j] &gt; nums[k+<span class="number">1</span>]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ans += <span class="built_in">max</span>(k-j, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>436. 寻找右区间</strong><br>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/024.4vfedl22glc0.webp#pic_center" width = 64%></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/025.24c1qurj96ww.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRightInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start_map = &#123;interval[<span class="number">0</span>] : i <span class="keyword">for</span> i, interval <span class="keyword">in</span> <span class="built_in">enumerate</span>(intervals)&#125;       <span class="comment"># 以区间左侧构建索引字典</span></span><br><span class="line">        starts = [interval[<span class="number">0</span>] <span class="keyword">for</span> interval <span class="keyword">in</span> intervals]                            <span class="comment"># 取出区间的左侧</span></span><br><span class="line">        res = []</span><br><span class="line">        starts.sort()</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            pos = self.higher_find(starts, interval[<span class="number">1</span>])                             <span class="comment"># 遍历每个区间的右侧，在所有区间的左侧进行二分查找</span></span><br><span class="line">            res.append(start_map[starts[pos]] <span class="keyword">if</span> pos != -<span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">higher_find</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)              <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[left] &gt;= target:    <span class="comment"># 最后判断一下，是否满足条件</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/026.3zi4l9anjzo0.gif#pic_center" width = 48%><p><strong>4. 寻找两个正序数组的中位数</strong></p><p>题目描述：给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 $O(log (m+n))$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getKthElement</span>(<span class="params">k</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            - 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="string">            - 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="string">            - nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="string">            - nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="string">            - 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="string">            - 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="string">            - 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="string">            - 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="string">            - 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            </span><br><span class="line">            index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> index1 == m:</span><br><span class="line">                    <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> index2 == n:</span><br><span class="line">                    <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 正常情况</span></span><br><span class="line">                newIndex1 = <span class="built_in">min</span>(index1 + k // <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>)</span><br><span class="line">                newIndex2 = <span class="built_in">min</span>(index2 + k // <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">                <span class="keyword">if</span> pivot1 &lt;= pivot2:</span><br><span class="line">                    k -= newIndex1 - index1 + <span class="number">1</span></span><br><span class="line">                    index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= newIndex2 - index2 + <span class="number">1</span></span><br><span class="line">                    index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        totalLength = m + n</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> getKthElement((totalLength + <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(totalLength // <span class="number">2</span>) + getKthElement(totalLength // <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/027.2oxogh32hg80.webp#pic_center" width = 48%><h3 id="2-3-不完全有序"><a href="#2-3-不完全有序" class="headerlink" title="2.3 不完全有序"></a>2.3 不完全有序</h3><p><strong>题库列表：</strong></p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>33</td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank">搜索旋转排序数组</a>（中等）</td></tr><tr><td>81</td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank">搜索旋转排序数组 II</a>（中等）</td></tr><tr><td>153</td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank">寻找旋转排序数组中的最小值</a>（中等）</td></tr><tr><td>154</td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank">寻找旋转排序数组中的最小值 II</a>（困难）</td></tr><tr><td>852</td><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank">山脉数组的峰顶索引</a>（简单）</td></tr><tr><td>1095</td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank">山脉数组中查找目标值</a>（中等）</td></tr></tbody></table><p><strong>33. 搜索旋转排序数组</strong></p><p>题目描述：整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 $k(0 &lt;&#x3D; k &lt; nums.length)$ 上进行了旋转，使数组变为 $[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]$（下标从0开始计数）。例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:                        <span class="comment"># 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:           <span class="comment"># target 在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                                           <span class="comment"># 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]: <span class="comment"># target 在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/028.qtcvkzfq8u8.webp#pic_center" width = 48%><p><strong>81. 搜索旋转排序数组 II</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/029.7guqdqr87o80.webp#pic_center" width = 80%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[left]:         <span class="comment"># 去重</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:        <span class="comment"># 左半部分有序，在左侧二分查找</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment"># 右半部分有序，在右侧二分查找</span></span><br><span class="line">                <span class="keyword">if</span>  nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>153. 寻找旋转排序数组中的最小值</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/030.4356lavtjeq0.webp#pic_center" width = 75%><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/031.2auzerg0b7fo.webp#pic_left" width = "45%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/032.3bntek4m9bu0.webp#pic_left"  width = "45%"></center></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:    </span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[pivot] &lt; nums[high]:</span><br><span class="line">                high = pivot </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure><p><strong>154. 寻找旋转排序数组中的最小值 II</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/033.5nj47nf02sw0.webp#pic_center" width = 75%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left+right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span>              <span class="comment"># 去重</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/034.zrj5dh2d3rk.gif#pic_center" width = 36%><p><strong>852. 山脉数组的峰顶索引（简单）</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/035.728jhdo84ho0.webp#pic_center" width = 75%><p><strong>1. 顺序查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peakIndexInMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 顺序查找最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p><strong>2. 二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peakIndexInMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 二分查找最大值</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &gt; arr[mid + <span class="number">1</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>1095. 山脉数组中查找目标值</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/036.309t987j7680.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findInMountainArray</span>(<span class="params">self, target: <span class="built_in">int</span>, mountain_arr: <span class="string">&#x27;MountainArray&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        先使用二分法找到数组的峰值。</span></span><br><span class="line"><span class="string">        在峰值左边使用二分法寻找目标值。</span></span><br><span class="line"><span class="string">        如果峰值左边没有目标值，那么使用二分法在峰值右边寻找目标值。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        head, tail = <span class="number">0</span>, mountain_arr.length()-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:             <span class="comment"># 找峰值，注意越界处理</span></span><br><span class="line">            mid = (head+tail)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; mountain_arr.get(mid+<span class="number">1</span>):</span><br><span class="line">                head = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tail = mid</span><br><span class="line">        peak = head</span><br><span class="line">        ans = self.binarySearch(mountain_arr, target, <span class="number">0</span>, peak)                                              <span class="comment"># 在左半边搜索</span></span><br><span class="line">        <span class="keyword">if</span> ans != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(mountain_arr, target, peak+<span class="number">1</span>, mountain_arr.length()-<span class="number">1</span>, <span class="keyword">lambda</span> x:-x)        <span class="comment"># 在右半边搜索</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">self, mountain, target, left, right, key=<span class="keyword">lambda</span> x: x</span>): </span><br><span class="line">        target = key(target)                            <span class="comment"># 这里的key相当于把两边全部转为升序部分，也可以用target*reverse，根据reverse的正负来判断</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            curr = key(mountain.get(mid))</span><br><span class="line">            <span class="keyword">if</span> curr == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> curr &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-4-二分答案（在一个有范围的区间里搜索一个整数）"><a href="#2-4-二分答案（在一个有范围的区间里搜索一个整数）" class="headerlink" title="2.4 二分答案（在一个有范围的区间里搜索一个整数）"></a>2.4 二分答案（在一个有范围的区间里搜索一个整数）</h3><p>如果题目要我们找一个整数，这个整数有确定的范围，可以通过二分查找逐渐缩小范围，最后逼近到一个数。</p><p>定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。</p><table><thead><tr><th>题号</th><th>链接</th></tr></thead><tbody><tr><td>69</td><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank">x 的平方根</a>（简单）</td></tr><tr><td>287</td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank">寻找重复数</a>（中等）</td></tr><tr><td>374</td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank">猜数字大小</a>（简单）</td></tr></tbody></table><p><strong>69. x 的平方根</strong></p><p>题目描述：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right= <span class="number">0</span>, x//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> left-<span class="number">1</span>          </span><br></pre></td></tr></table></figure><p><strong>287. 寻找重复数</strong></p><p>题目描述：给定一个包含 $n+1$ 个整数的数组 nums ，其数字都在 $[1, n]$ 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数。你设计的解决方案必须 不修改 数组 nums 且只用常量级 $O(1)$ 的额外空间。</p><p><strong>1. 二分法</strong></p><p>设数组长度为nnn，则数组中元素 $\in[1, n-1]$，且只有一个重复元素。一个直观的想法，设一个数字 $k\in[1,n-1]$，统计数组中小于等于 $k$ 的数字的个数 count：</p><ul><li>若 $count&lt;&#x3D;k$，说明重复数字一定在 $(k,n−1]$ 的范围内。</li><li>若 $count&gt;k$，说明重复数字一定在 $[0,k]$ 的范围内。<br>利用这个性质，我们使用二分查找逐渐缩小重复数字所在的范围。</li></ul><ol><li>初试化左右 数字 边界 $left&#x3D;1, right&#x3D;n-1$</li><li>循环条件 $left&lt;right:$<ul><li>$mid&#x3D;(left+right)&#x2F;&#x2F;2$</li><li>按照性质，统计数组中小于等于 $mid$ 的元素个数 $count$</li><li>若 $count&lt;&#x3D;mid$，说明重复数字一定在 $(mid,right]$ 的范围内。令 $left&#x3D;mid+1$</li><li>若 $count&gt;mid$，说明重复数字一定在 $[left,mid]$ 的范围内。令 $right&#x3D;mid$。</li></ul></li><li>返回 $left$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right):</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=mid):</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(count&lt;=mid):</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>2. 快慢指针</strong></p><p>分为两步：</p><ol><li>找到环</li><li>找到环的入口（即重复元素）</li></ol><p>找环：</p><ol><li>定义快慢指针 $slow&#x3D;0, fast&#x3D;0$</li><li>进入循环：<br> - $slow$ 每次走一步，即 $slow&#x3D;nums[slow]$<br> - $fast$ 每次走两步，即 $fast&#x3D;nums[nums[fast]]$<br> - 当 $slow&#x3D;&#x3D;fast$时，退出循环。 当快慢指针相遇时，一定在环内。此时假设slow 走了 $k$ 步，则 fast 走了 $2k$ 步。设环的周长为 $c$，则 $k%c&#x3D;&#x3D;0$。</li></ol><p>找环的入口：</p><ol><li>定义新的指针 $find&#x3D;0$</li><li>进入循环：<ul><li>find 每次走一步，即 $find&#x3D;nums[find]$</li><li>slow每次走一步，即 $slow&#x3D;nums[slow]$</li><li>当两指针相遇时，即 $find&#x3D;&#x3D;slow$，返回 find</li></ul></li></ol><p>为何相遇时，找到的就是入口： 假设起点到环的入口(重复元素)，需要 $m$ 步。此时 slow 走了 $n+m$ 步，其中 $n$ 是环的周长 $c$ 的整数倍，所以相当于 slow走了 $m$ 步到达入口，再走了 $n$ 步。所以相遇时一定是环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow=<span class="number">0</span></span><br><span class="line">        fast=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            slow=nums[slow]</span><br><span class="line">            fast=nums[nums[fast]]</span><br><span class="line">            <span class="keyword">if</span>(slow==fast):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        find=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            find=nums[find]</span><br><span class="line">            slow=nums[slow]</span><br><span class="line">            <span class="keyword">if</span>(find==slow):</span><br><span class="line">                <span class="keyword">return</span> find</span><br></pre></td></tr></table></figure><p><strong>374. 猜数字大小</strong></p><p>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/037.6x7yhtzgw4g0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The guess API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param num, your guess</span></span><br><span class="line"><span class="comment"># @return -1 if num is higher than the picked number</span></span><br><span class="line"><span class="comment">#          1 if num is lower than the picked number</span></span><br><span class="line"><span class="comment">#          otherwise return 0</span></span><br><span class="line"><span class="comment"># def guess(num: int) -&gt; int:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">guessNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + ((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            temp = guess(mid)</span><br><span class="line">            <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> temp == <span class="number">1</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/038.p6o8es6da34.webp#pic_center" width = 64%><hr><blockquote><p><font color=#9900CC><strong>二分法暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/039.6rf3tza12s0.gif#pic_center" width = 48%><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>二分查找算法：<a href="https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README">https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README</a></li><li>二分算法：<a href="https://oi-wiki.org/basic/binary/">https://oi-wiki.org/basic/binary/</a></li><li>二分查找：<a href="https://www.cnblogs.com/jasonbourne3/p/17141780.html">https://www.cnblogs.com/jasonbourne3/p/17141780.html</a></li><li>算法与数据结构（七）：二分查找法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/94332149">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;94332149</a></li><li>一文带你搞定二分查找及其多个变种：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/</a></li><li>写对二分查找不是套模板并往里面填空，需要仔细分析题意：<a href="https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></li><li>二分查找（折半查找）算法详解：<a href="http://data.biancheng.net/view/336.html">http://data.biancheng.net/view/336.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 有序数组 </tag>
            
            <tag> 旋转数组 </tag>
            
            <tag> 山脉数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（四）-- 滑动窗口算法</title>
      <link href="/article/f08fb2ff.html"/>
      <url>/article/f08fb2ff.html</url>
      
        <content type="html"><![CDATA[<p>本篇带你走进滑动窗口算法，进一步强化双指针的使用，  滑动窗口算法常用于字符串匹配问题和子数组问题，本篇就总结出来Python的编写模板，从此刷题不心慌！</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。</p><h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1 滑动窗口"></a>1 滑动窗口</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>在计算机网络里经常用到滑动窗口协议（Sliding Window Protocol），该协议是 TCP协议 的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。</p><p>滑动窗口算法其实和这个是一样的，只是用的地方场景不一样，可以根据需要调整窗口的大小，有时也可以是固定窗口大小。</p><p>滑动窗口使用双指针解决问题，所以一般也叫双指针算法，因为两个指针间形成一个窗口。双指针也并不局限在数组问题，像链表场景的 “快慢指针” 也属于双指针的场景，其快慢指针滑动过程中本身就会产生一个窗口，比如当窗口收缩到某种程度，可以得到一些结论。</p><p><font color=#9900CC><strong>什么情况适合用滑动窗口算法呢？</font></strong></p><ul><li>需要输出或比较的结果在原数据结构中是连续排列的，特别是数组或链表问题；</li><li>每次窗口滑动时，只需观察窗口两端元素的变化，无论窗口多长，每次只操作两个头尾元素，当用到的窗口比较长时，可以显著减少操作次数；</li><li>窗口内元素的整体性比较强，窗口滑动可以只通过操作头尾两个位置的变化实现，但对比结果时往往要用到窗口中所有元素。</li></ul><p>滑动窗口算法常用于字符串匹配问题和子数组问题。</p><blockquote><p>滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来<font color=#9900CC><strong>滑动窗口主要应用在数组和字符串上。</strong></font></p></blockquote><h3 id="1-2-滑动窗口法的大体框架"><a href="#1-2-滑动窗口法的大体框架" class="headerlink" title="1.2 滑动窗口法的大体框架"></a>1.2 滑动窗口法的大体框架</h3><p>在介绍滑动窗口的框架时候，大家先从字面理解下：</p><ul><li>滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。</li><li>窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</li></ul><p>为了便于理解，这里采用的是字符串来讲解。但是对于数组其实也是一样的。<strong>滑动窗口算法的思路是这样：</strong></p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left &#x3D; right &#x3D; 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</li><li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol><p>这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><h3 id="1-3-滑动窗口模板"><a href="#1-3-滑动窗口模板" class="headerlink" title="1.3 滑动窗口模板"></a>1.3 滑动窗口模板</h3><p><strong>滑窗模板 Python 伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">problemName</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line">        x, y = ..., ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">            x = new_x</span><br><span class="line">            <span class="keyword">if</span> condition:</span><br><span class="line">                y = new_y</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            ------------- 下面是两种情况，读者请根据题意二选1 -------------</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># Step 4 - 情况1</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 </span></span><br><span class="line">            <span class="comment"># 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, </span></span><br><span class="line">            <span class="comment"># 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span> 窗口长度达到了限定长度:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 - 情况2</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span> 不合法:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针(end)作为驱动，拖着左指针(start)向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote><ul><li><p><a href="https://leetcode.cn/problems/maximum-average-subarray-i/" target="_blank">643. 子数组最大平均数 I</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-erasure-value/" target="_blank">1695. 删除子数组的最大得分</a></p></li><li><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank">438. 找到字符串中所有字母异位词</a></p></li><li><p><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></p></li><li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-ii/" target="_blank">487. 最大连续1的个数 II</a></p></li><li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/" target="_blank">1004. 最大连续1的个数 III</a></p></li><li><p><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/" target="_blank">1208. 尽可能使字符串相等</a></p></li><li><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/" target="_blank">1052. 爱生气的书店老板</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/" target="_blank">1151. 最少交换次数来组合所有的1 Π</a></p></li><li><p><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></p></li><li><p><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></p></li></ul></blockquote> <h3 id="2-2-真题演练"><a href="#2-2-真题演练" class="headerlink" title="2.2 真题演练"></a>2.2 真题演练</h3><p><strong>643. 子数组最大平均数 I</strong><br>题目描述：给你一个由 n 个元素组成的整数数组 nums 和一个整数 k。请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本题求最大平均值 (其实就是求最大和)，所以需要定义sum_sub_array, 同时定义一个max_value (初始值为负无穷)</span></span><br><span class="line">        sum_sub_array, max_value = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (sum_sub_array, max_value), 不断把当前值积累到sum_sub_array上</span></span><br><span class="line">            sum_sub_array += num</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_value = <span class="built_in">max</span>(max_value, sum_sub_array)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口首指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= k - <span class="number">1</span>:</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_value/k</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.25s1cl9rnrxc.gif#pic_center" width = 48%><p><strong>3. 无重复字符的最长子串</strong></p><p>题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hash_map = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度</span></span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hash_map) == end - start + <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hash_map):</span><br><span class="line">                head = s[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hash_map[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hash_map[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.1zysuq1eegbk.gif#pic_center" width = 48%><p><strong>159. 至多包含两个不同字符的最长子串</strong></p><p>题目描述：给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringTwoDistinct</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题求最大长度，所以需要定义max_len,</span></span><br><span class="line">        <span class="comment"># 该题又涉及计算不重复元素个数，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># 首先，把当前元素的计数加一</span></span><br><span class="line">            <span class="comment"># 一旦哈希表长度小于等于2(之多包含2个不同元素)，尝试更新最大长度</span></span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) &lt;= <span class="number">2</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表长度大于2的时候 (说明存在至少3个重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(hashmap) &gt; <span class="number">2</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><strong>209. 长度最小的子数组</strong></p><p>题目描述：给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 $[nums_l, nums_{l+1}, …, nums_{r-1}, nums_r]$，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量</span></span><br><span class="line">        min_len, sum_sub_array = math.inf, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (min_len, sum_sub_array)</span></span><br><span class="line">            sum_sub_array += num</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这一段可以删除，因为下面的while已经handle了这一块儿逻辑，不过写在这也没影响</span></span><br><span class="line">            <span class="keyword">if</span> sum_sub_array &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 这一题这里稍微有一点特别: sum_sub_array &gt;= target其实是合法的，但由于我们要求的是最小长度，</span></span><br><span class="line">            <span class="comment"># 所以当sum_sub_array已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案</span></span><br><span class="line">            <span class="comment"># 由于左指针的移动可能影响min_len和sum_sub_array的值，因此需要在移动前将它们更新</span></span><br><span class="line">            <span class="keyword">while</span> sum_sub_array &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5：返回答案 (最小长度)</span></span><br><span class="line">        <span class="keyword">if</span> min_len == math.inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.7089o47r9v00.gif#pic_center" width = 48%><p><strong>1695. 删除子数组的最大得分</strong></p><p>题目描述：给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和。返回 只删除一个 子数组可获得的 最大得分。如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumUniqueSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题最大得分，所以需要定义当前得分sum_sub_array和最大得分max_sum</span></span><br><span class="line">        <span class="comment"># 本题又涉及去重 (题目规定子数组不能有重复)，因此还需要一个哈希表</span></span><br><span class="line">        sum_sub_array, max_sum, hashmap = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array, hashmap)</span></span><br><span class="line">            <span class="comment"># sum和hashmap需要更新就不说了，max_sum当且仅当哈希表里面没有重复元素时 (end - start + 1 == len(hashmap)) 更新</span></span><br><span class="line">            sum_sub_array += tail</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == <span class="built_in">len</span>(hashmap):</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, sum_sub_array)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表里面有重复元素时 (end - start + 1 &gt; len(hashmap)) 窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap， sum_sub_array)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hashmap):</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                sum_sub_array -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><p><strong>438. 找到字符串中所有字母异位词</strong></p><p>题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本文需要对比两组字符串是否为异位词，所以用哈希表 (abc和bac是异位词是因为他们对应的哈希表相等)</span></span><br><span class="line">        <span class="comment"># 同时我们需要找到所有合法解，所以还需要一个ans数组</span></span><br><span class="line">        ans, hashmap_s = [], &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1： 同时把p的哈希表也建立了 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hashmap_p = Counter(p)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hashmap)， 如果hashmap == hashmap_p，代表找到了一个解，加入到ans</span></span><br><span class="line">            hashmap_s[tail] = hashmap_s.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap_s == hashmap_p:</span><br><span class="line">                ans.append(start)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(p) - <span class="number">1</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap_s[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap_s[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap_s[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.13gnl7q09urg.webp#pic_center" width = 36%><p><strong>567. 字符串的排列</strong></p><p>题目描述：给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为和排列相关 (元素相同，顺序可以不同)，使用哈希表</span></span><br><span class="line">        hash_map_s2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1: 同时建立s1的哈希表 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hash_map_s1 = Counter(s1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s2):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hash_map_s2)， 如果hash_map_s1 == hash_map_s2，代表s2包含s1的排列，直接return</span></span><br><span class="line">            hash_map_s2[tail] = hash_map_s2.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map_s1 == hash_map_s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hash_map_s2)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(s1) - <span class="number">1</span>:</span><br><span class="line">                head = s2[start]</span><br><span class="line">                hash_map_s2[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hash_map_s2[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hash_map_s2[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5： 没有在s2中找到s1的排列，返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.6alyfc9r05s0.gif#pic_center" width = 48%><p><strong>487. 最大连续1的个数 II</strong></p><p>题目描述：给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计数 (0的个数不能超过1个)，所以还要一个哈希表</span></span><br><span class="line">        max_len, hash_map = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hash_map， max_len)</span></span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当hash_map里面0的个数大于1的时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hash_map)</span></span><br><span class="line">            <span class="keyword">while</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">1</span>:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><strong>1004. 最大连续1的个数 III</strong><br>题目描述：给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len, start = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hash_map[tail] = hash_map.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= k:     <span class="comment"># 相比较于上一题，只需要把1改成k</span></span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end-start+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> hash_map.get(<span class="number">0</span>, <span class="number">0</span>) &gt; k:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hash_map[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.351qb5gxbne0.gif#pic_center" width = 48%><p><strong>1208. 尽可能使字符串相等</strong><br>题目描述：给你两个长度相同的字符串，s 和 t。将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, max_cost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计算开销 (和求和一个道理)， 所以还要一个cur_cost</span></span><br><span class="line">        cur_cost, max_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (cur_cost)</span></span><br><span class="line">            <span class="comment"># 每一对字符的order差值就是当前时间点的开销，直接累积在cur_cost上即可</span></span><br><span class="line">            <span class="comment"># cur_cost只要不超过最大开销，就更新max_len</span></span><br><span class="line">            cur_cost += <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[end]) - <span class="built_in">ord</span>(t[end]))</span><br><span class="line">            <span class="keyword">if</span> cur_cost &lt;= max_cost:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当cur_cost大于最大开销时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法 (cur_cost &lt;= max_cost)</span></span><br><span class="line">            <span class="keyword">while</span> cur_cost &gt; max_cost:</span><br><span class="line">                cur_cost -= <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[start])-  <span class="built_in">ord</span>(t[start]))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.3j0vqxe6f6g0.gif#pic_center" width = 48%><p><strong>1052. 爱生气的书店老板</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.6xm4xkuf5qg0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量,</span></span><br><span class="line">        <span class="comment"># 因为涉及求和所以定义sum_sub_array和max_sum, 同时需要知道老板什么时候&#x27;发动技能&#x27;，再定义一个max_start</span></span><br><span class="line">        sum_sub_array, max_sum, max_start = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(customers):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            <span class="comment"># 注意：这里只要当老板在当前时间点会发脾气的时候才维护</span></span><br><span class="line">            <span class="comment"># sum_sub_array就不说了，和前面N道题的维护方法一样，新多出来的max_start也就是记录一样时间点而已，没什么fancy的</span></span><br><span class="line">            <span class="keyword">if</span> grumpy[end] == <span class="number">1</span>:</span><br><span class="line">                sum_sub_array += tail</span><br><span class="line">            <span class="keyword">if</span> sum_sub_array &gt; max_sum:</span><br><span class="line">                max_sum = sum_sub_array</span><br><span class="line">                max_start = start</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (老板技能持续时间固定)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_sub_array, max_avg)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= minutes - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> grumpy[start]:</span><br><span class="line">                    sum_sub_array -= customers[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里对比其他题目多了一小步: 在找到老板发动技能的最大收益时间点(max_start)后</span></span><br><span class="line">        <span class="comment"># 需要把受技能影响时间段中的grumpy全部置0 - 代表老板成功压制了自己的怒火</span></span><br><span class="line">        grumpy[max_start:max_start+minutes] = [<span class="number">0</span>] * minutes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 再遍历一遍数组求customer总数量并且返回结果   </span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> customer, grum <span class="keyword">in</span> <span class="built_in">zip</span>(customers, grumpy):</span><br><span class="line">            <span class="keyword">if</span> grum == <span class="number">0</span>:</span><br><span class="line">                res += customer</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.3wf994p63sc0.gif#pic_center" width = 48%><p><strong>1423. 可获得的最大点数</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.3wwhkrlmfzo0.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 这题相比前面的题目加了一丢丢小的变通: 题目要求首尾串最大点数，其实就是求非首尾串的连续序列的最小点数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxScore</span>(<span class="params">self, cardPoints: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，因为涉及求和所以定义sum_sub_array和min_sum</span></span><br><span class="line">        sum_sub_array, min_sum = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(cardPoints):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_sub_array)</span></span><br><span class="line">            sum_sub_array += tail</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cardPoints)-k == end - start + <span class="number">1</span>:</span><br><span class="line">                min_sum = <span class="built_in">min</span>(min_sum, sum_sub_array)</span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (min_sum， sum_sub_array)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(cardPoints) - k - <span class="number">1</span>:</span><br><span class="line">                sum_sub_array -= cardPoints[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (总点数减去非首尾串的连续序列的最小点数就可以得到首尾串的最大点数)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cardPoints) - min_sum <span class="keyword">if</span> min_sum != inf <span class="keyword">else</span> <span class="built_in">sum</span>(cardPoints)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.6ahf0vp2uk4.gif#pic_center" width = 36%><p><strong>1151. 最少交换次数来组合所有的1 Π</strong></p><p>题目描述：给出一个二进制数组data，你需要通过交换位置，将数组中任何位置上的1组合到一起，并返回所有可能中所需最少的交换次数。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.7k6gqpmoa5s0.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSwaps</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先数出一共有多少个1，输出来的个数就是窗口的长度</span></span><br><span class="line">        num_ones = data.count(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，求最小swap次数其实就是求窗口中0个数的最小值，因此定义num_zeros, min_num_zeros</span></span><br><span class="line">        num_zeros, min_num_zeros = <span class="number">0</span>, math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (num_zeros， min_num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> data[end] == <span class="number">0</span>:</span><br><span class="line">                num_zeros += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == num_ones:</span><br><span class="line">                min_num_zeros = <span class="built_in">min</span>(min_num_zeros, num_zeros)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (数组1的总个数)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> end &gt;= num_ones - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> data[start] == <span class="number">0</span>:</span><br><span class="line">                    num_zeros -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (如果min_num_zeros依旧是math.inf说明数组没有1存在，不能swap，返回0即可)</span></span><br><span class="line">        <span class="keyword">return</span> min_num_zeros <span class="keyword">if</span> min_num_zeros != math.inf <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>76. 最小覆盖子串</strong></p><p>题目描述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        need_dict = Counter(t)                      <span class="comment"># 哈希表：记录需要匹配到的各个元素的数目</span></span><br><span class="line">        need_count = <span class="built_in">len</span>(t)                         <span class="comment"># 记录需要匹配到的字符总数(need=0表示匹配到了)</span></span><br><span class="line">        left = <span class="number">0</span>                                    <span class="comment"># 窗口的左边界</span></span><br><span class="line">        res = (<span class="number">0</span>, inf)                              <span class="comment"># 记录目标子串 s[res[0], res[1]+1] 的起始和结尾</span></span><br><span class="line">        <span class="keyword">for</span> right, tail <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):             <span class="comment"># 窗口右边界右移一位，窗口中增加的字符 tail</span></span><br><span class="line">            <span class="keyword">if</span> tail <span class="keyword">in</span> need_dict:                    <span class="comment"># 窗口新加入的字符位于t中</span></span><br><span class="line">                <span class="keyword">if</span> need_dict[tail] &gt; <span class="number">0</span>:              <span class="comment"># 对当前字符还有需求</span></span><br><span class="line">                    need_count -= <span class="number">1</span>                 <span class="comment"># 此时新加入窗口中的 tail 对 need_count 有影响</span></span><br><span class="line">                need_dict[tail] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> need_count == <span class="number">0</span>:                  <span class="comment"># 窗口左边界持续右移，need_count=0，当前窗口完全覆盖了 t</span></span><br><span class="line">                <span class="keyword">if</span> res[<span class="number">1</span>] - res[<span class="number">0</span>] &gt; right - left:  <span class="comment"># 出现了更短的字符串</span></span><br><span class="line">                    res = (left, right)</span><br><span class="line">                head = s[left]                       <span class="comment"># 窗口中要滑出的字符 head</span></span><br><span class="line">                <span class="keyword">if</span> head <span class="keyword">in</span> need_dict:                <span class="comment"># 刚滑出的字符 head 位于 t 中</span></span><br><span class="line">                    <span class="keyword">if</span> need_dict[head] &gt;= <span class="number">0</span>:         <span class="comment"># 对当前字符ch还有需求，或刚好无需求(其实此时只有=0的情况)</span></span><br><span class="line">                        need_count += <span class="number">1</span>             <span class="comment"># 此时滑出窗口的 head 会对 need_count 有影响</span></span><br><span class="line">                    need_dict[head] += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span>                           <span class="comment"># 窗口左边界+1</span></span><br><span class="line">        <span class="keyword">return</span> s[res[<span class="number">0</span>]:res[<span class="number">1</span>]+<span class="number">1</span>] <span class="keyword">if</span> res[<span class="number">1</span>] &lt; <span class="built_in">len</span>(s) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.1kdghtlgzc5c.gif#pic_center" width = 48%><p><strong>239. 滑动窗口最大值</strong></p><p><strong>题目描述</strong><br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.bz3b93ddmio.webp#pic_center" width = 64%></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 用双端队列来存储数组的下标，为什么要存下标而不是存数值？</span></span><br><span class="line">        <span class="comment"># 因为存下标可以更方便的来确定元素是否需要移出滑动窗口</span></span><br><span class="line">        <span class="comment"># 判断下标是否合法来确定是否要移出</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">if</span> k == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">max</span>(nums)]</span><br><span class="line">        result, queue = [], deque()             <span class="comment"># 使用collections内置的双端队列，加快运行速度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前队列最左侧存储的下标等于 i-k 的值，代表目前队列已满。</span></span><br><span class="line">            <span class="comment"># 但是新元素需要进来，所以列表最左侧的下标出队列</span></span><br><span class="line">            <span class="keyword">if</span> queue <span class="keyword">and</span> queue[<span class="number">0</span>] == i - k:           </span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[queue[-<span class="number">1</span>]] &lt; nums[i]:      <span class="comment"># 对于新进入的元素，如果队列前面的数比它小，那么前面的都出队列</span></span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)         <span class="comment"># 新元素入队列</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:            <span class="comment"># 当前的大值加入到结果数组中</span></span><br><span class="line">                result.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>滑动窗口暂时告一段落，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.4ql491awvt00.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>双指针套路总结：<a href="https://zhuanlan.zhihu.com/p/95747836">https://zhuanlan.zhihu.com/p/95747836</a></li><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>算法与数据结构（一）：滑动窗口法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/89066140">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;89066140</a></li><li>滑动窗口法python模板写法：<a href="https://blog.csdn.net/weixin_44414948/article/details/113862173">https://blog.csdn.net/weixin_44414948&#x2F;article&#x2F;details&#x2F;113862173</a></li><li>滑动窗口的应用：<a href="https://leetcode.cn/problems/minimum-window-substring/solutions/1503454/by-flix-1kac/">https://leetcode.cn/problems/minimum-window-substring/solutions/1503454/by-flix-1kac/</a></li><li>秒杀12道中档题————滑动窗口：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 最小覆盖子串 </tag>
            
            <tag> 最小/最大数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 文章汇总</title>
      <link href="/article/212a3cab.html"/>
      <url>/article/212a3cab.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章是对Python专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1 基础篇"></a>1 基础篇</h2><ul><li><a href="https://qxienote.com/article/175d115.html">Python基础篇（一）– 十分钟学会基础语法</a></li><li><a href="https://qxienote.com/article/8a42c3c2.html">Python基础篇（二）– 数据类型和运算符</a></li><li><a href="">Python基础篇（三）– 列表、元组、字典、集合、字符串</a></li><li><a href="">Python基础篇（四）– 流程控制</a></li><li><a href="">Python基础篇（五）– 函数和表达式</a></li><li><a href="">Python基础篇（六）– 类和对象</a></li><li><a href="">Python基础篇（七）– 迭代器和生成器</a></li><li><a href="">Python基础篇（八）– 文件操作</a></li><li><a href="">Python基础篇（九）– 正则表达式</a></li><li><a href="">Python基础篇（十）– 异常处理</a></li><li><a href="">Python基础篇（十一）– 模块和包</a></li><li><a href="">Python基础篇（十二）– 常用模块</a></li><li><a href="">Python基础篇（十三）– 进程和线程</a></li><li><a href="">Python基础篇（十四）– 数据类dataclass使用指南</a></li><li><a href="">Python基础篇（十五）– Pygame游戏编程</a></li><li><a href="">Python基础篇（十六）– Python标准库模块之heapq与bisect</a></li></ul><h2 id="2-进阶篇"><a href="#2-进阶篇" class="headerlink" title="2 进阶篇"></a>2 进阶篇</h2><ul><li><a href="">Python进阶篇（一）– Django快速上手</a></li><li><a href="">Python进阶篇（二）– Django 深入模型</a></li><li><a href=""></a></li></ul><h2 id="3-数据结构与算法"><a href="#3-数据结构与算法" class="headerlink" title="3 数据结构与算法"></a>3 数据结构与算法</h2><ul><li><a href="https://qxienote.com/article/d46e4964.html">Python数据结构与算法篇（一）– 算法分析基础</a></li><li><a href="https://qxienote.com/article/319c8c73.html">Python数据结构与算法篇（二）– 前缀和与差分数组</a></li><li><a href="https://qxienote.com/article/37ba44a4.html">Python数据结构与算法篇（三）– 快慢指针与碰撞指针</a></li><li><a href="">Python数据结构与算法篇（四）– 滑动窗口算法</a></li><li><a href="">Python数据结构与算法篇（五）– 二分查找与二分答案</a></li><li><a href="">Python数据结构与算法篇（六）– 哈希表</a></li><li><a href="">Python数据结构与算法篇（七）– 栈的实现与应用</a></li><li><a href="">Python数据结构与算法篇（八）– 队列的实现与应用</a></li><li><a href="">Python数据结构与算法篇（九）–单调栈与单调队列</a></li><li><a href="">Python数据结构与算法篇（十）– 链表的实现</a></li><li><a href="">Python数据结构与算法篇（十一）– 链表的应用与常见题型</a></li><li><a href="">Python数据结构与算法篇（十二）– 树和二叉树</a></li><li><a href="">Python数据结构与算法篇（十三）– 位运算与使用技巧</a></li><li><a href="">Python数据结构与算法篇（十四）– 冒泡排序算法</a></li><li><a href="">Python数据结构与算法篇（十五）– 二叉树的遍历：深度优先搜索与广度优先搜索</a></li></ul><h2 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4 数据分析"></a>4 数据分析</h2><ul><li><a href="">Python数据分析（一）– NumPy 学习笔记</a></li><li><a href="">Python数据分析（二）– Matplotlib 学习笔记</a></li><li><a href="">Python数据分析（三）– Matplotlib绘图进阶</a></li><li><a href=""></a></li></ul><h2 id="5-网络爬虫"><a href="#5-网络爬虫" class="headerlink" title="5 网络爬虫"></a>5 网络爬虫</h2><h2 id="6-PyQt5"><a href="#6-PyQt5" class="headerlink" title="6 PyQt5"></a>6 PyQt5</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（三）-- 快慢指针与碰撞指针</title>
      <link href="/article/37ba44a4.html"/>
      <url>/article/37ba44a4.html</url>
      
        <content type="html"><![CDATA[<p>数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。本篇主要分析双指针在字符串数组中常用解题套路。</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。</p><p>双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。</p><p>双指针是一种思想，一种技巧或一种方法，并不是什么特别具体的算法，在二分查找等算法中经常用到这个技巧。具体就是用两个变量动态存储两个或多个结点，来方便我们进行一些操作。通常用在线性的数据结构中，比如链表和数组，有时候也会用在图算法中。</p><p>在我们遇到像数组，链表这类数据结构的算法题目的时候，应该要想得到双指针的套路来解决问题。特别是链表类的题目，经常需要用到两个或多个指针配合来记忆链表上的节点，完成某些操作。链表这种数据结构也是树形结构和图的原型，所以有时候在关于图和树形结构的算法题目中也会用到双指针。</p><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1 双指针"></a>1 双指针</h2><p>双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（碰撞指针或者叫左右指针）的指针进行扫描，从而达到相应的目的。</p><p>换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。</p><h3 id="1-1-快慢指针"><a href="#1-1-快慢指针" class="headerlink" title="1.1 快慢指针"></a>1.1 快慢指针</h3><p>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和 慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。</p><p>利用快慢指针可以用来解决某些算法问题，比如：</p><ul><li>计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。</li><li>判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。</li><li>判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</li><li>求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了</li><li>求链表倒数第 k 个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第 k 个元素。（严格来说应该叫先后指针而非快慢指针）</li></ul><p>快慢指针在链表的详细使用，可以阅读下一篇文章——<a href="https://blog.csdn.net/xq151750111/article/details/129303127?spm=1001.2014.3001.5501">Python数据结构与算法篇（六）– 链表的应用</a></p><h3 id="1-2-碰撞指针"><a href="#1-2-碰撞指针" class="headerlink" title="1.2 碰撞指针"></a>1.2 碰撞指针</h3><p>对撞指针（或者称作左右指针）是指在数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。一般都是排好序的数组或链表，否则无序的话这两个指针的位置也没有什么意义。特别注意两个指针的循环条件在循环体中的变化，小心右指针跑到左指针左边去了。常用来解决的问题有：</p><ul><li>二分查找问题</li><li>n 数之和问题：比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数。如果是三数问题就转化为一个数和另外两个数的两数问题。以此类推。</li></ul><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-快慢指针"><a href="#2-1-快慢指针" class="headerlink" title="2.1 快慢指针"></a>2.1 快慢指针</h3><ul><li>掌握数组删除元素的直接覆盖操作</li><li>双指针法</li></ul><p><strong>题库列表：</strong></p><blockquote> <ul><li><p>26. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank">删除有序数组中的重复项</a> （快慢指针）</p><li><p>27. <a href="https://leetcode-cn.com/problems/remove-element" target="_blank">移除元素</a> （快慢指针）</p><li><p>80. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank">删除有序数组中的重复项 II</a> (快慢指针） </p></li><li><p>283. <a href="https://leetcode.cn/problems/move-zeroes/description/" target="_blank">移动零</a>（快慢指针）</p></li></ul></blockquote> <p><strong>26. 删除有序数组中的重复项</strong></p><p>题目描述：给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow += <span class="number">1</span>                   <span class="comment"># 每个元素只出现一次，先 slow+1 再覆盖</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/001.3ltlzaihk9e0.gif#pic_center" width = 48%><p><strong>27. 移除元素</strong></p><p>题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>1. 快慢指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 快慢指针</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:               <span class="comment"># 删除指定元素，直接覆盖掉</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/002.4140vjzuc040.gif#pic_center" width = 48%><p>这里和有序数组去重的解法有一个细节差异，我们这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><p><strong>2. 单指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;拷贝覆盖&#x27;&#x27;&#x27;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num!= val:</span><br><span class="line">                nums[ans] = num</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/003.3p3rmieqqso0.gif#pic_center" width = 48%><p><strong>80. 删除有序数组中的重复项 II</strong></p><p>题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">1</span>, <span class="number">2</span>       <span class="comment"># 使得出现次数超过两次的元素只出现两次</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow-<span class="number">1</span>]:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>  slow + <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/004.6iyyl4e6wp80.gif#pic_center" width = 48%><p><strong>通用解法：</strong></p><p>为了让解法更具有一般性，我们将原问题的 <strong>「最多保留 1 位」修改为「最多保留 k 位</strong>。</p><p>对于此类问题，我们应该进行如下考虑：</p><p>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。</p><p>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。</p><p>此时，初始化时指针 slow 指向数组的起始位置（nums[k-1]），指针 fast 指向指针 slow 的后一个位置（nums[k]）。随着指针 fast 不断向后移动，将指针 fast 指向的元素与指 slow 指向的元素进行比较：</p><ul><li>如果nums[fast] ≠ nums[slow-k+1]，那么nums[slow + 1] &#x3D; nums[fast]；</li><li>如果nums[fast] &#x3D; nums[slow]，那么指针q继续向后查找；</li></ul><p><strong>283. 移动零</strong><br>题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>1. 快慢指针</strong><br><strong>写法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:                 <span class="comment"># 把前面为0的项覆盖掉</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        nums[slow:] = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)-slow)    <span class="comment"># 把后面填充为 0</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/005.2v3f4q957060.gif#pic_center" width = 48%><p><strong>写法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast]:</span><br><span class="line">                <span class="keyword">if</span> nums[slow] == <span class="number">0</span>:             <span class="comment"># 快指针不为零，慢指针为零，进行交换</span></span><br><span class="line">                    nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/006.79i27t7x4iw0.gif#pic_center" width = 48%><h3 id="2-2-左右指针"><a href="#2-2-左右指针" class="headerlink" title="2.2 左右指针"></a>2.2 左右指针</h3><p><strong>题库列表：</strong></p><blockquote> <ul><li><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank">88. 合并两个有序数组</a>：<mark>如何将数组所有元素整体后移，防止数组覆盖？</mark></p></li><li><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. 两数之和 II - 输入有序数组</a>（有序数列的首尾双指针）</p></li><li><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank">125. 验证回文串</a></p></li><li><p><a href="https://leetcode.cn/problems/reverse-string/" target="_blank">344. 反转字符串</a></p></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/" target="_blank">151. 反转字符串中的单词</a></p></li><li><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank">345. 反转字符串中的元音字母</a></p></li><li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank">11. 盛最多水的容器</a>：<strong>经典题目</strong></p></li><li><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/" target="_blank">42. 接雨水</a>：<strong>经典题目</strong></p></li><li><p> <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank">75. 颜色分类</a>（左右指针，三色旗）</p></li><li><p><a href="https://leetcode.cn/problems/backspace-string-compare/" target="_blank">844. 比较含退格的字符串</a>（左右指针）</p></li></ul></blockquote> <p><strong>88. 合并两个有序数组</strong></p><p>题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p><strong>1. 左右指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        nums1[m:] = nums2               # 直接合并后排序</span></span><br><span class="line"><span class="string">        nums1.sort()           </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p0, p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span>, m+n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0 &gt;= <span class="number">0</span> <span class="keyword">or</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> p0 == -<span class="number">1</span>:                <span class="comment"># num1 已经循环结束</span></span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p1 == -<span class="number">1</span>:              <span class="comment"># # num2 已经循环结束</span></span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p0] &gt; nums2[p1]:</span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/007.465vy0ux2co0.gif#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        p0, p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span>, m+n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0 &gt;= <span class="number">0</span> <span class="keyword">and</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p0] &gt; nums2[p1]:   <span class="comment"># num1 更大</span></span><br><span class="line">                nums1[p2] = nums1[p0]</span><br><span class="line">                p0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                      </span><br><span class="line">                nums1[p2] = nums2[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后拼接没有遍历完的数组，由于直接在 nums1 上操作，只需要在nums2没遍历完，拼接起来就可以了</span></span><br><span class="line">        <span class="keyword">if</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[:p2+<span class="number">1</span>] = nums2 [:p1+<span class="number">1</span>]  </span><br></pre></td></tr></table></figure><p><strong>167. 两数之和 II - 输入有序数组</strong></p><p>题目描述：给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            two_sum = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> two_sum == target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]    <span class="comment"># 题目要求下标从1开始</span></span><br><span class="line">            <span class="keyword">elif</span> two_sum &gt; target:          <span class="comment"># 两数之和大于目标值，右边的值太大了，right--</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                           <span class="comment"># 两数之和小于目标值，左边值太小，left++</span></span><br><span class="line">                left += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/008.3gtipsibd9q0.gif#pic_center" width = 48%><p><strong>125. 验证回文串</strong></p><p>题目描述：如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串。字母和数字都属于字母数字字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 思路一：正则表达式</span></span><br><span class="line"><span class="string">        if not s:</span></span><br><span class="line"><span class="string">            return True</span></span><br><span class="line"><span class="string">        s = s.lower()</span></span><br><span class="line"><span class="string">        pattern = re.compile(r&#x27;[^a-z0-9]&#x27;)   # 正则表达式，把数字和字母都剔除掉</span></span><br><span class="line"><span class="string">        new_str = pattern.sub(&#x27;&#x27;, s)</span></span><br><span class="line"><span class="string">        return new_str == new_str[::-1]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 字符串预处理</span></span><br><span class="line"><span class="string">        new_str = &#x27;&#x27;.join(ch.lower() for ch in s if ch.isalnum())</span></span><br><span class="line"><span class="string">        return new_str == new_str[::-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 左右指针</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 两个循环找到左侧和右侧为字母或者数字的位置</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:                   <span class="comment"># 判断移动过后的left，right是否满足left在左，right在右的相对位置</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[left] != s[right]:         <span class="comment"># 如果左右指针所指不同，则肯定不构成回文</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:                           <span class="comment"># 左右指针各前进一步</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这里使用了正则表达式移除所有非字母数字字符，然后判断新的字符串是否是回文，也可以使用双指针，直接一次遍历，遇到字母数字字符就进行判断。</p><p><strong>151. 反转字符串中的单词</strong></p><p>题目描述：给你一个字符串 s，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.strip() <span class="comment"># 删除首尾空格</span></span><br><span class="line">        i = j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">&#x27; &#x27;</span>: i -= <span class="number">1</span>    <span class="comment"># 搜索首个空格</span></span><br><span class="line">            res.append(s[i + <span class="number">1</span>: j + <span class="number">1</span>])             <span class="comment"># 添加单词</span></span><br><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">&#x27; &#x27;</span>: i -= <span class="number">1</span>               <span class="comment"># 跳过单词间空格</span></span><br><span class="line">            j = i                                   <span class="comment"># j 指向下个单词的尾字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)                        <span class="comment"># 拼接并返回</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/009.21eld8of51fk.gif#pic_center" width = 48%><p><strong>2. 分割 + 倒序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.strip().split()[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.736ly7pxg8s0.webp#pic_center" width = 48%><p><strong>344. 反转字符串</strong></p><p>题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 $O(1)$ 的额外空间解决这一问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        return s.reverse()</span></span><br><span class="line"><span class="string">        s[:] = s[::-1]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 左右指针法</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/010.ituca5t9lds.gif#pic_center" width = 48%><p><strong>345. 反转字符串中的元音字母</strong></p><p>题目描述：给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现不止一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        str_set = <span class="built_in">set</span>(<span class="string">&quot;aeiouAEIOU&quot;</span>)</span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        str_list = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">if</span> str_list[head] <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">in</span> str_set:</span><br><span class="line">                str_list[head], str_list[tail] = str_list[tail], str_list[head]</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str_list[head] <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">not</span> <span class="keyword">in</span> str_set:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> str_list[head] <span class="keyword">not</span> <span class="keyword">in</span> str_set <span class="keyword">and</span> str_list[tail] <span class="keyword">in</span> str_set:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br></pre></td></tr></table></figure><p><strong>11. 盛最多水的容器</strong></p><p>题目描述：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 双指针，移动小的那一边</span></span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">if</span> height[head] &lt; height[tail]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[head]*(tail-head))</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[tail]*(tail-head))</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/011.63a65w667xw0.gif#pic_center" width = 48%><p><strong>42. 接雨水</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/012.rx8hdafpg8w.webp#pic_center" width = 64%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        leftMax = rightMax = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left])</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right])</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                ans += leftMax - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += rightMax - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/013.2ziftttwjuk0.gif#pic_center" width = 48%><p><strong>75. 颜色分类</strong></p><p>题目描述：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>1. 单指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">            <span class="keyword">if</span> nums[k] == <span class="number">1</span>:</span><br><span class="line">                nums[k], nums[i] = nums[i], nums[k]</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/014.6ht435cinmw0.gif#pic_center" width = 48%><p><strong>2. 左右指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 定义三个变量，p0 表示数组最左边0的区域，p1是数组最右边2的区域</span></span><br><span class="line">        i, p0, p1 = <span class="number">0</span>, <span class="number">0</span> , <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p1:</span><br><span class="line">            <span class="comment"># 如果当前指向的是 0，就把这个元素交换到数组左边</span></span><br><span class="line"><span class="comment"># 也就是跟 p0 指针交换，之后cur，p0 就往前一动一位</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前指向的是2，就把这个元素交换到数组右边</span></span><br><span class="line"><span class="comment"># 也就是跟p2指针交换，注意此时cur指针就不用移动了</span></span><br><span class="line"><span class="comment"># 因为右边的一片区域都是2，只要把元素交换过去就可以了，cur不用移动</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果是1的话，就不用交换</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/015.27435ybjphus.gif#pic_center" width = 48%><p><strong>844. 比较含退格的字符串</strong></p><p>题目描述：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。如果对空文本输入退格字符，文本继续为空。</p><p><strong>1. 双指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s_skip_num = <span class="number">0</span>                              <span class="comment"># 记录s的#数量</span></span><br><span class="line">        t_skip_num = <span class="number">0</span>                              <span class="comment"># 记录t的#数量</span></span><br><span class="line">        i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        j = <span class="built_in">len</span>(t) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>):                         <span class="comment"># 从后向前，消除S的#</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>): </span><br><span class="line">                    s_skip_num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (s_skip_num &gt; <span class="number">0</span>): </span><br><span class="line">                        s_skip_num -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>):                         <span class="comment"># 从后向前，消除T的#</span></span><br><span class="line">                <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>):</span><br><span class="line">                    t_skip_num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (t_skip_num &gt; <span class="number">0</span>):</span><br><span class="line">                        t_skip_num -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 后半部分</span></span><br><span class="line">            <span class="comment"># 消除完了，接下来比较s[i] != t[j]</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span>                              <span class="comment"># s 或者 t 遍历到头了</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[j]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 说明S和T同时遍历完毕</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> <span class="keyword">and</span> j == -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/016.bbd1edjnceg.gif#pic_center" width = 48%><p><strong>2. 栈模拟法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.back_strip(s) == self.back_strip(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">back_strip</span>(<span class="params">self, s</span>):</span><br><span class="line">        s_list = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> item == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> s_list:</span><br><span class="line">                    s_list.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_list.append(item)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p><strong>3. 移除元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        list_s, list_t = <span class="built_in">list</span>(s), <span class="built_in">list</span>(t)</span><br><span class="line">        idx_s, idx_t = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_s)):</span><br><span class="line">            <span class="keyword">if</span> list_s[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                list_s[idx_s] = list_s[i]</span><br><span class="line">                idx_s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx_s -= <span class="number">1</span> <span class="keyword">if</span> idx_s &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_t)):</span><br><span class="line">            <span class="keyword">if</span> list_t[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                list_t[idx_t] = list_t[i]</span><br><span class="line">                idx_t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx_t -= <span class="number">1</span> <span class="keyword">if</span> idx_t &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> list_s[:idx_s] == list_t[:idx_t]</span><br></pre></td></tr></table></figure><p><strong>977. 有序数组的平方</strong></p><p>题目描述：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;先平方后排序，每次利用已排序的先验信息，最大值必定在两端出现&quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, length-<span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[left] ** <span class="number">2</span> &lt; nums[right] ** <span class="number">2</span>:</span><br><span class="line">                result.append(nums[right] ** <span class="number">2</span>)</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(nums[left] ** <span class="number">2</span>)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/017.5si4hg3y9m00.gif#pic_center" width = 48%><hr><h3 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h3><p>题库列表：</p><blockquote> <ul><li><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/" target="_blank">5. 最长回文子串</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum/" target="_blank">15. 三数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum-closest/" target="_blank">16. 最接近的三数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/4sum/" target="_blank">18. 四数之和</a></p></li><li><p><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank">56. 合并区间</a>：<strong>数组类操作</strong></p></li></ul></blockquote> <p><strong>5. 最长回文子串</strong></p><p>题目描述：给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>思路分析：找回⽂串的难点在于，回⽂串的的⻓度可能是奇数也可能是偶数，解决该问题的核⼼是<font color=#9900CC><strong>从中⼼向两端扩散的双指针技巧</strong></font>。如果回⽂串的⻓度为奇数，则它有⼀个中⼼字符；如果回⽂串的⻓度为偶数，则可以认为它有两个中⼼字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找到以i和i+1为中心的回文字符串&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            s1 = self.palindrome(s, i, i)</span><br><span class="line">            s2 = self.palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            res = s1 <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(res) <span class="keyword">else</span> res</span><br><span class="line">            res = s2 <span class="keyword">if</span> <span class="built_in">len</span>(s2) &gt; <span class="built_in">len</span>(res) <span class="keyword">else</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">self, s, l, r</span>):</span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure><p><strong>15. 三数之和</strong><br>题目描述：给你一个整数数组 nums ，判断是否存在三元组 $[nums[i], nums[j], nums[k]]$ 满足 $i !&#x3D; j、i !&#x3D; k$ 且 $j !&#x3D; k$ ，同时还满足 $nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0$。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums_sorted)):</span><br><span class="line">            <span class="keyword">if</span> nums_sorted[i] &gt; <span class="number">0</span>:                              <span class="comment"># 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            # 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line"><span class="string">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="string">                continue;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:      <span class="comment"># 去重</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums_sorted)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                # 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0, 0, 0 这种三元组</span></span><br><span class="line"><span class="string">                while left &lt; right and nums_sorted[left] == nums_sorted[left+1]:    left += 1</span></span><br><span class="line"><span class="string">                while left &lt; right and nums_sorted[right] == nums_sorted[right-1]:  right -= 1</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> nums_sorted[i]+nums_sorted[left]+nums_sorted[right] == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums_sorted[i], nums_sorted[left], nums_sorted[right]])</span><br><span class="line">                    <span class="comment"># 在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], </span></span><br><span class="line">                    <span class="comment"># i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[left] == nums_sorted[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[right] == nums_sorted[right-<span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 找到答案时双指针同时收缩</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums_sorted[i]+nums_sorted[left]+nums_sorted[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/018.2k1miygya7c0.gif#pic_center" width = 48%><p><strong>16. 最接近的三数之和</strong><br>题目描述：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)         <span class="comment"># 初始化，因为找最小值，因此把初始值设置成实数的最大值</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)          <span class="comment"># 排序是前提</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:    <span class="comment"># 常见的剪枝操作</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i+<span class="number">1</span>                                          <span class="comment"># 双指针：指针对撞</span></span><br><span class="line">            right = length-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                temp = nums_sorted[left] + nums_sorted[right] + nums_sorted[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(temp-target) &lt; diff:     </span><br><span class="line">                    diff = <span class="built_in">abs</span>(temp-target)</span><br><span class="line">                    ans = temp</span><br><span class="line">                <span class="comment"># 不管是变小还是变大，尝试的作用是让 temp 与 target 更接近，即 temp 与 target 的绝对值之差越来越小</span></span><br><span class="line">                <span class="keyword">if</span> temp &gt; target:        <span class="comment"># 如果大了，尝试右边界收缩一格，让 temp 变小</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> temp &lt; target:     <span class="comment"># 如果小了，尝试左边界收缩一格，让 target 变大</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 如果已经等于 target 的话, 肯定是最接近的，根据题目要求，返回这三个数的和</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/019.2na0d7iaxdo0.gif#pic_center" width = 48%><p><strong>18. 四数之和</strong></p><p>题目描述：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li>0 &lt;&#x3D; a, b, c, d &lt; n</li><li>a、b、c 和 d 互不相同</li><li>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</li></ul><p>你可以按 任意顺序 返回答案 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length): </span><br><span class="line">            <span class="comment"># 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> nums_sorted[i] &gt; target <span class="keyword">and</span> nums_sorted[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 对 nums_sorted[i] 去重</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums_sorted[i] == nums_sorted[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):        <span class="comment"># 比原来多一层循环</span></span><br><span class="line">                <span class="comment"># 二级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> nums_sorted[i] + nums_sorted[j] &gt; target <span class="keyword">and</span> nums_sorted[i] + nums_sorted[j] &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 对 nums_sorted[j] 去重</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums_sorted[j] == nums_sorted[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="keyword">if</span> nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] == target:</span><br><span class="line">                        result.append([nums_sorted[i], nums_sorted[j], nums_sorted[left], nums_sorted[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[left] == nums_sorted[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums_sorted[right] == nums_sorted[right-<span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>56. 合并区间</strong></p><p>题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] &#x3D; [starti, endi]$。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result= []</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 如果列表为空，或者当前区间与上一区间不重合，直接添加</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">or</span> result[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                result.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则的话，我们就可以与上一区间进行合并</span></span><br><span class="line">                result[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(result[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=#9900CC><strong>左右指针与快慢指针暂时告一段落，但还有很多自己不满意的地方，后面在学习中持续补充，谢谢大家的鼓励和支持！<font><strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/020.3nvcyp0fhrq0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>双指针套路总结：<a href="https://zhuanlan.zhihu.com/p/95747836">https://zhuanlan.zhihu.com/p/95747836</a></li><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>算法与数据结构（一）：滑动窗口法总结：<a href="https://blog.csdn.net/Dby_freedom/article/details/89066140">https://blog.csdn.net/Dby_freedom&#x2F;article&#x2F;details&#x2F;89066140</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快慢指针 </tag>
            
            <tag> 碰撞指针 </tag>
            
            <tag> 连续区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（二）-- 前缀和与差分数组</title>
      <link href="/article/319c8c73.html"/>
      <url>/article/319c8c73.html</url>
      
        <content type="html"><![CDATA[<p>前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。本节主要学习算法的原理，结合LeetCode题目分析如何使用这些技巧。</p><span id="more"></span><p>数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。</p><p>数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。</p><p>此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。本节主要讲解这两种算法。</p><h2 id="1-前缀和与差分数组"><a href="#1-前缀和与差分数组" class="headerlink" title="1 前缀和与差分数组"></a>1 前缀和与差分数组</h2><p>前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和，差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。合理的使用前缀和与差分，可以将某些复杂的问题简单化。</p><h3 id="1-1-前缀和"><a href="#1-1-前缀和" class="headerlink" title="1.1 前缀和"></a>1.1 前缀和</h3><p>假设有一个序列 A，前缀和为 S。根据概念很容易知到公式</p><p>$$S[i]&#x3D;\displaystyle \sum_{j&#x3D;1}^iA[j]$$</p><p>如何求区间 $[l,r]$ 的和呢？</p><p>$$sum[l,r]&#x3D;s[r]-s[l-1]$$</p><h3 id="1-2-差分数组"><a href="#1-2-差分数组" class="headerlink" title="1.2 差分数组"></a>1.2 差分数组</h3><p>设原数组为 A[i],差分数组为 diff[i]，则：</p><p>$$diff[i]&#x3D;\begin{cases} A[i]&amp;i&#x3D;1\ A[i]-A[i-1]&amp;i\geq2 \end{cases}$$</p><p>差分数组的性质是：</p><ul><li>如果对区间 $[l,r]$ 进行修改，只需修改 $diff[l], diff[r+1]$（diff[l]加上修改值，diff[r+1] 减去修改值）</li><li>$A[i]&#x3D;\displaystyle \sum_{j&#x3D;1}^{i}B[j]$（通过 $B[i]&#x3D;A[i]-A[i-1]$ 证明）</li><li>$S[x]&#x3D;\displaystyle \sum_{i&#x3D;1}^{x}A[i]&#x3D;\displaystyle \sum_{i&#x3D;1}^{x} \displaystyle \sum_{j&#x3D;1}^{i}diff[j]&#x3D;\displaystyle \sum _{i&#x3D;1}^{x}(x-i+1)*diff[i]$$</li></ul><blockquote><p>当我们希望对原数组的某一个区间 $[i, j]$ 施加一个增量 inc 时，差分数组 $d$ 对应的变化是：$d[i] 4$ 增加 inc，$d[j+1]$ 减少inc，并且这种操作是可以叠加的。</p></blockquote><p>下面举个例子：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/043.6lmgy6vjiyc0.webp#pic_center" width = 64%><p>差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。</p><p>还是上面那个表里的例子，我们需要进行以下操作：</p><ol><li>将区间[1，4]的数值全部加上3</li><li>将区间[3，5]的数值全部减去5</li></ol><p>很简单对吧，你可以进行枚举。但是如果给你的数据量是 $1\times e^5$，操作量 $1\times e^5$，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。</p><p>其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。</p><p>利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/044.125vurueqzr4.webp#pic_center" width = 64%><p>进行下一个操作，</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/045.71279cxlwrs0.webp#pic_center" width = 64%><p>这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。</p><p>本部分参考自：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分详解+例题</a></p><p>也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，<font color=#9900CC><strong>差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。</font></strong></p><p>有 $n$ 个数，$m$ 个操作，每一次操作，将 $x<del>y$ 区间的所有数增加 $z$；最后有 $q$ 个询问，每一次询问求出 $x</del>y$ 的区间和。设原数组为 $A[i]$。其步骤为：</p><ul><li>先求出差分数组 $B[i]&#x3D;A[i]−A[i−1]$</li><li>在根据 $m$ 个造作修改 $B[i]$</li><li>求修改后的 $A[i]&#x3D;A[i−1]+B[i]$</li><li>求前缀和 $S[i]&#x3D;S[i−1]+A[i]$</li><li>最后输出区间和 $sum[x,y]&#x3D;S[y]−S[x−1]$</li></ul><blockquote><p><font color=#9900CC><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，适用于快速、频繁地计算一个索引区间内的元素之和以及频繁查询某个区间的累加；差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</font></strong></p></blockquote><hr><h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2 常见题型"></a>2 常见题型</h2><h3 id="2-1-题库列表"><a href="#2-1-题库列表" class="headerlink" title="2.1 题库列表"></a>2.1 题库列表</h3><blockquote> <ul><li><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/" target="_blank">303. 区域和检索 - 数组不可变</a>：<strong>一维前缀和</strong></p></li><li><p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/" target="_blank">304. 二维区域和检索 - 矩阵不可变</a>：<strong>二维前缀和</strong></p></li><li><p><a href="https://leetcode.cn/problems/range-addition/" target="_blank">370. 区间加法</a>：<strong>差分数组</strong></p></li><li><p><a href="https://leetcode.cn/problems/corporate-flight-bookings/" target="_blank">1109. 航班预订统计</a>：<strong>差分数组</strong></p></li><li><p><a href="https://leetcode.cn/problems/car-pooling/" target="_blank">1094. 拼车</a>：<strong>差分数组</strong></p></li></ul></blockquote> <p><strong>303. 区域和检索 - 数组不可变</strong></p><p>题目描述：<br><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/046.4jq9oeam7mw0.webp#pic_center" width = 80%></p><p><strong>一维前缀和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.nums_array = [<span class="number">0</span>]            <span class="comment"># 便于计算累加和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.nums_array.append(self.nums_array[i] + nums[i])  <span class="comment"># 计算nums累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.nums_array[right+<span class="number">1</span>] - self.nums_array[left]</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/047.xrjyxto1ocw.gif#pic_center" width = 64%><p><strong>304. 二维区域和检索 - 矩阵不可变</strong></p><p>题目描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/048.6ey4bron1sg0.webp#pic_center" width = 80%><p><strong>二维前缀和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])                  <span class="comment"># 矩阵的行和列</span></span><br><span class="line">        self.pre_sum = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]      <span class="comment"># 构造一维前缀和矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.pre_sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = self.pre_sum[i+<span class="number">1</span>][j] + self.pre_sum[i][j+<span class="number">1</span>] - self.pre_sum[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.pre_sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - self.pre_sum[row1][col2+<span class="number">1</span>] - self.pre_sum[row2+<span class="number">1</span>][col1] + self.pre_sum[row1][col1])</span><br></pre></td></tr></table></figure><p><strong>370. 区间加法</strong></p><p>题目描述：假设你有一个长度为n的数组，初始情况下所有的数字均为0，你将会被给出k个更新的操作。其中，每个操作会被表示为一个三元组: [startIndex, endIndex, inc]，你需要将子数组 A[startIndex, endIndex]（包括startlndex和endIndex）增加 inc。<br>请你返回 k 次操作后的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (length+<span class="number">1</span>)  <span class="comment"># 末尾多个0，防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end + <span class="number">1</span>] -= inc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            diff[i] += diff[i - <span class="number">1</span>]            <span class="comment"># 对差分数组求前缀和便可得到原数组</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> diff[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>1109. 航班预订统计</strong></p><p>题目描述：这里有 n 个航班，它们分别从 1 到 n 进行编号。有一份航班预订表 bookings ，表中第 $i$ 条预订记录 $bookings[i] &#x3D; [first_i, last_i, seats_i]$ 意味着在从 $first_i$ 到 $last_i$（包含 $first_i$ 和 $last_i$）的 每个航班 上预订了 $seats_i$ 个座位。请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        diff = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> booking <span class="keyword">in</span> bookings:</span><br><span class="line">            start, end, inc = booking[<span class="number">0</span>], booking[<span class="number">1</span>], booking[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            <span class="keyword">if</span> end &lt; n:             <span class="comment"># 没在末尾添加0，要判断一下边界</span></span><br><span class="line">                diff[end+<span class="number">1</span>] -= inc</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/052.6gnyefuumd80.gif#pic_left" width = "40%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/052.6gnyefuumd80.gif#pic_left"  width = "48%"></center></p><p><strong>1094. 拼车</strong></p><p>题目描述：车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向），给定整数 capacity 和一个数组 trips ,  $trip[i] &#x3D; [numPassengers_i, from_i, to_i]$ 表示第 $i$ 次旅行有 $numPassengers_i$ 乘客，接他们和放他们的位置分别是 $from_i$ 和 $to_i$。这些位置是从汽车的初始位置向东的公里数。当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="number">1001</span>)      <span class="comment"># 题目中最多有1001个车站</span></span><br><span class="line">        max_station = <span class="number">0</span>          <span class="comment"># 找到车站数</span></span><br><span class="line">        <span class="keyword">for</span> trip <span class="keyword">in</span> trips:</span><br><span class="line">            inc, start, end = trip[<span class="number">0</span>], trip[<span class="number">1</span>], trip[<span class="number">2</span>]</span><br><span class="line">            diff[start] += inc</span><br><span class="line">            diff[end] -= inc      <span class="comment"># 第end站乘客已经下车，这里就不用end+1</span></span><br><span class="line">            max_station = <span class="built_in">max</span>(max_station, end)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_station+<span class="number">1</span>): <span class="comment"># 进行区间求和</span></span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(diff[:max_station]) &gt; capacity:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/050.qso2bf25fv4.webp#pic_center" width = 80%><hr><blockquote><p><font color=#9900CC><strong>欢迎各位大佬一起来学习前缀和与差分数组，希望本篇可以让你对前缀和和差分的概念及使用技巧有更清晰的理解，欢迎继续补充！</font></strong></p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230610/051.4lt77415u1s0.gif#pic_center" width = 48%><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>数组+常见题型与解题策略：<a href="https://blog.csdn.net/qq_42647903/article/details/120594856">https://blog.csdn.net/qq_42647903&#x2F;article&#x2F;details&#x2F;120594856</a></li><li>差分详解+例题：<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">https://blog.csdn.net/qq_44786250&#x2F;article&#x2F;details&#x2F;100056975</a></li><li>数组（三）– LC[370]&amp;[1109]&amp;[1094] 区间加法：<a href="https://blog.csdn.net/xq151750111/article/details/129243272?spm=1001.2014.3001.5502">https://blog.csdn.net/xq151750111/article/details/129243272?spm=1001.2014.3001.5502</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学（一）-- LC[12]&amp;[13] 整数转罗马数字</title>
      <link href="/article/b86971b3.html"/>
      <url>/article/b86971b3.html</url>
      
        <content type="html"><![CDATA[<p>本篇以LeetCode[12]——整数转罗马数字为例，分析如何使用数学方法进行解题</p><span id="more"></span><h2 id="1-整数转罗马数字"><a href="#1-整数转罗马数字" class="headerlink" title="1 整数转罗马数字"></a>1 整数转罗马数字</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><blockquote><p>示例 1:<br>输入: num &#x3D; 3<br>输出: “III”</p></blockquote><blockquote><p>示例 2:<br>输入: num &#x3D; 4<br>输出: “IV”</p></blockquote><blockquote><p>示例 3:<br>输入: num &#x3D; 9<br>输出: “IX”</p></blockquote><blockquote><p>示例 4:<br>输入: num &#x3D; 58<br>输出: “LVIII”<br>解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</p></blockquote><blockquote><p>示例 5:<br>输入: num &#x3D; 1994<br>输出: “MCMXCIV”<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p></blockquote><p>提示：1 &lt;&#x3D; num &lt;&#x3D; 3999</p><p>题目链接：<a href="https://leetcode.cn/problems/integer-to-roman/">https://leetcode.cn/problems/integer-to-roman/</a></p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p>根据题目分析，我们知道罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。这给了我们总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/040.lngh4orwxww.webp#pic_center" width = 48%><p>考虑 140140 的罗马数字表示，我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为 C&#x3D;100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL&#x3D;40。因此，140 的对应的罗马数字为 <code>C+XL=CXL</code>。这说明罗马数字是唯一表示的。(这不就是贪心策略，和找零钱的问题有点类似)</p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p><strong>1. 思路一: 模拟</strong><br>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 整除该符号值，并将整除的值乘以该符号，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。设计算法的思想如下：每一步都使用当前对应阿拉伯数字较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。(贪心算法)</p><p>编程时，可以建立一个数值-符号对的列表 value_symbol，按数值从大到小排列。遍历 value_symbol 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        value_symbol = [(<span class="number">1000</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="number">900</span>, <span class="string">&#x27;CM&#x27;</span>), (<span class="number">500</span>, <span class="string">&#x27;D&#x27;</span>), (<span class="number">400</span>, <span class="string">&#x27;CD&#x27;</span>), (<span class="number">100</span>, <span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        (<span class="number">90</span>, <span class="string">&#x27;XC&#x27;</span>), (<span class="number">50</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="number">40</span>, <span class="string">&#x27;XL&#x27;</span>), (<span class="number">10</span>, <span class="string">&#x27;X&#x27;</span>), (<span class="number">9</span>, <span class="string">&#x27;IX&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;V&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;IV&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;I&#x27;</span>)]</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> value, symbol <span class="keyword">in</span> value_symbol:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= value:</span><br><span class="line">                result += symbol * (num // value)</span><br><span class="line">                num = num % value</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。由于 value_symbol 长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3(超过3就要进位了)，因此循环次数有一个确定的上限。</li><li>空间复杂度：$O(1)$。</li></ul><p><strong>2. 思路二：硬编码数字</strong></p><p>我们可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 0 对应的是空字符串。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/041.4cvm6z500240.webp#pic_center" width = 48%><p>利用模运算和除法运算，我们可以得到 num 每个位上的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thousands_digit = num // <span class="number">1000</span></span><br><span class="line">hundreds_digit = (num % <span class="number">1000</span>) // <span class="number">100</span></span><br><span class="line">tens_digit = (num % <span class="number">100</span>) // <span class="number">10</span></span><br><span class="line">ones_digit = num % <span class="number">10</span></span><br></pre></td></tr></table></figure><p>最后，根据 num 每个位上的数字，在硬编码表中查找对应的罗马字符，并将结果拼接在一起，即为 num 对应的罗马数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    thousands = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;MMM&#x27;</span>]</span><br><span class="line">    hundreds = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;CD&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;DC&#x27;</span>, <span class="string">&#x27;DCC&#x27;</span>, <span class="string">&#x27;DCCC&#x27;</span>, <span class="string">&#x27;CM&#x27;</span>]</span><br><span class="line">    tens = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;XX&#x27;</span>, <span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XL&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;LX&#x27;</span>, <span class="string">&#x27;LXX&#x27;</span>, <span class="string">&#x27;LXXX&#x27;</span>, <span class="string">&#x27;XC&#x27;</span>]</span><br><span class="line">    ones = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>, <span class="string">&#x27;VII&#x27;</span>, <span class="string">&#x27;VIII&#x27;</span>, <span class="string">&#x27;IX&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> Solution.thousands[num//<span class="number">1000</span>] + Solution.hundreds[num%<span class="number">1000</span>//<span class="number">100</span>] + Solution.tens[num%<span class="number">100</span>//<span class="number">10</span>] + Solution.ones[num%<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。计算量与输入数字的大小无关。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="2-罗马数转整数"><a href="#2-罗马数转整数" class="headerlink" title="2 罗马数转整数"></a>2 罗马数转整数</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><blockquote><p>示例 1:<br>输入: s &#x3D; “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:<br>输入: s &#x3D; “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:<br>输入: s &#x3D; “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:<br>输入: s &#x3D; “LVIII”<br>输出: 58<br>解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</p></blockquote><blockquote><p>示例 5:<br>输入: s &#x3D; “MCMXCIV”<br>输出: 1994<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p></blockquote><p>题目链接：<a href="https://leetcode.cn/problems/roman-to-integer/">https://leetcode.cn/problems/roman-to-integer/</a></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>思路一：观察下图，我们可以发现罗马数字最多为两位，所以可以利用这个来判断和下一个字母组合是否是构成一个整数，示例代码如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/042.141x8tzxsjhc.webp#pic_center" width = 48%><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        symbol_value = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;CM&#x27;</span>: <span class="number">900</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;CD&#x27;</span>: <span class="number">400</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;XC&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;XL&#x27;</span>: <span class="number">40</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;IX&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;IV&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[index:index+<span class="number">2</span>] <span class="keyword">in</span> symbol_value.keys():</span><br><span class="line">                result += symbol_value[s[index:index+<span class="number">2</span>]]</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += symbol_value[s[index]]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>思路二：我们由上面的定义可以知道，对于罗马数字<code>AB</code>，A代表的整数小于B是，要用B代表的整数减去A代表的整数，否则两个代表的整数相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        symbol_value = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> symbol_value[s[i]] &lt; symbol_value[s[i+<span class="number">1</span>]]:</span><br><span class="line">                result -= symbol_value[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += symbol_value[s[i]]</span><br><span class="line">        <span class="keyword">return</span> result + symbol_value[s[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础文章汇总</title>
      <link href="/article/a0d5b4a3.html"/>
      <url>/article/a0d5b4a3.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章是对计算机基础专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1 计算机网络"></a>1 计算机网络</h2><h3 id="1-1-网络篇"><a href="#1-1-网络篇" class="headerlink" title="1.1  网络篇"></a>1.1  网络篇</h3><ul><li><a href="https://qxienote.com/article/54ebc735.html">计算机网络篇（一）– 网络协议入门</a></li><li><a href="https://qxienote.com/article/279b4884.html">计算机网络篇（二）– HTTP 协议入门</a></li><li><a href="https://qxienote.com/article/ae7157b3.html">计算机网络篇（三）– SSL&#x2F;TLS 协议入门</a></li><li><a href="https://qxienote.com/article/1ee3e5d0.html">计算机网络篇（四）– TCP&#x2F;IP 协议族详解</a></li><li><a href="https://qxienote.com/article/84fa558.html">计算机网络篇（五）– TCP 套接字编程</a></li><li><a href="https://qxienote.com/article/929e2127.html">计算机网络篇（六）– UDP 套接字编程</a></li><li><a href="https://qxienote.com/article/24fe53d6.html">计算机网络篇（七）– ICMP-Ping 服务程序框架</a></li><li><a href="https://qxienote.com/article/ba7802fc.html">计算机网络篇（八）-邮件客户端实现与电子邮件发送</a></li></ul><h3 id="1-2-《计算机网络—自顶向下方法》-Wireshark实验"><a href="#1-2-《计算机网络—自顶向下方法》-Wireshark实验" class="headerlink" title="1.2 《计算机网络—自顶向下方法》 Wireshark实验"></a>1.2 《计算机网络—自顶向下方法》 Wireshark实验</h3><ul><li><a href="https://blog.csdn.net/xq151750111/article/details/130515236">《计算机网络—自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130536991">《计算机网络—自顶向下方法》 Wireshark实验（二）：HTTP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130576182">《计算机网络—自顶向下方法》 Wireshark实验（三）：DNS协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130648866">《计算机网络—自顶向下方法》 Wireshark实验（四）：TCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130660079">《计算机网络—自顶向下方法》 Wireshark实验（五）：UDP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130675220">《计算机网络—自顶向下方法》 Wireshark实验（六）：IP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130663286">《计算机网络—自顶向下方法》 Wireshark实验（七）：以太网与ARP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775056">《计算机网络—自顶向下方法》 Wireshark实验（八）：ICMP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130769488">《计算机网络—自顶向下方法》 Wireshark实验（九）：DHCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775356">《计算机网络—自顶向下方法》 Wireshark实验（十）：NAT 协议分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（八）-- 邮件客户端实现与电子邮件发送</title>
      <link href="/article/ba7802fc.html"/>
      <url>/article/ba7802fc.html</url>
      
        <content type="html"><![CDATA[<p>通过完成本实验，我们将更加了解SMTP协议。还将学到使用Python实现标准协议的经验。主要任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><span id="more"></span><h2 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1 SMTP"></a>1 SMTP</h2><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><p>这里采用qq邮箱来完成。本文将实现一个SMTP客户端，使用qq邮箱作为发件人，向指定的163邮箱发送一封邮件。</p><p>SMTP协议即简单邮件传输协议，允许用户按照标准发送&#x2F;接收邮件。</p><p>在本文中，SMTP邮件客户端程序的基本流程如下：</p><ol><li>与qq邮件服务器建立TCP连接，域名”smtp.qq.com”，SMTP默认端口号25。建立连接后服务器将返回状态码220，代表服务就绪（类似HTTP，SMTP也使用状态码通知客户端状态信息）。</li><li>发送”HELO”命令，开始与服务器的交互，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”AUTH LOGIN”命令，开始验证身份，服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的用户名（本例中是163邮箱的账号），服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的密码（本例中是163邮箱的密码），服务器将返回状态码235（用户验证成功）。</li><li>发送”MAIL FROM”命令，并包含发件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”RCPT TO”命令，并包含收件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”DATA”命令，表示即将发送邮件内容，服务器将返回状态码354（开始邮件输入，以”.”结束）。</li><li>发送邮件内容，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”QUIT”命令，断开与邮件服务器的连接。</li></ol><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230504</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 实现邮件客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mail content</span></span><br><span class="line">subject = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">contenttype = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">msg = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sender and reciever</span></span><br><span class="line">fromaddress = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">toaddress = <span class="string">&quot;xxxxx@163.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth information (Encode with base64)</span></span><br><span class="line">username = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">username = base64.b64encode(username.encode()).decode()</span><br><span class="line">password = base64.b64encode(password.encode()).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line">clientSocket.connect((mailserver, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO CarpeDiem\r\n&#x27;</span></span><br><span class="line">clientSocket.send(heloCommand.encode())</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv1)</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;AUTH LOGIN\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((username + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((password + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;235&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;235 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send MAIL FROM command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;MAIL FROM: &lt;&#x27;</span> + fromaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send RCPT TO command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;RCPT TO: &lt;&#x27;</span> + toaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send DATA command and print server response.</span></span><br><span class="line">clientSocket.send(<span class="string">&#x27;DATA\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;354&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;354 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send message data.</span></span><br><span class="line">message = <span class="string">&#x27;from:&#x27;</span> + fromaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;to:&#x27;</span> + toaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;subject:&#x27;</span> + subject + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;Content-Type:&#x27;</span> + contenttype + <span class="string">&#x27;\t\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;\r\n&#x27;</span> + msg</span><br><span class="line">clientSocket.sendall(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Message ends with a single period.</span></span><br><span class="line">clientSocket.sendall(endmsg.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send QUIT command and get server response.</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;QUIT\r\n&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close connection</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 有些邮箱默认关闭SMTP服务，比如本文使用的qq邮箱。需要在设置中打开SMTP服务。另外，qq邮箱在打开SMTP服务后，会设置一个授权码，在程序使用这个授权码作为密码登录，而不是平时使用的密码。</p><p>一切正常的话，运行效果如下图所示，将会看到服务器返回的每条消息，其中包含每次操作后返回的状态码。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.euksoeo322w.webp#pic_center" width = 36%><p>同时，我们还可以登陆发件人邮箱和收件人邮箱，在发件人的已发送文件夹中和收件人的收件箱中都能看到这封被发送的邮件。左图为qq邮箱，右图为网易163邮箱。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.56cyk5j0h1g0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.60g5ulueg0o0.webp#pic_left"  width = "45%"></center></p><hr><h2 id="2-网络应用开发"><a href="#2-网络应用开发" class="headerlink" title="2 网络应用开发"></a>2 网络应用开发</h2><h3 id="2-1-发送电子邮件"><a href="#2-1-发送电子邮件" class="headerlink" title="2.1 发送电子邮件"></a>2.1 发送电子邮件</h3><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p><p>smtplib和email，这俩模块是Python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。</p><ul><li>smtplib模块主要负责发送邮件：是一个发送邮件的动作，连接邮箱服务器，登录邮箱，发送邮件（有发件人，收信人，邮件内容）。</li><li>email模块主要负责构造邮件：指的是邮箱页面显示的一些构造，如发件人，收件人，主题，正文，附件等。</li></ul><p><strong>代码说明：</strong></p><ol><li>smtplib模块</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">smtplib.SMTP()              <span class="comment"># 实例化SMTP()</span></span><br><span class="line"></span><br><span class="line">login(user, password)</span><br><span class="line"><span class="comment"># user：登录邮箱的用户名。</span></span><br><span class="line"><span class="comment"># password：登录邮箱的密码，像笔者用的是网易邮箱，网易邮箱一般是网页版，需要用到客户端密码，需要在网页版的网易邮箱中设置授权码，该授权码即为客户端密码。</span></span><br><span class="line"></span><br><span class="line">sendmail(from_addr, to_addrs, msg,…)</span><br><span class="line"><span class="comment"># from_addr：邮件发送者地址</span></span><br><span class="line"><span class="comment"># to_addrs：邮件接收者地址。字符串列表[‘接收地址1’,‘接收地址2’,‘接收地址3’,…]</span></span><br><span class="line"><span class="comment"># msg：发送消息：邮件内容。一般是msg.as_string():as_string()是将msg(MIMEText对象或者MIMEMultipart对象)变为str。</span></span><br><span class="line"></span><br><span class="line">quit()      <span class="comment"># 用于结束SMTP会话。</span></span><br></pre></td></tr></table></figure><p><strong>2) email模块</strong></p><p>email模块下有mime包，mime英文全称为<code>“Multipurpose Internet Mail Extensions”</code>，即多用途互联网邮件扩展，是目前互联网电子邮件普遍遵循的邮件技术规范。</p><p>该mime包下常用的有三个模块：text, image, multpart。</p><p>导入方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br></pre></td></tr></table></figure><p>构造一个邮件对象就是一个Message对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure><p>下面的代码演示了如何在Python发送普通的文字邮件。</p><p><strong>1. 发送普通文字邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230428</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header </span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 设定邮件发送者和接受者</span></span><br><span class="line">    host_server = <span class="string">&#x27;smtp.qq.com&#x27;</span>             <span class="comment"># qq 邮箱smtp服务器</span></span><br><span class="line">    sender = <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>              <span class="comment"># 发件人邮箱</span></span><br><span class="line">    pwd = <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span></span><br><span class="line">    receivers = [<span class="string">&#x27;xxxxxxx@gmail.com&#x27;</span>, <span class="string">&#x27;xxxxxx@163.com&#x27;</span>]              <span class="comment"># 收件人邮箱</span></span><br><span class="line">    mail_title = <span class="string">&quot;Python自动发送的邮件&quot;</span>                               <span class="comment"># 邮件标题  </span></span><br><span class="line">    mail_content = <span class="string">&quot;您好，这是使用python登录QQ邮箱发送邮件的测试——xq&quot;</span>   <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()               <span class="comment"># 初始化一个邮件主体</span></span><br><span class="line">    message[<span class="string">&#x27;Subject&#x27;</span>] = Header(mail_title, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    message[<span class="string">&#x27;From&#x27;</span>] = sender</span><br><span class="line">    message[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;;&quot;</span>.join(receivers)</span><br><span class="line">    message.attach(MIMEText(mail_content, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    smtper = SMTP_SSL(host_server)      <span class="comment"># ssl登录</span></span><br><span class="line">    <span class="comment"># login(user,password):</span></span><br><span class="line">    <span class="comment"># user:登录邮箱的用户名。</span></span><br><span class="line">    <span class="comment"># password：登录邮箱的密码，这里用的是QQ邮箱，</span></span><br><span class="line">    <span class="comment"># 需要用到客户端密码，需要在QQ邮箱中设置授权码，该授权码即为客户端密码</span></span><br><span class="line">    smtper.login(sender, pwd)</span><br><span class="line">    smtper.sendmail(sender, receivers, message.as_bytes())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送完成!&quot;</span>)</span><br><span class="line">    <span class="comment"># quit(): 用于结束SMTP会话</span></span><br><span class="line">    smtper.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.6alnsifgg2o0.webp#pic_center" width = 64%><p><strong>2. 发送html格式邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.6yb1qqrncyo0.webp#pic_center" width = 36%><p><strong>3. 发送带附件的邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件以及附件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication  <span class="comment"># 用于添加附件</span></span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line">attachment = MIMEApplication(<span class="built_in">open</span>(<span class="string">&quot;H:\\毕业设计\\LassoNet\\脑区选择.xlsx&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">attachment[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给附件重命名</span></span><br><span class="line">basename = <span class="string">&quot;test.xlsx&quot;</span></span><br><span class="line">attachment.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;&#x27;</span>, basename))</span><br><span class="line">msg.attach(attachment)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.6g3dk32y7kg0.webp#pic_center" width = 36%><h3 id="2-2-发送短信"><a href="#2-2-发送短信" class="headerlink" title="2.2 发送短信"></a>2.2 发送短信</h3><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a href="https://www.ihuyi.com/duanxin.html?e=591">互亿无线短信平台</a>（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    host  = <span class="string">&quot;106.ihuyi.com&quot;</span></span><br><span class="line">    sms_send_uri = <span class="string">&quot;/webservice/sms.php?method=Submit&quot;</span></span><br><span class="line">    <span class="comment"># 下面的参数需要填入自己注册的账号和对应的密码</span></span><br><span class="line">    params = urllib.parse.urlencode(&#123;<span class="string">&#x27;account&#x27;</span>: <span class="string">&#x27;API ID&#x27;</span>, <span class="string">&#x27;password&#x27;</span> : <span class="string">&#x27;API KEY&#x27;</span>, <span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;您的验证码是：666888。请不要把验证码泄露给其他人。&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>: <span class="string">&#x27;xxxxxxxxx&#x27;</span>, <span class="string">&#x27;format&#x27;</span>:<span class="string">&#x27;json&#x27;</span> &#125;)</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=<span class="number">80</span>, timeout=<span class="number">30</span>)</span><br><span class="line">    conn.request(<span class="string">&#x27;POST&#x27;</span>, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    jsonstr = response_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(json.loads(jsonstr))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>详细了解，请阅读：<a href="https://www.ihuyi.com/api/sms.html">短信验证码&#x2F;通知 - API文档</a></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python实现自动发送邮件（详解）：<a href="https://blog.csdn.net/weixin_44827418/article/details/111255414">https://blog.csdn.net/weixin_44827418&#x2F;article&#x2F;details&#x2F;111255414</a></li><li>Python网络应用开发：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（七）-- ICMP Ping服务程序框架</title>
      <link href="/article/24fe53d6.html"/>
      <url>/article/24fe53d6.html</url>
      
        <content type="html"><![CDATA[<p>Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。</p><span id="more"></span><p>Ping的实现通常使用ICMP协议。ICMP协议在协议族中的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.ziro52u46eo.webp#pic_center" width = 48%><p>通过本文，你将更好地理解因特网控制报文协议（<code>ICMP</code>），学习使用<code>ICMP</code>请求和响应消息实现<code>Ping</code>程序。通过向目标主机发送<code>ICMP</code>回显包并监听<code>ICMP</code>回显应答来工作。回显有时称为<code>pong</code>。<code>ping</code>程序测量往返时间，记录数据包丢失，并输出接收到的回显包的统计摘要（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差）。</p><p>主要任务：用<code>python</code>开发自己的简单<code>Ping</code>程序。程序将使用<code>ICMP</code>协议，但为了保持简单，将不完全遵循<code>RFC 1739</code>中的正式规范。在本实训中只需要编写程序的客户端，因为服务器端所需的功能几乎内置于所有操作系统中。Ping程序的基本功能如下： Ping 程序能将 ping 请求发送到指定的主机，间隔大约一秒钟。每个消息包含一个带有时间戳的数据包。 每个数据包发送完后，程序最多等待一秒，用于接收响应。如果一秒后服务器没有响应，那么客户端应假设 ping 数据包或 pong 数据包在网络中丢失（或者服务器已关闭）。 统计摘要信息（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差） 本实训将使用原始套接字来使用ICMP协议。</p><p>下面将为为Ping客户端创建一个原始类型的套接字。</p><h2 id="1-Ping客户端创建原始套接字"><a href="#1-Ping客户端创建原始套接字" class="headerlink" title="1 Ping客户端创建原始套接字"></a>1 Ping客户端创建原始套接字</h2><h3 id="1-1-原始套接字"><a href="#1-1-原始套接字" class="headerlink" title="1.1 原始套接字"></a>1.1 原始套接字</h3><p>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。使用原始套接字进行网络通信的基本步骤为：</p><ul><li>（1）创建原始套接字、设置套接字选项和创建并填充相应协议头；</li><li>（2）用 <code>sendto()</code> 函数将组装好的数据发送出去；</li><li>（3）使用 <code>recvfrom()</code> 函数接收数据并解析；</li><li>（4）关闭套接字。</li></ul><p>在Python中使用套接字编程，需要先引入套接字（import socket）；使用 <code>socket()</code> 函数来创建套接字。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket(socket_family,socket_type,protocol=<span class="number">0</span>)</span><br><span class="line">socket_family可以是如下参数之一：</span><br><span class="line">  　　AF_INET IPv4（默认）</span><br><span class="line">　　  AF_INET6 IPv6</span><br><span class="line">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span><br><span class="line">socket_type可以是如下参数之一:</span><br><span class="line">　　  SOCK_STREAM　　流式socket , <span class="keyword">for</span> TCP （默认）</span><br><span class="line">　  　SOCK_DGRAM　　 数据报式socket , <span class="keyword">for</span> UDP</span><br><span class="line">　  　SOCK_RAW 原始套接字</span><br></pre></td></tr></table></figure><p>普通的套接字无法处理ICMP、IGMP等网络报文，而原始套接字 <code>SOCK_RAW</code> 可以；<code>SOCK_RAM</code> 用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。<code>SOCK_RAM</code> 通常仅限于高级用户或管理员运行的程序使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol参数：</span><br><span class="line">　　<span class="number">0</span>　（默认）与特定的地址家族相关的协议。如果是 <span class="number">0</span> ，则系统就会根据地址格式和套接类别，自动选择一个合适的协议。也可以使用</span><br><span class="line">  getprotobyname()指定要使用的协议名称如“ICMP”、“UDP”等。</span><br></pre></td></tr></table></figure><p>在本实验中，要创建一个使用IPV4地址族的的原始套接字，并指定使用ICMP协议，可以使用如下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmp = getprotobyname(<span class="string">&quot;icmp&quot;</span>)   /*指定ICMP协议</span><br><span class="line">rawsocket=socket(AF_INET, SOCK_RAW, icmp)</span><br></pre></td></tr></table></figure><h2 id="2-封装并发送ICMP报文"><a href="#2-封装并发送ICMP报文" class="headerlink" title="2 封装并发送ICMP报文"></a>2 封装并发送ICMP报文</h2><h3 id="2-1-ICMP协议"><a href="#2-1-ICMP协议" class="headerlink" title="2.1 ICMP协议"></a>2.1 ICMP协议</h3><p>ICMP协议：<code>Internet Control Message Protocol</code>（Internet控制报文协议）；由于IP协议并不是一个可靠的协议，它不保证数据被成功送达。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的，经常供IP层或更高层协议（TCP或UDP）使用。所以它经常被认为是IP层的一个组成部分。</p><p>制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着<font color=#9900CC><strong>“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议”</font></strong>。即，ICMP 是为了分担IP 一部分功能而被制定出来的。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.ed8xfkhqoh4.webp#pic_center" width = 48%><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p><p>在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.39oq4lvlrna0.webp#pic_center" width = 48%><ul><li>[1]给送信者的错误通知；[2]送信者的信息查询。</li><li>[1]是到IP 数据包被对方的计算机处理的过程中，发生了什么错误时被使用。不仅传送发生了错误这个事实，也传送错误原因等消息。</li><li>[2]的信息询问是在送信方的计算机向对方计算机询问信息时被使用。被询问内容的种类非常丰富，他们有目标IP 地址的机器是否存在这种基本确认，调查自己网络的子网掩码，取得对方机器的时间信息等。</li></ul><p>ICMP是TCP&#x2F;IP模型中网络层的重要成员，与IP协议、ARP协议、RARP 协议及 IGMP协议共同构成 TCP&#x2F;IP模型中的网络层。<code>ping</code> 和 <code>tracert</code> 是两个常用网络管理命令，<code>ping</code> 用来测试网络可达性，<code>tracert</code> 用来显示到达目的主机的路径。<code>ping</code> 和 <code>tracert</code> 都利用ICMP 协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。</p><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。但RFC认为ICMP是分担了IP的一部分功能。所以，ICMP也被认为是与IP同层的协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。看一下RFC 规定的数据包格式和报文内容吧。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.4xn5l5nbahs0.webp#pic_center" width = 48%><p>当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP的数据报文格式如下所示。所有报文的前4个字节都是一样的，其他的因报文类型不同而不一样。类型字段可以有15个不同的值，用以描述不同的ICMP报文。校验和字段覆盖整个ICMP报文，使用了和IP首部检验和一样的算法，详细请搜索TCP&#x2F;IP检验和算法。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.52nce9l7ak40.webp#pic_center" width = 48%><p><strong>字段说明：</strong></p><ul><li>类型：标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。    </li><li>代码：标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。    </li><li>校验和：对包括ICMP报文数据部分在内的整个ICMP&#96;数据报的校验和，以检验报文在传输过程中是否出现了差错。</li></ul><p><font color=#9900CC><strong>不同类型的报文是由类型字段和代码字段来共同决定。</font></strong>下表是各种类型的ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.5ol4guwagpk0.webp#pic_center" width = 48%><p>根据上表可知，ICMP协议大致分为两类，一种是查询报文，一种是差错报文。查询报文是用一对请求和应答定义的，它通常有以下几种用途:</p><ol><li>ping查询</li><li>子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）</li><li>时间戳查询（可以用来同步时间）</li></ol><p>而差错报文通常包含了引起错误的IP数据报的第一个分片的IP首部（和选项），加上该分片数据部分的前8个字节。RFC 792规范中定义的这8个字节中包含了该分组运输层首部的所有分用信息，这样运输层协议就可以向正确的进程提交ICMP差错报文。</p><p>当传送IP数据包发生错误时，比如主机不可达，端口不可达等，ICMP协议就会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。由上面可知，ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成，而前 16bit就组成了ICMP所要传递的信息。由数据链路层所能发送的最大数据帧，即MTU（Maximum Transmission Unit）为1500，计算易知ICMP协议在实际传输中数据包为：20字节IP首部 + 8字节ICMP首部+ 1472字节（数据大小）。</p><p>尽管在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的。如下</p><ol><li>ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）</li><li>目的地址是广播地址或多播地址的IP数据报。</li><li>作为链路层广播的数据报。</li><li>不是IP分片的第一片。</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。</li></ol><h3 id="2-2-ping程序原理分析"><a href="#2-2-ping程序原理分析" class="headerlink" title="2.2 ping程序原理分析"></a>2.2 ping程序原理分析</h3><p>ping程序是由Mike Muuss编写，目的是为了测试另一 台主机是否可达，现在已经成为一个常用的网络状态检查工具。该程序发送一份 ICMP回显请求报文给远程主机，并等待返回 ICMP回显应答。利用ping这种原理，已经出现了许多基于ping的网络扫描器，比如nmap、arping、fping、hping3等。所以随着Internet安全意识的增强，现在有些提供访问控制策略的路由器和防火墙已经可以设置过滤特定ICMP报文请求。因此并不能通过简单的ping命令判断远程主机是否在线。</p><p>ping 使用的是ICMP协议，它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。大多数的 TCP&#x2F;IP 实现都在内核中直接支持Ping服务器，ICMP回显请求和回显应答报文如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.klquqyz6p2o.webp#pic_center" width = 48%><p>ping的原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。通过计算ICMP应答报文数量和与接受与发送报文之间的时间差，判断当前的网络状态。这个往返时间的计算方法是：ping命令在发送ICMP报文时将当前的时间值存储在ICMP报文中发出，当应答报文返回时，使用当前时间值减去存放在ICMP报文数据中存放发送请求的时间值来计算往返时间。ping返回接受到的数据报文字节大小、TTL值以及往返时间。</p><p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的 ID号。这样 即使在同一台主机上同时运行了多个 ping程序实例，ping程序也可以识别出返回的信息。</p><p><code>ping</code> 操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.3qwubtumq28.webp#pic_center" width = 48%><p>过程如下：</p><ol><li><p>向目标服务器发送回送请求。<br>首先，向目标服务器发出回送请求（类型是8，代码是0）报文（同2）。在这个回送请求报文里，除了类型和代码字段，还被追加了标识符和序号字段。标识符和序号字段分别是16 位的字段。ping 命令在发送回送请求报文时，在这两个字段里填入任意的值。对于标识符，应用程序执行期间送出的所有报文里填入相同的值。对于序号，每送出一个报文数值就增加1。而且，回送请求的选项数据部分用来装任意数据。这个任意数据用来调整ping 的交流数据包的大小。</p></li><li><p>鹦鹉学舌一样返回回送回答。<br>计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求（类型是0，代码是0）（同3）。这个ICMP 回送回答报文在IP 层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP 地址字段被交换了，类型字段里填入了表示回送回答的0。也就是，从送信方来看，自己送出的ICMP 报文从目标服务器那里象鹦鹉学舌那样原样返回了。<br>送信方的计算机可以通过收到回送回答报文，来确认目标服务器在工作着。进一步，记住发送回送请求报文的时间，与接收到回送回答报文的时间一比较，就能计算出报文一去一回往复所需要的时间（同4）。但是，收到的回送回答报文里写的只是类型和代码的话，发送方计算机将无法判断它是否是自己发出去请求的回答。因此，前面说到的标识符和序号字段就有它的意义了。将这两个值与回送回答报文中的相同字段值一比较，送行方计算机就能够简单地检测回送回答是否正确了。执行ping 命令而调查的结果没什么问题的话，就将目标服务器的IP 地址，数据大小，往复花费的时间打印到屏幕上。</p></li><li><p>用ping 命令不能确定与对方连通的原因大致有三个。<br>1）目标服务器不存在；2)花在数据包交流上的时间太长ping 命令认为超时；3）目标服务器不回答ping 命令。如果是原因2），通过ping 命令的选项来延长到超时的等待时间，就能正确显示结果了。如果原因是1）或3）的话，仅凭ping 命令的结果就不能判断是哪方了。正如这样，ping 命令不一定一定能判断对方是否存在。</p></li></ol><p>一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。</p><p>时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。</p><h3 id="2-3-协议数据包的封装"><a href="#2-3-协议数据包的封装" class="headerlink" title="2.3 协议数据包的封装"></a>2.3 协议数据包的封装</h3><p>Python中处理二进制数据如存取文件、socket操作时，可以使用 Python 的 struct 模块来完成。使用该模块可以方便地来实现协议数据的封装与解封。</p><p>struct模块中最重要的三个函数是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pack(fmt, v1, v2, ...)     <span class="comment"># 按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</span></span><br><span class="line">unpack(fmt, string)        <span class="comment"># 按照给定的格式(fmt)解析字节流string，返回解析出来的数组</span></span><br><span class="line">calcsize(fmt)              <span class="comment"># 计算给定的格式(fmt)占用多少字节的内存</span></span><br></pre></td></tr></table></figure><p>其中fmt支持的格式如下表描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5mgm8e69x380.webp#pic_center" width = 48%><p>在完成封装后，将封装后的数据data，使用原始套接字的 <code>sendto()</code> 方法进行发送。<code>sendto()</code> 主要参数：</p><ul><li>packet：发送的数据</li><li>Addr：形式为 <code>(ipaddr，port)</code> 的元组</li></ul><h2 id="3-解析IP包ICMP头信息"><a href="#3-解析IP包ICMP头信息" class="headerlink" title="3 解析IP包ICMP头信息"></a>3 解析IP包ICMP头信息</h2><h3 id="3-1-接收ICMP报文"><a href="#3-1-接收ICMP报文" class="headerlink" title="3.1 接收ICMP报文"></a>3.1 接收ICMP报文</h3><p>使用原始套接字的 <code>recvfrom()</code> 函数接收报文，输入参数指定为报文最大长度，如1024；函数返回值为报文发送方的地址、报文内容。接收代码示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfpacket, addr = mysocket.recvfrom(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-解析ICMP报文"><a href="#3-2-解析ICMP报文" class="headerlink" title="3.2 解析ICMP报文"></a>3.2 解析ICMP报文</h3><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议类型字段值为1时，就说明这是一个ICMP报文。</p><p>ICMP报头如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.5fd06it998c0.webp#pic_center" width = 48%><p>解析ICMP报文可以使用Python中struct模块的 <code>upack()</code> 函数来实现。其参数：</p><ul><li>fmtstr: 格式化字符串</li><li>packet: 需要解析的字符数组</li></ul><p>函数的返回值可以是多个，根据格式串中指定的类型返回到相应变量中。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d=struct.unpack(<span class="string">&#x27;5s6sif&#x27;</span>,<span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><p>则从bytes这个数组中解析出a：5个字符的字符串（5s），b:6个字符的字符串(6s)，c为整型(i)，d为浮点型数据(f)。</p><p>对于Ping命令的ICMP报文，我们需从IP包中取出ICMP报头，位于20到28字节；从中可以取出报文类型type,代码code，校验和checksum，报文ID及报文序号字段；</p><p>对于类型为1的报文且其ID为需要接收的报文，从28字节后面开始解析发送的数据为发送时间，数据类型及长度根据发送的数据来确定。</p><ul><li>响应时间：计算收到报文的时间与发送报文（ICMP报文的数据部分）的时间差；</li><li>TTL：TTL指Time To Live生成周期，指定IP包被路由器丢弃之前允许通过的最大网段数量。在IPv4包头中TTL是一个8 bit字段，它位于IPv4包的第9个字节。因此只需从接收报文中解析出第9字节即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chesksum</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    校验</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(data)</span><br><span class="line">    m = n % <span class="number">2</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - m ,<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">sum</span> += (data[i]) + ((data[i+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>)   <span class="comment"># 传入data以每两个字节（十六进制）通过ord转十进制，第一字节在低位，第二个字节在高位</span></span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        <span class="built_in">sum</span> += (data[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 将高于16位与低16位相加</span></span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>) + (<span class="built_in">sum</span> &amp; <span class="number">0xffff</span>)</span><br><span class="line">    <span class="built_in">sum</span> += (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>)      <span class="comment"># 如果还有高于16位，将继续与低16位相加</span></span><br><span class="line">    answer = ~<span class="built_in">sum</span> &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="comment"># 主机字节序转网络字节序列（参考小端序转大端序）</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一次Ping的返回消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiveOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr, timeout</span>):</span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        </span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        <span class="built_in">type</span>, code, checksum, packetID, sequence = struct.unpack(<span class="string">&quot;!bbHHh&quot;</span>, header)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">and</span> packetID == ID:  <span class="comment"># type should be 0</span></span><br><span class="line">            byte_in_double =  struct.calcsize(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">            timeSent = struct.unpack(<span class="string">&quot;d&quot;</span>, recPacket[<span class="number">28</span>:<span class="number">28</span>+byte_in_double])[<span class="number">0</span>]</span><br><span class="line">            delay = timeReceived - startedSelect</span><br><span class="line">            ttl = struct.unpack(<span class="string">&quot;!b&quot;</span>, recPacket[<span class="number">8</span>:<span class="number">9</span>])[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> (delay, ttl, byte_in_double)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送一次Ping数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr</span>):</span><br><span class="line">    <span class="comment"># 头部构成： type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;!d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># 计算头部和数据的校验和</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向指定地址发送Ping消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doOnePing</span>(<span class="params">destAddr, ID, sequence, timeout</span>):</span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建原始套接字</span></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"> </span><br><span class="line">    sendOnePing(mySocket, ID, sequence, destAddr)</span><br><span class="line">    delay = receiveOnePing(mySocket, ID, sequence, destAddr, timeout)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数Ping</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># timeout=1指: 如果1秒内没从服务器返回，客户端认为Ping或Pong丢失。</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pinging &quot;</span> + dest + <span class="string">&quot; using Python:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每秒向服务器发送一次Ping请求</span></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># 返回进程ID</span></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        result = doOnePing(dest, myID, i, timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Request timed out.&quot;</span>)</span><br><span class="line">            loss += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delay = <span class="built_in">int</span>(result[<span class="number">0</span>]*<span class="number">1000</span>)</span><br><span class="line">            ttl = result[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">bytes</span> = result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Received from &quot;</span> + dest + <span class="string">&quot;: byte(s)=&quot;</span> + <span class="built_in">str</span>(<span class="built_in">bytes</span>) + <span class="string">&quot; delay=&quot;</span> + <span class="built_in">str</span>(delay) + <span class="string">&quot;ms TTL=&quot;</span> + <span class="built_in">str</span>(ttl))</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Packet: sent = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>) + <span class="string">&quot; received = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>-loss) + <span class="string">&quot; lost = &quot;</span> + <span class="built_in">str</span>(loss))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6tiqidr3ru00.webp#pic_center" width = 36%><h2 id="4-ICMP-的应用–Traceroute"><a href="#4-ICMP-的应用–Traceroute" class="headerlink" title="4 ICMP 的应用–Traceroute"></a>4 ICMP 的应用–Traceroute</h2><h3 id="4-1-原理介绍"><a href="#4-1-原理介绍" class="headerlink" title="4.1 原理介绍"></a>4.1 原理介绍</h3><p>Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管 ping 工具也可以进行侦测，但是，因为 ip 头的限制，ping 不能完全的记录下所经过的路由器。所以 Traceroute 正好就填补了这个缺憾。</p><p>Traceroute 的原理是非常非常的有意思，它受到目的主机的 IP 后，首先给目的主机发送一个 TTL&#x3D;1(还记得 TTL 是什么吗?)的  UDP(后面就 知道 UDP 是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减1，而 TTL 变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL&#x3D;2的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 ip。从而避开了 ip 头只能记录有限路由 IP 的问题。</p><p>有人要问，我怎么知道 UDP 到没到达目的主机呢？这就涉及一个技巧的问题，TCP 和 UDP 协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较小的端口，比如说80，比如说23，等等。而 traceroute 发送的是端口号&gt;30000(真变态)的  UDP 报，所以到 达目的主机的时候，目的主机只能发送一个端口不可达的 ICMP 数据报给主机。主机接到这个报告以后就知道，主机到了，所以，说  Traceroute 是一个骗子一点也不为过。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.62nfc4shenk0.webp#pic_center" width = 48%><p><strong>过程如下：</strong></p><ol><li>执行tracert命令。<br>在Windows 上执行tracert 命令后，首先计算机向目的服务器发送IP 数据包。Windows 上使用的是与ping 同样的ICMP 回送请求报文。但是，有一点和通常的回送请求不一样。那是，最初将IP 首部的TTL(生存时间)字段设为1 这一点。</li></ol><p>路由器每转送一次数据包就将TTL 的值减1。当TTL 变为0 的时候，按规定将丢弃这个数据包。正如这样，与其说TTL 是时间，还不如说TTL 是经过路由器的个数。对于计算机发送出去的数据包，只要它与目标服务器不在同一局域网内，一定会被哪儿的路由器中继。这时如果TTL 的值是1，由于路由器的处理会变为0，则该数据包将会被丢弃（同2）。</p><ol start="2"><li>用超时报文来通知送信方。<br>路由器丢弃数据包的同时，用ICMP 报文来通知错误。这时使用的ICMP 报文是，类型为11，代码为0 的ICMP 超时报文。而且在选项数据字段里，将填入原先数据包的IP 首部和ICMP 的开始8 字节。正如ping 命令的时候看到的，ICMP 回送请求的先头8 字节里包含了标识符和序号字段。因此，送信方的计算机看了超时报文后，就知道是针对自己发出的回送请求的错误通知。</li></ol><p>计算机接到针对第一个数据包的ICMP 超时报文后，接下来将TTL 加1（TTL&#x3D;2）并同样地送出（同3）。这次通过第一个路由器，TTL 变为1，到达第二个路由器。但是第二个路由器象前面一样，由于TTL变为0，将不能转发该包。因此，同第一个路由器一样，将该包丢弃，并返回ICMP 超时报文。以后，收到错误的发送方计算机将TTL 加1，重复同样的工作（同4）。</p><ol start="3"><li>只有目标服务器的反应不同。<br>如此一个一个增加TTL，某个时候ICMP 回送请求报文将到达最终的目标服务器。这时，只有目标服务器与途中的路由器不同，不返回ICMP 超时报文。为什么呢？因为即使目标服务器收到TTL 为1 的数据包也不会发生错误。</li></ol><p>作为代替处理，服务器针对送信方计算机发出的ICMP 回送请求报文，返回ICMP 回送回答报文。也就是，送信方计算机与服务器之间，与ping 命令的执行一样了（同5）。得到了ICMP 回送回答报文的送信方知道了路经调查已经到了目标服务器，就结束了tracert 命令的执行（同6）。像这样，通过列出中途路由器返回的错误，就能知道构成到目标服务器路径的所有路由器的信息了。</p><ol start="4"><li>操作系统不同则实现方法略微不同。<br>到这里，以Windows 上的tracert 命令为例看了原理，有些别的操作系统的traceroute 命令的原理略微不同。</li></ol><p>具体来说，也有用向目标发送UDP 数据包代替ICMP 回送请求报文来实现的。虽说是用UDP，但途中的路由器的处理与図 8完全相同。只是UDP 数据包到达目标后的处理不同。目标计算机突然收到与通信无关的数据包，就返回ICMP 错误，因此根据返回数据包的内容来判断命令的中止。</p><h3 id="4-2-Python-实现"><a href="#4-2-Python-实现" class="headerlink" title="4.2 Python 实现"></a>4.2 Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230423</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 基于ICMP协议Traceroute实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kamene.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tracert_one</span>(<span class="params">dst,dport,ttl_no</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;发一个Traceroute包，参数需要目的地址，目的端口，TTL&#x27;&#x27;&#x27;</span></span><br><span class="line">    send_time = time.time()         <span class="comment"># 记录发送时间</span></span><br><span class="line">    Tracert_one_reply = sr1(IP(dst=dst, ttl=ttl_no)/UDP(sport=<span class="number">6600</span>, dport=dport)/<span class="string">b&#x27;my traceroute!!!&#x27;</span>, timeout = <span class="number">1</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Scapy中UDP默认源目端口53，需要将源端口也改掉，否则中间设备将不回应</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">11</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果收到TTL超时</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>, hop_ip, time_to_passed        <span class="comment"># 返回1表示并未抵达目的地</span></span><br><span class="line">        <span class="keyword">elif</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">3</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">3</span>:</span><br><span class="line">            <span class="comment"># 如果收到端口不可达</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>, hop_ip, time_to_passed    <span class="comment"># 返回2表示抵达目的地</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">&#x27;.*NoneType.*&#x27;</span>,<span class="built_in">str</span>(e)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>     <span class="comment"># 测试失败返回None,没有回包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MY_Tracert</span>(<span class="params">dst,hops</span>):</span><br><span class="line">    dport = <span class="number">33434</span>           <span class="comment"># Traceroute的目的端口从33434开始计算</span></span><br><span class="line">    hop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> hop &lt; hops:</span><br><span class="line">        dport = dport + hop</span><br><span class="line">        hop += <span class="number">1</span></span><br><span class="line">        Result = Tracert_one(dst,dport,hop)</span><br><span class="line">        <span class="keyword">if</span> Result == <span class="literal">None</span>:      <span class="comment"># 如果测试失败就打印‘*’</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; *&#x27;</span>,flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">1</span>:    <span class="comment"># 如果未抵达目的，就打印这一跳和消耗的时间</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">2</span>:    <span class="comment"># 如果抵达目的，就打印这一跳和消耗的时间，并且跳出循环！</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conf.route.add(net=<span class="string">&#x27;172.16.10.0/24&#x27;</span>,gw=<span class="string">&#x27;192.168.10.115&#x27;</span>)    <span class="comment"># 为Scapy添加路由</span></span><br><span class="line">    destIP=<span class="built_in">input</span>(<span class="string">&quot;目标IP&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    hops=<span class="built_in">input</span>(<span class="string">&quot;最大跳数&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    MY_Tracert(destIP, <span class="built_in">int</span>(hops))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.40tookmha7w0.webp#pic_center" width = 64%><blockquote><p>了解更多，请阅读：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">ICMP实现之端口扫描、ICMP实现之改变路由、ICMP实现之源点抑制、ICMP实现之MTU探索</a></p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>python实现ping工具：<a href="https://blog.csdn.net/jia666666/article/details/85254450">https://blog.csdn.net/jia666666/article/details/85254450</a></li><li>ICMP协议与ping原理以及用Python实现ping：<a href="https://cloud.tencent.com/developer/article/1156671">https://cloud.tencent.com/developer/article/1156671</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li><li>完全理解icmp协议：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">https://www.cnblogs.com/iiiiher/p/8513748.html</a></li><li>Python网络编程2–实现Ping程序与Traceroute程序：<a href="https://www.jianshu.com/p/0c52955515c7">https://www.jianshu.com/p/0c52955515c7</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICMP 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（六）- UDP套接字编程</title>
      <link href="/article/929e2127.html"/>
      <url>/article/929e2127.html</url>
      
        <content type="html"><![CDATA[<p>本文将首先利用 Python 实现面向UDP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。</p><span id="more"></span><h2 id="1-创建UDP套接字"><a href="#1-创建UDP套接字" class="headerlink" title="1 创建UDP套接字"></a>1 创建UDP套接字</h2><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。<font color=#9900CC><strong>TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。</strong></font>可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。</p><p>数据包格式套接字（<code>Datagram Sockets</code>）也叫“无连接的套接字”，在代码中使用 <code>SOCK_DGRAM</code> 表示。可以将 <code>SOCK_DGRAM</code> 比喻成高速移动的摩托车快递，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的。</li></ul><p>数据包套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。</p><p>实际应用中，QQ 视频聊天和语音聊天主要使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。当然，SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</p><p>本部分将学习利用 UDP 套接字编程实现网络连通程序Ping。包含如何使用 UDP 套接字发送和接收数据报；如何设置适当的套接字超时；Ping 应用程序通信过程及计算网络统计信息（如丢包率）。</p><p>Ping 程序的基本原理：利用客户端发送一个数据包到远程机器，远程机器将收到的数据包返回到客户端（称为回显），客户端根据是否收到发送的消息及计算数据包的往返时间来反映网络是否连通及网络状态。</p><p>首先，要实现一个用 Python 编写的简单的 Ping 服务端程序，然后再实现对应的客户端程序。程序功能类似于现代操作系统中可用的标准 Ping 程序功能，不过这里使用简单的 UDP 协议，而不是标准互联网控制消息协议（ICMP）来进行通信的</p><h3 id="1-1-基于-UDP-协议的-Socket-套接字编程"><a href="#1-1-基于-UDP-协议的-Socket-套接字编程" class="headerlink" title="1.1 基于 UDP 协议的 Socket 套接字编程"></a>1.1 基于 UDP 协议的 Socket 套接字编程</h3><p>UDP 协议是非连接的协议，通信双方不用建立连接，而是直接把要发送的数据发送给对方。UDP 协议适用于一次传输数据量很少，对可靠性要求不高的应用场景。但由于UDP 协议没有类似于 TCP 的三次握手、可靠传输机制等，所以通信效率比较高。</p><p>UDP 协议的应用也非常广泛，比如知名的应用层协议：SNMP、DNS 都是基于 UDP的。一个常用的 UDP 通信的框架如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.2h2w2f6qok40.webp#pic_center" width = 64%><p>由图可以看出，客户端要发起一次请求，仅仅需要两个步骤（socket 和 sendto），而服务器端也仅仅需要三个步骤即可接收到来自客户端的消息（socket、bind、recvfrom）。和 TCP 通信不同的是，UDP 通信不需要监听（listen）及建立连接（accept）步骤，在创建及套接字后，可以直接使用 <code>sendto()</code> 及 <code>recvform()</code> 进行数据的发送及接收。</p><h3 id="1-2-UDP-Ping服务程序框架"><a href="#1-2-UDP-Ping服务程序框架" class="headerlink" title="1.2 UDP Ping服务程序框架"></a>1.2 UDP Ping服务程序框架</h3><p>在这个简单的 UDP Ping 服务器程序中，完成套接字创建及绑定后，当接收到消息后进行简单处理（这里是转化为大写），再将消息回传给相应的客户端。</p><h4 id="1-2-1-Ping服务端创建UDP套接字"><a href="#1-2-1-Ping服务端创建UDP套接字" class="headerlink" title="1.2.1 Ping服务端创建UDP套接字"></a>1.2.1 Ping服务端创建UDP套接字</h4><p>创建UDP套接字，绑定地址包含主机及其端口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">12000</span>))</span><br></pre></td></tr></table></figure><h4 id="1-2-2-UDP通信中发送与接收数据"><a href="#1-2-2-UDP通信中发送与接收数据" class="headerlink" title="1.2.2 UDP通信中发送与接收数据"></a>1.2.2 UDP通信中发送与接收数据</h4><p>在 UDP 通信中，使用 <code>sendto()</code> 函数发送 UDP 数据，将数据发送到套接字，输入参数 address 是形式为 <code>(host, port)</code> 的元组，指定远程地址，其中 <code>host</code> 表示服务器地址，<code>port</code> 表示服务器端口号。返回值是发送的字节数。</p><p>接收数据使用 <code>recvfrom()</code> 函数实现。输入参数为接收缓冲区大小。该函数接收 UDP 数据，与 <code>recv()</code> 类似，但返回值是 <code>(data, address)</code>。其中 <code>data</code> 是包含接收数据的字符串，<code>address</code> 是发送数据的套接字地址。</p><p><strong>示例如下：</strong></p><ul><li><p>接收数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg, addr = udp_server.recvfrom(BUFSIZE)   <span class="comment"># 使用套接字对象udp_server的recvfrom()方法接收数据</span></span><br></pre></td></tr></table></figure></li><li><p>发送数据</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp_server.sendto(msg,addr)     <span class="comment"># 使用套接字对象udp_server的sendto()方法发送数据</span></span><br></pre></td></tr></table></figure><p>完整的服务器程序一般都处于后台服务状态，通过不断循环等待客户端发送 <code>Ping</code> 消息，经过简单处理后，将消息发给相应的客户端。</p><p>在本实验中，为了避免大量资源的消耗，设置了一个接收消息计数器，当接收到消息超过设定值后，服务程序就退出（break）循环。</p><p>UDP为应用程序提供了不可靠的传输服务。消息可能因为路由器队列溢出，硬件错误或其他原因，而在网络中丢失。但由于在内网中很少丢包甚至不丢包，所以在本实验室的服务器程序添加人为损失来模拟网络丢包的影响。这里为了模拟，采用对接收到的消息计数器进行模运算，当模 3 的取值为 1 时，就不回传消息，返回接收下一条消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建UDP套接字</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定本机IP地址和端口号</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>))</span><br><span class="line"></span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接收客户端消息</span></span><br><span class="line">    message, address = serverSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将数据包消息转换为大写</span></span><br><span class="line">    message = message.upper()</span><br><span class="line">        </span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将消息传回给客户端</span></span><br><span class="line">    serverSocket.sendto(message, address)</span><br></pre></td></tr></table></figure><h3 id="1-3-客户端创建UDP套接字"><a href="#1-3-客户端创建UDP套接字" class="headerlink" title="1.3 客户端创建UDP套接字"></a>1.3 客户端创建UDP套接字</h3><p>创建 UDP 套接字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure><h4 id="1-3-1-设置套接字超时时间"><a href="#1-3-1-设置套接字超时时间" class="headerlink" title="1.3.1 设置套接字超时时间"></a>1.3.1 设置套接字超时时间</h4><p>在进行客户端向服务器发送 Ping 消息的过程中，有时候可能会因为网络原因造成一直连不上服务器（如服务器程序没有开启），这时如不手动停止，Socket 可能会一直尝试重连，造成资源的浪费。这就需要设置 <code>timeout</code> 来限制重连时间，当 Socket 尝试重连到指定的时间时，就会停止一切操作，并提示达到 <code>timeout</code> 设定阈值。设置超时时间一般在创建套接字后，在网络通信之前进行。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysocket.settimeout(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>代码作用为设定套接字的超时时间为 10 秒</p><p>客户端程序在创建完套接字后，通过循环向服务器发送消息，然后接收服务器回传的消息，通过计算收到消息及发送消息的时间差，来反映网络的状况。如果超时时间过后还没收到消息，则报出超时异常。</p><h4 id="1-3-2-客户端向服务器发送消息并接收消息"><a href="#1-3-2-客户端向服务器发送消息并接收消息" class="headerlink" title="1.3.2 客户端向服务器发送消息并接收消息"></a>1.3.2 客户端向服务器发送消息并接收消息</h4><p><strong>1. 消息编解码</strong></p><p>在网络通信中，网络线路中传输的是字节（二进制格式）流 <code>bytes</code>。但在我们发送的消息习惯用字符串 <code>string</code> 来表示，这时就需要用编码 <code>encode()</code> 和解码 <code>decode()</code> 函数来转换。</p><p><code>encode()</code> 函数：字符串类型（str）提供的方法，用于将字符串类型转换成 bytes 类型，这个过程也称为“编码”。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>注意，格式中用 [] 括起来的参数为可选参数，也就是说，在使用此方法时，可以使用 [] 中的参数，也可以不使用。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.53ukirqvzok0.webp#pic_center" width = 64%><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode()</span><br></pre></td></tr></table></figure><p>采用默认的 UTF-8 字符集将 str 编码为字节流</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode(<span class="string">&#x27;GBK&#x27;</span>)</span><br></pre></td></tr></table></figure><p>采用指定的 GBK 字符集将 str 编码为字节流</p><p><code>decode()</code> 函数：用于将 bytes 类型的二进制数据转换为 string 类型，这个过程也称为“解码”。其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>使用默认的 UTF-8 字符集进行解码为字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode()</span><br></pre></td></tr></table></figure><p>如果编码时采用的不是默认的 UTF-8 编码，则解码时要选择和编码时一样的格式，否则会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span> = <span class="built_in">str</span>.encode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line"><span class="built_in">bytes</span>.decode()  <span class="comment">#默认使用 UTF-8 编码，会抛出以下异常。</span></span><br><span class="line"><span class="built_in">bytes</span>.decode(<span class="string">&quot;GBK&quot;</span>)  <span class="comment">#不会抛出异常</span></span><br></pre></td></tr></table></figure><p>在 Ping 客户端程序中，发送消息时将发送消息的序号及发送时间发送到 Ping 服务器，然后接收消息，并将收到消息的时间与发送消息的时间差作为消息的延迟时间进行计算，并打印出来。</p><p>客户端程序为：</p><ol><li>使用UDP发送<code>ping</code>消息（注意：不同于TCP，您不需要首先建立连接，因为UDP是无连接协议。）</li><li>从服务器输出响应消息</li><li>如果从服务器受到响应，则计算并输出每个数据包的往返时延（RTT）（以秒为单位），</li><li>否则输出“请求超时”</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;127.0.0.1&#x27;</span> <span class="comment"># 服务器地址，本例中使用本机地址</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment"># 服务器指定的端口</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment"># 创建UDP套接字，使用IPv4协议</span></span><br><span class="line">clientSocket.settimeout(<span class="number">1</span>) <span class="comment"># 设置套接字超时值1秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">    sendTime = time.time()</span><br><span class="line">    message = (<span class="string">&#x27;Ping %d %s&#x27;</span> % (i+<span class="number">1</span>, sendTime)).encode()     <span class="comment"># 生成数据报，编码为bytes以便发送</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将信息发送到服务器</span></span><br><span class="line">        clientSocket.sendto(message, (serverName, serverPort))</span><br><span class="line">        <span class="comment"># 从服务器接收信息，同时也能得到服务器地址</span></span><br><span class="line">        modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">        rtt = time.time() - sendTime    <span class="comment"># 计算往返时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Reply from %s    RTT = %.3fs&#x27;</span> % (i+<span class="number">1</span>, serverName, rtt))         <span class="comment"># 显示信息</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Request timed out.&#x27;</span> % (i+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">clientSocket.close()            <span class="comment"># 关闭套接字</span></span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><p>在一台主机上运行<code>UDPPingerServer.py</code>，作为接收ping程序数据的服务器。</p><p>效果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.7g8vggsmopo0.webp#pic_center" width = 64%><p><strong>客户端：</strong></p><p>在另一台主机上运行<code>UDPPinger.py</code>，效果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.2qzffvjk6qw0.webp#pic_center" width = 48%>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（五）-- TCP套接字编程</title>
      <link href="/article/84fa558.html"/>
      <url>/article/84fa558.html</url>
      
        <content type="html"><![CDATA[<p>本文将首先利用 Python 实现面向TCP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。其次还将学习 HTTP 协议格式的相关知识。在此基础上，本篇将用 Python 语言开发一个简单的 Web 服务器，它仅能处理一个HTTP连接请求。</p><span id="more"></span><h2 id="1-Python3-网络编程"><a href="#1-Python3-网络编程" class="headerlink" title="1 Python3 网络编程"></a>1 Python3 网络编程</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Web 服务器的基本功能是接受并解析客户端的 HTTP 请求，然后从服务器的文件系统获取所请求的文件，生成一个由头部和响应文件内容所构成成的 HTTP 响应消息，并将该响应消息发送给客户端。如果请求的文件不存在于服务器中，则服务器应该向客户端发送“404 Not Found”差错报文。</p><p> &#x3D;&#x3D;具体的过程分为：&#x3D;&#x3D;</p><ul><li>当一个客户（浏览器）连接时，创建一个连接套接字；</li><li>从这个连接套接字接收 HTTP 请求；</li><li>解释该请求以确定所请求的特定文件；</li><li>从服务器的文件系统获得请求的文件；</li><li>创建一个由请求的文件组成的 HTTP 响应报文，报文前面有首部行；</li><li>经 TCP 连接向请求浏览器发送响应。</li><li>如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。</li></ul><p>要实现 Web 服务器，需使用套接字 Socket 编程接口来使用操作系统提供的网络通信功能。</p><p><font color=#9900CC><strong>Socket 是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，是一组编程接口。它把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。使用 Socket 后，无需深入理解 TCP&#x2F;UDP 协议细节（因为Socket 已经为我们封装好了），只需要遵循 Socket 的规定去编程，写出的程序自然就是遵循 TCP&#x2F;UDP 标准的。</strong></font>Socket 的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.1wujw2azhhhc.webp#pic_center" width = 36%><p><font color=#9900CC><strong>从某种意义上说，Socket 由地址IP和端口Port构成。</font></strong>IP 是用来标识互联网中的一台主机的位置，而 Port 是用来标识这台机器上的一个应用程序，IP 地址是配置到网卡上的，而 Port 是应用程序开启的，IP 与 Port 的绑定就标识了互联网中独一无二的一个应用程序。</p><p><strong>套接字类型</strong></p><ul><li>流式套接字（SOCK_STREAM）：用于提供面向连接、可靠的数据传输服务。——TCP</li><li>数据报套接字（SOCK_DGRAM）：提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。——UDP</li><li>原始套接字（SOCK_RAW）：主要用于实现自定义协议或底层网络协议。</li></ul><p>在本 WEB 服务器程序实验中，采用流式套接字进行通信。其基本模型如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.3r9nhi7ohm00.webp#pic_center" width = 48%><p>其工作过程如下：服务器首先启动，通过调用 <code>socket()</code> 建立一个套接字，然后调用绑定方法 <code>bind()</code> 将该套接字和本地网络地址联系在一起，再调用 <code>listen()</code> 使套接字做好侦听连接的准备，并设定的连接队列的长度。客户端在建立套接字后，就可调用连接方法 <code>connect()</code> 向服务器端提出连接请求。服务器端在监听到连接请求后，建立和该客户端的连接，并放入连接队列中，并通过调用 <code>accept()</code> 来返回该连接，以便后面通信使用。客户端和服务器连接一旦建立，就可以通过调用接收方法 <code>recv()/recvfrom()</code> 和发送 方法 <code>send()/sendto()</code> 来发送和接收数据。最后，待数据传送结束后，双方调用 <code>close()</code> 关闭套接字。</p><blockquote><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p></blockquote><hr><h2 id="2-创建TCP套接字"><a href="#2-创建TCP套接字" class="headerlink" title="2 创建TCP套接字"></a>2 创建TCP套接字</h2><h3 id="2-1-套接字"><a href="#2-1-套接字" class="headerlink" title="2.1 套接字"></a>2.1 套接字</h3><p><font color=#9900CC><strong>套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I&#x2F;O 插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是 IP 地址与端口 Port 的组合。</font></strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.1a0a2dxbsfr4.webp#pic_center" width = 48%><p>为了满足不同的通信程序对通信质量和性能的要求，网络系统提供了三种不同类型的套接字，以供用户在设计网络应用程序时根据不同的要求来选择。分别是：</p><ul><li>流式套接字（SOCK-STREAM）。提供一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在 TCP&#x2F;IP 协议簇中，使用 TCP 协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</li><li>数据报套接字（SOCK-DGRAM）。提供一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在 TCP&#x2F;IP 协议簇中，使用 UDP 协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</li><li>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如 IP 或 ICMP ）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</li></ul><p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建 <code>socket</code> 对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。<font color=#9900CC><strong>这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</font></strong></p><p>Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。</p><h3 id="2-2-如何创建套接字"><a href="#2-2-如何创建套接字" class="headerlink" title="2.2 如何创建套接字"></a>2.2 如何创建套接字</h3><p>套接字 Socket 实质上提供了主机间进程通信的连接点。进程通信之前，双方首先必须各自创建一个连接点。否则是没有办法建立联系并相互通信的。Python 中，我们用 <code>socket()</code> 函数来创建套接字，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my_socket = socket(socket_family, socket_type, protocol=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">socket_family可以是如下参数之一：</span></span><br><span class="line"><span class="string">  　　AF_INET IPv4（默认）</span></span><br><span class="line"><span class="string">　　  AF_INET6 IPv6</span></span><br><span class="line"><span class="string">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span></span><br><span class="line"><span class="string">socket_type可以是如下参数之一:</span></span><br><span class="line"><span class="string">　　  SOCK_STREAM　　流式socket , for TCP （默认）</span></span><br><span class="line"><span class="string">　  　SOCK_DGRAM　　 数据报式socket , for UDP</span></span><br><span class="line"><span class="string">　  　SOCK_RAW 原始套接字</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>Socket 对象(内建)方法</strong></p><table> <thead> <tr> <th align="left">函数</th> <th align="left">描述</th> </tr> </thead> <tbody><tr> <td align="left">服务器端套接字</td>  </tr> <tr> <td align="left">s.bind()</td> <td align="left">绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</td> </tr> <tr> <td align="left">s.listen()</td> <td align="left">开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td> </tr> <tr> <td align="left">s.accept()</td> <td align="left">被动接受TCP客户端连接,(阻塞式)等待连接的到来</td> </tr> <tr> <td align="left">客户端套接字</td>  </tr> <tr> <td align="left">s.connect()</td> <td align="left">主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td> </tr> <tr> <td align="left">s.connect_ex()</td> <td align="left">connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td> </tr> <tr> <td align="left">公共用途的套接字函数</td>  </tr> <tr> <td align="left">s.recv()</td> <td align="left">接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td> </tr> <tr> <td align="left">s.send()</td> <td align="left">发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td> </tr> <tr> <td align="left">s.sendall()</td> <td align="left">完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td> </tr> <tr> <td align="left">s.recvfrom()</td> <td align="left">接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td> </tr> <tr> <td align="left">s.sendto()</td> <td align="left">发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td> </tr> <tr> <td align="left">s.close()</td> <td align="left">关闭套接字</td> </tr> <tr> <td align="left">s.getpeername()</td> <td align="left">返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td> </tr> <tr> <td align="left">s.getsockname()</td> <td align="left">返回套接字自己的地址。通常是一个元组(ipaddr,port)</td> </tr> <tr> <td align="left">s.setsockopt(level,optname,value)</td> <td align="left">设置给定套接字选项的值。</td> </tr> <tr> <td align="left">s.getsockopt(level,optname[.buflen])</td> <td align="left">返回套接字选项的值。</td> </tr> <tr> <td align="left">s.settimeout(timeout)</td> <td align="left">设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td> </tr> <tr> <td align="left">s.gettimeout()</td> <td align="left">返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td> </tr> <tr> <td align="left">s.fileno()</td> <td align="left">返回套接字的文件描述符。</td> </tr> <tr> <td align="left">s.setblocking(flag)</td> <td align="left">如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td> </tr> <tr> <td align="left">s.makefile()</td> <td align="left">创建一个与该套接字相关连的文件</td> </tr> </tbody></table><h3 id="2-3-如何为套接字绑定主机及端口"><a href="#2-3-如何为套接字绑定主机及端口" class="headerlink" title="2.3 如何为套接字绑定主机及端口"></a>2.3 如何为套接字绑定主机及端口</h3><p>一个完整的 Socket 可以用一个通信双方的相关描述：<br>         $${协议,本地地址,本地端口,远程地址,远程端口}$$</p><p>实际应用中，在创建一个 Socket 时先用一个半相关描述（服务器这一半可以确定，而另一半尚不确定）:<br>         $${协议,本地地址,本地端口}$$<br>每一个 Socket 有一个本地的唯一端口号，由操作系统分配。</p><p>绑定指为套接字绑定地址包含主机及其端口。 在 AF_INET 下，以元组（host,port）的形式表示地址。</p><ul><li>host：用字符串表示主机的 IP 地址。表示本机<code>&#39;&#39;</code>，也可用 <code>127.0.0.1</code> 表示回环地址，或者主机的一般 IP 地址。</li><li>port：端口号，数字表示。1024 以下为系统约定，自定义的用 1024 以上。</li></ul><p>绑定通过套接字的绑定方法 <code>bind()</code> 来完成，输入参数为元组 <code>(host,port)</code>。<br><strong>绑定示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_socket.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1234</span>))         <span class="comment"># 绑定本地回环地址</span></span><br><span class="line">my_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">1234</span>))                  <span class="comment"># 自动获取IP地址</span></span><br></pre></td></tr></table></figure><h3 id="2-4-如何设置套接字监听"><a href="#2-4-如何设置套接字监听" class="headerlink" title="2.4 如何设置套接字监听"></a>2.4 如何设置套接字监听</h3><p>服务器程序在调用创建套接字 <code>socket()</code> 和绑定 <code>bind()</code> 之后需要处于监听状态，因为不知客户端什么时候开始进行请求连接。为此，需调用套接字的监听方法 <code>listen()</code>。</p><p>一个服务端可能同时面对多个客户端的连接请求，为此服务器程序需创建一个连接队列来保存的连接请求，并依次为连接请求建立相应连接。为此需设置队列的大小作为监听方法的参数。<br>监听示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_socket.listen(<span class="number">10</span>)    <span class="comment"># 设置连接队列大小为10，并使套接字处于监听状态。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-服务端获取连接请求"><a href="#2-5-服务端获取连接请求" class="headerlink" title="2.5 服务端获取连接请求"></a>2.5 服务端获取连接请求</h3><h4 id="2-5-1-如何获取客户端的连接请求"><a href="#2-5-1-如何获取客户端的连接请求" class="headerlink" title="2.5.1 如何获取客户端的连接请求"></a>2.5.1 如何获取客户端的连接请求</h4><p>当服务器中的套接字监听到了连接请求之后，内核和客户建立连接，并将连接放入连接队列中。典型的服务器程序是可以同时服务多个客户端的，当有客户端发起连接时，服务器就调用 <code>accept()</code> 返回并接收这个连接，如果有大量客户端发起请求，服务器来不及处理，还没有 accept 的客户端就处于连接等待状态。如果服务器调用 <code>accept()</code> 时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection_socket，addr = my_socket.accept()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">返回值： </span></span><br><span class="line"><span class="string">connectionSocket 客户端连接套接字</span></span><br><span class="line"><span class="string">addr 连接的客户端地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的 connectionSocket 称为客户端连接套接字，是 <code>accept()</code> 接收到一个客户端连接请求后返回的一个新的套接字，它代表了服务端和客户端的连接。后面可以用于读取数据以及关闭连接。</p><h4 id="2-5-2-如何获取客户端发送的报文内容"><a href="#2-5-2-如何获取客户端发送的报文内容" class="headerlink" title="2.5.2 如何获取客户端发送的报文内容"></a>2.5.2 如何获取客户端发送的报文内容</h4><p>服务器与客户端的连接建立好之后，就可以接收或发送消息操作。相应有下面几组方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recv()/send()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure><p>接收报文方法 <code>recv()</code> 用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = socket.recv(buffersize)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">　　　　　功能 ： 接收对应客户端消息</span></span><br><span class="line"><span class="string">　　　　　参数 ： 一次最多接收多少字节</span></span><br><span class="line"><span class="string">　　　　　返回值 ： 接收到的内容</span></span><br><span class="line"><span class="string">　　　    *  如果没有消息则会阻塞等待</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-服务端读取请求文件内容"><a href="#2-6-服务端读取请求文件内容" class="headerlink" title="2.6 服务端读取请求文件内容"></a>2.6 服务端读取请求文件内容</h3><h4 id="2-6-1-如何获取客户端请求的网页文件名"><a href="#2-6-1-如何获取客户端请求的网页文件名" class="headerlink" title="2.6.1 如何获取客户端请求的网页文件名"></a>2.6.1 如何获取客户端请求的网页文件名</h4><p>HTTP 请求是客户端通过发送信息向服务器请求对资源的访问。HTTP 请求由三部分组成：请求行、请求头和请求正文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /index.html HTTP/<span class="number">1.1</span>   <span class="comment"># 请求方法 url 协议及版本号</span></span><br><span class="line">Host: localhost             <span class="comment"># 主机地址</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">5.1</span>; rv:<span class="number">10.0</span><span class="number">.2</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">10.0</span><span class="number">.2</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*/*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Language: zh-cn,zh;q=<span class="number">0.5</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: &lt;a target=_blank href=<span class="string">&quot;http://localhost/&quot;</span> style=<span class="string">&quot;color: rgb(51, 102, 153); text-decoration: none;&quot;</span>&gt;http://localhost/&lt;/a&gt;</span><br><span class="line">Content-Length：<span class="number">25</span></span><br><span class="line">Content-<span class="type">Type</span>：application/x-www-form-urlencoded</span><br><span class="line">`     `</span><br><span class="line">username=aa&amp;password=<span class="number">1234</span>             <span class="comment"># 请求体</span></span><br></pre></td></tr></table></figure><p>从上方代码可以看出，请求网页文件名位于请求行（第一行）中用空格分隔的第二个部分。</p><p>在获得请求文件名后，读取文件内容使用文件操作来实现。Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。</p><h3 id="2-7-服务端响应请求头部信息"><a href="#2-7-服务端响应请求头部信息" class="headerlink" title="2.7 服务端响应请求头部信息"></a>2.7 服务端响应请求头部信息</h3><h4 id="2-7-1-WEB服务器响应消息头部定义"><a href="#2-7-1-WEB服务器响应消息头部定义" class="headerlink" title="2.7.1 WEB服务器响应消息头部定义"></a>2.7.1 WEB服务器响应消息头部定义</h4><p>WEB 服务器在接收到客户端的连接请求后，接下来就会响应该请求。HTTP 响应报文由三部分组成：响应行、响应头、响应体。如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.36a8ikrs6si0.webp#pic_center" width = 48%><ul><li>响应行：一般由协议版本、状态码及其描述组成，比如 <code>HTTP/1.1 200 OK</code> 其中协议版本 <code>HTTP/1.1</code> 或者 <code>HTTP/1.0</code>，<code>200</code> 就是它的状态码，<code>OK</code> 则为它的描述。</li><li>响应头：用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理它回送的数据。</li></ul><p>常见的响应头字段含义：</p><ul><li>Allow：服务器支持哪些请求方法(如GET、POST等)。</li><li>Content-Encoding：文档的编码(Encode)方法。</li><li>Content-Length：表示内容长度。</li><li>Content-Type：表示后面的文档属于什么MIME类型。</li><li>Date：当前的GMT时间</li><li>Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。</li><li>Last-Modified：文档的最后改动时间。</li><li>Location：用于重定向接收者到一个新URI地址。</li><li>Refresh：告诉浏览器隔多久刷新一次，以秒计。</li><li>Server：服务器通过这个头告诉浏览器服务器的类型。</li></ul><p>在这个 WEB 服务器返回的头部信息示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Connection: close</span><br><span class="line">Content-<span class="type">Type</span>: text/html</span><br><span class="line">Content-Length: <span class="number">24</span></span><br></pre></td></tr></table></figure><h4 id="2-7-2-发送响应消息头部内容"><a href="#2-7-2-发送响应消息头部内容" class="headerlink" title="2.7.2 发送响应消息头部内容"></a>2.7.2 发送响应消息头部内容</h4><p>在定义好响应消息的头部信息后，使用套接字的 send 方法发送即可。在发送前需要使用编码 <code>encode()</code> 方法，将字符串转换为字节数组后发送。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(header.encode())</span><br></pre></td></tr></table></figure><h4 id="2-7-3-如何捕获请求文件读取错误的异常"><a href="#2-7-3-如何捕获请求文件读取错误的异常" class="headerlink" title="2.7.3 如何捕获请求文件读取错误的异常"></a>2.7.3 如何捕获请求文件读取错误的异常</h4><p>在本服务器程序中，采用 <code>try...except</code> 结构来捕获异常。当请求的文件不存在（可能是文件名错误或路径错误）及其他可能导致文件访问错误（如没有相应权限）时，就会产生 IOError 异常。从而进入异常处理部分代码。</p><p><strong>发送自定义的异常信息给客户端</strong></p><p>在异常处理代码中，定义响应客户端请求文件不存在的响应消息头代码 404 及消息内容not Found。</p><p>将此响应消息头发给客户端，可以使用 socket 的发送方法 <code>send()</code> 完成，发送前需要使用编码方法 <code>encode()</code> 对响应消息进行编码。</p><p><strong>完整代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line"><span class="comment"># Prepare a sever socket </span></span><br><span class="line">serverSocket.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6789</span>))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始WEB服务...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">            connectionSocket, addr = serverSocket.accept()</span><br><span class="line">            message = connectionSocket.recv(<span class="number">1024</span>) <span class="comment"># 获取客户发送的报文</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 读取文件内容</span></span><br><span class="line">            filename = message.split()[<span class="number">1</span>]       <span class="comment"># message=[&quot;POST&quot;, &quot;/index.html&quot;, &quot;HTTP/1.1&quot;, ...]</span></span><br><span class="line">            f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">            outputdata = f.read()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 向套接字发送头部信息</span></span><br><span class="line">            header = <span class="string">&#x27; HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n&#x27;</span> % (<span class="built_in">len</span>(outputdata))</span><br><span class="line">            connectionSocket.send(header.encode())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送请求文件的内容</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">                connectionSocket.send(outputdata[i].encode())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line">            connectionSocket.close()</span><br><span class="line">    <span class="keyword">except</span> IOError:             <span class="comment"># 异常处理</span></span><br><span class="line">            <span class="comment"># 发送文件未找到的消息</span></span><br><span class="line">            header = <span class="string">&#x27; HTTP/1.1 404 not Found&#x27;</span></span><br><span class="line">            <span class="comment">#########Begin#########</span></span><br><span class="line">            connectionSocket.send(header.encode())</span><br><span class="line">            <span class="comment">#########End#########</span></span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line">            connectionSocket.close()</span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    serverSocket.close()</span><br></pre></td></tr></table></figure><p>上面建立了一个只允许一个连接的服务器，在指定端口监听客户端的请求，从客户端发送的请求中提取文件名，若该文件存在于服务器上（如下文的<code>&quot;HelloWorld.html&quot;</code>），则生成一个状态码200的POST报文，并返回该文件；若该文件不存在，则返回一个404 Not Found报文。</p><p><strong>HelloWorld.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><p>在一台主机上的同一目录下放入<code>WebServer.py</code>和<code>HelloWorld.html</code>两个文件，并运行<code>WebServer.py</code>，作为服务器。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.1q8kc9lae4sg.webp#pic_center" width = 48%><p><strong>客户端：</strong></p><p>在另一台主机上打开浏览器，并输入”<a href="http://xxx.xxx.xxx.xxx:6789/HelloWorld.html">http://XXX.XXX.XXX.XXX:6789/HelloWorld.html</a>“ （其中”XXX.XXX.XXX.XXX”是服务器IP地址），以获取服务器上的<code>HelloWorld.html</code>文件。</p><p>一切正常的话，可以看到如下页面：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1kv6ji5c5ygw.webp#pic_center" width = 48%><p>输入新地址<code>&quot;http://XXX.XXX.XXX.XXX:6789/abc.html&quot;</code>，以获取服务器上不存在的<code>abc.html</code>。将出现以下页面（注意页面中的”HTTP ERROR 404”）：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.7jp8f2p1r000.webp#pic_center" width = 48%><h3 id="2-8-示例分析"><a href="#2-8-示例分析" class="headerlink" title="2.8 示例分析"></a>2.8 示例分析</h3><p><strong>1. 服务端</strong></p><p>下面的代码实现了一个提供时间日期的服务器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230420</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 一个提供时间日期的服务器</span></span><br><span class="line"><span class="comment"># @Filename: server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET, gethostname</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1. 创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    <span class="comment"># family=AF_INET - IPv4地址</span></span><br><span class="line">    <span class="comment"># family=AF_INET6 - IPv6地址</span></span><br><span class="line">    <span class="comment"># type=SOCK_STREAM - TCP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_DGRAM - UDP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_RAW - 原始套接字</span></span><br><span class="line">    server = socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2. 绑定IP地址和端口（端口用于区分不同的服务）</span></span><br><span class="line">    <span class="comment"># 同一个时间在同一个端口只能绑定一个服务否则报错</span></span><br><span class="line">    <span class="comment"># server.bind((&#x27;192.168.1.2&#x27;, 1030))</span></span><br><span class="line">    host = gethostname()            <span class="comment"># 获取本地主机名</span></span><br><span class="line">    port = <span class="number">9999</span>                     <span class="comment"># 绑定端口号</span></span><br><span class="line">    server.bind((host, port))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    <span class="comment"># 参数512可以理解为连接队列的大小，超过后排队</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器启动开始监听……&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.通过循环接收客户端的连接并作出相应的处理(提供服务)</span></span><br><span class="line">        <span class="comment"># accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行</span></span><br><span class="line">        <span class="comment"># accept方法返回一个元组其中的第一个元素是客户端对象</span></span><br><span class="line">        <span class="comment"># 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)</span></span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(addr) + <span class="string">&quot;连接到了服务器.&quot;</span>)</span><br><span class="line">        <span class="comment"># 5. 发送数据</span></span><br><span class="line">        client.send(<span class="built_in">str</span>(datetime.now()).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># 6. 断开连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>查找自己电脑IP和端口的方法：<br>  <strong>第一步： Win+R</strong><br>  <strong>第二步： 输入：cmd  然后点击确定（Enter）进入</strong><br>  <strong>第三步： 输入：ipconfig  然后Enter</strong><br>  <strong>第四步： 输入：netstat 然后Enter</strong>  一般用第一个就行</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.1r14az76m0g0.webp#pic_center" width = 48%><p>运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.1lq3ku8fzvkw.webp#pic_left" width = "30%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.v6i83q4ig28.webp#pic_left"  width = "48%"></center></p><p>Windows开启telnet服务，见下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.72oe6hf6xfc0.gif#pic_center" width = 48%><p>当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p><p><strong>2. 客户端</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230420</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 一个接受时间日期的客户端</span></span><br><span class="line"><span class="comment"># @Filename: client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET, gethostname</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字对象默认使用IPv4和TCP协议</span></span><br><span class="line">    <span class="comment"># client = socket()</span></span><br><span class="line">    client = socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.连接到服务器（需要指定IP地址和端口）</span></span><br><span class="line">    <span class="comment"># client.connect((&#x27;10.69.164.78&#x27;, 1030))</span></span><br><span class="line">    host = gethostname()            <span class="comment"># 获取本地主机名</span></span><br><span class="line">    port = <span class="number">9999</span>                     <span class="comment"># 绑定端口号</span></span><br><span class="line">    client.connect((host, port))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.从服务器接受数据, 接收小于 1024 字节的数据</span></span><br><span class="line">    <span class="built_in">print</span>(client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>现在我们打开两个终端，第一个终端执行 <code>server.py</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 server.py</span><br></pre></td></tr></table></figure><p>第二个终端执行 <code>client.py</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 client.py</span><br><span class="line">2023-04-19 17:04:30.293444</span><br></pre></td></tr></table></figure><p>这时我们再打开第一个终端，就会看到有以下信息输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;192.168.1.2&#x27;</span>, 11046)连接到了服务器.</span><br></pre></td></tr></table></figure><p>需要注意的是，上面的服务器并没有使用多线程或者异步I&#x2F;O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p><p><strong>服务器端代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> dumps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自定义线程类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileTransferHandler</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cclient</span>):</span><br><span class="line">            <span class="built_in">super</span>().__init__()</span><br><span class="line">            self.cclient = cclient</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">            my_dict = &#123;&#125;</span><br><span class="line">            my_dict[<span class="string">&#x27;filename&#x27;</span>] = <span class="string">&#x27;guido.jpg&#x27;</span></span><br><span class="line">            <span class="comment"># JSON是纯文本不能携带二进制数据</span></span><br><span class="line">            <span class="comment"># 所以图片的二进制数据要处理成base64编码</span></span><br><span class="line">            my_dict[<span class="string">&#x27;filedata&#x27;</span>] = data</span><br><span class="line">            <span class="comment"># 通过dumps函数将字典处理成JSON字符串</span></span><br><span class="line">            json_str = dumps(my_dict)</span><br><span class="line">            <span class="comment"># 发送JSON字符串</span></span><br><span class="line">            self.cclient.send(json_str.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            self.cclient.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    server = socket()</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(区分不同的服务)</span></span><br><span class="line">    server.bind((<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;服务器启动开始监听...&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guido.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将二进制数据处理成base64再解码成字符串</span></span><br><span class="line">        data = b64encode(f.read()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 启动一个线程来处理客户端的请求</span></span><br><span class="line">        FileTransferHandler(client).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> loads</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    client = socket()</span><br><span class="line">    client.connect((<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 定义一个保存二进制数据的对象</span></span><br><span class="line">    in_data = <span class="built_in">bytes</span>()</span><br><span class="line">    <span class="comment"># 由于不知道服务器发送的数据有多大每次接收1024字节</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="comment"># 将收到的数据拼接起来</span></span><br><span class="line">        in_data += data</span><br><span class="line">        data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将收到的二进制数据解码成JSON字符串并转换成字典</span></span><br><span class="line">    <span class="comment"># loads函数的作用就是将JSON字符串转成字典对象</span></span><br><span class="line">    my_dict = loads(in_data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    filename = my_dict[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">    filedata = my_dict[<span class="string">&#x27;filedata&#x27;</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/Hao/&#x27;</span> + filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将base64格式的数据解码成二进制数据并写入文件</span></span><br><span class="line">        f.write(b64decode(filedata))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;图片已保存.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“&#x2F;”总共64个字符表示从000000到111111的64种状态。<a href="https://zh.wikipedia.org/wiki/Base64">维基百科</a>上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>网络编程入门：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.网络编程入门和网络应用开发.md</a></li><li>Python3 网络编程：<a href="https://www.nowcoder.com/tutorial/10005/99e037cb31a1486a8cf8ea61eb58dc8c">https://www.nowcoder.com/tutorial/10005/99e037cb31a1486a8cf8ea61eb58dc8c</a></li><li>WEB服务器编程实现：<a href="https://www.educoder.net/shixuns/synqujxr/challenges">https://www.educoder.net/shixuns/synqujxr/challenges</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP 套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（四）-- TCP/IP协议族详解</title>
      <link href="/article/1ee3e5d0.html"/>
      <url>/article/1ee3e5d0.html</url>
      
        <content type="html"><![CDATA[<p>TCP&#x2F;IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。TCP&#x2F;IP协议模型，包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><span id="more"></span><p>基于TCP&#x2F;IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP&#x2F;IP模型与OSI模型各层的对照关系。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5pqdp6bd4sw0.webp#pic_center" width = 48%><p><strong>1) 网络接口层</strong><br>        主要是指物理层次的一些接口，比如电缆等。</p><p><strong>2) 网络层</strong><br>        提供独立于硬件的逻辑寻址，实现物理地址与逻辑地址的转换。<br>        在 TCP &#x2F; IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）。</p><p><strong>3) 传输层</strong><br>        为网络提供了流量控制，错误控制和确认服务。<br>        在 TCP &#x2F; IP 协议族中有两个互不相同的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。</p><p><strong>4) 应用层</strong><br>        为网络排错，文件传输，远程控制和 Internet 操作提供具体的应用程序</p><p><strong><font color=#9900CC>重要协议：<ul><li>http (文本传输协议  当我们访问网页时使用的是http协议)  https 动态网页数据传输</li><li>  ftp  (文件传输协议  专门用于文件传输) </li><li>dhcp (自动ip地址分配协议   网络中要有一个dhcp服务器(路由器)) </li><li>   dns  (实现了域名到ip地址的解析)    ip地址    域名(www.qq.com) </li>实际网络之间通信用的是ip地址<br></br>dns服务器记录了常用的ip地址和域名的对应关系<li>icmp (ping 命令通过icmp协议发送出去的、装载错误报文信息) </li></ul></font> </strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">容易碰到的笔试面试题</span><br><span class="line">        1) tcp/ip有哪几层</span><br><span class="line">                应用层、传输层、网络层、网络接口层</span><br><span class="line">        2) 传输层有哪些协议</span><br><span class="line">                tcp   udp    icmp</span><br><span class="line">        3) 应用层有哪些协议</span><br><span class="line">                http  ftp  dns  dhcp</span><br><span class="line">        4) 请描述同一网段下主机A ping 主机B的全过程   (百度)</span><br><span class="line">                同一网段下   没用到dns</span><br><span class="line">                ping 192.168.1.100(不知道对方的网卡地址 MAC   MAC地址：每一个网卡有一个唯一地址(物理地址))    </span><br><span class="line">                如何得到对方MAC地址(用arp协议)</span><br><span class="line">                1) A发送一个ARP广播包，询问192.168.1.100的MAC地址是多少</span><br><span class="line">                2) B回送ARP包，包中携带自己的MAC地址(00 50 A9 90 88 07)    </span><br><span class="line">                3) A记录ip地址，ARP表中(以后不用发送广播包)（可以不写）</span><br><span class="line">                4) A 发送一个icmp报文给B</span><br><span class="line">                5) B收到回送一个icmp报文    </span><br></pre></td></tr></table></figure><hr><h2 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1 网络层"></a>1 网络层</h2><h3 id="1-1-IP协议"><a href="#1-1-IP协议" class="headerlink" title="1.1 IP协议"></a>1.1 IP协议</h3><p>IP协议是TCP&#x2F;IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><ul><li>A类IP地址: 0.0.0.0~127.255.255.255    IP 地址的前 8 位代表网络 ID ，后 24 位代表主机 ＩＤ。</li><li>B类IP地址:128.0.0.0~191.255.255.255   IP 地址的前 16 位代表网络 ID ，后 16 位代表主机 ＩＤ。</li><li>C类IP地址:192.0.0.0~239.255.255.255</li></ul><p>全是 0 的主机 ID 代表网络本身，比如说 IP 地址为 130.100.0.0 指的是网络 ID 为130.100 的 B 类地址。</p><p>全是 1 的主机 ID 代表广播，是用于向该网络中的全部主机方法消息的。 IP 地址为 130.100.255.255 就是网络 ID 为 130.100 网络的广播地址（二进制 IP 地址中全是 1 ，转换为十进制就是 255 ）</p><p>以十进制 127 开头的地址都是环回地址。目的地址是环回地址的消息，其实是由本地发送和接收的。主要是用于测试 TCP&#x2F;IP 软件是否正常工作。我们用 ping 功能的时候，一般用的环回地址是 127.0.0.1</p><h4 id="1-3-IP协议头"><a href="#1-3-IP协议头" class="headerlink" title="1.3 IP协议头"></a>1.3 IP协议头</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.2hkf0vw2kgw0.webp#pic_center" width = 48%><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64</p><h3 id="1-4-ARP及RARP协议"><a href="#1-4-ARP及RARP协议" class="headerlink" title="1.4 ARP及RARP协议"></a>1.4 ARP及RARP协议</h3><p>ARP 是根据IP地址获取MAC地址的一种协议。</p><p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p><p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p><p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>RARP协议的工作与此相反，不做赘述。</p><h3 id="1-5-ICMP协议"><a href="#1-5-ICMP协议" class="headerlink" title="1.5 ICMP协议"></a>1.5 ICMP协议</h3><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><hr><h2 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2 传输层"></a>2 传输层</h2><h3 id="2-1-TCP和UDP协议"><a href="#2-1-TCP和UDP协议" class="headerlink" title="2.1 TCP和UDP协议"></a>2.1 TCP和UDP协议</h3><p>TCP&#x2F;UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6oc8u9v1cf40.webp#pic_center" width = 48%><p><strong>面向报文(UDP)</strong></p><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文数据—大小有限制（64k）。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p><p><strong>面向字节流(TCP)</strong></p><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p><h3 id="2-2-TCP和UDP协议的一些应用"><a href="#2-2-TCP和UDP协议的一些应用" class="headerlink" title="2.2 TCP和UDP协议的一些应用"></a>2.2 TCP和UDP协议的一些应用</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.mwy4ndfwxgw.webp#pic_center" width = 48%><p><strong>什么时候应该使用TCP？</strong></p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p><strong>什么时候应该使用UDP？</strong></p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><hr><h2 id="3-TCP“三次握手”和“四次挥手”"><a href="#3-TCP“三次握手”和“四次挥手”" class="headerlink" title="3 TCP“三次握手”和“四次挥手”"></a>3 TCP“三次握手”和“四次挥手”</h2><h3 id="3-1-三次握手"><a href="#3-1-三次握手" class="headerlink" title="3.1 三次握手"></a>3.1 三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。<font color=#9900CC><strong>三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</font></strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.3ue72zpsrbs0.webp#pic_center" width = 48%><ol><li>第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ol><p><strong>为什么要三次握手？</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><h3 id="3-2-四次挥手"><a href="#3-2-四次挥手" class="headerlink" title="3.2 四次挥手"></a>3.2 四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.4cz29awk4ty0.webp#pic_center" width = 40%><ol><li>第一次挥手： 主机A（可以使客户端，也可以是服务器端），设置Sequence Number，向主机B发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机A没有数据要发送给主机B了；</li><li>第二次挥手： 主机B收到了主机A发送的FIN报文段，向主机A回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机A进入FIN_WAIT_2状态；主机B告诉主机A，我“同意”你的关闭请求；</li><li>第三次挥手： 主机B向主机A发送FIN报文段，请求关闭连接，同时主机B进入LAST_ACK状态；</li><li>第四次挥手： 主机A收到主机B发送的FIN报文段，向主机B发送ACK报文段，然后主机A进入TIME_WAIT状态；主机B收到主机A的ACK报文段以后，就关闭连接；此时，主机A等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机A也可以关闭连接了。</li></ol><p><strong>为什么要四次挥手？</strong> </p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机A发出FIN报文段时，只是表示主机A已经没有数据要发送了，主机A告诉主机B，它的数据已经全部发送完毕了；但是，这个时候主机A还是可以接受来自主机B的数据；当主机B返回ACK报文段时，表示它已经知道主机A没有数据发送了，但是主机B还是可以发送数据到主机A的；当主机B也发送了FIN报文段时，这个时候就表示主机B也没有数据要发送了，就会告诉主机A，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么在第四次挥手后会有2个MSL的延时？</strong></p><p>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。</p><p>假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。</p><hr><h2 id="4-TCP流量控制"><a href="#4-TCP流量控制" class="headerlink" title="4 TCP流量控制"></a>4 TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd &#x3D; 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。ACK表示首部中的确认位ACK，ack表示确认字段的值ack。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.1txsbpry9oxs.webp#pic_center" width = 48%><p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd &#x3D; 300 ，第二次又减到了 rwnd &#x3D; 100 ，最后减到 rwnd &#x3D; 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK &#x3D; 1 ，只有在ACK&#x3D;1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><hr><h2 id="5-TCP拥塞控制"><a href="#5-TCP拥塞控制" class="headerlink" title="5 TCP拥塞控制"></a>5 TCP拥塞控制</h2><h3 id="5-1-慢开始和拥塞避免"><a href="#5-1-慢开始和拥塞避免" class="headerlink" title="5.1 慢开始和拥塞避免"></a>5.1 慢开始和拥塞避免</h3><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p><strong>慢开始算法</strong></p><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.786waxk5a080.webp#pic_center" width = 48%><p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>另外，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li></ul><p><strong>拥塞避免</strong></p><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.vj0ehnw7ib4.webp#pic_center" width = 48%><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.5kw010mrs6s0.webp#pic_center" width = 48%><h3 id="5-2-快重传和快恢复"><a href="#5-2-快重传和快恢复" class="headerlink" title="5.2 快重传和快恢复"></a>5.2 快重传和快恢复</h3><p><strong>快重传</strong></p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/034.4np51k8fxnk0.webp#pic_center" width = 48%><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><p>应用层做为 TCP&#x2F;IP 协议的最高层级，对于我们移动开发来说，是接触最多的。</p><p><strong>运行在TCP协议上的协议：</strong></p><ul><li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 </li><li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本</li><li>FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。 </li><li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 </li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li><li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li><li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li></ul><p><strong>运行在UDP协议上的协议：</strong></p><ul><li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。 </li><li>NTP（Network Time Protocol，网络时间协议），用于网络同步。 </li><li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li></ul><p><strong>其他：</strong></p><ul><li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。</li><li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。 </li><li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。 </li><li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li></ul><hr><p>面试问题整理<br><a href="https://blog.csdn.net/u013354486/article/details/80588916">面试问题整理之TCP&#x2F;IP和网络编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP 协议族 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（三）-- SSL/TLS协议运行机制的概述</title>
      <link href="/article/ae7157b3.html"/>
      <url>/article/ae7157b3.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL&#x2F;TLS协议运行机制的概述》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --><p>互联网的通信安全，建立在SSL/TLS协议之上。</p><!-- /div --><!-- div id="more" class="asset-more" --><p>本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅<a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC文档</a>。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020501.jpg" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020501.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>一、作用</h2><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><blockquote>  <p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p><p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p><p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p></blockquote><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><blockquote>  <p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p><p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p></blockquote><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><p>——————————————————————————————————————————————————————————</p><h2>二、历史</h2><p>互联网加密通信协议的历史，几乎与互联网一样长。</p><blockquote>  <p>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</p><p>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</p><p>1996年，SSL 3.0版问世，得到大规模应用。</p><p>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer" target="_blank">TLS</a> 1.0版。</p><p>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的<a href="https://tools.ietf.org/html/rfc6176" target="_blank">修订版</a>。</p></blockquote><p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p><p>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p><p>——————————————————————————————————————————————————————————</p><h3>三、基本的运行过程</h3><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><p><strong>（1）如何保证公钥不被篡改？</strong></p><blockquote>  <p>解决方法：将公钥放在<a href="https://en.wikipedia.org/wiki/Digital_certificate" target="_blank">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p></blockquote><p><strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong></p><blockquote>  <p>解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</p></blockquote><p>因此，SSL/TLS协议的基本过程是这样的：</p><blockquote>  <p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成"对话密钥"。</p><p>（3） 双方采用"对话密钥"进行加密通信。</p></blockquote><p>上面过程的前两步，又称为"握手阶段"（handshake）。</p><p>——————————————————————————————————————————————————————————</p><h2>四、握手阶段的详细过程</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。</p><h3>4.1 客户端发出请求（ClientHello）</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p><p>在这一步，客户端主要向服务器提供以下信息。</p><blockquote>  <p>（1） 支持的协议版本，比如TLS 1.0版。</p><p>（2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。</p><p>（3） 支持的加密方法，比如RSA公钥加密。</p><p>（4） 支持的压缩方法。</p></blockquote><p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="https://tools.ietf.org/html/rfc4366" target="_blank">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p><h3>4.2 服务器回应（SeverHello）</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><blockquote>  <p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。</p><p>（3） 确认使用的加密方法，比如RSA公钥加密。</p><p>（4） 服务器证书。</p></blockquote><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><h3>4.3 客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><blockquote>  <p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</p><p>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。</p><p>至于为什么一定要用三个随机数，来生成"会话密钥"，<a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank">dog250</a>解释得很好：</p><blockquote>  <p>"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"</p></blockquote><p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><h3>4.4 服务器的最后回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。</p><blockquote>  <p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020503.gif" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020503.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>五、参考链接</h2><ul><li>MicroSoft TechNet, <a href="https://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx" target="_blank">SSL/TLS in Detail</a></li><li>Jeff Moser, <a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html" target="_blank">The First Few Milliseconds of an HTTPS Connection</a></li><li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">Transport Layer Security</a></li><li>StackExchange, <a href="https://security.stackexchange.com/questions/20803/how-does-ssl-work" target="_blank">How does SSL work?</a></li></ul><!-- /div --></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL/TLS 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（二）-- HTTP协议入门</title>
      <link href="/article/279b4884.html"/>
      <url>/article/279b4884.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP协议入门》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --><p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p><!-- /div --><!-- div id="more" class="asset-more" --><p>本文介绍 HTTP 协议的历史演变和设计思路。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.7dhbrewkz900.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.7dhbrewkz900.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的<a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank"><strong>应用层协议</strong></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p><pre class=" language-http"><code class=" language-http">GET /index.html</code></pre><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><pre><code class="language-html">&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>服务器发送完毕，就关闭TCP连接。</p><p>——————————————————————————————————————————————————————————</p><h2>二、HTTP/1.0</h2><h3>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><pre class=" language-http"><code class=" language-http">GET / HTTP/1.0<span class="token keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<span class="token keyword">Accept:</span> */*</code></pre><p>可以看到，这个格式与0.9版有很大变化。</p><p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p><h3>2.3 回应格式</h3><p>服务器的回应如下。</p><pre class=" language-http"><code class=" language-http">HTTP/1.0 200 OK <span class="token keyword">Content-Type:</span> text/plain<span class="token keyword">Content-Length:</span> 137582<span class="token keyword">Expires:</span> Thu, 05 Dec 1997 16:00:00 GMT<span class="token keyword">Last-Modified:</span> Wed, 5 August 1996 15:55:28 GMT<span class="token keyword">Server:</span> Apache 0.84&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>回应的格式是"头信息 + 一个空行（<code>\r\n</code>） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。</p><h3>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><blockquote>  <ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg</li><li>image/png</li><li>image/svg+xml</li><li>audio/mp4</li><li>video/mp4</li><li>application/javascript</li><li>application/pdf</li><li>application/zip</li><li>application/atom+xml</li></ul></blockquote><p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p><p>除了预定义的类型，厂商也可以自定义类型。</p><pre class=" language-http"><code class=" language-http">application/vnd.debian.binary-package</code></pre><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p><p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Type:</span> text/html; charset=utf-8</code></pre><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Accept:</span> */*</code></pre><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p><pre><code class="language-html">&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;!-- 等同于 --&gt;&lt;meta charset="utf-8" /&gt; </code></pre><h3>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Encoding:</span> gzip<span class="token keyword">Content-Encoding:</span> compress<span class="token keyword">Content-Encoding:</span> deflate</code></pre><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Accept-Encoding:</span> gzip, deflate</code></pre><h3>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> keep-alive</code></pre><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> keep-alive</code></pre><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><p>——————————————————————————————————————————————————————————</p><h2>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h3>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> close</code></pre><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p><h3>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h3>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Length:</span> 3495</code></pre><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank">"分块传输编码"</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Transfer-Encoding:</span> chunked</code></pre><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><pre class=" language-http"><code class=" language-http">HTTP/1.1 200 OK<span class="token keyword">Content-Type:</span> text/plain<span class="token keyword">Transfer-Encoding:</span> chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0</code></pre><h3>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p><p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p><blockquote><pre class=" language-http"><code class=" language-http"><span class="token keyword">Host:</span> www.example.com</code></pre></blockquote><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank">"队头堵塞"</a>（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><p>——————————————————————————————————————————————————————————</p><h2>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 </p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><p>——————————————————————————————————————————————————————————</p><h2>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><h3>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><p>——————————————————————————————————————————————————————————</p><h3>六、参考链接</h3><ul><li><a href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/" target="_blank">Journey to HTTP/2</a>, by Kamran Ahmed</li><li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">HTTP</a>, by Wikipedia</li><li><a href="https://tools.ietf.org/html/rfc1945" target="_blank">HTTP/1.0 Specification</a></li><li><a href="https://http2.github.io/http2-spec/" target="_blank">HTTP/2 Specification</a></li></ul> <!-- /div --></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（一）-- 网络协议入门</title>
      <link href="/article/54ebc735.html"/>
      <url>/article/54ebc735.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --> <p>我们每天使用互联网，你是否想过，它是如何实现的？</p> <!-- /div --><!-- div id="more" class="asset-more" --><p>全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？</p><p>互联网的核心是一系列协议，总称为"互联网协议"（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。</p><p>下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。</p><p>=====================================================================================================</p><p><strong>互联网协议入门</strong></p><h2>一、概述</strong></h2><h3>1.1 五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p><p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p><p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.38nwepibeja0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.38nwepibeja0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>如上图所示，最底下的一层叫做"实体层"（Physical Layer），最上面的一层叫做"应用层"（Application Layer），中间的三层（自下而上）分别是"链接层"（Link Layer）、"网络层"（Network Layer）和"传输层"（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p><p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p><h3>1.2 层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p><p>大家都遵守的规则，就叫做"协议"（protocol）。</p><p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>二、实体层</h2><p>我们从最底下的一层开始。</p><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.7bhub0v9cro0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.7bhub0v9cro0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p><strong>这就叫做"实体层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>三、链接层</h2><h3>3.1 定义</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><p><strong>这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。</strong></p><h3>3.2 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank">"以太网"</a>（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.3sj550tq6ko0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.3sj550tq6ko0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>"标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容。</p><p>"标头"的长度，固定为18字节。"数据"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h3>3.3 MAC地址</h3><p>上面提到，以太网数据包的"标头"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.3kqm9zic6mm0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.3kqm9zic6mm0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.3blgbxit7ew0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.3blgbxit7ew0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h3>3.4 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1yajhsqchfc0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1yajhsqchfc0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"（broadcasting）。</p><p><strong><font color=#9900CC>有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。</font></strong></p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>四、网络层</h2><h3>4.1 网络层的由来</h3><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.mrj64s4xek0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.mrj64s4xek0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。（"路由"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p><strong>这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。</strong></p><p>于是，"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p><strong><font color=#9900CC>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</strong></font></p><h3>4.2 IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.5u7v0i8645s0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.5u7v0i8645s0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"（subnet mask）。</p><p>所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，<strong><font color=#9900CC>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</strong></font></p><h3>4.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为"标头"和"数据"两个部分。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.64f4rdo4nkk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.64f4rdo4nkk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.5zhlnq0lgjk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.5zhlnq0lgjk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h3>4.4 ARP协议</h3><p>关于"网络层"，还有最后一点需要说明。</p><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，<strong><font color=#9900CC>有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</strong></font></p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>五、传输层</h2><h3>5.1 传输层的由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p><strong><font color=#9900CC>"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。</font></strong>因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。</p><h3>5.2 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由"标头"和"数据"两部分组成。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.6plmy6jn3to0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.6plmy6jn3to0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>"标头"部分主要定义了发出端口和接收端口，"数据"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.52t1zltlu1g0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.52t1zltlu1g0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h3>5.3 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>六、应用层</h2><p>应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p><strong>"应用层"的作用，就是规定应用程序的数据格式。</strong></p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.59qyg4v1nis0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.59qyg4v1nis0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。<a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank">接下来</a>，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>七、一个小结</h2><p>先对前面的内容，做一个小结。</p><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.4dpg8ltt0oa0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.4dpg8ltt0oa0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>发送这个包，需要知道两个地址：</p><blockquote><p>　　* 对方的MAC地址</p><p>　　* 对方的IP地址</p></blockquote><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.5zkk0043ot00.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.5zkk0043ot00.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</p><table width="70%" border="1"><tbody><tr><td>场景</td><td>数据包地址</td></tr><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>八、用户的上网设置</h2><h3>8.1 静态IP地址</h3><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.5w0gc8mfxng0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.5w0gc8mfxng0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=30%></p><p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p><blockquote><p> * 本机的IP地址<br>　* 子网掩码<br>　* 网关的IP地址<br>　* DNS的IP地址</p></blockquote><p>下图是Windows系统的设置窗口。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.4m5ltvx8uq60.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.4m5ltvx8uq60.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作"静态IP地址上网"。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用"动态IP地址上网"。</p><h3>8.2 动态IP地址</h3><p>所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<a href="https://zh.wikipedia.org/zh/DHCP" target="_blank">DHCP协议</a>。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><h3>8.3 DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.3thi8oox1wk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.3thi8oox1wk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>　　（1）最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>　　（2）后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>　　（3）最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><h3>8.4 上网设置：小结</h3><p>这个部分，需要记住的就是一点：不管是"静态IP地址"还是"动态IP地址"，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p><blockquote><p>　　* 本机的IP地址<br>　　* 子网掩码<br>　　* 网关的IP地址<br>　　* DNS的IP地址</p></blockquote><p>有了这几个数值，电脑就可以上网"冲浪"了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>九、一个实例：访问网页</h2><h3>9.1 本机参数</h3><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p><blockquote><p>　　* 本机的IP地址：192.168.1.100<br>　　* 子网掩码：255.255.255.0<br>　　* 网关的IP地址：192.168.1.1<br>　　* DNS的IP地址：8.8.8.8</p></blockquote><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.33qdb1us7i80.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.33qdb1us7i80.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><h3>9.2 DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。</p><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank">DNS协议</a>可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.4bq5vfqsa1w0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.4bq5vfqsa1w0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><h3>9.3 子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><h3>9.4 应用层协议</h3><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.74a6x63uktg0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.74a6x63uktg0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>HTTP部分的内容，类似于下面这样：</p><blockquote><p>　　GET / HTTP/1.1<br>　　Host: www.google.com<br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: ... ...</p></blockquote><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><h3>9.5 TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h3>9.6 IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><h3>9.7 以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.3r7z857cbfo0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.3r7z857cbfo0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><h3>9.8 服务器端响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.1xbl4h8urn5s.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.1xbl4h8urn5s.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p><!-- /div --></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基本使用</title>
      <link href="/article/62580e04.html"/>
      <url>/article/62580e04.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要记录使用 hexo 写博客并发布到个人网站上。建议先学习：<a href="https://qxienote.com/article/6c09ec5e.html">MarkDown</a></p><span id="more"></span><h2 id="1-新建、编辑并预览文章"><a href="#1-新建、编辑并预览文章" class="headerlink" title="1 新建、编辑并预览文章"></a>1 新建、编辑并预览文章</h2><p><strong>1. 新建文章</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] title       <span class="comment"># 或 hexo n [layout] title</span></span><br></pre></td></tr></table></figure><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用 post 布局，然后自动在 <code>source\_posts</code> 目录生成一个text1.md 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n text1</span><br></pre></td></tr></table></figure><p>当然你还可以指定布局：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n [layout_name] draft1</span><br></pre></td></tr></table></figure><p>该命令创建了一个使用特定布局的名为draft1的文章。</p><p>打开之前创建的 text1.md 文件，我们可以看到文章开头包含以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">text1</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-04-10 04:13:36</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">blog</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>你显示的内容可能未必与我一样，不必担心，这是由于我自定义过。只需要知道，上面的内容在hexo被称作Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在scaffolds&#x2F;目录下，可以看到hexo自带的三种布局其实就是三个.md文件：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.yh8sg3aoii.webp#pic_center" width = 48%><p>所有的文章都是放在主目录下source文件下的_posts目录下的，这里参考我的存放目录 <code>D:\Blog\source\_posts</code></p><p>这里作出两点说明：</p><p>该目录下可以再创建目录，系统可以识别到多层文件夹中的文章，方便分类；如果用命令生成的新文章一定是在_posts主目录下</p><p>我用 VSCode 写 MarkDown，非常好用，点开创建的文件，先看看里面有啥</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">第一篇文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-06-08 10:30:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>两个虚线之间的内容就是叫 Front-matter，主要是你文章的配置，具体配置如下，这里不同主题不一样，我以 Next 主题为例。</p><p>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td><a href="/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td><code>title</code></td><td>标题</td><td>文章的文件名</td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td><code>null</code></td></tr><tr><td><code>excerpt</code></td><td>纯文本的页面摘要。使用 <a href="/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td></td></tr><tr><td><code>disableNunjucks</code></td><td>启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和 <a href="/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td>false</td></tr><tr><td><code>lang</code></td><td>设置语言以覆盖 <a href="/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td>继承自 <code>_config.yml</code></td></tr></tbody></table><p>以下为文章的 Front-matter 示例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">第一篇文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-06-08 10:30:00</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">cover:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">coverImg:</span> <span class="string">/images/1.jpg</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">********************************</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，也可以使用</span> <span class="string">&lt;!--more--&gt;</span> <span class="string">强制截断</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Markdown</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">VSCode</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Markdown</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>你会发现，每次 <code>hexo n</code> 的时候 Front-matter 中内容少的可怜，那怎么修改默认的格式呢？只要去主目录下找到 scaffolds 文件夹下找到一个 post.md 文件修改即可，这里是我的目录<code>D:\Blog\scaffolds\post.md</code>，例如我的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">author:</span> <span class="string">Carpe</span> <span class="string">Diem</span></span><br><span class="line"><span class="comment"># 标签</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="comment"># 分类</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="comment"># 简述</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="comment"># 使用自定义封面 </span></span><br><span class="line"><span class="attr">img:</span> </span><br><span class="line"><span class="comment"># 是否置顶true，或者去掉</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 轮播</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="comment"># 轮播图</span></span><br><span class="line"><span class="attr">coverImg:</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="2-只在首页显示文章摘要"><a href="#2-只在首页显示文章摘要" class="headerlink" title="2 只在首页显示文章摘要"></a>2 只在首页显示文章摘要</h2><p><strong>方法一：写概述</strong></p><p>在文章的 <code>front-matter</code> 中添加 <code>description</code>，其中 <code>description</code> 中的内容就会被显示在首页上，其余一律不显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p><p><strong>方法二:文章截断</strong></p><p>在需要截断的地方加入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p><p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置SSL证书</title>
      <link href="/article/ecc40a95.html"/>
      <url>/article/ecc40a95.html</url>
      
        <content type="html"><![CDATA[<p>本文讲解如何使用SSL证书保护我们的应用，并在 Nginx 配置 HTTP 跳转到 HTTPS</p><span id="more"></span><h2 id="1-Ubuntu-20-04-上安装-Nginx"><a href="#1-Ubuntu-20-04-上安装-Nginx" class="headerlink" title="1 Ubuntu 20.04 上安装 Nginx"></a>1 Ubuntu 20.04 上安装 Nginx</h2><p>Nginx 发音 “engine x” ,是一个开源软件，高性能 HTTP 和反向代理服务器，用来在互联网上处理一些大型网站。它可以被用作独立网站服务器，负载均衡，内容缓存和针对 HTTP 和非 HTTP 的反向代理服务器。和 Apache相比，Nginx 可以处理大量的并发连接，并且每个连接占用一个很小的内存。</p><h3 id="1-1-前提条件"><a href="#1-1-前提条件" class="headerlink" title="1.1 前提条件"></a>1.1 前提条件</h3><p>在继续之前，保证以 sudo 用户身份登录，并且你不能运行 Apache 或者 其他处理进程在80端口和443端口。</p><h3 id="1-2-安装-Nginx"><a href="#1-2-安装-Nginx" class="headerlink" title="1.2 安装 Nginx"></a>1.2 安装 Nginx</h3><p>Nginx 在默认的 Ubuntu 源仓库中可用。想要安装它，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><p>一旦安装完成，Nginx 将会自动被启动。你可以运行下面的命令来验证它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 设置nginx开机启动</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">systemctl enable nginx.service</span><br><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p>输出类似下面这样：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/034.5zxqznpeapc0.webp#pic_center" width = 48%><h3 id="1-3-配置防火墙"><a href="#1-3-配置防火墙" class="headerlink" title="1.3 配置防火墙"></a>1.3 配置防火墙</h3><p>现在你已经在你的服务器上安装和运行了 Nginx，你需要确保你的防火墙被配置好，允许流量通过 HTTP（80）和 HTTPS（443）端口。假设你正在使用UFW，你可以做的是启用 <code>‘Nginx Full’ profile</code>，它包含了这两个端口：</p><p>UFW 全称为 Uncomplicated Firewall，是 Ubuntu 系统上配置 iptables 防火墙的工具。UFW 提供一个非常友好的命令用于创建基于IPV4，IPV6的防火墙规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span><br></pre></td></tr></table></figure><p>想要验证状态，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><p>输出将会像下面这样：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/036.59l1rkr9xrk0.webp#pic_center" width = 48%><h3 id="1-4-测试安装"><a href="#1-4-测试安装" class="headerlink" title="1.4 测试安装"></a>1.4 测试安装</h3><p>想要测试你的新 Nginx 安装，在你的浏览器中打开<a href="http://your_ip,你应该可以看到默认的/">http://YOUR_IP，你应该可以看到默认的</a> Nginx 加载页面，像下面这样：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/035.5u53rg3bzp00.webp#pic_center" width = 48%><h3 id="1-5-Nginx-配置文件结构以及最佳实践"><a href="#1-5-Nginx-配置文件结构以及最佳实践" class="headerlink" title="1.5 Nginx 配置文件结构以及最佳实践"></a>1.5 Nginx 配置文件结构以及最佳实践</h3><ul><li>所有的 Nginx 配置文件都在 <code>/etc/nginx/</code> 目录下。</li><li>主要的 Nginx 配置文件是 <code>/etc/nginx/nginx.conf</code>。</li><li>为每个域名创建一个独立的配置文件，便于维护服务器。你可以按照需要定义任意多的 block 文件。</li><li>Nginx 服务器配置文件被储存在 <code>/etc/nginx/sites-available</code> 目录下。在 <code>/etc/nginx/sites-enabled</code> 目录下的配置文件都将被 Nginx 使用。</li><li>最佳推荐是使用标准的命名方式。例如，如果你的域名是mydomain.com，那么配置文件应该被命名为 <code>/etc/nginx/sites-available/mydomain.com.conf</code></li><li>如果你在域名服务器配置块中有可重用的配置段，把这些配置段摘出来，做成一小段可重用的配置。</li><li>Nginx 日志文件(access.log 和 error.log)定位在 <code>/var/log/nginx/</code> 目录下。推荐为每个服务器配置块，配置一个不同的access和error。</li><li>你可以将你的网站根目录设置在任何你想要的地方。最常用的网站根目录位置包括：<ul><li><code>/home/&lt;user_name&gt;/&lt;site_name&gt;</code></li><li><code>/var/www/&lt;site_name&gt;</code></li><li><code>/var/www/html/&lt;site_name&gt;</code></li><li><code>/opt/&lt;site_name&gt;</code></li></ul></li></ul><h3 id="2-HTTPS介绍"><a href="#2-HTTPS介绍" class="headerlink" title="2 HTTPS介绍"></a>2 HTTPS介绍</h3><p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL&#x2F;TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><p><strong>特点</strong></p><ul><li>内容加密：采用混合加密技术，中间者无法直接查看明文内容；</li><li>验证身份：通过证书认证客户端访问的是自己的服务器；</li><li>保护数据完整性：防止传输的内容被中间人冒充或者篡改。</li></ul><h3 id="2-1-HTTP-原理"><a href="#2-1-HTTP-原理" class="headerlink" title="2.1 HTTP 原理"></a>2.1 HTTP 原理</h3><p>HTTPS 主要由两部分组成：HTTP + SSL &#x2F; TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。</p><p>(1) 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP来完成，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和许可内容。</p><p>(2) 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><h3 id="2-2-HTTPS-原理"><a href="#2-2-HTTPS-原理" class="headerlink" title="2.2 HTTPS 原理"></a>2.2 HTTPS 原理</h3><p>(1) 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；<br>(2) 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；<br>(3) 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 &#x2F; 解密），并将加密后的信息发送给服务器；<br>(4) 客户端与服务器端根据pre_master_secret以及客户端与服务器的随机数值独立计算出加密和 MAC密钥；<br>(5) 客户端将所有握手消息的 MAC 值发送给服务器；<br>(6) 服务器将所有握手消息的 MAC 值发送给客户端；</p><h3 id="2-3-HTTPS-优缺点"><a href="#2-3-HTTPS-优缺点" class="headerlink" title="2.3 HTTPS 优缺点"></a>2.3 HTTPS 优缺点</h3><p><strong>优点</strong></p><ul><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS 协议是由 SSL+HTTP构建的可进行加密传输、身份认证的网络协议，要比HTTP安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性；</li><li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本；</li></ul><p><strong>缺点</strong></p><ul><li>相同网络环境下，HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。此外，HTTPS 协议还会影响缓存，增加数据开销和功耗；</li><li>成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</li></ul><h2 id="3-配置HTTPS"><a href="#3-配置HTTPS" class="headerlink" title="3 配置HTTPS"></a>3 配置HTTPS</h2><h3 id="3-1-准备"><a href="#3-1-准备" class="headerlink" title="3.1 准备"></a>3.1 准备</h3><p><strong>1. 一台可用的服务器</strong></p><p>首先需要有一台可用的服务器，后续用作域名解析。如果没有服务器可以先购买一台云服务器。</p><p><strong>2. 一个备案过的域名</strong></p><p>需要一个备过案的域名，用于解析服务器的IP地址。在对应购买的域名的服务商网站控制台可以完成备案。</p><p><strong>3. SSL证书</strong></p><p>SSL证书有免费和收费两个渠道。</p><p>我们这边主要介绍腾讯云和阿里云(排名不分先后)两个免费申请SSL证书的方式，当然资金允许情况下也可以直接购买。</p><p><strong>4. 阿里云申请免费SSL证书</strong></p><p>阿里云免费证书规则：自2021年起，免费证书申请将切换到证书资源包下每个实名个人&#x2F;企业主体在一个自然年内可以一次性领取20张免费证书，免费证书每张证书有效期一年。免费证书仅支持绑定一个单域名，不支持绑定通配符域名或者IP。</p><p>阿里云申请免费SSL证书文档：<a href="https://help.aliyun.com/document_detail/156645.htm?spm=a2c4g.11186623.2.7.2db71a63TXmPoB#task-2436672">官方文档地址</a></p><p><strong>5. 腾讯云申请免费SSL证书</strong></p><p>腾讯云免费证书规则：只支持绑定1个域名，可以支持绑定二级域名 abc.com、或是三级域名 example.abc.com。同一主域最多只能申请20张免费证书,每张有效期一年，免费证书到期后如需继续使用证书，需要重新申请并安装。</p><p>腾讯云申请免费SSL证书文档：<a href="https://cloud.tencent.com/document/product/400/6814">官方文档地址</a></p><h3 id="3-2-域名升级成HTTPS"><a href="#3-2-域名升级成HTTPS" class="headerlink" title="3.2 域名升级成HTTPS"></a>3.2 域名升级成HTTPS</h3><p>我们如果直接用域名解析IP地址，域名也是可以访问的，但是是HTTP环境的。 我们使用的Nginx来配置升级HTTPS</p><blockquote><p><a href="https://github.com/Tzlibai/Nginx.conf/blob/main/%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/nginx.conf">Github地址：完整的单域名nginx.conf文件配置(清晰注释) – 点击进入</a></p></blockquote><p>当我们在上面申请成功免费的SSL证书之后，点击下载证书。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/037.3u00n8uyq6m0.webp#pic_center" width = 48%><p>下载完成会得到一个压缩包，我们解压之后选择Nginx文件夹，里面的两个文件就是我们后续需要配置的文件。 下载到本地的压缩文件包解压后Nginx文件夹包含：</p><ul><li>.pem文件：是证书文件；</li><li>.key文件：证书的私钥文件。</li></ul><p>这时候我们打开我们的SSH工具，进入Nginx的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 进入nginx目录,默认安装在/etc/nginx，这个目录如果未找到，可以根据nginx安装的位置进入</span><br><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br></pre></td></tr></table></figure><p><strong>步骤一</strong></p><p>在Nginx的安装目录下创建cert目录，并且将下载的全部文件拷贝到 <code>/etc/nginx/cert</code> 目录中（使用SSH工具附带的本地文件上传功能，将本地证书文件和密钥文件上传到Nginx服务器的证书目录[示例中为 <code>/etc/nginx/cert</code>]）。如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并且命名为a.key；</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/038.3dneejzgol40.webp#pic_center" width = 48%><p><strong>步骤二</strong></p><p>然后开始Nginx配置,编辑Nginx配置文件（nginx.conf）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 进入nginx目录,默认安装在/etc/nginx，这个目录如果未找到，可以根据nginx安装的位置进入</span><br><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line"></span><br><span class="line">// 编辑nginx的配置文件</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p><strong>步骤三</strong></p><p>修改与证书相关的配置内容按i键进入编辑模式,增加代码，监听443端口，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen       443 ssl;</span><br><span class="line">      listen       [::]:443;</span><br><span class="line">      server_name  localhost;</span><br><span class="line">       ssl on;</span><br><span class="line"></span><br><span class="line">              root /usr/share/nginx/html;</span><br><span class="line">              index index.html index.htm;</span><br><span class="line">      <span class="comment">#证书文件名称</span></span><br><span class="line">      ssl_certificate cert/a.crt;</span><br><span class="line">      <span class="comment">#私钥文件名称</span></span><br><span class="line">      ssl_certificate_key cert/a.key;</span><br><span class="line"></span><br><span class="line">      ssl_session_cache shared:SSL:1m;</span><br><span class="line">      ssl_session_timeout  5m;</span><br><span class="line">      ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">      ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">      ssl_prefer_server_ciphers on;</span><br><span class="line">      <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      error_page 404 /404.html;</span><br><span class="line">          location = /40x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      error_page 500 502 503 504 /50x.html;</span><br><span class="line">          location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>步骤四</strong></p><p>执行命令 <code>/sbin/nginx -s reload</code> 重启服务器即可！（如果重启未成功，说明配置文件nginx.conf错误，检查是否有错误，后执行重启）</p><p><strong>步骤五</strong></p><p>验证是否安装成功,证书安装完成后，可通过访问证书的绑定域名验证该证书是否安装成功。</p><p>上述步骤成功之后，我们就可以通过 <code>https://www.域名.com</code> 来访问我们网站了，但是问题来了，因为我们申请的免费SSL证书是单域名绑定，也就是只能让<code>https://www.域名.com</code> 下的内容实现HTTPS访问，我们的二级域名 <code>api.域名.com</code> 还是只能 HTTP 访问。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>如何在 Ubuntu 20.04 上安装 Nginx：<a href="https://www.itcoder.tech/posts/how-to-install-nginx-on-ubuntu-20-04/">https://www.itcoder.tech/posts/how-to-install-nginx-on-ubuntu-20-04/</a></li><li>网站还是HTTP?快把你的域名和二级域名变成HTTPS：<a href="https://juejin.cn/post/6953649812097122312">https://juejin.cn/post/6953649812097122312</a></li><li>Nginx配置HTTP跳转到HTTPS：<a href="https://juejin.cn/post/7044911075480829959">https://juejin.cn/post/7044911075480829959</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 使用问题汇总</title>
      <link href="/article/cc21273e.html"/>
      <url>/article/cc21273e.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要汇总在使用 Git 进行提交和拉取文件时，遇到的问题的解决方案，以便下次查找。</p><h3 id="1-关于使用Git出现“git-Failed-to-connect-to-127-0-0-1-port-xxxx-Connection-refused”的问题解决方案"><a href="#1-关于使用Git出现“git-Failed-to-connect-to-127-0-0-1-port-xxxx-Connection-refused”的问题解决方案" class="headerlink" title="1 关于使用Git出现“git Failed to connect to 127.0.0.1 port xxxx: Connection refused”的问题解决方案"></a>1 关于使用Git出现“git Failed to connect to 127.0.0.1 port xxxx: Connection refused”的问题解决方案</h3><p><strong>1. 问题描述</strong></p><p>在使用 git 拉取、提交代码的时候，会出现 git Failed to connect to 127.0.0.1 port xxxx: Connection refused 的问题。</p><p>原因：无法连接到127.0.0.1: xxx端口: 连接被拒绝。</p><p><strong>2. 解决方案</strong><br>方案一：<br>思路：查询当前是否有代理，如果有就取消。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 首先，查一下当前全局的 http 代理：</span><br><span class="line">git config --global http.proxy</span><br><span class="line">// 如果有代理，就取消</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 再查 https 的代理：</span><br><span class="line">git config --global https.proxy</span><br><span class="line">// 同样的，有就取消</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>方案二：<br>上面的方案如果不行的话，再参考这个方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 首先，查一下代理：</span><br><span class="line"><span class="built_in">env</span>|grep -i proxy</span><br><span class="line">// 有就取消</span><br><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"></span><br><span class="line">// 再查</span><br><span class="line"><span class="built_in">env</span>|grep -i proxy</span><br><span class="line">// 正常情况下是没有代理了</span><br><span class="line">// 再次查询一下，如果还有的再取消</span><br></pre></td></tr></table></figure><p>方案三<br>修改环境变量<br>在系统变量中找到了变量<code>http_proxy</code>和<code>https_proxy</code>，用户变量也可以看看有没有，删除他就可以了。</p><p>重启计算机。</p><p>再用 git，正常了，再查<code>env|grep -i proxy</code>，代理没有了。</p><p><strong>3. 小结</strong></p><p>代理没有了，就可以正常拉取、提交代码了。</p><blockquote><p>本部分参考自：<a href="https://blog.csdn.net/XH_jing/article/details/115095225">关于使用Git出现“git Failed to connect to 127.0.0.1 port xxxx: Connection refused”的问题解决方案</a></p></blockquote><h3 id="2-error-src-refspec-master-does-not-match-any"><a href="#2-error-src-refspec-master-does-not-match-any" class="headerlink" title="2 error: src refspec master does not match any."></a>2 error: src refspec master does not match any.</h3><p><strong>1. 问题描述</strong></p><p>在将本地项目上传到新建的仓库时，出现了下图的错误：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/004.6d5q38zcl2o0.webp#pic_center" width = 48%><p>问题的内容是：<br>错误：SRC ReFSPEC 主控器不匹配任何。<br>错误：未能将某些引用推到 <code>git@github.com:molimi/MyBlog.git</code></p><p><strong>2. 解决方案</strong></p><p>其实只需要进行下面几步就能把本地项目上传到Github</p><ol><li>在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；</li><li>把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；</li><li>再通过 <code>git commit -m &quot;注释内容&quot;</code> 把项目提交到仓库；</li><li>在Github上设置好SSH密钥后，新建一个远程仓库，通过 <code>git remote add origin https://github.com/molimi/MyBlog.git</code> 将本地仓库和远程仓库进行关联；</li><li>最后通过 <code>git push -u origin master</code> 把本地仓库的项目推送到远程仓库（也就是Github）上；（若新建远程仓库的时候自动创建了README文件会报错，解决办法看上面）。</li></ol><blockquote><p>本部分参考自：<a href="https://blog.csdn.net/qq_38198952/article/details/82792279">error: src refspec master does not match any. 错误的解决办法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（一）-- 算法分析基础</title>
      <link href="/article/d46e4964.html"/>
      <url>/article/d46e4964.html</url>
      
        <content type="html"><![CDATA[<p>近期在学习《数据结构与算法分析Python》，本篇主要介绍算法分析的基础，介绍Python中List和Dic常用操作的时间复杂度，最后用一个变位词的例子比较不同算法的复杂度。</p><span id="more"></span><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>算法分析主要就是从计算资源消耗的角度来评判和比较算法，更高效利用计算资源，或者更少占用计算资源的算法，就是好算法。计算资源主要分为两种，一种是算法解决问题过程中需要的存储空间或内存，另一种是算法的执行时间。</p><p><strong>温馨提示：</strong> 存储空间受到问题自身数据规模的变化影响要区分哪些存储空间是问题本身描述所需，哪些是算法占用，这个不容易</p><p>算法复杂度表示法：</p><ul><li>大 $O(n)$ 表示法：表示了所有上限中最小的那个上限</li><li>大 $Ω$ 表示法：表示了所有下限中最大的那个下限</li><li>大 $\theta$ 表示法：如果上下限相同，那么就可以用大 $\theta$ 表示</li></ul><p>算法：解决问题的方法和步骤</p><ul><li>评价算法的好坏：渐近时间复杂度和渐近空间复杂度。</li><li>渐近时间复杂度的大O标记：<ul><li>$O(c)$- 常量时间复杂度 - 布隆过滤器 &#x2F; 哈希存储</li><li>$O(log_2n)$ - 对数时间复杂度 - 折半查找（二分查找）</li><li>$O(n)$ - 线性时间复杂度 - 顺序查找 &#x2F; 计数排序</li><li>$O(n*log_2n)$ - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）</li><li>$O(n^2)$ - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）</li><li>$O(n^3)$ - 立方时间复杂度 - Floyd算法 &#x2F; 矩阵乘法运算</li><li>$O(2^n)$ - 几何级数时间复杂度 - 汉诺塔</li><li>$O(n!)$ - 阶乘时间复杂度 - 旅行经销商问题 - NPC</li></ul></li></ul><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/005.522kgotj5gs0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/006.wrpp4q8w3s0.webp#pic_left"  width = "48%"></center></p><h2 id="2-Python数据类型的性能"><a href="#2-Python数据类型的性能" class="headerlink" title="2 Python数据类型的性能"></a>2 Python数据类型的性能</h2><p>list 类型各种操作（interface）的实现方法有很多，如何选择具体哪种实现方法？总的方案就是，让最常用的操作性能最好，牺牲不太常用的操作。准则：80% 的功能其使用率只有20%</p><p>List基本操作的大O数量级</p><table><thead><tr><th>Operation</th><th>Big-O Efficiency</th></tr></thead><tbody><tr><td>index[]</td><td>O(1)</td></tr><tr><td>index assignment</td><td>O(1)</td></tr><tr><td>append</td><td>O(1)</td></tr><tr><td>pop()</td><td>O(1)</td></tr><tr><td>pop(i)</td><td>O(n)</td></tr><tr><td>insert(i, item)</td><td>O(n)</td></tr><tr><td>del operator</td><td>O(n)</td></tr><tr><td>iteration</td><td>O(n)</td></tr><tr><td>contains(in)</td><td>O(n)</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td></tr><tr><td>del slice</td><td>O(n)</td></tr><tr><td>set slice</td><td>O(n+k)</td></tr><tr><td>reverse</td><td>O(n)</td></tr><tr><td>concatenate</td><td>O(k)</td></tr><tr><td>sort</td><td>O(nlogn)</td></tr><tr><td>multiply</td><td>O(nk)</td></tr></tbody></table><p>字典与列表不同，根据关键码（key）找到数据项，而列表是根据位置（index）。最常用的取值get和赋值set，其性能为 $O(1)$；另一个重要操作<code>contains(in)</code>是判断字典中是否存在某个关键码（key），这个性能也是 $O(1)$</p><p>Dict基本操作的大O数量级</p><table><thead><tr><th>Operation</th><th>Big-O Efficiency</th></tr></thead><tbody><tr><td>copy</td><td>O(n)</td></tr><tr><td>get item</td><td>O(1)</td></tr><tr><td>set item</td><td>O(1)</td></tr><tr><td>delete item</td><td>O(1)</td></tr><tr><td>contains (in)</td><td>O(1)</td></tr><tr><td>iteration</td><td>O(n)</td></tr></tbody></table><p>更多，请参考Python官方的算法复杂度网站：<a href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a></p><p><strong>例子</strong></p><p><code>timeit</code> 模块对函数计时：创建一个Timer对象，指定需要反复运行的语句和只需要运行一次的“安装语句”；然后调用这个对象的 <code>timeit</code> 方法，其中可以指定反复运行多少次，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line">t = Timer(<span class="string">&quot;函数名()&quot;</span>,<span class="string">&quot;from __main__ import 函数名&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(“%f seconds\n” % t.timeit(number = <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环连接列表&quot;&quot;&quot;</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        l = l + [i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;append方式&quot;&quot;&quot;</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        l.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;列表推导式&quot;&quot;&quot;</span></span><br><span class="line">    l = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test4</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;range函数调用转成列表&quot;&quot;&quot;</span></span><br><span class="line">    l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Timer(<span class="string">&quot;test1()&quot;</span>, <span class="string">&quot;from __main__ import test1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;concat %f seconds\n&quot;</span> % t1.timeit(number=<span class="number">1000</span>))           <span class="comment"># concat 1.077540 seconds</span></span><br><span class="line"></span><br><span class="line">t2 = Timer(<span class="string">&quot;test2()&quot;</span>, <span class="string">&quot;from __main__ import test2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;append %f seconds\n&quot;</span> % t2.timeit(number=<span class="number">1000</span>))           <span class="comment"># append 0.049203 seconds</span></span><br><span class="line"></span><br><span class="line">t3 = Timer(<span class="string">&quot;test3()&quot;</span>, <span class="string">&quot;from __main__ import test3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;comprehension %f seconds\n&quot;</span> % t3.timeit(number=<span class="number">1000</span>))    <span class="comment"># comprehension 0.039851 seconds</span></span><br><span class="line"></span><br><span class="line">t4 = Timer(<span class="string">&quot;test4()&quot;</span>, <span class="string">&quot;from __main__ import test4&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list range %f seconds\n&quot;</span> % t4.timeit(number=<span class="number">1000</span>))       <span class="comment"># list range 0.016467 seconds</span></span><br></pre></td></tr></table></figure><p>结论：由于不同计算机，运算时间有差异，但可以发现：列表连接（concat）最慢，List range最快，速度相差近100倍，append也要比concat快得多</p><h2 id="3-线性结构"><a href="#3-线性结构" class="headerlink" title="3 线性结构"></a>3 线性结构</h2><p>线性结构是一种有序数据项的集合，其中每个数据项都有唯一的前驱和后继，除了第一个没有前驱，最后一个没有后继，新的数据项加入到数据集中时，只会加入到原有某个数据项之前或之后，具有这种性质的数据集，就称为线性结构。</p><p>不同线性结构的关键区别在于数据项增减的方式，有的结构只允许数据项从一端添加，而有的结构则允许数据项从两端移除。</p><p>接下来学习的主要是栈Stack，队列Queue，双端队列Deque和列表List</p><p>性结构：线性结构是-种有序数据项的集合，其中每个数据项都有唯一的前驱和后继（数据集）</p><h3 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h3><p>栈的特性：反转次序，后进先出（主要应用：网页、word编辑）</p><p>抽象数据类型“栈”定义为如下的操作：（默认左端为栈底，右端为栈顶）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack( )：创建一个空栈，不包含任何数据项</span><br><span class="line">push(item)：将item加入栈顶，无返回值，append()</span><br><span class="line">pop( )：将栈顶数据项移除，并返回，栈被修改pop()</span><br><span class="line">peek( ):“窥视” 栈顶数据项，返回栈顶的数据项但不移除，栈不被修改。</span><br><span class="line">isEmpty( )：返回栈是否为空栈</span><br><span class="line">size( )：返回栈中有多少个数据项</span><br></pre></td></tr></table></figure><p>栈的应用：简单括号匹配（最后打开的右括号必须与第一个左括号匹配），十进制转换为二进制。</p><p>中缀表达式（优先级），前后缀表达式转换，所以在很多情况下，表达式的计算机表示都避免用复杂的中缀形式；在前缀和后缀表达式中，操作符的次序完全决定了运算的次序，不再有混淆<br>所以说，无论表达式多复杂，需要转换成前缀或者后缀，只需要两个步骤：将中缀表达式转换为全括号形式；将所有的操作符移动到子表达式所在的左括号(前缀)或者右括号(后缀)处，替代之，再删除所有的括号</p><h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><p>队列是一种有次序的数据集合，其特征是新数据项的添加总发生在一端(通常为“尾rear”端)，而现存数据项的移除总发生在另一端(通常称为首front”端)，原则：先进先出，队列仅有一个入口和一个出口。（主要应用：打印队列，进程调度，键盘缓冲，）主要适用于实际模拟仿真<br>抽象数据类型Queue由如下操作定义：（默认左端为队尾，右端为队首）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue( )：创建一个空队列对象，返回值为Queue对象</span><br><span class="line">enqueue(item)：将数据项item添加到队尾，无返回值insert(<span class="number">0</span>,item)  复杂度O(n)</span><br><span class="line">dequeue( )：从队首移除数据项，返回值为队首数据项，队列被修改复杂度O(<span class="number">1</span>)</span><br><span class="line">isEmpty( )：测试是否空队列，返回布尔值</span><br><span class="line">size( )：返回队列中数据项的个数</span><br></pre></td></tr></table></figure><h3 id="3-3-双端队列"><a href="#3-3-双端队列" class="headerlink" title="3.3 双端队列"></a>3.3 双端队列</h3><p>双端队列Deque：一种有次序的数据集，跟队列相似，其两端可以称作“首“”“尾”端，但deque中数据项既可以从队首加入，也可以从队尾加入；数据项也可以从两端移除。某种意义上说，双端队列集成了栈和队列的能力。（应用：回文词判定）</p><p>deque定义的操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque()：创建一个空双端队列</span><br><span class="line">addFront(item)：将item加入队首</span><br><span class="line">addRear(item)：将item加入队尾</span><br><span class="line">removeFront( )：从队首移除数据项，返回值为移除的数据项</span><br><span class="line">removeRear( )：从队首移除数据项，返回值为移除的数据项</span><br><span class="line">isEmpty( )：返回deque是否为空</span><br><span class="line">size( )：返回deque中包含数据项的个数</span><br></pre></td></tr></table></figure><h3 id="3-4-列表"><a href="#3-4-列表" class="headerlink" title="3.4 列表"></a>3.4 列表</h3><p>无序表List：一种数据项按照相对位置存放的数据集。操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>( )：创建一个空列表</span><br><span class="line">add(item)：添加一个数据项到列表中，假设item原先不存于列表中</span><br><span class="line">remove(item)：从列表中移除item，列表被修改，item原先应存在于列表中</span><br><span class="line">search(item)：在列表中查找item，返回布尔类型值</span><br><span class="line">isEmpty( )：返回列表是否为空</span><br><span class="line">size( )：返回列表包含了多少数据项</span><br><span class="line">append(item)：添加一个数据项到列表末尾，假设item原先不存在于列表中</span><br><span class="line">index(item)：返回数据项在表中的位置</span><br><span class="line">insert(pos,item)：将数据项插入到位置pos，假设item原先不存在列表中，同时原列表具有足够多个数据项，能让item占据位置pos</span><br><span class="line">pop( )：从列表末尾移除数据项，假设原列表至少有一个数据项</span><br><span class="line">pop(pos)：移除位置为pos的数据项，假设原列表存在位置pos</span><br></pre></td></tr></table></figure><p>列表List（数据项的增减方式不同）<br>采用链表实现无序表，数据项存放位置并没有规则，但如果在数据项之间建立链接指向，就可以保持其前后相对位置。链表实现的最基本元素是节点Node（包含数据项本身，以及指向下一个节点的引用信息）。<br>有序表OrderedList：有序表是一种数据项依照其某可比性质(如整数大小、字母表先后)来决定在列表<br>中的位置。操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OrderedList( )：创建一个空列表</span><br><span class="line">add(item)：添加一个数据项到列表中，假设item原先不存于列表中</span><br><span class="line">remove(item)：从列表中移除item，列表被修改，item原先应存在于列表中</span><br><span class="line">search(item)：在列表中查找item，返回布尔类型值</span><br><span class="line">isEmpty( )：返回列表是否为空</span><br><span class="line">size( )：返回列表包含了多少数据项</span><br><span class="line">index(item)：返回数据项在表中的位置</span><br><span class="line">pop( )：从列表末尾移除数据项，假设原列表至少有一个数据项</span><br><span class="line">pop(pos)：移除位置为pos的数据项，假设原列表存在位置pos</span><br></pre></td></tr></table></figure><h2 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4 案例分析"></a>4 案例分析</h2><p>案例一：“变位词”判断问题<br>问题描述：所谓“变位词”是指两个词之间存在组成字母的重新排列关系，如heart和earth，python和typhon，这里为了降低难度：假设参与判断的两个词仅由小写字母构成，而且长度相等。</p><p>解题目标：写一个bool函数，以两个词作为参数，返回这两个词是否变位词</p><p><strong>1. 检查标记</strong><br>（1）每个位置进行比对，用字符串1的字符遍历字符串2，检查标记一个字符要用特定值None 来代替，作为标记。然而，由于字符串不可变，首先要把第二个字符串转化成一个列表。第一个字符串中的每一个字符都可以在列表的字符中去检查，如果找到，就用None 代替以示标记。算法复杂度：$O(n^2)$</p><p>参考代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagram_solution</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    a_list = <span class="built_in">list</span>(s2)</span><br><span class="line">    still_ok = <span class="literal">True</span></span><br><span class="line">    pos1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> pos1 &lt; <span class="built_in">len</span>(s1) <span class="keyword">and</span> still_ok:</span><br><span class="line">        pos2 = <span class="number">0</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos2 &lt; <span class="built_in">len</span>(s2) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> s1[pos1] == a_list[pos2]:</span><br><span class="line">                a_list[pos2] = <span class="literal">None</span></span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            pos1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            still_ok = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> still_ok</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;cadb&#x27;</span>))           <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abababa&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>))        <span class="comment"># False    </span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abgsgg&#x27;</span>, <span class="string">&#x27;ababjjsj&#x27;</span>))     <span class="comment"># False    </span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><strong>2. 排序比较法</strong></p><p>尽管s1和s2并不相同，但若为变位词它们一定包含完全一样的字符，利用这一特点，我们可以采用另一种方法。我们首先从a到z给每一个字符串按字母顺序进行排序，如果它们是变位词，那么我们将得到两个完全一样的字符串。此外，我们可以先将字符串转化为列表，再利用Python 中内建的<code>sort</code>方法对列表进行排序。下面代码展示了这种方法。由于用到排序算法，所以算法复杂度为$O(nlogn)$。<br>参考代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagram_solution</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    a_list1 = <span class="built_in">list</span>(s1)</span><br><span class="line">    a_list2 = <span class="built_in">list</span>(s2)</span><br><span class="line">    a_list1.sort()</span><br><span class="line">    a_list2.sort()</span><br><span class="line">    <span class="keyword">return</span> (a_list1 == a_list2)   <span class="comment"># 排序后比较</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abcde&#x27;</span>, <span class="string">&#x27;edcba&#x27;</span>))       <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;edcba&#x27;</span>))        <span class="comment"># False</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abababab&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>))     <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><strong>3. 暴力匹配法</strong><br>解决这个问题的典型暴力方法是尝试所有的可能。为了解决变位词检测问题，我们可以简单地构造一个由s1中所有字符组成的所有可能的字符串的列表，并检查s2是否在列表中。然而这个方法有一个困难之处。当我们构造由s1中字符组成的所有可能字符串时，第一个字符有n个可能，第二个字符有n-1种可能，第三个则是n-2种，以此类推。所有可能字符串的总数是$n*(n-1)<em>(n-2)</em>…<em>3</em>2*1$。也就是n!。尽管这些字符串中的一些可能是重复的，但程序不能提前预见到，所以还是会产生$n!$个字符串。看前言里的算法复杂度，就知道$O(n!)$增长比$O(2^n)$还要快。</p><ol start="4"><li>计数比较法</li></ol><p>解决变位词问题的最后一个方法利用了任何变位词都有相同数量的a，相同数量的b，相同数量的c等等。为判断两个字符串是否为变位词，我们首先计算每一个字符在字符串中出现的次数。由于共有26个可能的字符，我们可以利用有26 个计数器的列表，每个计数器对应一个字符。每当我们看到一个字符，就在相对应的计数器上加一。最终，如果这两个计数器列表相同，则这两个字符串是变位词。下面展示了这种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">s</span>):</span><br><span class="line">    count_list = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        pos = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        count_list[pos] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anagram_solution</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> count(s1) == count(s2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pleap&#x27;</span>))                   <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abd&#x27;</span>, <span class="string">&#x27;ggsabad&#x27;</span>))                   <span class="comment"># False</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abab&#x27;</span>, <span class="string">&#x27;bbaa&#x27;</span>))                     <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;gsgddjkdsdgds&#x27;</span>, <span class="string">&#x27;dsdgdsgsgddjk&#x27;</span>))   <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>这个方法有一些循环操作。然而不同于第一个方法，所有循环都不是嵌套的。前两个计数字符数的循环都是n重。而因为字符串中总共有26种可能的字符，第三个比较两个计数列表的循环总是执行26步。把它们全部加起来就得到$T(n)&#x3D;2n+26$，也就是$O(n)$。这样，我们就找到了一个解决这个问题的线性复杂度的算法。</p><p><strong>小结</strong><br>关于空间需求，尽管最后一个方法可以以线性的时间复杂度来运行，但是这是以使用了额外的空间来存储两个计数器列表为代价的。换句话说，这个算法牺牲了空间来换取时间。这是一个常见的现象。很多情况下你需要在时间和空间的权衡中做出选择。在这个例子中，额外的空间消耗并不足道。但是如果可能的字母多达几百万种，这将是一个问题。作为一个计算机科学家，当要做出算法选择时，需要你根据具体问题来决定利用计算资源的最好方式。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 复杂度分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你要选择一个怎样的伴侣，去渡过自己的一生？</title>
      <link href="/article/85f919bc.html"/>
      <url>/article/85f919bc.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要转自———小吏深度 || 你要选择一个怎样的伴侣，去渡过自己的一生？理论+实践，挺有启发性的，整理到博客自己来阅读吧。</p><span id="more"></span><p>今天主要谈的问题是，我们要选择一个什么样的伴侣去步入婚姻殿堂。</p><p>这个问题比较大，我们一步步来推演。</p><h2 id="壹：为什么学生时代颜值即正义？"><a href="#壹：为什么学生时代颜值即正义？" class="headerlink" title="壹：为什么学生时代颜值即正义？"></a>壹：为什么学生时代颜值即正义？</h2><p>学生时代的时候，无论男孩还是女孩，都是对那些颜高的校草校花超级迷恋，对于物质和精神层面并不怎么在意。</p><p>为啥会这样呢？</p><p>1、因为<strong>学生时代是个有限博弈的规则模式</strong>，在这个赛道上，评判价值的关键点和展示点太少，而且所有的男孩女孩此时储备还都不够，无法将努力和储备转化为生产力。</p><p>2、因为孩子们此时都还啥都没见过，见识太低。学识和见识水平还相差不大，经济实力更是没太大机会发挥，此时只能比较那些看得见的东西。</p><p>所以颜值即正义，男孩拿把吉他嚎两嗓子就容易给女孩弹懵了。</p><p>所谓最单纯的美好也在于此。</p><p>很多男女生们此时可以当舔狗还很骄傲，风中流泪还自我感觉很美好。</p><p>说到底，是因为校园求爱的失败不像步入社会后输的那么鲜血淋漓，甚至连输的资格都没有。</p><p>因为参与评比的综合维度太低。</p><p>但这并不意味着很多别的层面就不起作用了。</p><p>我们大学时还是经常能看到开奔驰的孩子身边总是最漂亮的妞，或者男神旁边挎着一个一般的姑娘，但全身上下的行头都是普通学生望尘莫及的。</p><p>但这个阶段，总体来讲，颜值即正义，性魅力最抢手。</p><p>等到大学毕业进入社会后，孩子们突然发现换了天地。</p><p>太多之前没见过的维度突然被加入到了生活中。</p><p>颜值和性魅力已经不再那么稳固的高居处对象的榜首了。</p><p>你是男神，你月薪一万，家里有房，有车，那基本上可以继续吊打月薪三万，家里三套房，三辆车的普通男孩。</p><p>毕竟如果其他维度都能说得过去的话，谁都仍然希望身边睡得是个看着顺眼的。</p><p>但是，颜值的正义已经不能包打四方了。</p><p>比如当你除了你的男神外，还有一个家里月收租一百万，住豪宅开豪车的丑男孩想要明媒正娶的抬你回家时，比较可以肯定的是，你男神此时的性吸引力就开始不值一提了。</p><p>同样还是那个男神，你突然就会觉得他好幼稚，好绣花枕头，那个百万收租的男孩放个屁都觉得有一股别样的韵味。</p><p>为什么会这样？</p><p>这是基因里自带的思考方式。建议读读<a href="https://book.douban.com/subject/26683297/">《进化心理学》</a>和<a href="https://book.douban.com/subject/35153840/">《欲望的演化：人类的择偶策略》</a></p><p>人的性魅力，无论她多么的美若天仙，无论他多么的俊美雄壮，通常在朝夕相处后最多最多在三年的时间里你多巴胺和羟色胺的分泌就开始大幅度减量，你就会失去对他的感觉和性吸引力。</p><p>这是天性。</p><p>这也就意味着，当你思考婚姻问题时，前面二十多年的感觉和经验通常不管用了。</p><p>结果很多男孩女孩在切换角色的过程中出了大问题。</p><h2 id="贰：婚姻对象选择时要考虑的三个维度"><a href="#贰：婚姻对象选择时要考虑的三个维度" class="headerlink" title="贰：婚姻对象选择时要考虑的三个维度"></a>贰：婚姻对象选择时要考虑的三个维度</h2><p>每个男生女生，在即将进入婚姻的时候都会琢磨好多事情。</p><p>通常越琢磨越乱，越挑越花眼，越等发现等的人越不来。</p><p>问一个问题给没结婚的自己，婚姻为了啥？已经结了婚的同志们也可以思考下，这些年过明白了吗？</p><p>婚姻这个问题之所以被人慨叹“怎么选都是错”，其实是因为你没结婚的时候永远不知道这段旅程考验你的到底都是些什么。</p><p>绝大多数家长又通常不会对自己的婚姻进行一个详尽的总结，甚至会在自己的伤痛中总结出一些错误的观点比如“看住男人的钱”和“单亲家庭的孩子不要选择”等等并不真正准确的指标去影响孩子的判断，要么就是看不上孩子挑的对象，但又不能给出孩子一个合理信服的原因。</p><p>总结一下，就是我们身边的绝大多数人没办法准确的总结出来婚姻的本质和幸福与否的标准。</p><p>这道题没有标准答案，也没有分数线，还没有辅导老师。</p><p>但却成为了我们几乎刚步入社会后就被家长们逼着去解决的问题。</p><p>婚后幸福的，通常要么是命好中了概率的彩票，要么就是有超级智慧的父母在保驾护航。</p><p>咱们今天从源头开始说起，“婚姻”到底是为了什么？</p><p>这要从法学的概念上来引申，因为我们之所以选择结婚，是因为这种形式合理合法。</p><p><strong>婚姻在法学意义上有三层含义：</strong></p><ol><li>以男女两性结合为基础；</li><li>以共同生活为目的；</li><li>具有夫妻身份的公示性。</li></ol><p>比较懵圈是吧，没事咱们来解释一下婚姻是为了啥：</p><ol><li>为了解决繁殖问题。</li><li>为了让男女双方在物质上1+1》2；</li><li>为了让男女双方在精神上1+1》2；</li></ol><p>如果你只考虑性生活而不考虑孩子问题完全就可以不结婚；</p><p>如果你没有两人贷款买房子等现实压力，或者夫妻去深圳上海积分的考虑，或者豪门强强联合做大做强的资产联盟考虑，本质上也可以不结婚；</p><p>如果你觉得自己的精神领域已经足够高端，完全可以面对这叵测的世界不被影响自己内心深处永远春暖花开，其实你也是可以不用考虑结婚的。</p><p>现在之所以剩女的数量越来越大，质量还都相当高，本质上就是人家很多优质女孩能够无视那三个问题。</p><p>既然我碰不到能够让我上面三点问题更好的优质男孩，那我也没必要去委屈自己嫁给一个啥都搞不定的熊孩子。</p><p>在我国，男孩对比女孩成熟度的巨大差距导致了优质有责任的男孩刚一上货架就被适龄女孩们迅速瓜分，剩下的好女孩们看不上那些注定问题多多的男孩子，但是年龄又对女孩并不友好。</p><p>所有的那些兴趣、性趣、感觉、美好等等在恋爱升级到婚姻的过程中本质上都应该成为上述三点的补充。</p><p>如果你决定和这个人进行婚姻的法律形式捆绑，你一定还是要考虑到上面那三点的：</p><ol><li>你觉得你和他&#x2F;她在一起后物质基础上会1+1》2，或者说你自己就可以覆盖到两个人的物质生活而且你愿意给这个人花一辈子钱；</li><li>你觉得你和这个人在一起后，你的精神殿堂会变得更加高端，更加辽阔，或者你的那些脆弱和痛苦在一个人承受不了的时候，他&#x2F;她能够帮你撑过那些苦难的岁月；</li><li>你对他&#x2F;她不光有性欲，还有繁殖欲，你想和他&#x2F;她养育彼此的血脉。</li></ol><p>并不是说，我们一定要找到上面三点都满足的才能考虑解决。</p><p>因为我们通常不会有那么好命的。</p><p>天之道损有余而补不足，万物皆有残缺的。</p><p>众生皆苦，当你遇到了上述三点都达标而且彼此都极度心动的异性时，极大概率那只是最后为了让你知道痛苦和放下的感觉。</p><p>通常上面三个维度都没有短板的时候，就可以考虑为结婚对象了。</p><p>如果有一个维度，是长板，那就相当优质了。</p><p>或者说有的维度有明显的短板，但你有信心能够消除对方这块短板时，也可以去进一步往下思考。</p><p>总之，面对婚姻对象，我们要接受的第一个态度是：<font color=#9900CC><strong>永远不要认为会有完美！只是各个维度的一种权衡。</strong></font></p><p><font color=#9900CC><strong>最好的婚姻，是能权衡着走一辈子的一个契约形式，你的伴侣一定会有短板，要看你是否愿意因为他&#x2F;她的长板而迁就他&#x2F;她的短板。</strong></font></p><p><font color=#9900CC><strong>最好的婚姻，是永远保持并拓宽“长板”的吸引力和竞争力，与此同时不断补上自己的“短板”。</strong></font></p><p>再重申下这个概念，最好的婚姻，是永远保持住“长板”的新引力和竞争力，与此同时不断补上自己的“短板”。</p><p>我亲爱的弟弟妹妹们，这句话我建议抄下来放在一个醒目的地方时时刻刻提醒下自己。</p><p>这应该是我们做人一辈子的准则，与此同时也应该是你挑另一半时的重要依据。</p><p>你们都会变得越来越好，你们都会在这漫长一生中获得自己应有的价值。</p><h2 id="叁：婚后生活中，最关键的三个指标"><a href="#叁：婚后生活中，最关键的三个指标" class="headerlink" title="叁：婚后生活中，最关键的三个指标"></a>叁：婚后生活中，最关键的三个指标</h2><p>前面我们说了婚姻在法律意义上要解决繁殖、物质、精神三个问题，在具体内化到婚后生活后，分别代表哪三个环节呢？</p><p><strong>1. 性能力</strong></p><p>前面我们说了颜值的效果只能维持两年，但婚姻是一辈子的事，而且性欲望也是一辈子的事情。</p><p>人是有性需求的，你家里媳妇或者老爷们要是天天憋得眼珠子通红你那个婚姻指定好不了，想白头到老那就是个梦。</p><p>在此我强烈建议男孩子们，千万千万别看A片。</p><p>看A片会把你的肾气无形中耗干，将来你的夫妻生活一定会抬不起头来。</p><p>所谓“早泄”的本质，是肾气不足。</p><p>你肾气不足就固不住精，所以在阴阳相交的时候你的阳气率先就跑了。</p><p>所谓“阳痿”的本质，是肾气不足以及心血管系统不够强大支撑不了这么强大耗能的运动，是身体对肾和心脏以及血管的一个自发保护。</p><p>我在这不是建议女孩子们挨个睡一遍哈，判断一个男孩的身体状况其实比较容易。</p><p>眼睛冒不冒光，脸色是发亮还是发黑，体育运动怎么样，坚持一件事情是否有韧性，是否能深度的完成一项大工作。</p><p>性能力差的人肾气和元气都不行，眼睛肯定是浑浊的，脸色尤其是眼下一定是发黑的，特别容易累，走一会儿脑子就不好受，干啥事都是没有长性的，也肯定干不成什么深度的大项目工程。</p><p>你不看A片，生活有规律，注意体育锻炼，你的性能力就不用担心抬不起头来，你在事业上深耕也根本不用担心体力和脑力不够。</p><p>有的朋友说，会有撒切尔夫人那样每天睡四小时的天生精力狂人，最新的基因研究显示还是人家的基因上有优势，菲尔普斯的乳酸消化速度是普通人的五倍，所以人家可以走马灯似的赶场游泳然后北京奥运会拿八块金牌。</p><p>相信我，绝大多数的领域根本用不着拼天赋。</p><p>你没必要成为那0.01%！</p><p>你爬到前10%就相当牛了，而前10%要求的那些标准远远用不着什么天赋异禀，做个规律生活的人就完全够用达标了。</p><p><font color=#9900CC><strong>小总结：为了事业和婚姻，拒绝色情，爱惜身体。</strong></font></p><p><strong>2. 物质条件</strong></p><p>前面我们说过，婚姻要两个人在物质上期望做到1+1》2。</p><p>这并不是一种简单的堆叠，婚后生活中会演变为一个相当复杂的问题，因为人的欲望是无尽的。</p><p>关于择偶的物质问题，这并不简简单单是选择富裕家庭的普通孩子还是选择普通家庭的奋斗孩子的问题，而是你本人是否是个有成功欲的人。</p><p>你要是觉得每天开开心心就挺好，你没有太大的成功欲望，那你最优质的婚恋对象，一定是个家境还算殷实，同样也没啥太大志向和想法的伴侣。</p><p>对于你来讲，物质的要求可以提炼为“稳定”。</p><p>乘风破浪的富商冒险家其实并不适合你，一个家里殷实到点下班回家的公务员才是你最好的选择。</p><p>有的朋友会问：我也搞不清自己的内心，我自己没啥奋斗欲望，但我却希望找个特牛X特有钱的成功者来带我装X带我飞。</p><p>上面这种情况是“穷人思维”，说明你的心智还不成熟，你本人还不适合谈婚论嫁，你的婚姻大概率怎么选都是错。</p><p>要么考虑明白适合自己不奋斗的消费观和价值观该是啥样子，要么去先匹配好适合自己欲望的奋斗水平。</p><p>你如果是个奋斗狂魔，是个梦想成功的，或者是个成功欲望超强的，那也请找个和你同类型的伴侣，而不是天天追剧打游戏无忧无虑的另一半。</p><p>这个“同类型”，是指在各自领域上有追求和梦想并为之不断努力的人。</p><p>奋斗与创业是一个世上最不可测的事情。</p><p>它大概率会让人输的体无完肤，输的让身边所有人把风凉话说尽，让你爱的人本该无忧无虑的生活被破坏；</p><p>它同样概率会让这个人鲤鱼化龙，脱胎换骨，你成功后，是大概率无法和那个一直没啥变化的他&#x2F;她继续走下去的。</p><p>并不是说两口子都是奋斗型的将来过日子天天跟俩疯子似的，而是说两个人在各自领域上不断努力的过程中，很多产生的共识都是殊途同归的，两个人会减少很多不必要的矛盾。</p><p>通常只有这样，将来你这个家庭才能抵御的住各种各样远远超于普通家庭的风浪和质疑。</p><p>一个热衷于稳定，一个梦想于成功，这样的婚姻注定在磨合上有着巨大的痛苦。</p><p>“稳定”这东西意味着不折腾；“成功”这东西意味着玩命折腾。</p><p>在优先稳定的生活和爱情中，通常对夫妻陪伴，孩子陪伴，父母陪伴，旅游、逛街、看电视等等这种天伦之乐极度重视。</p><p>在追逐成功的生活和爱情中，通常天天忙得跟上了弦的发条一样，时间极度不够用，在夫妻和子女陪伴等家庭生活中会相当缺位。</p><p>这两种人要是做了两口子，一个认为你天天陪不了我；一个认为我都快累死了为的是谁啊你也不理解我，这天然就是中巨大的矛盾错位。</p><p>本质上其实谁也没错。</p><p>就是最开始选对象的时候没琢磨明白。</p><p><font color=#9900CC><strong>小总结：看准自己想要啥样的生活，然后选择同类型的伴侣。</strong></font></p><p><strong>3. 精神生活</strong></p><p>我们常常会听说过一句话：两口子要互补才会和谐。</p><p>这句话的原意，是一个人粗心大意一个人心细如发；一个人左脑强一个人右脑强，这种能力上的互补对于两口子相当重要。</p><p>因为婚姻本质上有很多物质的问题，两口子本质上也是合伙人，所以在能力天赋上两个人如果能互补那相当伟大。</p><p>但是吧，这句话却通常被用来了在脾气上产生巨大不和谐时劝两口子凑合过时常说的一句话。</p><p>一个暴脾气，一个好脾气，然后一个大言不惭的旁观者说两口子在性格上要互补。</p><p>性格这东西是最不需要什么互补的！相反的脾气和性格绝对不会带来什么互补，带来的永远是冰火两重天！</p><p>所谓的一个暴脾气和一个好脾气在一起过一辈子也过下来了的本质不过是好脾气在拿自己的情商和意志去“兼容”那个暴脾气。</p><p>要么就是暴脾气的物质能力能够补偿对好脾气施暴后的心灵创伤。</p><p>那是不是意味着两个人都没有脾气，就适合过一辈子呢？</p><p>也并非如此。</p><p>性格上，最大的问题不在于脾气的大小，而是在于这个人能不能沟通以及愿意为了你而磨合改正。</p><p>两个人都没啥脾气，但生活中仍然肯定会有各种各样的小矛盾与小分歧，俩人都憋着，小矛盾就终有一天会憋成大矛盾，也许哪天急眼了两个人就过不下去了。</p><p>同样，一个人脾气大也不可怕，男孩功名看气概，有的时候就是会有脾气的。</p><p>你考量的关键点，是准确的判断出来他&#x2F;她在发完脾气之后能不能进行沟通，能不能倾听你的想法并愿意今后磨合改正让自己的脾气越来越小。</p><p>所谓的牛人从来不在家里发脾气，本质上是因为牛人的沟通能力都很强，而且牛人一直在改变自己去让家庭矛盾越来越少。</p><p>这个人在恋爱中如果在多次明确沟通后仍然控制不了自己的脾气，通常只有三种可能：</p><ol><li>这个人极度自私；</li><li>这个人自视甚高；</li><li>这个人并不爱你。</li></ol><p>无论是哪种可能，你都没必要去选择跟这样的人迈向婚姻的那一步。</p><p>谈恋爱时都无所谓，大不了就分手嘛！</p><p>但婚姻的成本极高！不是你那么轻松就能掰扯开的。</p><p>一旦你打算往婚姻方向上走，一定要观察你们在矛盾冲突后，是否能够坐下来分析明白彼此这次矛盾的引爆点在哪。</p><p>有一句超级扯淡的话叫做：家里不是能讲理的地方。</p><p>这句话拆散了一个又一个本来可以白头到老的家庭。</p><p>家里不能讲理的时候只有一种可能：就是这矛盾已经大到复杂到说不清了的程度！</p><p>金钱、时间、亲属、误会、失望、陈年旧账······已经多维度的掺和在一块了。</p><p>最终只能拿这么一句话打马虎眼。</p><p>最后要么就是两口子互相觉得自己不合适，但为了孩子或家产老人啥的只能糊弄下去，要么就是这矛盾大到没法过了然后一拍两散。</p><p>大风起于青萍之末，相信我，生活是很具体的，沟通是为你婚姻保驾护航的最关键武器。</p><p>比如谈恋爱的时候，你觉得你工作时需要专注四大皆空，你对象觉得你这样就是不爱她不拿她当回事。</p><p>这就得去沟通。</p><p>你要说明白你工作专注是为了产生核心竞争力，核心优势大了才能给她更美好的生活才不是拿嘴去爱她，你可以在陪她的时候专心致志陪她等等。</p><p>她如果觉得不行无法达成共识，或者说当时能同意，但随后一而再再而三对已经达成的共识不尊重，你就要思考这个伴侣是否适合走到谈婚论嫁的这一步了。</p><p>因为这属于你们将来安身立命的问题，未来会有太多次的机会出现矛盾，我想想都替你愁的慌。</p><p>或者你就去迁就，去一切以他&#x2F;她为中心，将来所有的生命中出现和他&#x2F;她撞车的事时一切以人家为重的改变。</p><p>你觉得这样义无反顾没怨言的话，那也行。</p><p>但又一个问题来了，没有了自我的人，通常不会得到等价的尊重，这条道路注定艰辛崎岖，你要想清楚。</p><p>肆：挑对象实际上是在找“双胞胎”的自己</p><p>说了这一大堆，其实是在说咋去挑对象的事吗？</p><p>其实是在讲咋样让自己变成一个优质的伴侣，随后你去谨慎的挑选和自己同样价值的人。</p><p>最后总结下：</p><p>1、自己的身体和伴侣的身体都很重要，注意身材，保持锻炼，远离色情。</p><p>你需要一个精力旺盛的身体去迎接生活的洗礼和事业的挑战，你需要一个过硬的身体去履行自己的性义务。</p><p>2、婚后的物质基础很重要，你要对自己的性格与财富观念有一个预期。</p><ul><li>你是事业型的？还是生活型的？</li><li>最好找和自己相似类型的。</li><li>婚姻和谐的本质是减少摩擦，而不是熊熊烈火燃烧你我。</li></ul><p>3、在不嫖不赌不暴力倾向等硬伤之外，是否会进行沟通以及是否会愿意为你磨合及改正，这相当重要。</p><p>阅读这篇文章的弟弟妹妹都是人中龙凤，未来所要面对的思考和问题，注定会比太多的同龄人要多的多。</p><p>婚姻是一个人一生中堪称最大的课题，我希望能够帮你们多一个维度的思考，也希望我的弟弟妹妹们能够幸福美满的度过自己未来人生中的每一天。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 好文收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生伴侣 </tag>
            
            <tag> 亲密关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next 主题 -- 基本配置</title>
      <link href="/article/db7d7796.html"/>
      <url>/article/db7d7796.html</url>
      
        <content type="html"><![CDATA[<p>当前用得最多的是next主题，那为什么用得多呢？当然是符合大多数人的审美。我使用的是next(v7.8.0)，下载地址：<a href="https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next</a></p><span id="more"></span><h2 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1 基本设置"></a>1 基本设置</h2><h3 id="1-1-主题设置"><a href="#1-1-主题设置" class="headerlink" title="1.1 主题设置"></a>1.1 主题设置</h3><p>打开博客根目录 Blog 文件夹，右键 <code>Git Bash</code>，输入如下代码将next主题下载到目录 <code>Blog/themes</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>打开根目录下的 <code>_config.yml</code>(称为站点配置文件)，修改主题（注意冒号后都要有空格）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">CarpeDiem&#x27;s</span> <span class="string">Blog</span>         <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;虽不能至，心向往之&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。&#x27;</span>       <span class="comment"># 简介或格言</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&quot;Python, Linux, Java, 算法, 人工智能&quot;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Carpe</span> <span class="string">Diem</span>     <span class="comment"># 作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>           <span class="comment"># 主题语言 en/zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span>           <span class="comment"># 中国的时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-bamboo</span>          <span class="comment"># 主体修改为 next</span></span><br></pre></td></tr></table></figure><p>主题语言主要是看你的themes&#x2F;next&#x2F;language中的简体中文是 zh-CN 还是 zh-Hans：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/010.6bt308ce0240.webp#pic_center" width = 48%><p>next主题有四种，如下图依次为Muse、Mist、Pisces、Gemini（你可以每个设置一遍，确定一个喜欢的），这里选的是Gemini，打开目录 <code>Blog/themes/next/</code> 下的_config.yml（称为主题配置文件），只要将你选的主题前的#删除就行了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span>          <span class="comment"># 选择的主题</span></span><br></pre></td></tr></table></figure><p>温馨提示：注意区分 根目录 Blog 下的 _config.yml 和 <code>Blog/themes/next/</code> 下的_config.yml，搞混就找不到相应的配置</p><p>回到根目录打开 <code>Git Bash</code>，输入如下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><h3 id="1-2-设置菜单"><a href="#1-2-设置菜单" class="headerlink" title="1.2 设置菜单"></a>1.2 设置菜单</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，查找menu，将前面的#删除就行了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                      <span class="comment">#首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>      <span class="comment">#归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span>       <span class="comment">#分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span>                 <span class="comment">#标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span>               <span class="comment">#关于</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">/resources/</span> <span class="string">||</span> <span class="string">download</span>   <span class="comment">#资源</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar    #日历</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat      #腾讯公益404</span></span><br></pre></td></tr></table></figure><p>“||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href="https://fontawesome.com.cn/search-download">图标库 - Font Awesome 中文网</a> 这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。resources 是我自己添加的。</p><p>新添加的菜单需要翻译对应的中文，打开 <code>theme/next/languages/zh-CN.yml</code>，在 menu 下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br></pre></td></tr></table></figure><p>在根目录下打开 <code>Git Bash</code>，输入如下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;resources&quot;</span></span><br></pre></td></tr></table></figure><p>此时在根目录的sources文件夹下会生成categories、tags、about、resources四个文件，每个文件中有一个 <code>index.md</code> 文件，修改内容分别如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">资源</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;resources&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段 comments 并将值设置为false。</p><h3 id="1-3-设置建站时间"><a href="#1-3-设置建站时间" class="headerlink" title="1.3 设置建站时间"></a>1.3 设置建站时间</h3><p>打开主题配置文件即 <code>themes/next</code> 下的_config.yml，查找since：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2023-06</span>      <span class="comment"># 建站时间</span></span><br></pre></td></tr></table></figure><h3 id="1-4-设置头像"><a href="#1-4-设置头像" class="headerlink" title="1.4 设置头像"></a>1.4 设置头像</h3><p>打开主题配置文件即 <code>themes/next</code> 下的 <code>_config.yml</code>，查找avatar，url后是图片的链接地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span>   <span class="comment">#图片的位置，也可以是http://xxx.com/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>   <span class="comment">#头像展示在圈里</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>  <span class="comment">#头像随光标旋转</span></span><br></pre></td></tr></table></figure><h3 id="1-5-网站图标设置"><a href="#1-5-网站图标设置" class="headerlink" title="1.5 网站图标设置"></a>1.5 网站图标设置</h3><p>我是在这个网站找的图标，免费的图标素材网站：<a href="https://www.easyicon.cc/">Easyicon</a></p><p>下载16x16和32x32的图标后，打开主题配置文件，查找favicon，只要修改small和medium为你的图标路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h3 id="1-6-设置动态背景"><a href="#1-6-设置动态背景" class="headerlink" title="1.6 设置动态背景"></a>1.6 设置动态背景</h3><p><strong>1. canvas nest 风格</strong></p><p>在themes&#x2F;next目录下打开Git Bash，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-canvas-nest <span class="built_in">source</span>/lib/canvas-nest</span><br></pre></td></tr></table></figure><p>打开主题配置文件即 themes&#x2F;next 下的 _config.yml，找到 canvas-nest，将<code>enable：false</code> 改为true：（如果找不到 canvas-nest，可能是文件修改了，试试将下面的代码复制粘贴到 themes&#x2F;next 中）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;0,0,255&quot;</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># The number of lines</span></span><br></pre></td></tr></table></figure><p><strong>2. JavaScript 3D library风格</strong></p><p>在themes&#x2F;next目录下打开Git Bash，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-three <span class="built_in">source</span>/lib/three</span><br></pre></td></tr></table></figure><p>打开主题配置文件即themes&#x2F;next下的_config.yml，找到three，这里有三种风格，可以试一下看看喜欢哪种风格，直接将false改为true就行了，我已经选了canvas-nest，就没有选这种风格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="1-7-添加顶部加载条"><a href="#1-7-添加顶部加载条" class="headerlink" title="1.7 添加顶部加载条"></a>1.7 添加顶部加载条</h3><p>在themes&#x2F;next目录下打开Git Bash，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure><p>打开主题配置文件即themes&#x2F;next下的_config.yml，找到pace，将enable：false改为true，你还可以选择类型（theme）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure><h3 id="1-8-设置侧边栏显示效果"><a href="#1-8-设置侧边栏显示效果" class="headerlink" title="1.8 设置侧边栏显示效果"></a>1.8 设置侧边栏显示效果</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，找到Sidebar Settings，设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position. #设置侧边栏位置</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  - post    默认显示模式</span></span><br><span class="line">  <span class="comment">#  - always  一直显示</span></span><br><span class="line">  <span class="comment">#  - hide    初始隐藏</span></span><br><span class="line">  <span class="comment">#  - remove  移除侧边栏</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure><h3 id="1-9-侧边栏推荐阅读"><a href="#1-9-侧边栏推荐阅读" class="headerlink" title="1.9 侧边栏推荐阅读"></a>1.9 侧边栏推荐阅读</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，搜索links（里面写你想要的链接）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_settings:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">推荐网站</span>          <span class="comment"># 修改名称</span></span><br><span class="line">  <span class="comment"># Available values: block | inline</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">block</span></span><br><span class="line"></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="comment">#Title: http://yoursite.com</span></span><br><span class="line">  <span class="string">菜鸟教程:</span> <span class="string">https://www.runoob.com/</span></span><br><span class="line">  <span class="string">C语言中文网:</span> <span class="string">http://c.biancheng.net/sitemap/</span></span><br><span class="line">  <span class="string">CS自学指南:</span> <span class="string">https://csdiy.wiki/</span></span><br><span class="line">  <span class="attr">Road To Coding:</span> <span class="string">https://www.r2coding.com/#/</span></span><br><span class="line">  <span class="string">计算机专业学习路线:</span> <span class="string">https://hackway.org/docs/cs/intro</span></span><br><span class="line">  <span class="string">鱼C论坛:</span> <span class="string">https://fishc.com.cn</span></span><br></pre></td></tr></table></figure><h3 id="1-10-添加社交链接"><a href="#1-10-添加社交链接" class="headerlink" title="1.10 添加社交链接"></a>1.10 添加社交链接</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，搜索social：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/molimi</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:qxie8888@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/xq151750111</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-codiepie</span></span><br></pre></td></tr></table></figure><p>“||”前面的是链接，后面的是 FontAwesome 图标名称。</p><h3 id="1-11-设置博文内链接为蓝色"><a href="#1-11-设置博文内链接为蓝色" class="headerlink" title="1.11 设置博文内链接为蓝色"></a>1.11 设置博文内链接为蓝色</h3><p>打开themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;post&#x2F;post.styl文件，将下面的代码复制到文件最后：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.post-body</span> <span class="string">p</span> <span class="string">a&#123;</span></span><br><span class="line">     <span class="attr">color:</span> <span class="comment">#0593d3;</span></span><br><span class="line">     <span class="attr">border-bottom:</span> <span class="string">none;</span></span><br><span class="line">     <span class="string">&amp;:hover</span> &#123;</span><br><span class="line">       <span class="attr">color:</span> <span class="comment">#0477ab;</span></span><br><span class="line">       <span class="attr">text-decoration:</span> <span class="string">underline;</span></span><br><span class="line">     &#125;</span><br><span class="line">   <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-12-显示文章字数和阅读时长"><a href="#1-12-显示文章字数和阅读时长" class="headerlink" title="1.12 显示文章字数和阅读时长"></a>1.12 显示文章字数和阅读时长</h3><p>从根目录Blog打开Git Bash，执行下面的命令，安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后打开站点配置文件，在文件末尾加上下面的代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure><h3 id="1-13-文章末尾添加版权说明"><a href="#1-13-文章末尾添加版权说明" class="headerlink" title="1.13 文章末尾添加版权说明"></a>1.13 文章末尾添加版权说明</h3><p>查找主题配置文件themes&#x2F;next&#x2F;_config.yml中的creative_commons：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>  <span class="comment"># 将false改为true即可显示版权信息</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure><h3 id="1-14-添加评论"><a href="#1-14-添加评论" class="headerlink" title="1.14 添加评论"></a>1.14 添加评论</h3><p>针对 Hexo 静态博客的 nexT主题 继承了多种评论系统，此处介绍两种相对好用的评论系统： Valine、Gitment 和 Utterances 。</p><p><strong>1. Valine 评论系统</strong></p><p>Valine 评论系统，此款系统不需要登录，无后端，nexT 主题最新也已经支持安装。</p><p>因为 Valine 是基于 LeanCloud 系统的，所以先在 LeanCloud 中注册账号，LeanCloud官网：<a href="https://console.leancloud.cn/login">https://console.leancloud.cn/login</a>，注册登陆后，访问控制台，创建应用，选择开发版，确定创建，如下图</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/007.63c1igtf5a40.webp#pic_center" width = 48%><p>创建成功，生成了 AppID 和 AppKey，在控制台—应用凭证 查看，如下图</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/008.3bs8wz462a20.webp#pic_center" width = 48%><p>在主题的配置文件_config.yml中，修改关于 valine 的配置，如下图</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/009.3xocq7i43e20.webp#pic_center" width = 48%><p>上述设置仅作参考！<br>最后，重新部署即可。</p><p><strong>2. Gitment 评论系统</strong></p><p>Gitment 评论系统是基于 Github 开发的，是依靠 GitHub Issues 的评论系统，Next 主题最新也已经支持安装。</p><p>安装前提：更新 Next 主题（5.1.2 主题及以上）</p><p><strong>1. 注册 OAuth application</strong></p><ol><li>在 github 中进行注册，进入 <a href="https://github.com/settings/profile">https://github.com/settings/profile</a></li><li>点击左侧 Developer settings</li><li>点击左侧Oauth Apps</li><li>点击 Register a new application</li></ol><p>注册完成之后，得到：Client ID 和 Client Secret</p><p><strong>2. 新建存放博客评论仓库</strong></p><p>在 github 中建一个项目，专门用来存储你的博客评论</p><p><strong>3. 配置 nexT 主题文件</strong></p><p>编辑主题配置文件：<code>themes\ next主题 \ _config.yml</code>，找到有关 gitment 的设置，如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitment:</span>   </span><br><span class="line">  <span class="attr">enable:</span>  <span class="literal">true</span></span><br><span class="line">  <span class="attr">mint:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">lazy:</span> <span class="literal">false</span>  <span class="comment">#评论懒加载，如果true，则默认不展示评论，点击按钮查看评论</span></span><br><span class="line">  <span class="attr">cleanly:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">language:</span> </span><br><span class="line">  <span class="attr">github_user:</span> <span class="comment">#github名称</span></span><br><span class="line">  <span class="attr">github_repo:</span> <span class="string">BlogComments</span><span class="comment">#上一步新建存放评论的仓库名</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">b8bad0exxxx</span><span class="comment">#上面注册 OAuth Application 的 Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">bcee560xxxxxx</span><span class="comment">#上面注册 OAuth Application 申请的 Client Secret</span></span><br><span class="line">  <span class="attr">proxy_gateway:</span> </span><br><span class="line">  <span class="attr">redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint</span></span><br></pre></td></tr></table></figure><p><strong>4. 初始化</strong></p><p>在设置完成后，Hexo重新部署。每篇文章都要点击初始化评论按钮。</p><p><strong>5. 管理</strong></p><p>评论显示在新建存放评论的仓库中的 issue 中。</p><p><strong>6. 关闭</strong></p><p>可以单独关闭某个页面的评论，在页面的 Front-matter 中添加 comments 字段，设为 false。比如标签页不想要评论，则在标签页面中做如下设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxxxxxxx</span><br><span class="line">date: <span class="number">2023</span>-06-06 <span class="number">17</span>:05:<span class="number">24</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>3. Utterances 评论系统</strong></p><p>这里主要介绍基于 Github Issues 的轻量级博客评论系统 Utterances。主要介绍 Utterances 的配置与使用</p><p>Utterances是一个基于Github Issues的轻量级评论系统，可用于博客、Wiki等。它具有以下优点：</p><ul><li>开源</li><li>不追踪，无广告，始终免费</li><li>所有的数据都存储在Github Issues</li><li>样式基于Github的Primer设计语言</li><li>夜间模式</li><li>轻量级；原生TypeScript；在“常青树”浏览器上不使用网络字体，JavaScript框架或Polyfill。</li></ul><p>快速上手</p><ol><li>在 GitHub 上新建一个公开仓库（Repository），安装 <a href="https://github.com/apps/utterances">Utterances GitHub App</a> 至该仓库。</li><li>在你的网页需要插入 Utterances 评论的位置，粘贴以下代码（username，reponame 分别修改为你的 GitHub 用户名，仓库名）。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">repo</span>=<span class="string">&quot;username/reponame&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">issue-term</span>=<span class="string">&quot;pathname&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">theme</span>=<span class="string">&quot;github-light&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">async</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>刷新网页就可以看到Utterances评论框了。</li></ol><p>了解更多配置，请移步——<a href="https://blog.njilc.com/post/self-hosted-utterances-tutorial">自托管Utterances教程：基于Github Issues的轻量级博客评论系统</a></p><h3 id="1-15-修改永久链接的默认格式"><a href="#1-15-修改永久链接的默认格式" class="headerlink" title="1.15 修改永久链接的默认格式"></a>1.15 修改永久链接的默认格式</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。</p><p>在 Hexo 根目录下的 _config.yml 文件采用初始设置。这里因为用“年月日”会让文章链接的层次太深，所以我用”article”代替：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line">permalink: article/:title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>生成的文章链接就是 (标题为“我的个人博客”)：<code>https://[你的网站域名]/article/我的个人博客.html</code></p><p>链接中出现中文显然不太好，所以下面给出三种替代中的方法。</p><p><strong>1. 安装插件方法一（推荐）</strong></p><p>在 Hexo 根目录下使用 <code>git bash</code> 执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件，修改为如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment"># permalink: article/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">article/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>然后在 <code>git bash</code> 按顺序运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><p>再打开网站的文件就可以看到效果————<code>https://[你的网站域名]/article/60762.html</code>（其中60762就是随机生成的）</p><p><strong>2. 安装插件方法二</strong></p><p>中文链接转拼音，在 Hexo 根目录下使用 <code>git bash</code> 执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 _config.yml 文件中，修改以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:title.html</span></span><br><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span>    <span class="comment"># default: &#x27;-&#x27;</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>然后在 <code>git bash</code> 按顺序运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><p>再打开网站的文件就可以看到效果。<code>https://[你的网站域名]/article/wo-de-ge-ren-bo-ke.html</code>（标题为“我的个人博客”）</p><p>**3. 采用urlname<br>**<br>在写每篇md文章的时候，在 Front-matter 里加上urlname：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Next 主题介绍</span><br><span class="line">date: 2023-06-06 15:31:11</span><br><span class="line">urlname: 2023060601</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 _config.yml 文件中，修改以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:urlname.html</span>  <span class="comment"># urlname值文章里必须填写，格式2023060601</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>然后在 <code>git bash</code> 按顺序运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><p>再打开网站的文件就可以看到效果。<code>https://[你的网站域名]/article/2023060601.html</code></p><p><strong>小结</strong></p><p>第一种方法是我试过中最好的；第三次之，因为每次都要手动加上urlname；而第二种，当文章的中文标题名字过长时，效果并不好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/article/f3fb008f.html"/>
      <url>/article/f3fb008f.html</url>
      
        <content type="html"><![CDATA[<p>发博客，总会因为各种原因不过审，那就自己申请域名搭博客，这样既可以记录技术，又可以写自己的感悟。</p><span id="more"></span><p>搭建博客需要的前提条件：</p><ul><li>GitHub&#x2F;Gitee 账户</li><li>安装 Git</li></ul><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1 购买域名"></a>1 购买域名</h2><p>购买域名有几个网站，可以在<a href="https://www.godaddy.com/zh-sg/offers/domains/godaddycom?isc=gennbacn07&countryview=1&currencyType=CNY&utm_source=baidu&utm_medium=cpc&utm_term=Title&utm_campaign=zh-cn_corp_sem_x_b_x_bz_001&utm_content=Brandzone%20PC&gclid=CIXh9LjPmecCFdOavAoddDkHcw&gclsrc=ds">Godaddy</a>上，也可以在<a href="https://wanwang.aliyun.com/">万网</a>，<a href="https://cloud.tencent.com/?fromSource=gwzcw.2212127.2212127.2212127&utm_medium=cpd&utm_id=gwzcw.2212127.2212127.2212127">腾讯云</a>等网站购买，我是在万网上购买的，一个.com的域名第一年就69元。</p><p>首先用支付宝登录万网，点击查询自己想要注册的域名是否已经被注册</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/112.1ehd79l0zgf4.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/112.1ehd79l0zgf4.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="112" width=36%/><p>如果你需要的域名没有被注册，点击加入清单，再点击立即结算</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/113.3hm2ohhzcvk0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/113.3hm2ohhzcvk0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="113" width=48%/>先选择你要的年限，再点击个人，接着点击创建新的信息模板：<img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/114.6vy5ufotxb0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/114.6vy5ufotxb0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="114" width=48%/><p>填完下图信息，点击 保存 即可：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/115.4z85yyc8xrk0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/115.4z85yyc8xrk0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="115" width=36%/><p>接下来，先验证邮箱，再实名认证，然后打开万网给你发的邮件验证，实名认证需要上传身份证，此时模板还是未认证状态，等认证通过，勾选模板，再勾选我已阅读，点击立即购买即可完成。</p><h2 id="2-安装-node-js-和-Hexo"><a href="#2-安装-node-js-和-Hexo" class="headerlink" title="2 安装 node.js 和 Hexo"></a>2 安装 node.js 和 Hexo</h2><h3 id="2-1-安装-node-js"><a href="#2-1-安装-node-js" class="headerlink" title="2.1 安装 node.js"></a>2.1 安装 node.js</h3><p>下载地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/116.2m2s8oqd4zi0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/116.2m2s8oqd4zi0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="116" width=30%/><p>如上图，直接点击下载，完成后双击安装，安装直接默认 next 就好，很简单，需要改的也就是安装位置改一下，我是在D盘新建了一个文件夹 nodejs，安装在这个文件夹里。如果要看详细到每一步的话，可以看一下这个文章：<a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程</a>。</p><p>安装成功，文件夹结构如下，并在上面安装过程中已自动配置了环境变量和安装好了 npm 包（也可以手动配置），此时可以执行 <code>node -v</code> 和 <code>npm -v</code> 分别查看 node 和 npm 的版本号：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/134.5u91jsytfjk0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/134.5u91jsytfjk0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="134" width=48%/><p>因为在执行例如 <code>npm install webpack -g</code> 等命令全局安装的时候，默认会将模块安装在 <code>C:\Users\用户名\AppData\Roaming</code> 路径下的npm和npm_cache中，不方便管理且占用C盘空间，如下图所示：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/135.1pcyhnd2eeo0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/135.1pcyhnd2eeo0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="135" width=24%/><p>所以这里配置自定义的全局模块安装目录，在 node.js 安装目录下新建两个文件夹 node_global 和 node_cache，然后在cmd命令下执行如下两个命令：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/136.222iqanek05c.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/136.222iqanek05c.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="136" width=48%/><p>执行成功。然后在环境变量 -&gt; 系统变量中新建一个变量名为 “NODE_PATH”， 值为 <code>“D:\Program Files\nodejs\node_global\node_modules”</code>，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/142.3a74zjfl9w80.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/142.3a74zjfl9w80.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="142" width=36%/><p>最后编辑用户变量里的Path，将相应npm的路径改为：<code>D:\Program Files\nodejs\node_global</code>，如下：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/138.pzitxkoa17k.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/138.pzitxkoa17k.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="138" width=48%/><p>在 cmd 命令下执行 <code>npm install webpack -g</code>：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/139.5wybpub3wc00.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/139.5wybpub3wc00.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="139" width=36%/><p>温馨提示：注意在建立两个文件夹 node_global 与 node_cache 时，需要右键设置“属性”，将用户具有完全属性的权限，否则在 <code>npm install webpack</code> 时会报错。</p><p>然后 webpack 这个模块已经在我们设置默认的文件夹中了：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/140.3oapxqi22ig0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/140.3oapxqi22ig0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="140" width=36%/><h3 id="2-2-安装-Hexo"><a href="#2-2-安装-Hexo" class="headerlink" title="2.2 安装 Hexo"></a>2.2 安装 Hexo</h3><p>Hexo就是我们的个人博客网站的框架，在安装之前，我们要先在GitHub上创立一个仓库，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/141.15czm339hzi8.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/141.15czm339hzi8.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="141" width=36%/><p><strong>1. 下载 Hexo</strong></p><p>接下来就是安装Hexo，首先在D盘建立一个文件夹 Blog，点开 Blog 文件夹，y以管理员运行 CMD 终端（也可以鼠标右键打开 <code>Git Bash Here</code>），输入 npm 命令安装 Hexo，安装完成后，输入 <code>hexo init</code> 命令初始化博客，然后输入 <code>hexo g</code> 静态部署，这时网页已经部署完成，输入 <code>hexo s</code> 命令可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/004.4pekxs40zji0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/004.4pekxs40zji0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="004" width=40%/><p>浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以打开新部署的网页：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/003.vo16jvph5z4.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/003.vo16jvph5z4.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="003" width=30%/><p><strong>2. 将 Hexo 部署到 GitHub</strong></p><p>现在回到我们的 Blog 文件夹，用笔记本打开 <code>_config.yml</code> 文件，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/006.1dz8z5aa290g.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/006.1dz8z5aa290g.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="006" width=36%/><p>下滑到文件底部，填上如下内容：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/005.3k0fdvwucpw0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/005.3k0fdvwucpw0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="005" width=30%/><p>你的仓库地址就是下图这个：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/007.45l40fnl3u20.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/007.45l40fnl3u20.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="007" width=36%/><p>继续安装Git部署插件，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/008.12k2ai4luxw0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/008.12k2ai4luxw0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="008" width=36%/><p>然后分别输入以下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   <span class="comment"># 清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment"># 生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment"># 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/009.4824fabnrsi0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/010.12r1yrmi7aq8.webp#pic_left"  width = "48%"></center></p><p>完成以后，打开浏览器，输入 <a href="https://xxx.github.io/">https://xxx.github.io</a> 就可以打开你的网页了。</p><h3 id="2-3-解析域名"><a href="#2-3-解析域名" class="headerlink" title="2.3 解析域名"></a>2.3 解析域名</h3><p>第一步：登录万网，点击控制台，在你已购买的域名后点击解析添加一条解析记录：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/011.3ekdvo6ka6w0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/011.3ekdvo6ka6w0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="011" width=48%/><p>那个IPV4地址可以通过ping得到，具体方法是：打开cmd输入下面命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping molimi.github. -<span class="number">4</span>       <span class="comment"># ping + 你的GitHub的网址 </span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/012.6fttpyogc3o0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/012.6fttpyogc3o0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="012" width=36%/><p>第二步：打开 Blog 文件夹里的 source 文件夹，添加 CNAME 文件，可以先创建一个 CNAME.txt 文件，打开后写上你的域名，不要加 www 否则每次访问都必须加 www，但如果不带有 www，以后访问的时候带不带 www 都可以访问，保存后记得要重命名，将 .txt 删除，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/013.3jkkos4ga9a0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/013.3jkkos4ga9a0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="013" width=36%/><p>第三步回到 Blog 文件夹，右键打开 Git Bash，依次输入下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开 GitHub，看看CNAME文件是否已经在你的项目中：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/014.5ui049889rw0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/014.5ui049889rw0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="014" width=48%/><p>这样就完成啦！这时候你就可以浏览器直接输入你的域名就会进入你搭建的网页啦！</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>从零开始搭建个人博客：<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></li><li>node.js 安装详细步骤教程：<a href="https://blog.csdn.net/antma/article/details/86104068">https://blog.csdn.net/antma/article/details/86104068</a></li><li>hexo+github搭建个人博客(超详细教程)：<a href="https://blog.csdn.net/AinUser/article/details/77609180">https://blog.csdn.net/AinUser/article/details/77609180</a></li><li>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo">https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名购买 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础篇（二）-- 数据类型和运算符</title>
      <link href="/article/8a42c3c2.html"/>
      <url>/article/8a42c3c2.html</url>
      
        <content type="html"><![CDATA[<p>这一部分主要对Python的数据类型包括：数字、字符串、列表、元组、集合、字典进行介绍，然后介绍运算符，转义字符、数据类型转换、算术运算符、赋值运算符、位运算、比较运算符、逻辑运算符等。</p><span id="more"></span><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h2><p>所有的编程语言都支持变量，变量是编程的起点，程序需要将数据存储到变量中。在编程语言中，变量是数据的载体，简单的说就是一块用来保存数据的内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><ul><li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li><li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）</li></ul><p>变量在<code>Python</code>内部是有类型的，比如<code>int</code>、<code>float</code> 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，<code>Python</code>是动态类型语言，可以将不同类型的数据赋值给同一个变量，所以变量的类型是随时可以改变的。</p><p>任何编程语言都需要处理数据，比如数字、字符串、字符等，我们可以直接使用数据，也可以将数据保存到变量中，方便以后使用。</p><p><code>Python</code>中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在<code>Python</code>中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。等号（&#x3D;）用来给变量赋值。</p><p><strong>变量与常量</strong></p><p>常量是在程序运行过程中，值不能改变的量。<code>Python</code>中并未提供定义常量的保留字，在<code>PEP8</code>规定常量有大写字母和下划线组成。</p><p><code>Python</code>中，使用内置函数<code>type()</code>返回变量类型，使用<code>id()</code>返回变量所指内存区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>AGE_OF_NICK = <span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(AGE_OF_NICK)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(AGE_OF_NICK)</span><br></pre></td></tr></table></figure><p>在内存中存储的数据可以有多种类型。字符型、数值型、布尔型都是<code>Python</code>语言中提供的基本数据类型。</p><h3 id="1-1-数字"><a href="#1-1-数字" class="headerlink" title="1.1 数字"></a>1.1 数字</h3><p><code>Python</code>中提供了数字类型保存数值，数字类型包括整数、浮点数和复数。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。当你指定一个值时，Number 对象就会被创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>number = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>1、整数</strong></p><p>整数包括正整数、负整数和零。在<code>Python3</code>中，不管对于多大或者多小的整数，只用一种类型存储，就是<code>int</code>。<code>Python</code>整数的取值范围是无限的，不管多大或者多小的数字，<code>Python</code>都能轻松处理。当所用数值超过计算机自身的计算能力时，<code>Python</code>会自动转用高精度计算（大数计算）。</p><p>整数类型包括十进制整数、八进制整数、十六进制整数和二进制整数。<br>1）十进制形式</p><p>我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。</p><p>2）二进制形式</p><p>由 0 和 1 两个数字组成，书写时以<code>0b</code>或<code>0B</code>开头。例如，101 对应十进制数是 5。</p><p>3）八进制形式</p><p>八进制整数由 0~7 共八个数字组成，以<code>0o</code>或<code>0O</code>开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。</p><p>4）十六进制形式</p><p>由 <code>0~9</code> 十个数字以及 <code>A~F</code>（或 a~f）六个字母组成，书写时以<code>0x</code>或<code>0X</code>开头</p><p><strong>数字分隔符：</strong> 对于很大的数，例如10000000000，很难数清楚0的个数。为了提高数字的的可读性，<code>Python 3.x</code>允许使用下划线_作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。</p><p><strong>2、小数&#x2F;浮点数</strong></p><p>浮点数由整数部分和小数部分组成，主要用于处理包括小数的数。有两种书写形式：</p><ol><li><p>十进制形式<br>这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。</p></li><li><p>指数形式<br>Python 小数的指数形式的写法为：</p></li></ol><blockquote><p>aEn 或 aen<br>a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 $a\times 10^n$。</p></blockquote><p><strong>温馨提示：</strong> 注意，只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">12e4</span>)</span><br><span class="line"><span class="number">120000.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">12.3</span>*<span class="number">0.1</span>)</span><br><span class="line"><span class="number">1.2300000000000002</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> <code>12.3*0.1</code>的计算结果很明显是 1.23，但是<code>print</code>的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的。对于浮点数，不能直接使用比较判断是否相等。</p><p><strong>3、复数类型</strong></p><p>复数由实部（real）和虚部（imag）组成，并且使用<code>j</code>或者<code>J</code>表示虚部。可以用<code>a + bj</code>，或者·complex(a,b)·表示， 复数的实部和虚部都是浮点型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a.real)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(a.imag)</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure><p><strong>4、布尔类型</strong></p><p>布尔类型主要用来表示真值或假值。在<code>Python</code>中，标识符<code>True</code>和<code>False</code>被解释为布尔值。另外，<code>Python</code>中的布尔值可以转化为数值，<code>True</code>表示1，<code>False</code>表示0。</p><p>在<code>Python</code>中，所有的对象都可以进行真值测试。其中，只有下面列出的几种情况得到的值为假，其他对象在<code>if</code>或者<code>while</code>语句中都表现为真。</p><ul><li>False 或 None。</li><li>数值中的零，包括0、0.0、虚数0。</li><li>回空序列，包括字符串、空元组、空列表、空字典。</li><li>自定义对象的实例，该对象的<code>_bool_</code>方法返回<code>False</code>或者<code>_len_</code>方法返回0。</li></ul><p><strong>温馨提示：</strong><code>Python</code>中的布尔类型的值可以进行数值运算，例如，<code>“False +1”</code>的结果为1。但是不建议对布尔类型的值进行数值运算。</p><h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2 字符串"></a>1.2 字符串</h3><p>字符串就是连续的字符序列，可以是计算机所能表示的一切字符的集合。<font color=#9900CC><strong><code>Python</code>中字符串属于不可变序列，使用单引号<code>&#39;...&#39;</code>，双引号<code>&#39;&#39;...&#39;&#39;</code>，或<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>括起来。</font></strong><code>Python</code>中单引号和双引号使用完全相同，只能单行；使用三引号(‘’’或”””)可以指定一个多行字符串。详细用法如下：</p><ul><li>字符串可以用<code>+</code>运算符连接在一起，用<code>*</code>运算符重复。</li><li><code>Python</code>中的字符串有两种索引方式，从左往右以 0 开始，最大范围是字符串长度少1；从右往左以 -1 开始，最大范围是字符串开头。</li><li><code>Python</code>没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量<code>[头下标:尾下标:步长]</code>，其中头下标是从 0 开始算起，可以是正数或负数；尾下标可以为空表示取到头或尾；步长表示间隔。获取的子字符串包含头下标的字符，但不包含尾下标的字符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>；<span class="number">5</span>])</span><br><span class="line">llo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>*<span class="number">2</span>)</span><br><span class="line">Hello World!Hello World!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>+<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">Hello World!Test</span><br></pre></td></tr></table></figure><h3 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用<code>[ ]</code>标识，是<code>python</code>最通用的复合数据类型。</p><p>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客图库/001.3d88ipk687i0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客图库/001.3d88ipk687i0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%><p>加号<code>+</code>是列表连接运算符，星号<code>*</code>是重复操作。如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span> + tinylist    <span class="comment"># 打印组合的列表</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>[‘runoob’, 786, 2.23, ‘john’, 70.2]<br>runoob<br>[786, 2.23]<br>[2.23, ‘john’, 70.2]<br>[123, ‘john’, 123, ‘john’]<br>[‘runoob’, 786, 2.23, ‘john’, 70.2, 123, ‘john’]</p></blockquote><h3 id="1-4-元组"><a href="#1-4-元组" class="headerlink" title="1.4 元组"></a>1.4 元组</h3><p>元组是另一个数据类型，类似于 List（列表）。元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第四个（不包含）的元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span> + tinytuple   <span class="comment"># 打印组合的元组</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>(‘runoob’, 786, 2.23, ‘john’, 70.2)<br> runoob<br> (786, 2.23)<br>  (2.23, ‘john’, 70.2)<br>  (123, ‘john’, 123, ‘john’)<br>  (‘runoob’, 786, 2.23, ‘john’, 70.2, 123, ‘john’)</p></blockquote><p><strong>温馨提示：</strong> 元组是不允许更新的，而列表是允许更新的。</p><h3 id="1-5-集合"><a href="#1-5-集合" class="headerlink" title="1.5 集合"></a>1.5 集合</h3><p><code>Python</code>中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。从形式上看，和字典类似，<code>Python</code>集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔，如下所示：</p><blockquote><p>{element1, element2, …, elementn}</p></blockquote><p>从内容上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误。</p><h3 id="1-6-字典"><a href="#1-6-字典" class="headerlink" title="1.6 字典"></a>1.6 字典</h3><p>字典(dictionary)是除列表以外<code>Python</code>之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值<code>value</code>组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>]          <span class="comment"># 输出键为&#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>This is one<br>This is two<br>{‘dept’: ‘sales’, ‘code’: 6734, ‘name’: ‘runoob’}<br>[‘dept’, ‘code’, ‘name’]<br>[‘sales’, 6734, ‘runoob’]</p></blockquote><p><strong>小结</strong></p><ul><li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li><li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</li></ul><hr><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2 运算符"></a>2 运算符</h2><p>运算符将各种类型的数据连接在一起形成表达式。Python 的运算符丰富但不混乱，比如 Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱。</p><p><code>Python</code>的运算符包括算术运算符、赋值运算符、比较运算符、逻辑运算符和位运算符。使用运算符将不同类型数据按照一定规则连接在一起的式子称为表达式。</p><h3 id="2-1-转义字符"><a href="#2-1-转义字符" class="headerlink" title="2.1 转义字符"></a>2.1 转义字符</h3><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>换行符，将光标位置移到下一行开头</td></tr><tr><td>\r</td><td>回车符，将光标位置移到本行开头</td></tr><tr><td>\t</td><td>水平制表符，也即 Tab 键，一般相当于四个空格</td></tr><tr><td>\a</td><td>蜂鸣器响铃</td></tr><tr><td>\b</td><td>退格（Backspace），将光标位置移到前一列</td></tr><tr><td>\0</td><td>空</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\</td><td>反斜线</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\</td><td>在字符串行尾的续行符，即一行未完，转到下一行继续写</td></tr></tbody></table><p><strong>温馨提示：</strong> 反斜杠可以用来转义，使用<code>r</code>可以让反斜杠不发生转义。 如<code>r&quot;this is a line with \n&quot;</code>则<code>\n</code>会显示，并不是换行。</p><h3 id="2-2-数据类型转换"><a href="#2-2-数据类型转换" class="headerlink" title="2.2 数据类型转换"></a>2.2 数据类型转换</h3><table class="reference"><tbody><tr><th>函数</th><th>描述</th></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-int.html" target="_blank" rel="noopener noreferrer">int(x [,base])</a></p></td><td><p>将x转换为一个整数</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-float.html" target="_blank" rel="noopener noreferrer">float(x)</a></p></td><td><p>将x转换到一个浮点数</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-complex.html" target="_blank" rel="noopener noreferrer">complex(real [,imag])</a></p></td><td><p>创建一个复数</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-str.html" target="_blank" rel="noopener noreferrer">str(x)</a></p></td><td><p>将对象 x 转换为字符串</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-repr.html" target="_blank" rel="noopener noreferrer">repr(x)</a></p></td><td><p>将对象 x 转换为表达式字符串</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-eval.html" target="_blank" rel="noopener noreferrer">eval(str)</a></p></td><td><p>用来计算在字符串中的有效Python表达式,并返回一个对象</p></td></tr><tr valign="top"><td><p><a href="att-tuple-tuple.html" target="_blank" rel="noopener noreferrer">tuple(s)</a></p></td><td><p>将序列 s 转换为一个元组</p></td></tr><tr valign="top"><td><p><a href="att-list-list.html" target="_blank" rel="noopener noreferrer">list(s)</a></p></td><td><p>将序列 s 转换为一个列表</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-set.html" target="_blank" rel="noopener noreferrer">set(s)</a></p></td><td><p>转换为可变集合</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-dict.html" target="_blank" rel="noopener noreferrer">dict(d)</a></p></td><td><p>创建一个字典。d 必须是一个序列 (key,value)元组。</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-frozenset.html" target="_blank" rel="noopener noreferrer">frozenset(s)</a></p></td><td><p>转换为不可变集合</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-chr.html" target="_blank" rel="noopener noreferrer">chr(x)</a></p></td><td><p>  将一个整数转换为一个字符</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-unichr.html" target="_blank" rel="noopener noreferrer">unichr(x)</a></p></td><td><p>将一个整数转换为Unicode字符</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-ord.html" target="_blank" rel="noopener noreferrer">ord(x)</a></p></td><td><p> 将一个字符转换为它的整数值</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-hex.html" target="_blank" rel="noopener noreferrer">hex(x)</a></p></td><td><p>  将一个整数转换为一个十六进制字符串</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-oct.html" target="_blank" rel="noopener noreferrer">oct(x)</a></p></td><td><p> 将一个整数转换为一个八进制字符串</p></td></tr></tbody></table><h3 id="2-3-算术运算符"><a href="#2-3-算术运算符" class="headerlink" title="2.3 算术运算符"></a>2.3 算术运算符</h3><p>这里以 $a&#x3D;10, b&#x3D;20$ 为例</p><table class="reference"><tbody><tr><th>运算符</th><th>描述</th><th>实例</th></tr><tr><td>+</td><td>加 - 两个对象相加</td><td> a + b 输出结果 30</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td> a - b 输出结果 -10</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td> a * b 输出结果 200</td></tr><tr><td>/</td><td>除 - x除以y</td><td> b / a 输出结果 2</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td> b % a 输出结果 0</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td> a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td>//</td><td>取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td> <pre class="prettyprint prettyprinted" style=""><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="lit">9</span><span class="com">//2</span><span class="pln"></span><span class="lit">4</span><span class="pln"></span><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">9</span><span class="com">//2</span><span class="pln"></span><span class="pun">-</span><span class="lit">5</span></pre></td></tr></tbody></table><p><strong>1、&#x2F; 和 &#x2F;&#x2F; 除法运算符</strong></p><p><code>Python</code>支持<code>/</code>和<code>//</code>两个除法运算符，但它们之间是有区别的：</p><ul><li><code>/</code>表示普通除法，使用它计算出来的结果和数学中的计算结果相同。</li><li><code>//</code>表示整除，只保留结果的整数部分，舍弃小数部分；注意是直接丢掉小数部分，而不是四舍五入。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">20</span>/<span class="number">4</span>)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">20</span>//<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">20.4</span>/<span class="number">4</span>)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong></p><ul><li><code>/</code>的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。当有小数参与运算时，<code>//</code>结果才是小数，否则就是整数。</li><li>需要注意的是，除数始终不能为 0，除以 0 是没有意义的，这将导致<code>ZeroDivisionError</code>错误。在某些编程语言中，除以 0 的结果是无穷大（包括正无穷大和负无穷大）。</li></ul><p><strong>2、% 求余运算符</strong></p><p><code>%</code>运算符用来求得两个数相除的余数，包括整数和小数。<code>Python</code>使用第一个数字除以第二个数字，得到一个整数的商，剩下的值就是余数。对于小数，求余的结果一般也是小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;7.7%2.2 =&quot;</span>, <span class="number">7.7</span>%<span class="number">2.2</span>)</span><br><span class="line"><span class="number">7.7</span>%<span class="number">2.2</span> = <span class="number">1.0999999999999996</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;-7.7%2.2 =&quot;</span>, -<span class="number">7.7</span>%<span class="number">2.2</span>)</span><br><span class="line">-<span class="number">7.7</span>%<span class="number">2.2</span> = <span class="number">1.1000000000000005</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;7.7%-2.2 =&quot;</span>, <span class="number">7.7</span>%-<span class="number">2.2</span>)</span><br><span class="line"><span class="number">7.7</span>%-<span class="number">2.2</span> = -<span class="number">1.1000000000000005</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;-7.7%-2.2 =&quot;</span>, -<span class="number">7.7</span>%-<span class="number">2.2</span>)</span><br><span class="line">-<span class="number">7.7</span>%-<span class="number">2.2</span> = -<span class="number">1.0999999999999996</span></span><br></pre></td></tr></table></figure><p>从运行结果可以发现两点：</p><ul><li>只有当第二个数字是负数时，求余的结果才是负数。换句话说，求余结果的正负和第一个数字没有关系，只由第二个数字决定。</li><li><code>%</code>两边的数字都是整数时，求余的结果也是整数；但是只要有一个数字是小数，求余的结果就是小数。</li></ul><h3 id="2-4-赋值运算符"><a href="#2-4-赋值运算符" class="headerlink" title="2.4 赋值运算符"></a>2.4 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取模赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>:&#x3D;</td><td>海象运算符，可在表达式内部为变量赋值</td><td>b &#x3D; [(a:&#x3D;0)+1, a-1, a*1, a&#x2F;1]</td></tr></tbody></table><p><strong>温馨提示：</strong> 海象运算符是<code>Python3.8</code>版本新增运算符。</p><h3 id="2-5-比较运算符"><a href="#2-5-比较运算符" class="headerlink" title="2.5 比较运算符"></a>2.5 比较运算符</h3><p>比较运算符，也称关系运算符，用于对常量、变量或表达式的结果进行大小比较。如果这种比较是成立的，则返回 True（真），反之则返回 False（假）。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于——比较对象是否相等，返回True&#x2F;False</td></tr><tr><td>!&#x3D;</td><td>不等于——比较两个对象是否相等，返回True&#x2F;False</td></tr><tr><td>&gt;</td><td>大于——判断x是否大于y，返回True&#x2F;False</td></tr><tr><td>&lt;</td><td>小于——判断x是否小于y，返回True&#x2F;False</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于——判断x是否大于等于y，返回True&#x2F;False</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于——判断x是否小于等于y，返回True&#x2F;False</td></tr></tbody></table><p>补充：在<code>Python</code>中，当需要判断一个变量是否介于两个值之间时，可以采用“值1&lt;变量&lt;值2”的形式，例如“0&lt;a&lt;100”。</p><h3 id="2-6-逻辑运算符"><a href="#2-6-逻辑运算符" class="headerlink" title="2.6 逻辑运算符"></a>2.6 逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>逻辑与运算，a and b，如果a为False，返回a的计算值，否则返回b的计算值</td></tr><tr><td>or</td><td>逻辑或运算，a or b，如果a是True，则返回a的计算值，否则返回b的计算值</td></tr><tr><td>not</td><td>逻辑非运算，not a，如果a为 True，返回 False，反之，则返回True</td></tr></tbody></table><p>对于<code>and</code>运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 <code>Python</code>按照下面的规则执行<code>and</code>运算：</p><ul><li>如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时<code>and</code>会把左边表达式的值作为最终结果。</li><li>如果左边表达式的值为真，那么最终值是不能确定的，<code>and</code>会继续计算右边表达式的值，并将右边表达式的值作为最终结果。</li></ul><p>对于<code>or</code>运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以<code>Python</code>按照下面的规则执行<code>or</code>运算：</p><ul><li>如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时<code>or</code>会把左边表达式的值作为最终结果。</li><li>如果左边表达式的值为假，那么最终值是不能确定的，<code>or</code>会继续计算右边表达式的值，并将右边表达式的值作为最终结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;Python&quot;</span>)</span><br><span class="line">Pyhton</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">18.5</span> <span class="keyword">or</span> <span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="number">18.5</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 在<code>Python</code>中，<code>and</code>和<code>or</code>不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。另外，<code>and</code>和<code>or</code>运算符会将其中一个表达式的值作为最终结果，而不是将<code>True</code>或者<code>False</code>作为最终结果。</p><h3 id="2-7-位运算符"><a href="#2-7-位运算符" class="headerlink" title="2.7 位运算符"></a>2.7 位运算符</h3><p>位运算符把数字看作二进制进行计算。Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13，二进制格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = 0011 <span class="number">1100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">0000</span> <span class="number">1101</span></span><br></pre></td></tr></table></figure><table class="reference"><tbody><tr><th>运算符</th><th>描述</th><th>实例</th></tr><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td> (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td> 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td> (a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1 </td><td> (a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td> 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。<span class="marked">~x</span> 类似于 <span class="marked">-x-1</span></td><td> (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由 <span class="marked">&lt;&lt;</span> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td><td> a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把"&gt;&gt;"左边的运算数的各二进位全部右移若干位，<span class="marked">&gt;&gt;</span> 右边的数字指定了移动的位数 </td><td> a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><p><strong>温馨提示：</strong> 由于移位运算的速度很快，在程序中遇到表达式乘以或除以2的n次幂的情况时，一般采用移位运算来代替。</p><h3 id="2-8-其他运算符"><a href="#2-8-其他运算符" class="headerlink" title="2.8 其他运算符"></a>2.8 其他运算符</h3><p><strong>1、成员运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td></tr></tbody></table><p><strong>2、身份运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>is</td><td>判断两个标识符是不是引用自一个对象，返回True&#x2F;False</td></tr><tr><td>is not</td><td>判断两个标识符是不是引用自不同对象，返回True&#x2F;False</td></tr></tbody></table><blockquote></blockquote><p><code>is</code>判断两个对象是否相同，就是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了。 <code>==</code>用于判断引用变量的值是否相等。</p><h3 id="2-9-运算符优先级"><a href="#2-9-运算符优先级" class="headerlink" title="2.9 运算符优先级"></a>2.9 运算符优先级</h3><p>优先级高的优先计算，优先级一样的从左往右依次计算(此为3.8官方文档数据)</p><table><thead><tr><th>优先级</th><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>(experession,…)，[expression,…]，{key:datum,…}，{expression,…}</td><td>绑定或元组显示,列表显示,字典显示,设置显示</td></tr><tr><td>2</td><td>x[index]，x[index:index]，f(arguments…)，x.attribute</td><td>抽取（下标）切片（寻址段）调用（函数调用），属性引用</td></tr><tr><td>3</td><td>await x</td><td>await表达式</td></tr><tr><td>4</td><td>**</td><td>乘方</td></tr><tr><td>5</td><td>+x，-x，~x</td><td>正，负，按位非 NOT</td></tr><tr><td>6</td><td>*，/，%,//,@</td><td>乘法、除法、取余、整除、矩阵乘</td></tr><tr><td>7</td><td>+,-</td><td>加法与减法</td></tr><tr><td>8</td><td>&lt;&lt;,&gt;&gt;</td><td>移位</td></tr><tr><td>9</td><td>&amp;</td><td>按位与AND</td></tr><tr><td>10</td><td>^</td><td>按位异或XOR</td></tr><tr><td>11</td><td>|</td><td>按位或OR</td></tr><tr><td>12</td><td>&lt;，&lt;=，&gt;，&gt;=，!=，==，in，not in，is，is not</td><td>比较运算，包括成员检测和标识号检测</td></tr><tr><td>13</td><td>not x</td><td>布尔逻辑“非” NOT</td></tr><tr><td>14</td><td>and</td><td>布尔逻辑“与” AND</td></tr><tr><td>15</td><td>or</td><td>布尔逻辑“或” OR</td></tr><tr><td>16</td><td>if–else</td><td>条件表达式</td></tr><tr><td>17</td><td>lambda</td><td>Lambda表达式</td></tr><tr><td>18</td><td>:=</td><td>海象运算符</td></tr></tbody></table><p><strong>温馨提示：</strong> 虽然<code>Python</code>运算符存在优先级的关系，但不推荐过度依赖运算符的优先级，这会导致程序的可读性降低。因此，建议编程时：</p><ul><li>不要把一个表达式写得过于复杂，如果一个表达式过于复杂，可以尝试把它拆分来书写。</li><li>不要过多地依赖运算符的优先级来控制表达式的执行顺序，这样可读性太差，应尽量使用<code>( )</code>来控制表达式的执行顺序。</li></ul><hr><blockquote><p>以上内容仅作为自己学习使用，主要整理自以下Python教程网站：</p><ul><li>C语言中文网Python教程：<a href="http://c.biancheng.net/python/variable/">http://c.biancheng.net/python/variable/</a></li><li>菜鸟教程：<a href="https://www.runoob.com/python/python-variable-types.html">https://www.runoob.com/python/python-variable-types.html</a></li><li>廖雪峰Python教程：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832">https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节气习俗</title>
      <link href="/article/b81b9daf.html"/>
      <url>/article/b81b9daf.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要记录一些重要的节日和节气的注意事项，希望给大家带来好运！</p><span id="more"></span><p>春节，华人最重要的节日，如何过，各地早就约定俗成，无需赘述。简单补充一下，说说一些易行的居家开运小方法，大家可以尝试下图个吉利：</p><ol><li><p>除尘。想必大部分人春节前都会对家里进行清洁，打扫除尘，洗洗涮涮。有个地方千万别漏掉，就是自家的卫生间，要清洁干净。从民俗上说，国内一些地方有敬厕神的习俗，扶桑也有种招财的法术，核心方法是每天在特定时间清理自家厕所，恭敬厕神，则财源滚滚。一些国际金融家在考察创业投资对象，进行实地考察时，对于细节的考察，比较注重两个地方 ，一个是老板的办公室，另一个是公司供内员工使用的厕所的清洁程度。创业之初，老板的办公室小而整洁，可以多少反映出老板务实自信不务虚的价值观，厕所则反映出细微处管理命令的执行力度和老板对生活对员工的态度。把卫生间打扫干净，是很吉利的事情。洋快餐卫生间的清洁程度一直都很高，没少赚国人的钱吧，笑。公司是否有钱途看卫生间，别人家里是否有钱，也可以去他家卫生间瞧瞧，笑。</p></li><li><p>贴福字。大门和最外层窗户的福字是坚决不能倒着贴的，否则福到你家门外就撒泼打滚不进去了，笑。汉字有繁简之分，更有倒正之分，字是有能量的。大门上，窗户上的吉祥画，吉祥话，如福字，都要正着贴。如果想取巧转运，可以讨个吉利：在需要转运的人卧室门上，或者里屋的墙壁，或者床头，倒着贴福字，把福引到需要者身边。自己的办公室内，还有办公桌隔断上，都可以倒着贴福字。</p></li><li><p>春节，是一家人团圆充电的时候，特别是对于千里之外归乡的游子来说，同一个姓氏的族人聚集在一起，抛开烦心事，说一些吉利话，你能感受到温暖安心，在一年更替时，心神安定，对来年的事业健康运势都是一种正能量的补充。祖坟风水好尚能福泽子孙，何况长辈健在时的团圆呢。能使人心安，使人谦卑，多听听长辈的唠叨，去粗取精，对自己的人生也有指导作用。</p></li><li><p>鞭炮。小朋友要注意安全第一，燃放危险程度低的小烟花小鞭炮就好。成年人有条件的自己燃放鞭炮，没条件的可以适当观看别人燃放鞭炮，效果差不多。人在紧张时肾上腺素激增，男性在影院看大片，炮弹轰鸣刀刀见血觉得特过瘾，肾上腺素激增可以使人更积极，更富有朝气，百邪不侵。女孩因为禀赋原因，对动作大片等使人肾上腺激增的东西大都不敢兴趣，过年时可以出去看看放炮的人群，听听炮声。古人没大片看，没摇滚音乐听，但是中国人很聪明，用爆竹声来振发阳气，激荡心神，驱赶鬼神，过年时放炮振发阳气，然后吃饺子吃美食来补充能量，你看，古人多么智慧。如果今年过得郁闷不得志，运气不好，那就出去听听炮声，或者亲手放鞭炮。如果觉得炮声很烦，那就别强迫自己去放鞭炮，特别是岁数大的人，一切以舒适为度。</p></li></ol><p>大年初四治治赖债不还者，即如何讨债。在红纸上写下对方姓名、住址、金额（如有八字更好），再念三遍：遁甲太阴显用！某某人名！速速还我银两。然后烧掉，将灰烬倒在自己住家周边水沟、河流等，实在不行冲在下水道也可以。上述方法在年初四使用最佳，当然此后也可用，注意：可以在使用一次后的七七四九天后再次使用，赖债者不还都难啦。</p><p>太君曰：“四立:是立春、立夏、立秋、立冬，四绝:为春分、夏至、秋分、冬至。”碰到这种季节的前后几天，地球轨道上的磁场和电波都会自然震动，影响气流、云层和天气变化。气流快，在季节前变天，曰气盛。气流慢，季节后变天，谓气衰。天气会骤变。患台风、寒潮或高温、暴雨。这个时候人和动物都会随着季节换毛和更新血脉，因此人们在这种时间要顺天循道，不能酗酒乱性、舟车探险，要戒烦戒燥，虚心静气，可防治伤寒流感传染病及慢性病者的旧病复发。避免不必要的人身伤害！遵者平安长寿。</p><p>立春这天“阳和起蛰，品物皆春”，过了立春，万物复苏生机勃勃，一年四季从此开始。</p><p>躲春，中国命理学认为，立春这一天，黄赤夹角应该是315度，由于磁场和气场的缘故，通常会比较乱，无论是家中还是办公室，容易招惹口舌事非。因此要进行躲春，否则一年内可能都非常不顺利。躲春这一天不宜搬迁、看望病重患者及参加丧事等，以免招惹晦气，影响一整年的运气。不妄动、不争论，乐呵呵的度过这一天。</p><p>古代有一个传说：立春快到来的时候，县官会带着本地的知名人士去土地里挖一个坑，然后把羽毛、鸡毛等轻物质放在坑里，等到了某个时辰，坑里的羽毛和鸡毛会从坑里飘上来，这个时刻就是立春时辰，开始放鞭炮庆祝，预祝明年风调雨顺、五谷丰登。</p><p>立春日祈福：找出自己年柱上之在自己三合的生肖， 三合的时辰(申子辰、已酉丑、寅午戍、亥卯未)【如猴生肖者， 可在子时或辰， 在子或辰位】，三合的方位，用锤敲墙或地三下，待土地公公感灵遂通，为你开天门，接福增运！<br>三合方位：东【卯兔】；南【午马】；西【酉鸡】；北【子鼠】。 东北偏东【寅虎】；西南偏西【申猴】；东南偏南【巳蛇】。西北偏北【亥猪】。 东南偏东【辰龙】；西北偏西【戌狗】；东北偏北【丑牛】；西南偏南【未羊】。</p><p><strong>二月二龙抬头、剃龙头</strong></p><p>民间普遍认为在这一天剃头，会使人红运当头、福星高照，因此，民谚说“二月二剃龙头，一年都有精神头”。孩子要“剃喜头”，保佑健康成长，长大后出人头地；大人要“剃龙头”辞旧迎新，希望带来好运。要是准备理髮，得早点去排队！</p><ul><li>四离指春分、秋分、夏至、冬至的前一天，称为离日。</li><li>四绝指立春、立夏、立秋、立冬的前一天，叫做绝日。</li></ul><p>碰到这种季节的前后几天，地球轨道上的磁场和电波都会自然震动，影响气流、云层和天气变化。气流快，在季节前变天，曰气盛。气流慢，季节后变天，谓气衰。天气会骤变。患台风、寒潮或高温、暴雨。这个时候人和动物都会随着季节换毛和更新血脉，因此人们在这种时间要顺天循道，不能酗酒乱性、舟车探险，要戒烦戒燥，虚心静气，可防治伤寒流感传染病及慢性病者的旧病复发。</p><p><strong>春分，这几天不宜劳累、熬夜等</strong></p><ul><li>春分、秋分、夏至、冬至的前一天，在术数上叫做“离日”。 </li><li>立春、立夏、立秋、立冬的前一天，叫做“绝日”。</li><li>按玄学的说法，四离日和四绝日，为四季相交，节令转移阴阳杂乱之时。</li></ul><p><strong>立夏，节气前后不宜熬夜酗酒等</strong></p><p><strong>端午节和一些禁忌</strong></p><p>端午节左右不要让小孩随便下水或接近水源的地方。</p><p>五月将至，农历五月俗称毒月，其中九日为伤身损气耗精元之日，分别为五月初五、初六、初七、十五、十六、十七、二五、二六、二七，其中端午为九毒日之首，故这一天民间有喝雄黄酒、插艾草等避邪驱毒的仪式。中国的每一个传统节日，都寓含着古德先贤智慧经验的传承以及先人对后人的无尽慈爱！</p><p>农历五月 农历五月俗称毒月。其中，五月初五、初六、初七、十五、十六、十七以及二五、二六、二七，此九天为“天地交泰九毒日”；“十四”为天地交泰日，一共十天。这十天内，务必端容肃己，严禁杀生，行淫，否则严重伤身损气耗精元。五月俗称“恶月”。君子应节制嗜欲，食物清淡，减少酸味，增加苦味，益肝补肾。此时节应静养，与自然和谐平定心气。天地主气交合及造化万物之辰，最宜戒酒色禁忌。</p><p>端午节午时：农历五月初五（从中午十一点到中午的十三点，而正午则是十二点）从井里打的水</p><ul><li>无根午时水：端午午时下雨接的雨水。</li><li>解暑午时水：用黄瓜的芯加盐泡成解暑的午时水。</li></ul><p>午时水用三种功效，一是饮用，泡茶或者制成解暑的午时水，甚至是制成酒；二是洗澡；三是清扫；人们用汲来的午时水加入一些白酒和少许雄黄粉(中药)，用以喷洒房间庭院，或洗澡、洗脸、洗手脚。传说，喝过午时水的都能活过九十八岁；用午时水加雄黄洗澡，那一年入夏不会生痱子，外出不会被蛇咬</p><p><strong>夏至</strong></p><p>要了解自己的旺运方位</p><ul><li>属相为鼠、牛、鸡的朋友，夏季旺运方位在西方</li><li>属相为蛇、马、猪的朋友，夏季旺运方位在东方</li><li>属相为龙、羊、狗的朋友，夏季旺运方位在南方</li><li>属相为虎、兔、猴的朋友，夏季旺运方位在北方</li></ul><p>夏天已到，此时，是喝姜枣茶养身最好的时候！养身方法：每年从立夏那一天开始，每天早上喝生姜红枣茶，一直喝到入伏的头一天。</p><p>三伏晒：【三伏晒太阳祛病法】三伏当天的上午九点到下午三点(9点～11是巳时，中午11点～1点是午时、1点～3点是未时)，赤身在烈日中暴晒，有点像欧美流行的裸身日光浴，但是古人发现，三伏这一天做足日光浴，不但能祛男男女女的陈年痼疾，也可医新病，效果之好，甚至痊愈除根。</p><p>立秋：用红纸书写“今日立秋，百病皆休”字样贴于墙上（入户门一侧的墙上即可），以起到预防疾病之目的。<br>立秋当天最好要避免男女同房做爱，否则容易产生情绪波动、抑郁的情绪，因为立秋阳气渐衰、阴气渐长，会伤及阳气，最终导致运势受损。有些地方立秋当日要避免洗澡、以及在田间行走，否则不利。</p><p>鬼节，农历七月阎罗打开地狱放出鬼，八月初关闭。<br>有些事情在这个月能不做最好不要做，例如搬家，去河边海边游泳，去医院探望病人，看尸体，参加白事，对视尸体的眼睛，说脏话，在野外树林里便溺，在野外树林河边海边的车内做那种事情<br>本月给鬼施食，捐寿盒，都能获得回报。</p><p>七月初一全素食，七月七日凌晨1点前不睡觉，十月十五这一天很少说话，基本不说话</p><p>七夕的时候，别忘了多喝水，参与体内循环代谢。</p><p>处暑的水好，身体有恙的多喝点水治病，开水生水井水湖水都行。喝白水，越早喝越好 参与体内循环代谢</p><p>伏天是养阳气的时候，空调温度不要太低，不要贪凉，在能承受的范围内多出一些汗，增强大脑对核心温度的调节能力，有助于健康。</p><p>秋冬：人的血压在秋季会逐渐升高，使体内气血更高效的到达全身各处以应对即将到来的寒冬，吃同样的东西，这个季节身体吸收的最快，所以秋冬之交养生效果最佳，是进补的季节。</p><p>【九九重阳禁忌】今日乃道佛二家一年难得几次的宜开光加持之日！<br>今日娃子们当尽孝心，忌对外送物！不可嫁娶，不可参加婚宴，不可兴土木！切记。桑拓木，满执位，冲马煞南！娃娃们要理发做头发的，今天最好不过了，除晦气煞气也！今日切忌不可安床！不可动家里床位！还有，今日万万不可入不认识的人的家中！大凶！</p><p>延寿的方法是每天吃饭必有一顿白米饭，一天吃的食物种类不会少于十种，每逢七月初一全素食，七月七日凌晨1点前不睡觉，十月十五这一天很少说话，基本不说话。</p><p><strong>拜斗</strong></p><p><strong>冬至提醒</strong></p><p>明年一年的身体健康与否，取决于你今晚子时体内阳气生发得是否旺盛，所以今晚万万不可熬夜，白天宜温补。19点后尽量少吃东西少喝水，23-5点最好不要小便，以免走失子时刚刚生发的弱阳。</p><p>冬至前后，节令转移，磁场、电波自然震动，要保持良好的心境，戒烦戒燥。<br>冬至温补羊肉为佳。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 生活常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节气 </tag>
            
            <tag> 生活习俗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个时代“寒门再难出贵子”</title>
      <link href="/article/98fdd8aa.html"/>
      <url>/article/98fdd8aa.html</url>
      
        <content type="html"><![CDATA[<p>最近刚读了天涯上的一篇帖子讨论这个时代为什么寒门再难出贵子，里面很多观点可以让自己反思为什么总是迷茫和受挫，从而更好地前行，愿我们每个人都可以跳出自我局限，从而成长为更好的自己。</p><span id="more"></span><p>读完感受，一个人的出身是影响发展的很重要的因素，但不是唯一的，下面的摘录：</p><p>在一个物欲横流的时代，当金钱决定一切，成为人得终极信仰的时候，这时候也是“门阀”，阶层相应出现的年代。马克思说过：阶级一旦形成，那么处于各个阶级的人想打破阶级的鸿沟壁垒几乎不可能。</p><p>家庭条件差些大多都是有些狡黠的，做事心理有很大的计算过程，这个计算过程对父母来讲是好事，比较节省，但是对自己发展，交友，人生态度是一个很大的思维框架，往往会跟随自己的一生……</p><p>如何活是一个问题，无非就是轻松简单点，安稳点，保障高点，很多孩子也包括当年的楼主在学校的时候，觉得心比天高，但是到了社会上摔打几年，有发现这个江山真是铁打得，社会不是那么好混的，很重要的一点在即将毕业将要选择进行什么工作的时候，真的需要精心来思虑一段时间，包括我们这些成年的面临跳槽，同样需要认真的去思考，指导这个思考最重要的就是一定要有自知之明，一定要明白自己的条件，自己的能力，自己的背景，这里面不能有半点幻想的成分……</p><p><strong>人生很有意思，你怎么对它，它怎么对待你，你拿人生开玩笑，不认真，人生立马偿还你一个你的人生是笑话，你如果选择不认真，那么立马人生就对你不认真，其实人生在某种可控范围内是可以规划的。</strong></p><p>一个人也许一辈子两家事最重要。第一：是去找一份工作，一份待遇较好，有发展前途的工作。第二，是选择一个他或者她结婚。。。在这两项中，告诉你，工作不会抛弃你，工作能养活你，让你活着不用靠人施舍，当你的工作处理好了，婚姻是一个自然的过程的，但是如果你要是想着先成家，再立业，我会告诉你，我身边有朋友因为颠倒了顺序现在离婚了。</p><p>人是靠本能和欲望活着的，婚姻是一个相互交换，相互承诺的本质，构成是两个人，这里而是有利益衡量的，如果婚姻的天平不是那么平衡了，要么一个人永远受气，要不不受气就是分手。我们的社会已经不再是30年前，结婚了就是一辈子，了解这些，做好自己，婚姻也差不到那里……</p><p>学习的真正作用——储备知识，锻炼思维，进而增强能力，获取更多你身边人不具备，不会，不懂得知识。因为是这样你可以从做父母，身边人，周围人做不了的事情，你积累的越多的知识，掌握越多的思维技巧，你就会脱颖而出。遗憾的是多数家长理解不了学习的目的是淘汰不学习的，学习好的目的是淘汰学习不好的。教育，小学，初中，高中，大学，研究生，一级一级实际上是个完美的淘汰制度。</p><p>十几年的学习的真正作用——储备知识，锻炼思维，进而增强能力。真正的目的在于建立良好的思维习惯，而不是学习得了多少分，上了哪个学校……</p><p>多数人在为了一份薪水，或者为了自己创业那点小生意，起早贪黑，可是他们真的很卖力，真的很贫穷，为什么还是那么艰辛？其实重要的是，忽略了努力是需要有方向的，需要有指导的，如果在一个错误的思维指导下，也许累死你的努力换来的就是一个只能糊口微薄收入，谈何改变自己，付出真的就有回报吗？前提是你的付出是正确的付出，要不在努力付出自己也只是一个机器，一个日复一日损耗生命力换取微薄薪资挣扎在生存线的悲哀一族。</p><p>有多少律师在自己家办公？有多少律师满处散发名片？有多少律师在苦苦挣扎？这些人不努力吗？这些人在学校也是好学生，踏入社会也玩命的努力，但是为什么还过得那么艰辛？是因为什么？是没有跟对人，是没有做对事，绝对不能说他们不努力！也恰恰因为这样，“努力就有回报”成了一个骗局。因为努力就有回报是有前提条件的，前提条件，是要跟对人，是要人给你机会，是要做对事，如果忽略了这些前提，努力不但没有回报，努力会让你让越走越错，越努力越限制。正如著名拿破仑的论点：“愚蠢而又勤奋的人，绝对不能任用。”什么是愚蠢的人？要是真的愚蠢就不烦恼了，拿破仑的愚蠢是有着错误思维的那群人，一开始就忽略了正确的思维，在那里抱残守缺坚守着，还在这个方向上一直勤奋耕耘，除了错上加错，没有别的任何结局。跟对人，做对事，在一个完善的思维才有可能使得努力成为回报，要不然真的是抱残守缺成了愚蠢而又勤奋，那种就是绝对会失败，绝对不会被拿破仑任用的那群人。</p><p>家庭才是性格的养成地。思维的形成，做人做事的外延内涵的思维框架一直有着家庭成长环境的烙印。性格决定命运，思维决定发展，人的机遇决定一切。</p><p>为每个成功人士，每个成功机会都是有着当初的时代背景，社会发展机遇，和个人机遇作为强力辅助形成了这是优秀人物的人生辉煌。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 个人成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天涯论坛 </tag>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础篇（一）-- 十分钟学会基础语法</title>
      <link href="/article/175d115.html"/>
      <url>/article/175d115.html</url>
      
        <content type="html"><![CDATA[<p>Python 作为现在特别流行的编程语言，本文将带你走进 Python 的世界，首先介绍 Python 的语言特性以及如何学号 Python 编程，接着讲解 Python 基本编程，从而让我们实现简单的交互式编程和脚本式编程。</p><span id="more"></span><h2 id="1-Python简介"><a href="#1-Python简介" class="headerlink" title="1 Python简介"></a>1 Python简介</h2><h3 id="1-1-精通一门编程语言的必要性"><a href="#1-1-精通一门编程语言的必要性" class="headerlink" title="1.1 精通一门编程语言的必要性"></a>1.1 精通一门编程语言的必要性</h3><p>随着信息技术的发展，计算机技术应用越来越广泛，目前主流领域如下：</p><ul><li><font color=#9900CC><strong>科学计算：</strong></font>是现代计算机应用的一个重要领域；</li><li><font color=#9900CC><strong>数据处理：</strong></font>用计算机来加工、管理与操作任何形式的数据资料，主要包括数据的采集、转换、分组、组织、计算、排序、存储、检索等；</li><li><font color=#9900CC><strong>人工智能：</strong></font>用计算机来模仿人的智能，使计算机具有识别语言、文字、图形和进行推理、学习以及适应环境的能力；</li><li><font color=#9900CC><strong>网络应用：</strong></font>在信息共享、文件传输、电子商务等领域迅速发展。</li><li><font color=#9900CC><strong>辅助技术：</strong></font>用计算机辅助进行工程设计、产品制造、性能测试，可以使设计工作半自动化或自动化；</li><li><font color=#9900CC><strong>过程控制：</strong></font>用计算机作为控制部件对单台设备或整个生产过程进行控制；</li></ul><h3 id="1-2-Python是什么"><a href="#1-2-Python是什么" class="headerlink" title="1.2 Python是什么"></a>1.2 Python是什么</h3><p><strong>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</strong> Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字和一些标点符号，它具有比其他语言更有特色的语法结构。</p><ul><li><p>Python 是一种 <font color=#9900CC><strong>解释型语言：</strong></font>开发过程中没有了编译这个环节，类似于PHP和Perl语言；</p></li><li><p>Python 是 <font color=#9900CC><strong>交互式语言：</strong></font>可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码；</p></li><li><p>Python 是 <font color=#9900CC><strong>面向对象语言：</strong></font>Python支持面向对象的风格或代码封装在对象的编程技术；</p></li><li><p>Python 是 <font color=#9900CC><strong>初学者的语言：</strong></font>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到浏览器再到游戏。</p></li></ul><blockquote><p> <font color=#9900CC><strong>编译型语言：</strong></font>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。<br> <font color=#9900CC><strong>解释型语言：</strong></font>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。<br>想要了解更多，请参考：<a href="http://c.biancheng.net/view/4136.html">编译型语言和解释型语言的区别</a></p></blockquote><h3 id="1-3-Python语言特点"><a href="#1-3-Python语言特点" class="headerlink" title="1.3 Python语言特点"></a>1.3 Python语言特点</h3><p><strong>1、面向对象</strong></p><p><strong>Python语言具有很强的面向对象特性，简化了面向对象的实现，它消除了保护类型、抽象类、接口等面向对象的元素，使得面向对象的概念更容易理解。</strong></p><p><strong>2、内置的数据结构</strong></p><p>Python提供了一些内置的数据结构，这些数据结构实现了类似Java中集合类的功能。内置数据结构的出现简化了程序设计。<strong>Python的数据结构包括元组、列表、字典、集合等。</strong> 元组相当于“只读”的数组，列表可以作为可变长度的数组使用，字典相当于Java中的HashTable类型。</p><p><strong>3、简洁</strong></p><p>Python语言的关键字比较少，它没有分号、begin、 end等标记，代码块使用空格或Tab键缩进的方式来分隔。此外，<strong>Python代码简洁、短小、易于阅读。</strong> Python简化了循环语句，即使程序结构很复杂也能快速读懂。</p><p><strong>4、健壮</strong></p><p><strong>Python提供了异常处理机制，能捕获程序的异常情况。</strong> 此外Python的堆栈跟踪对象能够指出程序出错的位置和出错的原因。异常机制能够避免不安全退出的情况，同时能够帮助程序员调试程序。</p><p><strong>5、跨平台</strong></p><p>Python会先被编译为与平台相关的二进制代码，然后再解释执行。这种方式类似于Java，但Python的执行速度提高了。<strong>Python编写的应用程序可以运行在Windows、Unix、Linux等不同的操作系统上。</strong> 在一种操作系统上编写的Python代码只需做少量修改，就可移植到其他的操作系统上。</p><p><strong>6、可扩展</strong></p><p>Python是采用C开发的语言，因此可以使用C扩展Python，可以给Python添加新的模块、新的类。同时Python可以嵌入C、C++语言开发项目中，使程序具备脚本语言的特性。因此，<strong>Python 又常被称为“胶水”语言。</strong></p><p><strong>7、动态性</strong></p><p>Python 与JavaScript、PHP、Perl等语言类似，<strong>它不需要另外声明变量、直接赋值即可创建一个新的变量。</strong></p><p><strong>8、强类型语言</strong></p><p>Python的变量创建后会对应一种类型，它可根据赋值表达式的内容决定变量的类型。Python在内部建立了管理这些变量的机制，不同类型的变量需要类型转换。</p><p><strong>9、应用广泛</strong></p><p><strong>Python语言应用于数据库、网络、图形图像、数学计算、Web开发、操作系统扩展等领域。</strong> 有许多第三方库支持Python，例如：PIL（图像处理库）、Tkinter（创建图形用户界面）、Django（交互式网站）、Pygame（2D动画）、SCIPy（科学计算）、Twisted（网络编程）等。</p><p>Python的以上特性使得软件的代码大幅度减少，开发任务进一步简化，我们编程的关注点不再是语言特性，而是程序所要实现的任务。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2fy4k52udl0k.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2fy4k52udl0k.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width="80%"><h3 id="1-4-Python的应用领域"><a href="#1-4-Python的应用领域" class="headerlink" title="1.4 Python的应用领域"></a>1.4 Python的应用领域</h3><p>Python 通常应用于编写下述应用程序：</p><ul><li><font color=#9900CC><strong>脚本</strong></font>——这些简短的程序自动执行常见的管理任务，如在系统中新增用户、将文件上传到网站、在不使用浏览器的情况下下载网页等。</li><li><font color=#9900CC><strong>网站开发</strong></font>——作为快速创建动态网站的工具，Django、Bottle和Tope等Python项目深受开发人员欢迎。</li><li><font color=#9900CC><strong>文本处理</strong></font>——Python在字符串和文本文件处理方面提供了强大的支持。</li><li><font color=#9900CC><strong>图像处理</strong></font>——如PIL库(目前已不再维护，取而代之的有Pillow)科学计算。网上有许多卓越的Python科学计算库，提供了用以统计、数学计算和绘图的函数。如：NumPy 。</li><li><font color=#9900CC><strong>教育</strong></font>——鉴于Python简洁实用，越来越多的学习将其作为第一门编程教学语言。</li></ul><p>Python的主要运用领域有：</p><ul><li><font color=#9900CC><strong>云计算：</strong></font>云计算最热的语言，典型的应用OpenStack；</li><li><font color=#9900CC><strong> WEB应用开发：</strong></font>许多优秀的WEB框架，许多大型网站是Python开发、YouTube、Dropbox、Douban……典型的Web框架包括：Django、flask、TurboGears、web2py 等等；</li><li><font color=#9900CC><strong>科学计算和人工智能：</strong></font>Python 在人工智能领域内的机器学习、神经网络、深度学习等方面，都是主流的编程语言， 此外，Python擅长进行科学计算和数据分析，支持各种数学运算，可以绘制出更高质量的 2D 和 3D 图像；</li><li><font color=#9900CC><strong>自动化运维：</strong></font>系统操作和维护，通常情况下，Python 编写的系统管理脚本，无论是可读性，还是性能、代码重用度以及扩展性方面，都优于普通的 shell 脚本；</li><li><font color=#9900CC><strong>金融：</strong></font>定量交易、金融分析，在金融工程领域，Python使用越来越广泛；</li><li><font color=#9900CC><strong>图形 GUI：</strong></font>PyQT，WXPython，TkInter；</li><li>Python在<font color=#9900CC><strong>网络爬虫、游戏开发、机器人控制编程</strong></font>等领域也有广泛应用。</li></ul><h3 id="1-5-Python编程环境搭建"><a href="#1-5-Python编程环境搭建" class="headerlink" title="1.5 Python编程环境搭建"></a>1.5 Python编程环境搭建</h3><ol><li><p><font color=#9900CC><strong> Window 平台安装 Python：</strong></font>打开浏览器访问：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a> ，点击下载 executable installer，x86 表示是 32 位的安装程序，x86-64 表示 64 位的。详细安装过程，请参考：<a href="http://c.biancheng.net/view/4161.html">http://c.biancheng.net/view/4161.html</a></p></li><li><p><font color=#9900CC><strong>Unix &amp; Linux 平台安装 Python3：</strong></font>打开浏览器访问：<a href="https://www.python.org/downloads/source/">https://www.python.org/downloads/source/</a>，选择适用于 Unix&#x2F;Linux 的源码压缩包，然后解压缩并安装。详细安装过程，请参考：<a href="http://c.biancheng.net/view/4162.html">http://c.biancheng.net/view/4162.html</a></p></li><li><p><font color=#9900CC><strong>MAC平台安装Python3：</strong></font>打开浏览器访问：<a href="https://www.python.org/downloads/mac-osx/">https://www.python.org/downloads/mac-osx/</a>，下载最新版安装即可。</p></li></ol><p>安装完成之后，需要<font color=#9900CC><strong>配置环境变量，</strong></font>详细过程可以参考：<a href="https://www.runoob.com/python3/python3-install.html">Python3 环境搭建</a></p><p>此外，还推荐下载其他IDE进行Python编程，IDE 是 Intergreated Development Environment 的缩写，中文称为集成开发环境，用来表示辅助程序员开发的应用软件。换言之，<strong>集成开发环境就是一系列开发工具的组合套装。</strong> 一般情况下，程序员可选择的 IDE 类别是很多的，比如说，用 Python 语言进行程序开发，既可以选用 Python 自带的 IDLE，也可以选择使用 PyCharm 和 Notepad++ 作为 IDE。</p><ul><li>PyCharm下载和安装教程（包含Python解释器）：<a href="http://c.biancheng.net/view/5804.html">http://c.biancheng.net/view/5804.html</a></li><li>Python Eclipse+PyDec下载和安装教程：<a href="http://c.biancheng.net/view/5810.html">http://c.biancheng.net/view/5810.html</a></li><li>Python VS Code下载和安装教程：<a href="http://c.biancheng.net/view/5813.html">http://c.biancheng.net/view/5813.html</a></li></ul><h3 id="1-6-Python学习"><a href="#1-6-Python学习" class="headerlink" title="1.6 Python学习"></a>1.6 Python学习</h3><p>下面推荐几篇内容不错的关于Python学习路线和不同方向的进阶教程，有时间可以对照一下，看看自己还有多长的路要走。</p><ol><li><a href="https://blog.csdn.net/u014044812/article/details/88079011?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161843724916780261926748%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161843724916780261926748&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-88079011.pc_search_result_hbase_insert&utm_term=python&spm=1018.2226.3001.4187">Python学习路线（2021修正版）</a></li><li><a href="https://blog.csdn.net/xufive/article/details/102993570?ops_request_misc=&request_id=&biz_id=102&utm_term=python&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-102993570.pc_search_result_hbase_insert&spm=1018.2226.3001.4187">致Python初学者</a></li><li><a href="https://blog.csdn.net/luanpeng825485697/article/details/78347433?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161843724916780271586245%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161843724916780271586245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-9-78347433.pc_search_result_hbase_insert&utm_term=python&spm=1018.2226.3001.4187">python系列文章(基础，应用，后端，运维，自动化测试，爬虫，数据分析，可视化，机器学习，深度学习系列内容)</a></li><li><a href="https://blog.csdn.net/weixin_44318830/article/details/103739987?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161843724916780271586245%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161843724916780271586245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-18-103739987.pc_search_result_hbase_insert&utm_term=python&spm=1018.2226.3001.4187">全网最全Python学习路线图+14张思维导图</a></li></ol><hr><h2 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2 基础语法"></a>2 基础语法</h2><h3 id="2-1-标识符"><a href="#2-1-标识符" class="headerlink" title="2.1 标识符"></a>2.1 标识符</h3><p>标识符主要作用就是作为变量、函数、类、模块以及其他对象的名称，<strong>Python 中标识符的命名不是随意的，而是要遵守一定的命令规则，</strong> 如下：</p><ol><li>标识符对大小写敏感，且第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符不能和 Python 中的保留字相同。</li><li>标识符中不能包含空格、@、% 以及 $ 等特殊字符。</li></ol><blockquote><p>在Python中，以下划线开头的标识符有特殊含义，如下</p><ul><li>以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；</li><li>以双下划线开头的标识符（如__add）表示类的私有成员；</li><li>以双下划线作为开头和结尾的标识符（如 __init__），是专用标识符。<br>综上，除非特定场景需要，应避免使用以下划线开头的标识符。</li></ul></blockquote><p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了，但我们应尽量避免使用汉字作为标识符，容易遇到奇葩的错误。</p><blockquote><p>不同场景中的标识符，其名称也有一定的规范可循，具体如下：</p><ul><li>当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register 等。</li><li>当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 com.mr、com.mr.book 等。</li><li>当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。</li><li>模块内部的类名，可以采用 “下划线+首字母大写” 的形式，如 _Book；</li><li>函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；</li><li>常量命名应全部使用大写字母，单词之间可以用下划线分割；</li></ul></blockquote><h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h3><p>关键字即保留字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 开发程序时，不能将保留字作为变量、函数、类、模块和其他对象的名称来使用。在<code>Python</code>中，所有保留字区分大小写。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>为了规范页面编码，方便他人了解文件所用编码，建议在文件中使用中文编码声明注释。默认情况下，<strong>Python3源码文件以“可变长编码”的UTF-8编码，所有字符串都是unicode字符串。</strong> UTF-8编码把一个<code>Unicode</code>字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。了解更多，可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896">ASCII、GB2312、Unicode、UTF-8编码</a><br>在Linux下为源码文件指定编码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><h3 id="2-3-代码规范"><a href="#2-3-代码规范" class="headerlink" title="2.3 代码规范"></a>2.3 代码规范</h3><p><strong>1、注释</strong></p><p>注释（Comments）用来向用户提示或解释某些代码的作用和功能，它可以出现在代码中的任何位置。Python 解释器在执行代码时会忽略注释，不做任何处理，就好像它不存在一样。Python中单行注释以 <code>#</code> 开头，多行注释可以用多个<code>#</code>，也可以使用<code>&#39;&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>) <span class="comment"># 第二个注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第三个注释</span></span><br><span class="line"><span class="string">第四个注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第五注释</span></span><br><span class="line"><span class="string">第六注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> Python 多行注释不支持嵌套。添加注释时，一定要有意义，即注释能充分解释代码的功能及用途。注释除了可以解释代码的功能与用途，也可以用于临时注释不想执行的代码。</p><p><strong>2、行与缩进</strong></p><p><code>Python</code>最具特色的就是使用缩进来表示代码块，不需要使用大括号<code>&#123; &#125;</code>。<code>Python</code>对代码缩进要求非常严格，同一级别的代码块缩进必须相同。如果不采用合理的代码缩进，将抛出<code>SyntaxError</code>异常。<strong>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数，通常情况下是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。</strong> 示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。将首行及后面的代码组称为一个子句(clause)。</p></blockquote><p><strong>3、多行语句</strong></p><p>Python通常是一行写完一条语句，但如果语句很长，我们可以使用<strong>右反斜杠（\）</strong> 来实现多行语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">item_two + \</span><br><span class="line">item_three</span><br></pre></td></tr></table></figure><p>在[]，{}，或（）中的多行语句，不需要使用反斜杠（\），例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math; <span class="built_in">print</span>(math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p><strong>4、空行</strong></p><p><strong>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</strong></p><p>空行与代码缩进不同，空行并不是<code>Python</code>语法的一部分。书写时不插入空行，<code>Python</code>解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><blockquote><p>Python 采用 <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。下面列出PEP 8 中初学者应严格遵守的一些编码规则：</p><ol><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块。</li><li>不要在行尾添加分号，也不要用分号将两条命令放在同一行。</li><li>建议每行不超过 80 个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠 \ 进行连接。（例外：导入模块的语句过长；注释里的URL）</li><li>使用必要的空行可以增加代码的可读性，通常在顶级定义（如函数或类的定义）之间空两行，而方法定义之间空一行，另外在用于分隔某些功能的位置也可以空一行。</li><li>通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。</li><li>应该避免在循环中使用“+”和“&#x3D;”运算符累加字符串。这是因为字符串是不可变的，这样做会创建不必要的临时对象。推荐将每个子字符串加入列表，然后在循环结束后使用<code>join()</code>方法连接列表。</li><li>适当使用异常处理结构提高程序容错性，但不能过多依赖异常处理结构，适当的显式判断还是必要的。</li></ol></blockquote><p><strong>5、命名规范</strong></p><ul><li>模块名尽量短小，并且全部使用小写字母，可以使用下划线分隔多个字母。例如，<code>game_main</code>、<code>game_register</code>、<code>bmiexponent</code>都是推荐使用的模块名称。</li><li>包名尽量短小，并且全部使用小写字母，不推荐使用下划线。例如，<code>com.mingrisoft</code>、<code>com.mr</code>、<code>com.mr.book</code>都是推荐使用的包名称，而<code>com_mingrisoft</code>就是不推荐的。</li><li>类名采用单词首字母大写形式(即<code>Pascal</code>风格)。例如，定义一个借书类，可以命名为BorrowBooke。</li><li>模块内部的类采用下划线“_”+<code>Pascal</code>风格的类名组成。例如，在<code>BorrowBook</code>类中的内部类，可以使用<code>_BorrowBook</code>命名。</li><li>函数、类的属性和方法的命名规则同模块类似，也是全部使用小写字母，多个字母间用下划线“_”分隔。</li><li>常量命名时全部使用大写字母，可以使用下划线。</li><li>使用单下划线“_”开头的模块变量或者函数是受保护的，在使用<code>from xxx import *</code>语句从模块中导入时这些变量或者函数不能被导入。</li><li>使用双下划线“_”开头的实例变量或方法是类私有的。</li></ul><h3 id="2-4-导入模块"><a href="#2-4-导入模块" class="headerlink" title="2.4 导入模块"></a>2.4 导入模块</h3><p>模块就是<code>Python</code>程序，<strong>在<code>Python</code>中导入模块后，我们就可以使用该模块里定义的类、方法或者变量，这样既可以提高代码的可重用性，又可以避免变量冲突，我们通常用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。</strong> 像<code>def</code>一样，<code>import</code> 和 <code>from</code> 是可执行的语句，他们可以出现在 <code>if</code> 中，可以出现在函数中，执行到这些语句的时候才会进行解析，换句话说，被导入的模块和变量名只有在对应的 <code>import</code> 或 <code>from</code> 语句执行后才可以使用。</p><blockquote><p>  模块，可以理解为是对代码更高级的封装，即把能够实现某一特定功能的代码编写在同一个 .py 文件中，并将其作为一个独立的模块，这样既可以方便其它程序或脚本导入并使用，同时还能有效避免函数名和变量名发生冲突。</p></blockquote><p><strong>1、import语句</strong></p><p>既可以一行导入单个模块，也可以一行内导入多个模块，这里以常用的 <code>math</code> 和 <code>random</code> 模块为例，具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math<span class="comment"># 导入math整个模块</span></span><br><span class="line"><span class="built_in">print</span>(math.pi)<span class="comment"># 使用math模块名作为前缀来访问模块中的成员</span></span><br></pre></td></tr></table></figure><p>一次导入多个模块，多个模块之间用逗号隔开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math,random<span class="comment"># 导入math、random两个模块</span></span><br><span class="line"><span class="built_in">print</span>(math.pi)<span class="comment"># 输出π的近似值，十五位小数</span></span><br><span class="line"><span class="built_in">print</span>(random.random())<span class="comment"># 生成一个[0, 1.0)的随机小数</span></span><br></pre></td></tr></table></figure><blockquote><p>Python 不建议一行 import 所有模块，而是推荐用多行 import 来导入模块。更多的是出于操作便利性的原因，与代码本身无关，这样更易于阅读；更易于编辑；更易于维护。</p></blockquote><blockquote><p>import工作方式：Python会在两个地方寻找这个模块，第一个地方是在sys.path（可以运行代码import sysprint(sys.path)查看），一般安装的Python库的目录都可以在sys.path中找到（要将Python的安装目录添加到电脑的环境变量），对于安装好的库，我们直接import即可。第二个地方就是运行文件所在的目录。如果在一个模块的顶层导入，那么它的作用域就是全局的；如果在函数中导入，那么它的作用域是局部的。 如果模块是被第一次导入，它将被加载并执行。</p></blockquote><p><strong>2、import-as</strong></p><p>导入整个模块时，也可以为模块指定别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m<span class="comment"># 导入math整个模块，并制定别名为m</span></span><br><span class="line"><span class="built_in">print</span>(m.pi)<span class="comment"># 使用m模块别名作为前缀来访问模块中的成员</span></span><br></pre></td></tr></table></figure><p>在导入多个模块时，也可以为模块指定别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m, random <span class="keyword">as</span> ran<span class="comment"># 导入math、random两个模块，并为math指定别名m，为random指定别名ran</span></span><br><span class="line"><span class="built_in">print</span>(m.pi)</span><br><span class="line"><span class="built_in">print</span>(ran.random())</span><br></pre></td></tr></table></figure><p><strong>3、from-import</strong></p><p>下面使用 <code>from...import</code> 导入指定成员，即把指定成员导入到当前作用域，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi<span class="comment"># 导入math模块的pi成员</span></span><br><span class="line"><span class="built_in">print</span>(pi)<span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br></pre></td></tr></table></figure><p>导入模块成员时，也可以为成员指定别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi <span class="keyword">as</span> P<span class="comment"># 导入math模块的pi成员，并指定别名P</span></span><br><span class="line"><span class="built_in">print</span>(P)<span class="comment"># 使用导入成员（并指定别名）的语法，直接使用成员的别名访问</span></span><br></pre></td></tr></table></figure><p><code>form...import</code> 导入模块成员时，支持一次导入多个成员，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi, sqrt<span class="comment"># 导入math模块的pi，sqrt成员</span></span><br><span class="line"><span class="built_in">print</span>(pi)<span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br><span class="line"><span class="built_in">print</span>(sqrt(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>一次导入多个模块成员时，也可指定别名，同样使用 as 关键字为成员指定别名，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi <span class="keyword">as</span> P, sqrt <span class="keyword">as</span> sq<span class="comment"># 导入math模块的pi，sqrt成员，并为其指定别名P，sq</span></span><br><span class="line"><span class="built_in">print</span>(P)<span class="comment"># 使用导入成员（并指定别名）的语法，直接使用成员的别名访问</span></span><br><span class="line">paint(sq(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>在使用 <code>from...import</code> 语法时，可以一次导入指定模块内的所有成员（存在不同模块，相同成员名的情况，从而发生冲突，此方式不推荐），如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> *<span class="comment"># 导入math棋块内的所有成员</span></span><br><span class="line"><span class="built_in">print</span>(pi)<span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br><span class="line"><span class="built_in">print</span>(sqrt(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><blockquote><p>只在两种场合下建议使用这样的方法，一个场合是：目标模块中的属性非常多，反复键入模块名很不方便，例如 Tkinter (Python&#x2F;Tk) 和 NumPy (Numeric Python) 模块，可能还有 socket 模块。另一个场合是在交互解释器下，这样可以减少输入次数。</p></blockquote><h3 id="2-5-输入输出"><a href="#2-5-输入输出" class="headerlink" title="2.5 输入输出"></a>2.5 输入输出</h3><p><code>input()</code>是 Python 的内置函数，用于从控制台读取用户输入的内容。**<code>input()</code>函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)<span class="comment"># 数据以字符串的形式返回</span></span><br><span class="line">number1 = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>)<span class="comment"># eval()去掉&quot; &quot;，将字符串转化为有效的表达式，来求值，并返回计算结果，和str()功能刚好相反</span></span><br><span class="line">number2 = val(<span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;val() 函数当识别到非数字，停止读入字符串,字符串中的空格和换行符会被去掉。即如果字符串内有字母或其他非数字字符，</span></span><br><span class="line"><span class="string">val()函数只转换第一个非数字字符之前的数字。当字符串的首字符为非数字时，返回值为0。该函数也可以识别进制符号&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>print()</code> 默认输出是换行的，如果要实现不换行，需要在变量末尾加上 <code>end=&quot; &quot;</code>，输出多个变量时，print() 函数默认以空格隔开多个变量，想要使用不同的分隔符，可以使用缺省参数<code>seq=&#39;:&#39;</code>，可以通过<code>help(&quot;print&quot;)</code>了解更多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;网站：&quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;百度&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment"># str.format()实现字符串格式化，大括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;GitHub&#x27;</span>, <span class="string">&#x27;CSDN&#x27;</span>))<span class="comment"># 括号中的数字用于指向传入对象在format()中的位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你是:%s, %d岁&quot;</span> % (<span class="string">&quot;CSDN&quot;</span>, <span class="number">22</span>)<span class="comment"># % 操作符也可以实现字符串格式化</span></span><br><span class="line"><span class="comment"># 推荐使用str.format()，&#123;&#125;里可以添加可选项：和格式标识符，这样可以对值进行更好的格式化</span></span><br></pre></td></tr></table></figure><blockquote><p>%或者{}都可以看做转换说明符，转换说明符（Conversion Specifier）只是一个占位符，它会被后面表达式（变量、常量、数字、字符串、加减乘除等各种形式）的值代替。</p></blockquote><p><strong>1、%使用</strong></p><center><strong>表1 Python转换说明符</strong></center><table><thead><tr><th>转换说明符</th><th>解释</th></tr></thead><tbody><tr><td>%d、%i</td><td>转换为带符号的十进制整数</td></tr><tr><td>%o</td><td>转换为带符号的八进制整数</td></tr><tr><td>%x、%X</td><td>转换为带符号的十六进制整数</td></tr><tr><td>%e、%E</td><td>转化为科学计数法表示的浮点数（输出e的大小写不一样）</td></tr><tr><td>%f、%F</td><td>转化为十进制浮点数</td></tr><tr><td>%g、%G</td><td>智能选择使用 %f 或 %e 格式</td></tr><tr><td>%c</td><td>格式化字符及其 ASCII 码</td></tr><tr><td>%r</td><td>使用 repr() 函数将表达式转换为字符串</td></tr><tr><td>%s</td><td>使用 str() 函数将表达式转换为字符串</td></tr></tbody></table><p><strong>(1) 整数的输出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%o&#x27;</span> % <span class="number">24</span>)<span class="comment"># 转换为八进制输出</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%d&#x27;</span> % <span class="number">24</span>）</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p><strong>(2) 浮点数的输出</strong></p><ul><li>%f ——默认保留小数点后面六位，例：%.3f，保留3位小数位</li><li>%e ——保留小数点后面六位有效数字，指数形式输出，例：%.3e，保留3位小数位，使用科学计数法</li><li>%g ——在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法，例：%.3g，保留3位有效数字，使用小数或科学计数法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">6.6666</span>)<span class="comment"># 取3位小数</span></span><br><span class="line"><span class="number">6.666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%.3e&#x27;</span> % <span class="number">1.11</span>)<span class="comment"># 取3位小数，用科学计数法</span></span><br><span class="line"><span class="number">1.110e+00</span></span><br></pre></td></tr></table></figure><p><strong>(3) 字符串输出</strong></p><ul><li>%10s——右对齐，占位符10位</li><li>%-10s——左对齐，占位符10位</li><li>%.2s——截取2位字符串</li><li>%10.2s——10位占位符，截取两位字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%10s&#x27;</span> % <span class="string">&#x27;hello&#x27;</span>)<span class="comment"># 右对齐，取10位，不够则补位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%-10.2s&#x27;</span> % <span class="string">&#x27;hello&#x27;</span>)  <span class="comment"># 左对齐，取10位，并截取两位字符串，并用空格补位</span></span><br></pre></td></tr></table></figure><p><strong>2、format使用</strong></p><p><strong>(1) 位置匹配</strong></p><ul><li>不带编号，即“{}”</li><li>带数字编号，可调换顺序，即“{1}”、“{2}”</li><li>带关键字，即“{key1}”、“{key2}”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; &#123;1&#125; &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>))<span class="comment"># 带数字编号，并打乱顺序</span></span><br><span class="line">hello world hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;key1&#125; &#123;key2&#125; &#123;key1&#125;&#x27;</span>.<span class="built_in">format</span>(key1=<span class="string">&#x27;world&#x27;</span>, key2=<span class="string">&#x27;hello&#x27;</span>))<span class="comment"># 带关键字</span></span><br><span class="line">world hello world</span><br></pre></td></tr></table></figure><p><strong>(2) 格式转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;:b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">2</span>))<span class="comment"># 转换为二进制输出</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;:%&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0.2</span>))<span class="comment"># 将数值乘以100，然后以小数点保留六位格式打印，值后面会有一个百分号</span></span><br><span class="line"><span class="number">20.000000</span>%</span><br></pre></td></tr></table></figure><p><strong>(3) 进阶用法</strong></p><ul><li>指定小数精度和输出宽度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:8.4f&#125;&#x27;</span>.<span class="built_in">format</span>(pi))<span class="comment"># 位置为0，最小宽度为8，小数点后4位；:m.nf表示宽度为m，小数位为n，m和n都可以不指定</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:10s&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Hello&#x27;</span>))<span class="comment"># 输出字符串的宽度至少为10</span></span><br></pre></td></tr></table></figure><ul><li>指定对齐方式<br>&lt;——左对齐，&gt;——右对齐，^——居中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:^10s&#125; and &#123;:&gt;10s&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Github&#x27;</span>, <span class="string">&#x27;CSDN&#x27;</span>))<span class="comment"># 取10位居中，取10位右对齐</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:*^10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;CSDN&#x27;</span>))<span class="comment"># 使用*填充</span></span><br></pre></td></tr></table></figure><p>Python格式化输出，了解更多，请参考：<a href="https://www.cnblogs.com/fat39/p/7159881.html">%用法和format用法</a></p><h3 id="2-6-内建函数"><a href="#2-6-内建函数" class="headerlink" title="2.6 内建函数"></a>2.6 内建函数</h3><p>Python 解释器自带的函数叫做内置函数，这些函数可以直接使用，不需要导入某个模块。</p><blockquote><p>内置函数与标准库函数的对比：内置函数是解释器的一部分，它随着解释器的启动而生效；标准库函数是解释器的外部扩展，导入模块以后才能生效。一般来说，内置函数的执行效率要高于标准库函数。</p></blockquote><p>上一小节的 <code>print()</code> 函数就是内置函数，Python 解释器还提供了更多内置函数，以下按字母表顺序列出：</p><center><strong>表2 Python3 内置函数</strong></center><table class="docutils align-default"><colgroup><col style="width: 20%" /><col style="width: 18%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 22%" /></colgroup><tbody><tr class="row-even"><td><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></td><td><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></td><td><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></td><td><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></td><td><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></td><td><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></td><td><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></td><td><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></td><td><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></td><td><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></td><td><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></td><td><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></td><td><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></p></td><td><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></p></td><td><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></p></td><td><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></p></td><td><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></p></td><td><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></p></td><td><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></p></td><td><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></p></td><td><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></p></td><td><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></p></td><td><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></p></td><td><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></p></td><td><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a></p></td><td><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></p></td><td><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></p></td><td><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></p></td><td><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></p></td><td><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></p></td><td><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></p></td><td><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></p></td><td><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></p></td><td><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></p></td><td><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></p></td><td><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></p></td><td><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></p></td><td><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></p></td><td><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></p></td><td><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></p></td><td><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></p></td><td><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></p></td><td><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></p></td><td><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></p></td><td><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></p></td><td><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></p></td><td><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></p></td><td><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></p></td><td><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></p></td></tr></tr><tr class="row-even"><td><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></p></td><td><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></p></td><td><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></p></td><td><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></p></td><td><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></p></td><td><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></p></td><td><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></p></td><td><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></p></td><td></td></tr></tbody></table><p>各个内置函数的具体功能和用法，可以查看：<a href="https://docs.python.org/zh-cn/3/library/functions.html">https://docs.python.org/zh-cn/3/library/functions.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 基本使用</title>
      <link href="/article/6c09ec5e.html"/>
      <url>/article/6c09ec5e.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍 Markdown 基本使用，主要包括文本格式，如标题设置、加粗文本、斜体、下划线、删除线、引用、列表等；接着介绍插入表格、超链接、图片等。</p><span id="more"></span><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1 基本用法"></a>1 基本用法</h2><h3 id="1-1-文本格式"><a href="#1-1-文本格式" class="headerlink" title="1.1 文本格式"></a>1.1 文本格式</h3><p><strong>1. 设置分级标题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><strong>2. 加粗文本</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**我的博客**</span><br></pre></td></tr></table></figure><p><strong>印象笔记</strong></p><p><strong>3. 斜体</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*印象笔记*</span><br><span class="line">**天天向上**</span><br><span class="line">*努力学习*</span><br></pre></td></tr></table></figure><p><em>印象笔记</em><br><strong>天天向上</strong><br><em>努力学习</em></p><hr><p><strong>4. 下划线</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>how are you<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure><p><u>how are you</u></p><p><strong>5. 删除线</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~印象笔记不支持Markdown~~</span><br></pre></td></tr></table></figure><p><del>印象笔记不支持Markdown</del></p><p><strong>6. 添加分割线</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><p>哈哈</p><hr><p>那就这样吧</p><hr><p><strong>7. 引用文本</strong></p><p>文本前加<code>&gt;</code>就可以了，如下所示：</p><blockquote><p>鲁迅说：“横眉冷对千夫指，俯首甘为孺子牛”。</p></blockquote><p><strong>8. 添加符号列表和数字列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何写代码</span><br><span class="line">1. 下载编辑器</span><br><span class="line">2. 找到代码框架</span><br><span class="line">3. 根据语法编写</span><br></pre></td></tr></table></figure><p>如何写代码</p><ol><li>下载编辑器</li><li>找到代码框架</li><li>根据语法编写</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 编辑器正确</span><br><span class="line">- 语法合法</span><br></pre></td></tr></table></figure><ul><li>编辑器正确</li><li>语法合法</li></ul><hr><p><strong>9. 添加待办事项</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第十周工作安排</span><br><span class="line">* [x] 周一上课</span><br><span class="line">* [ ] 周二写作业</span><br><span class="line">* [X] 周三锻炼</span><br></pre></td></tr></table></figure><p>第十周工作安排</p><ul><li><input checked="" disabled="" type="checkbox"> 周一上课</li><li><input disabled="" type="checkbox"> 周二写作业</li><li><input checked="" disabled="" type="checkbox"> 周三锻炼</li></ul><h3 id="1-2-内容插入"><a href="#1-2-内容插入" class="headerlink" title="1.2 内容插入"></a>1.2 内容插入</h3><p><strong>1. 插入链接</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度百科](https://baike.baidu.com/)</span><br></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/">百度百科</a></p><p><strong>2. 插入图片</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![img](https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.nmjr2hxcr5c.webp)</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.nmjr2hxcr5c.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.nmjr2hxcr5c.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>3. 插入表格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|账户类型|免费账户|标准账户|高级账户|</span><br><span class="line">|---|---|---|---|</span><br><span class="line">| 帐户流量 | 60M | 1GB | 10GB |</span><br><span class="line">| 设备数目 | 2台 | 无限制 | 无限制 |</span><br><span class="line">| 当前价格 | 免费 | ￥8.17/月 | ￥12.33/月|</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>账户类型</th><th>免费账户</th><th>标准账户</th><th>高级账户</th></tr></thead><tbody><tr><td>帐户流量</td><td>60M</td><td>1GB</td><td>10GB</td></tr><tr><td>设备数目</td><td>2台</td><td>无限制</td><td>无限制</td></tr><tr><td>当前价格</td><td>免费</td><td>￥8.17&#x2F;月</td><td>￥12.33&#x2F;月</td></tr></tbody></table><p><strong>4. 插入行内代码或代码块</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#python</span><br><span class="line">import turtle</span><br><span class="line">turtle.pensize(50)</span><br><span class="line">turtle.down</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**5. 插入数学公式**</span><br><span class="line"></span><br><span class="line">印象笔记 Markdown 支持绝大多数的 LaTeX 数学公式，行间公式使用`$$f(x)=sin(x)$$`，行内公式使用`$\pmb&#123;A&#125;\in&#123;\mathcal&#123;R&#125;&#125;$`</span><br><span class="line">~~你太菜了~~</span><br><span class="line"></span><br><span class="line">```math</span><br><span class="line">e^&#123;i/pi&#125; +1 = 0</span><br></pre></td></tr></table></figure><p>详细了解，可以参考：<a href="https://www.zybuluo.com/codeep/note/163962#3">Cmd Markdown 公式指导手册</a></p><p><strong>6. 设置目录</strong></p><p>设置之后可以自动根据设置的分级标题来自动生成目录。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@[TOC]</span><br></pre></td></tr></table></figure><h2 id="2-多学几招"><a href="#2-多学几招" class="headerlink" title="2 多学几招"></a>2 多学几招</h2><p>Markdown也支持HTML格式，于是可以设置复杂的文本格式，比如页内跳转、图片大小，图片标题的设置等等</p><p><strong>1. 字体颜色设置</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#9900CC</span> &gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span> /etc/sudoers<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span>       </span><br></pre></td></tr></table></figure><p><font color=#9900CC ><strong> &#x2F;etc&#x2F;sudoers</strong></font>   </p><p><strong>2. 多个空格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. 换行</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. 复杂的表格设计</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span> <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>可分享的(shareable)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>不可分享的(unshareable) <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>不可变的(static) <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/usr(软件放置处)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/etc(配置文件)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/opt(第三方软件)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/boot(开机及内核文件)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>可变动的(variable) <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/var/mail(用户邮件信箱)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>/var/run(程序相关)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/var/news(新闻组)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/var/lock(文件锁相关)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th> </th>    <th colspan="3">可分享的(shareable)</th>    <th colspan="3">不可分享的(unshareable) </th>  </tr>  <tr>    <td rowspan="2"><center>不可变的(static) </center></td>    <td colspan="3"><center>/usr(软件放置处)</center></td>    <td colspan="3"><center>/etc(配置文件)</center></td>  </tr>  <tr>    <td colspan="3"><center>/opt(第三方软件)</center></td>    <td colspan="3"><center>/boot(开机及内核文件)</center></td>  </tr>  </tr>  <tr>    <td rowspan="2"><center>可变动的(variable) </center></td>    <td colspan="3"><center>/var/mail(用户邮件信箱)</center></td>    <td colspan="3">/var/run(程序相关)</center></td>  </tr>  <tr>    <td colspan="3"><center>/var/news(新闻组)</center></td>    <td colspan="3"><center>/var/lock(文件锁相关)</center></td>  </tr>  </table>  <p><strong>5. 合并单元格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>6. 给图片添加题注</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> <span class="attr">src</span>=<span class="string">&quot;这里输入图片地址&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;&quot;</span>&gt;</span>这里输入题注<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span> <span class="attr">class</span> = <span class="string">&quot;half&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> =<span class="string">&quot;https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2lqrscnuavs0.webp#pic_left&quot;</span> <span class="attr">width</span> = <span class="string">&quot;32%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/003.748m7etco700.webp#pic_left&quot;</span>  <span class="attr">width</span> = <span class="string">&quot;36%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改width的值就可以修改图片大小。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2lqrscnuavs0.webp#pic_left" width = "32%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/003.748m7etco700.webp#pic_right"  width = "36%"></center></p><p><strong>7. 页内跳转</strong></p><p>定义一个锚(id)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用markdown语法：[点击跳转](#jump)</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;jump&quot;</span>&gt;</span>跳转到的地方<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 PicX 创建免费的图床神器</title>
      <link href="/article/a559cbc7.html"/>
      <url>/article/a559cbc7.html</url>
      
        <content type="html"><![CDATA[<p>写博客文章时，图片的上传和存放是一个问题，我们也许会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片。为了解决这些问题，做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床。其返回一个图片的URL，使用 <code>markdown+图片url</code> 的方式写作文章，然后就可以直接使用链接引入图片。最后，整篇文章复制即可，再也不用担心图片的问题了。</p><span id="more"></span><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>PicX，基于 GitHub API 开发的图床管理神器，图片外链使用 jsDelivr 进行全球 CDN 加速。免费、稳定、高效。免下载、免安装，只需一个 <strong>GitHub 账号</strong>，打开网站即可进行配置使用，轻松解决图床难题。</p><p>一共3个步骤就完成设置了</p><ol><li>创建 GitHub 仓库</li><li>获取 GitHub Token</li><li>配置图床</li></ol><p>网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpicx.xpoet.cn%2F" target="_blank" title="https://picx.xpoet.cn/" ref="nofollow noopener noreferrer">picx.xpoet.cn/</a></p><p>仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FXPoet%2Fpicx" target="_blank" title="https://github.com/XPoet/picx" ref="nofollow noopener noreferrer">github.com/XPoet/picx</a></p><p>文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FXPoet%2Fpicx%2Fblob%2Fmaster%2FREADME.md" target="_blank" title="https://github.com/XPoet/picx/blob/master/README.md" ref="nofollow noopener noreferrer">github.com/XPoet/picx/…</a></p><p><strong>1. 创建 GitHub 仓库</strong></p><p>创建 一个用来存储图片的 GitHub 仓库，仓库属性必须选 Public 。</p><p>点击链接 <a href="https://github.com/">https://github.com/</a> 快速新建仓库</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/123.5icizwyveeg0.webp#pic_center" width = 48%/><p><strong>2. 创建 GitHub Token</strong></p><p>PicX 的图床服务依赖于 <code>GitHub Token</code>，在开始使用之前，你必须先 创建 一个带有 repo 权限的 <code>GitHub Token</code>。</p><p>点击 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 快速新建 GitHub Token</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/124.25nlu5i5j1ds.webp#pic_center" width = 48%/><p>这里我们填完名称和勾选上repo选项之后呢，然后直接点击 Generate token 按钮，即可生成一个token，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/001.6lklllgnfxc0.webp#pic_center" width = 48%/><p>注意：这里英文的意思是：确保立即复制您的个人访问令牌。你将无法再看到它！那万一没了重新生成一个就行。</p><p><strong>3. 配置图床</strong></p><p><strong>1) 一键自动配置</strong></p><p>填写 GitHub Token，点击 “一键自动配置” 按钮会自动创建 GitHub 仓库，并完成仓库、分支和目录之间的绑定。</p><ul><li>一键自动配置 &gt; 创建的仓库：picx-images-hosting</li><li>一键自动配置 &gt; 创建的分支：master</li><li>一键自动配置 &gt; 创建的目录：yyyyMMdd (当天日期，例如：20230403)</li></ul><p>如果你刚开始使用 PicX，那么推荐使用一键自动配置，非常方便。当然你也可以随时切换成手动配置。</p><p><strong>2) 手动配置</strong></p><p>填入刚刚在Github生成的Token，点击确认Token。会自动获取该用户下的仓库</p><p>如果你绑定的仓库有多个分支，那么会出现选择分支的下拉列表，否则直接进入选择目录。</p><p>多个分支情况，选择其中一个即可。PicX 暂时不支持新建分支，需要你手动去创建。只有一个分支情况，无分支下拉列表。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/128.62w39qmdbb00.webp#pic_center" width = 48% /><ul><li>新建目录：需手动输入一个新目录。</li><li>根目录：图片将直接存储在仓库根目录下。</li><li>自动目录：自动生成日期格式 YYYYMMDD 的目录。例如：20230526</li><li>选择仓库目录：自动获取仓库下所有目录，选择一个即可。</li></ul><p>至此，完成图床配置，点击 “确认” 按钮即可跳转到图片上传界面。</p><blockquote><p>如果想对图片进行一个分类怎么办呢？<br>这个也很简单，新建一个文件夹然后再上传，等到下次还要上传到这个文件夹，我们在目录方式中勾选选择仓库目录，就会展示你创建的所有文件夹。然后进行选择。</p></blockquote><p><a href="https://qxienote.com/">https://qxienote.com/</a></p><p><strong>4. 上传图片</strong></p><p>在上传图片界面，你可以使用 拖拽文件、复制粘贴、选择文件 这三种方式选择你的图片到上传区域。</p><ul><li>你可以拖拽 一张 或 多张 图片到上传区域。</li><li>你可以先将一张图片复制（快捷键 Ctrl+C &#x2F; Command+C）到系统剪贴板，然后在 PicX 上传界面通过按下快捷键 Ctrl+V &#x2F; Command+V 将图片粘贴到上传区域。</li><li>你可以选择 一张 或 多张 图片到上传区域。</li></ul><p>选择图片完成后，在上传之前，可以自由修改图片名。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/131.1zt39d3iin5s.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/131.1zt39d3iin5s.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="131" width=48% /><p>勾选中哈希化，会在图片名称加上一串哈希值，确保图片名的唯一性，强烈建议开启。</p><p>图片上传成功之后，会自动复制图片链接到系统剪贴板，也可以点击 “复制链接” 按钮进行复制。</p><p><strong>5. 图床管理</strong></p><p>点击左侧菜单栏的图床管理，我们可以看到当前目录是我们选择的 2230526</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/132.3r5biof03tg0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/132.3r5biof03tg0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="132" width=48% /><p>双击目录图标，可进入下一级目录，点击图片，可放大预览。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/133.94otifievhs.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/133.94otifievhs.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="133" width=48% /><p>支持的操作：</p><ul><li>在属性面板，可以查看到图片名称和图片大小。</li><li>在重命名输入框键入新名称后，按回车键确认。</li><li>删除单张图片&#x2F;批量删除多张图床</li><li>复制&#x2F;批量复制链接</li></ul><p><strong>6. 我的设置</strong></p><p>在我的设置界面，你可以体验到 PicX 图床丰富多彩的功能，根据自己需求调整最佳配置。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/130.6ywi4j6ahwc.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/130.6ywi4j6ahwc.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="130" width=48% /><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>使用 PicX 创建免费的图床神器：<a href="https://juejin.cn/post/6991273636493524999">https://juejin.cn/post/6991273636493524999</a></li><li>图床配置：<a href="https://picx-docs.xpoet.cn/usage-guide/config.html">https://picx-docs.xpoet.cn/usage-guide/config.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIGC使用教程（一）-- ChatGPT 注册与基本使用</title>
      <link href="/article/ad3c5526.html"/>
      <url>/article/ad3c5526.html</url>
      
        <content type="html"><![CDATA[<p>本篇带你走进 AIGC 的基本使用，一步一步注册 ChatGPT，申请自己的 API 进行使用，解决代理的问题，最后介绍如何本地部署 ChatGPT，以及通过免费云平台搭建代理转发，从而不需要使用魔法就可以访问。</p><span id="more"></span><h2 id="1-ChatGPT-注册"><a href="#1-ChatGPT-注册" class="headerlink" title="1 ChatGPT 注册"></a>1 ChatGPT 注册</h2><p>受限于ChatGPT的服务器以及相关要求影响，其注册比较繁琐，在国内是无法使用的，而我们又想体验一下ChatGPT，具体ChatGPT怎么注册呢？我综合了网络上的各种注册教程，整理了这篇文章，供大家学习和使用。</p><h3 id="1-1-工具准备"><a href="#1-1-工具准备" class="headerlink" title="1.1 工具准备"></a>1.1 工具准备</h3><p>注册&#x2F;登录环境要求：</p><ul><li>注册和登陆需要 magic 环境。</li><li>需要有一个可以接收验证码的 magic 手机号，同样地区也是如上述网络环境之外的地区手机号（注意部分虚拟手机号的厂家无法接受验证码，请注意甄别）。</li></ul><p><strong>1. 注册工具准备</strong></p><p>在注册ChatGPT之前，需要准备好以下几个工具：</p><ol><li>一个邮箱（我们用的Gmail邮箱，经测试其他邮箱也可以）</li><li>magic 工具（自行百度，或者私信我）</li><li>一个 magic 手机号（后文将详细告诉你如何花少许人民币获取一个临时 magic 手机号）</li></ol><p>在以上三个工具中，可能大部分人前两个工具已经有了。但很多人没有 magic 手机号。下面我们一起来看一下如何快速，低费用获取一个能接收ChatGPT验证短信的 magic 手机号。</p><p><strong>2. 购买一个临时国外手机号</strong></p><p>首先，登录一个 magic 临时手机号购买网站：<a href="https://sms-activate.org/">https://sms-activate.org/</a></p><ol><li>进入 <a href="https://sms-activate.org/">SMS-Activate是在线接收短信的虚拟号码服务平台</a> 的首页，选择右上角【注册】按钮，在弹出的窗口中继续选择【注册】按钮：</li></ol><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2qq2oz4gnhi0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2qq2oz4gnhi0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="012" width = 48%/><ol><li>输入邮箱、设置密码完成账号注册,（不建议用国内的邮箱，避免收不到问题，最好是Gmail之类的），密码长度在8位以上且必须包含拉丁字母和数字，至少一个大写字母。登录你的邮箱，然后你会收到一封标题为《确认电子邮件来注册SMS-Activate账户》这样的邮件，点击邮件中的【确认】按钮，注册成功后，在账号中，点击右上角的充值。提示：如果收件箱找不到，看一下垃圾箱或者黑名单&#x2F;规则之类是不是过滤掉了。如果实在没有，建议换一个邮箱试试。</li></ol><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2yj3a24fot40.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2yj3a24fot40.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="013" width = 48%/><ol><li>确认帐号注册成功后，登录平台，不过帐号还需要充值才能使用，可以使用支付宝充值。还是右上角，选择【余额】，然后选择【充值】按钮，接着选择支付宝进行充值，这里现在要求至少充值2美元，输入2，点击最下角的支付，然后进入支付宝扫码付款页面，扫码支付即可，自动汇率换算支付人民币14.93元（你注册时可能由于汇率不同金额会有差异）。</li></ol><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/003.2v8qjmcqw4e0.webp#pic_left" width = "30%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/004.3pzrnjbmbcy0.webp#pic_left"  width = "36%"></center></p><ol><li>充值完成后，注意看个人页面右上角的余额有没有变化。然后看左侧，找到“openAI”这个，点击展开（如果没有，在选择服务-服务搜索里直接搜索一下）：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/005.4zg8mxa5h9o0.webp#pic_center" width = 24%><ol><li>接着，选择手机号码的归属地，哪个便宜买哪个。选好后直接点击对应国家后面的购物车图片即可：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/006.6zlth6754ls0.webp#pic_center" width = 24%><ol><li>购买后，账号页面右侧，可以看到你购买的手机号，然后返回到ChatGPT的页面，填入对应的手机号码，页面会自动显示出收到的短信。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/007.48y0wpvvj4g0.webp#pic_center" width = 36%><p>关于这个国外手机号说四点：</p><ul><li>这里显示的号码是包含国家代码的。比如*国手机号+254771961634，你在网站上填写手机号时，需要去掉前面的 254 这个国别代码。另外在接收验证码时，建议使用低价的印尼等手机号，印度经常挤爆收不到；如果长时间没有收到验证码，可更换成其他区域尝试。</li><li>这是一个临时手机号，有效时长20分钟</li><li>20分钟内如果没有收到验证码，可以点右侧的叉号，退订，费用还会返还。（注：一般在ChatGPT注册页面发出验证码后一分钟左右便可以收到验证码。收不到验证短信可以在20分钟到期前退订，三分钟以上收不到验证码建议就不用再等了）</li><li>如遇到无法登录的情况，请打开谷歌浏览器的无痕窗口进行登录，一般会很快登录账号。</li></ul><p>另外保留这个显示 magic 手机号的页面处于打开状态即可，便于快速回来查收验证短信。重点是：在手机验证页面，一定要注意选择正确的国家（注意国旗）！一定要注意选择正确的国家！一定要注意选择正确的国家！</p><h3 id="1-2-注册流程"><a href="#1-2-注册流程" class="headerlink" title="1.2 注册流程"></a>1.2 注册流程</h3><p><strong>1. 进入注册</strong><br>打开ChatGPT的官方网站，链接为 <a href="https://openai.com/">https://openai.com/</a>，然后点击【Sign Up】进入下一步。</p><p>如果页面无法正常显示，需要更换其他的网络节点，或者清理下浏览器cookie再次尝试。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/008.4m2curnqu1a0.webp#pic_center" width = 36%><p><strong>2. 邮箱注册</strong></p><p>注册方式为邮箱注册，可以用微软帐号或者谷歌帐号登录，微软账号或者谷歌账号好像不需要验证，国内或者其他邮箱地址都需要进行验证（比如QQ邮箱是需要验证的）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/009.1a9537ruo4rk.webp#pic_center" width = 24%><p><strong>3. 填写姓名信息</strong></p><p>邮箱通过后，会提示你输入姓名，按照要求进行输入即可。如果显示该IP地址注册数量过多，则需要更换节点（更换节点时，无需对浏览器进行重启，刷新页面即可）。</p><p><strong>4. 验证手机号（重点！！！）</strong><br>随后将会进入手机验证的环节，记住：这里不能选择国内的手机号，国内的手机号无法进行注册。</p><p>如果是只想体验一下产品的朋友，可直接在某海鲜市场购买服务，实时帮你接收验证码，非常快速。动手能力强一些的朋友，可以通过虚拟接码平台进行接收验证码。</p><p>选择手机号国别，并输入第二步中购买的手机号码，点击发送验证短信（send code）：（例如，我们买的是手机号，则选择Kenya，后面输入手机号时注意国家区号不要重复输入）</p><p>然后返回到第二步中购买手机号的页面，查收短信：(一般一分钟左右可以收到短信)</p><h3 id="1-3-申请-API"><a href="#1-3-申请-API" class="headerlink" title="1.3 申请 API"></a>1.3 申请 API</h3><p>OpenAI账号注册完成后，登录界面如下所示。点击右上角View API keys—&gt; Create new secret key，可以生成属于你自己的API，有了这个API，就可以用于开发基于ChatGPT API的应用程序。</p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/010.3ruq1w73inu0.webp#pic_left" width = "24%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/024.56cyk54rvtc0.webp#pic_left"  width = "48%"></center></p><p>需要注意的是，出于安全原因，这个API只展示一次，请务必在关闭对话框之前，将其复制到你其他的地方保管。</p><p>另外，点击左侧栏的Usage ,可以方便清晰看到token的使用量情况，数据5分钟更新一次。OpenAI官方针对每一个新注册的账户，提供$5免费token使用额度。这样一想，前面花费不到$5免费token使用额度。不过需要注意的是，免费额度有时间限制，过期了额度就作废。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/011.wvukprqvcq8.webp#pic_center" width = 48%><hr><h2 id="2-API-使用"><a href="#2-API-使用" class="headerlink" title="2 API 使用"></a>2 API 使用</h2><h3 id="2-1-简单测试"><a href="#2-1-简单测试" class="headerlink" title="2.1 简单测试"></a>2.1 简单测试</h3><p>使用 Python 简单测试，你只需 <code>import openai</code> 包，带上刚申请的API，模型选择——<code>text-davinci-003</code> 就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"> </span><br><span class="line">openai.api_key = <span class="string">&#x27;sk-xxxxxx&#x27;</span>        <span class="comment"># 填写个人API</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat_gpt</span>(<span class="params">prompt</span>):</span><br><span class="line">     prompt = prompt</span><br><span class="line">     model_engine = <span class="string">&quot;text-davinci-003&quot;</span></span><br><span class="line">     completion = openai.Completion.create(</span><br><span class="line">         engine=model_engine,</span><br><span class="line">         prompt=prompt,</span><br><span class="line">         max_tokens=<span class="number">1024</span>,</span><br><span class="line">         n=<span class="number">1</span>,</span><br><span class="line">         stop=<span class="literal">None</span>,</span><br><span class="line">         temperature=<span class="number">0.5</span>,</span><br><span class="line">         timeout=<span class="number">1000</span>,</span><br><span class="line">     )</span><br><span class="line"> </span><br><span class="line">     response = completion.choices[<span class="number">0</span>].text</span><br><span class="line">     <span class="built_in">print</span>(response)</span><br><span class="line"> </span><br><span class="line">chat_gpt(<span class="string">&quot;现在几点了&quot;</span>)          <span class="comment"># 现在是北京时间下午4点30分。</span></span><br></pre></td></tr></table></figure><blockquote><p>更多的例子，请自行参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenai.com%2Fblog%2Fintroducing-chatgpt-and-whisper-apis" target="_blank" title="https://openai.com/blog/introducing-chatgpt-and-whisper-apis" ref="nofollow noopener noreferrer">官方例子</a>以及<a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fapi-reference%2Fintroduction" target="_blank" title="https://platform.openai.com/docs/api-reference/introduction" ref="nofollow noopener noreferrer">官方API文档</a>。</p></blockquote><h3 id="2-2-设置代理"><a href="#2-2-设置代理" class="headerlink" title="2.2 设置代理"></a>2.2 设置代理</h3><p>有的同学可能会遇到以下问题，这里综合了网上的解决办法。</p><blockquote><p>返回错误信息：<br>raise error.APIConnectionError(openai.error.APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host&#x3D;’api.openai.com’, port&#x3D;443): Max retries exceeded with url: &#x2F;v1&#x2F;chat&#x2F;completions (Caused by SSLError(SSLEOFError(8, ‘EOF occurred in violation of protocol (_ssl.c:1131)’)))</p></blockquote><p><strong>1. urllib3 降低版本到 1.25.11</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install urllib3==<span class="number">1.25</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><blockquote><p>参考大佬文章：<a href="https://zhuanlan.zhihu.com/p/350015032">Python 遭遇 ProxyError 问题记录</a></p></blockquote><p>简单来说就是 1.26.0 版本的 urllib3 添加了 HTTPS 支持，但代理服务器不支持 HTTPS，所以报错（pip走代理报错也差不多类似原因，具体请参考上文，有详细解读）</p><p><strong>2. 修改openai源码（亲测成功）</strong></p><p>根据自己安装openai包的路径，找到并打开 <code>api_requestor.py</code>，我的路径为：<code>C:\***\***\.conda\envs\py3.8\lib\site-packages\openai\api_requestor.py</code>，找到下面的部分：<code>if not hasattr(_thread_context, &quot;session&quot;):</code>，并在此方法上方加入代理，如下图框的部分。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/012.r0cjtzw1ank.webp#pic_center" width = 48%><p><strong>代理部分：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proxy = &#123;</span></span><br><span class="line"><span class="comment">#    &#x27;http&#x27;: &#x27;http://&lt;代理ip&gt;:&lt;代理端口&gt;&#x27;,</span></span><br><span class="line"><span class="comment">#    &#x27;https&#x27;: &#x27;https://&lt;代理ip&gt;:&lt;代理端口&gt;&#x27;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"> </span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://localhost:7890&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口号是你用对应软件的代理端口，我这里是7890。</p><p>在 <code>“result = _thread_context.session.request(”</code> 中加入代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = _thread_context.session.request(</span><br><span class="line">    method,</span><br><span class="line">    abs_url,</span><br><span class="line">    headers=headers,</span><br><span class="line">    data=data,</span><br><span class="line">    files=files,</span><br><span class="line">    stream=stream,</span><br><span class="line">    timeout=request_timeout <span class="keyword">if</span> request_timeout <span class="keyword">else</span> TIMEOUT_SECS,</span><br><span class="line">    <span class="comment"># proxies=_thread_context.session.proxies,      # 注释掉原本的代理</span></span><br><span class="line">    proxies=proxy                                   <span class="comment"># 添加自己的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>参考大佬文章：<a href="https://www.cnblogs.com/ghj1976/p/diao-yongopenai-deapi-chu-xianrequest-timed-out-ch.html">调用OpenAI的API出现Request timed out处理</a></p></blockquote><p><strong>3、代码里设置环境变量（亲测成功）</strong></p><p>添加以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">os.environ[<span class="string">&quot;http_proxy&quot;</span>] = <span class="string">&quot;http://localhost:7890&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;https_proxy&quot;</span>] = <span class="string">&quot;http://localhost:7890&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-ChatGPT-本地部署"><a href="#3-ChatGPT-本地部署" class="headerlink" title="3 ChatGPT 本地部署"></a>3 ChatGPT 本地部署</h2><h3 id="3-1-使用魔法"><a href="#3-1-使用魔法" class="headerlink" title="3.1 使用魔法"></a>3.1 使用魔法</h3><p><strong>第一步，将 ChatGPT 的源代码从 Github 上下载到本地</strong></p><p>以下是命令示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xtekky/chatgpt-clone.git</span><br></pre></td></tr></table></figure><p>这样就可以克隆代码到您的电脑上。</p><p><strong>第二步是安装环境</strong></p><p>这里选用熟悉的 Conda 安装，首先进入项目目录，然后运行以下命令来创建虚拟环境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n chatgpt-py3<span class="number">.9</span> python=<span class="number">3.9</span>        <span class="comment"># 创建虚拟环境</span></span><br><span class="line">conda activate chatgpt-py3<span class="number">.9</span>                    <span class="comment"># 激活环境</span></span><br><span class="line">cd ../chatgpt-clone                             <span class="comment"># 进入项目</span></span><br></pre></td></tr></table></figure><p>没有 Anconda 的，可以使用 Python 的 <code>venv</code> 包，首先进入项目目录，然后运行以下命令来创建虚拟环境（Linux）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd chatgpt-clone</span><br><span class="line">python -m venv venv</span><br><span class="line">source venv/<span class="built_in">bin</span>/activate            <span class="comment"># macOS/Linux</span></span><br></pre></td></tr></table></figure><p>如果您在使用 Windows 系统，需要使用以下的命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">venv\Scripts\activate.bat</span><br></pre></td></tr></table></figure><p><strong>第三步：安装所需要的依赖</strong></p><p>使用以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><strong>第四步：修改配置文件</strong></p><p>找到项目目录下的 config.josn 文件，并将文件中的 openai_key 替换成您自己的 key。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/013.7hmsme73cv80.webp#pic_center" width = 64%><p><strong>第五步：配置 magic 端口</strong></p><p>因为 ChatGPT 在本质上是调用 OpenAI 的接口，因此在运行该项目之前，需要让命令行工具具有 magic 能力（用魔法，前面讲过了）。</p><p>可以在命令行工具里输入以下命令（注意：您需要修改这个端口号！）</p><p><strong>Linux</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span> http_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span> all_proxy=socks5://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br><span class="line"><span class="built_in">set</span> https_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> http_proxy_user=user</span><br><span class="line"><span class="built_in">set</span> http_proxy_pass=<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> https_proxy_user=user</span><br><span class="line"><span class="built_in">set</span> https_proxy_pass=<span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：一定要加 http:&#x2F;&#x2F;，直接写域名或者 IP 不行。http 和 https 都要设置。然后如果想验证是否成功配置了代理的话，用 ping 命令是不可以的；ping的协议不是https，也不是https，是ICMP协议。可以使用 <code>curl -vv http://www.google.com</code>这条命令来验证。</p></blockquote><p>cmd，Git Bash，PowerShell 设置的方式不同</p><ul><li>cmd 中用 set http_proxy 设置</li><li>Git Bash 中用 export http_proxy 设置</li><li>PowerShell 中按照这样设置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#<span class="doctag">NOTE:</span> registry keys for IE 8, may vary for other versions</span></span><br><span class="line">$regPath = <span class="string">&#x27;HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings&#x27;</span></span><br><span class="line"></span><br><span class="line">function Clear-Proxy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyEnable -Value <span class="number">0</span></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyServer -Value <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyOverride -Value <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;http_proxy&#x27;</span>, $null, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;https_proxy&#x27;</span>, $null, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="type">Set</span>-Proxy</span><br><span class="line">&#123;</span><br><span class="line">    $proxy = <span class="string">&#x27;http://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyEnable -Value <span class="number">1</span></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyServer -Value $proxy</span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyOverride -Value <span class="string">&#x27;&lt;local&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;http_proxy&#x27;</span>, $proxy, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;https_proxy&#x27;</span>, $proxy, <span class="string">&#x27;User&#x27;</span>)</span><br></pre></td></tr></table></figure><p>也可以在代码里设置环境变量</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/014.qkw15yc8g8g.webp#pic_center" width = 48%><p><strong>第六步就是运行 ChatGPT 项目并进行访问了</strong></p><p>你只需要在命令行输入 python run.py，然后在浏览器中访问相应的链接就好了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/015.d6bfqrwxovk.webp#pic_center" width = 48%><p>首先，您可以像使用普通的 GPT 一样使用暗黑版。但是，为什么他被称之为 “暗黑版” 呢？因为当您使用了暗黑模式之后，ChatGPT 将突破底线，以一种更加深入和黑暗的方式回答您的问题。以下是如何使用暗黑版的提示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/016.ic4al3nz228.webp#pic_center" width = 48%><h3 id="3-2-通过免费云平台搭建代理转发"><a href="#3-2-通过免费云平台搭建代理转发" class="headerlink" title="3.2 通过免费云平台搭建代理转发"></a>3.2 通过免费云平台搭建代理转发</h3><p>第一步，我们需要登录云平台并进入应用选择菜单。下面是云平台官网链接：<a href="https://cloud.sealos.io/">https://cloud.sealos.io/</a></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/017.arkjwnce80c.webp#pic_center" width = 36%><p>第二步，首次进入的用户需要新建一个应用，并进行应用的基本配置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/018.1fs4xplnxlxc.webp#pic_center" width = 48%><p>第三步，通过高级配置来实现代理转发。</p><p>您现在可以进入高级设置选项卡来配置代理转发功能。</p><ul><li>点开高级配置</li><li>点击新增 configmap</li><li>文件名写: <code>/etc/nginx/nginx.conf</code></li><li>文件值为刚刚复制的那段代码</li><li>点击确认</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/019.3w5pf0dgrew0.webp#pic_center" width = 36%><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/020.15fxydbv0f9c.webp#pic_center" width = 48%><p><strong>nginx 配置代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">worker_rlimit_nofile <span class="number">51200</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    resolver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>;</span><br><span class="line">    proxy_ssl_server_name on;</span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    server_names_hash_bucket_size <span class="number">512</span>;</span><br><span class="line">    client_header_buffer_size 64k;</span><br><span class="line">    large_client_header_buffers <span class="number">4</span> 64k;</span><br><span class="line">    client_max_body_size 50M;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout       240s;</span><br><span class="line">    proxy_read_timeout          240s;</span><br><span class="line">    proxy_buffer_size 128k;</span><br><span class="line">    proxy_buffers <span class="number">4</span> 256k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xxxxx.cloud.sealos.io; <span class="comment"># 这个地方替换成 sealos 提供的内容</span></span><br><span class="line"></span><br><span class="line">        location ~ /openai/(.*) &#123;</span><br><span class="line">            <span class="comment"># auth check</span></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">            proxy_pass https://api.openai.com/$<span class="number">1</span>$is_args$args;</span><br><span class="line">            proxy_set_header Host api.openai.com;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="comment"># 如果响应是流式的</span></span><br><span class="line">            proxy_set_header Connection <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">            chunked_transfer_encoding off;</span><br><span class="line">            proxy_buffering off;</span><br><span class="line">            proxy_cache off;</span><br><span class="line">            <span class="comment"># 如果响应是一般的</span></span><br><span class="line">            proxy_buffer_size 128k;</span><br><span class="line">            proxy_buffers <span class="number">4</span> 256k;</span><br><span class="line">            proxy_busy_buffers_size 256k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，点击部署应用按钮。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/021.16j17a5gndj4.webp#pic_center" width = 48%><p>第五步，如果成功，你将看到下面的结果。最后，你可以点击详情获得外部访问链接。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/022.36lusgudolk0.webp#pic_center" width = 48%><p>第六步，如果你正在使用暗黑版的 OpenAI GPT，并且想要更轻松地使用以上方法，那么你可以修改 <code>config.json</code> 文件中的两个参数，具体操作请看下面：</p><ul><li>将 <code>proxy.enable</code> 设置为 false；</li><li>将 <code>openai_api_base</code> 改为在上一步获取的对外链接后加 <code>/openai</code>。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/023.3gy8v0zm7xo0.webp#pic_center" width = 64%><p>最后，你可以通过命令运行暗黑版 GPT，就可以实现无魔法访问。好了，以上就是通过免费云平台搭建代理转发，实现对 OpenAI GPT 的免费访问的全部步骤。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>ChatGPT注册教程攻略：<a href="https://www.xnbeast.com/create-openai-chatgpt-account/">https://www.xnbeast.com/create-openai-chatgpt-account/</a></li><li>2023年最新国内ChatGPT注册教程：<a href="https://juejin.cn/post/7220696541309108285">https://juejin.cn/post/7220696541309108285</a></li><li>Python 遭遇 ProxyError 问题记录：<a href="https://zhuanlan.zhihu.com/p/350015032">https://zhuanlan.zhihu.com/p/350015032</a></li><li>ChatGPT Plus官方推荐新手教程：<a href="https://chatgpt-plus.github.io/chatgpt-plus/">https://chatgpt-plus.github.io/chatgpt-plus/</a></li><li>ChatGPT本地部署：<a href="https://juejin.cn/post/7236668895867764773">https://juejin.cn/post/7236668895867764773</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> AIGC </category>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> OPENAI </tag>
            
            <tag> AIGC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
