<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机基础内容汇总</title>
      <link href="/article/a0d5b4a3.html"/>
      <url>/article/a0d5b4a3.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章是对计算机基础专栏下的文章进行汇总，方便系统地学习和复习。</p><span id="more"></span><h2 id="1-计算机"><a href="#1-计算机" class="headerlink" title="1 计算机"></a>1 计算机</h2><h3 id="1-1-网络篇"><a href="#1-1-网络篇" class="headerlink" title="1.1  网络篇"></a>1.1  网络篇</h3><ul><li><a href="https://qxienote.com/article/54ebc735.html">计算机网络篇（一）– 网络协议入门</a></li><li><a href="https://qxienote.com/article/279b4884.html">计算机网络篇（二）– HTTP 协议入门</a></li><li><a href="https://qxienote.com/article/ae7157b3.html">计算机网络篇（三）– SSL&#x2F;TLS 协议入门</a></li><li><a href="https://qxienote.com/article/1ee3e5d0.html">计算机网络篇（四）– TCP&#x2F;IP 协议族详解</a></li><li><a href="https://qxienote.com/article/84fa558.html">计算机网络篇（五）– TCP 套接字编程</a></li><li><a href="https://qxienote.com/article/929e2127.html">计算机网络篇（六）– UDP 套接字编程</a></li><li><a href="https://qxienote.com/article/24fe53d6.html">计算机网络篇（七）– ICMP-Ping 服务程序框架</a></li><li><a href="https://qxienote.com/article/ba7802fc.html">计算机网络篇（八）-邮件客户端实现与电子邮件发送</a></li></ul><h3 id="1-2-《计算机网络—自顶向下方法》-Wireshark实验"><a href="#1-2-《计算机网络—自顶向下方法》-Wireshark实验" class="headerlink" title="1.2 《计算机网络—自顶向下方法》 Wireshark实验"></a>1.2 《计算机网络—自顶向下方法》 Wireshark实验</h3><ul><li><a href="https://blog.csdn.net/xq151750111/article/details/130515236">《计算机网络—自顶向下方法》 Wireshark实验（一）：Wireshark软件的安装和入门</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130536991">《计算机网络—自顶向下方法》 Wireshark实验（二）：HTTP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130576182">《计算机网络—自顶向下方法》 Wireshark实验（三）：DNS协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130648866">《计算机网络—自顶向下方法》 Wireshark实验（四）：TCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130660079">《计算机网络—自顶向下方法》 Wireshark实验（五）：UDP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130675220">《计算机网络—自顶向下方法》 Wireshark实验（六）：IP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130663286">《计算机网络—自顶向下方法》 Wireshark实验（七）：以太网与ARP协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775056">《计算机网络—自顶向下方法》 Wireshark实验（八）：ICMP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130769488">《计算机网络—自顶向下方法》 Wireshark实验（九）：DHCP 协议分析</a></li><li><a href="https://blog.csdn.net/xq151750111/article/details/130775356">《计算机网络—自顶向下方法》 Wireshark实验（十）：NAT 协议分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（八）-- 邮件客户端实现与电子邮件发送</title>
      <link href="/article/ba7802fc.html"/>
      <url>/article/ba7802fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1 SMTP"></a>1 SMTP</h2><p>通过完成本实验，我们将更加了解SMTP协议。还将学到使用Python实现标准协议的经验。主要任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><span id="more"></span><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><p>这里采用qq邮箱来完成。本文将实现一个SMTP客户端，使用qq邮箱作为发件人，向指定的163邮箱发送一封邮件。</p><p>SMTP协议即简单邮件传输协议，允许用户按照标准发送&#x2F;接收邮件。</p><p>在本文中，SMTP邮件客户端程序的基本流程如下：</p><ol><li>与qq邮件服务器建立TCP连接，域名”smtp.qq.com”，SMTP默认端口号25。建立连接后服务器将返回状态码220，代表服务就绪（类似HTTP，SMTP也使用状态码通知客户端状态信息）。</li><li>发送”HELO”命令，开始与服务器的交互，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”AUTH LOGIN”命令，开始验证身份，服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的用户名（本例中是163邮箱的账号），服务器将返回状态码334（服务器等待用户输入验证信息）。</li><li>发送<strong>经过base64编码</strong>的密码（本例中是163邮箱的密码），服务器将返回状态码235（用户验证成功）。</li><li>发送”MAIL FROM”命令，并包含发件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”RCPT TO”命令，并包含收件人邮箱地址，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”DATA”命令，表示即将发送邮件内容，服务器将返回状态码354（开始邮件输入，以”.”结束）。</li><li>发送邮件内容，服务器将返回状态码250（请求动作正确完成）。</li><li>发送”QUIT”命令，断开与邮件服务器的连接。</li></ol><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230504</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 实现邮件客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mail content</span></span><br><span class="line">subject = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">contenttype = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">msg = <span class="string">&quot;I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sender and reciever</span></span><br><span class="line">fromaddress = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">toaddress = <span class="string">&quot;xxxxx@163.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth information (Encode with base64)</span></span><br><span class="line">username = <span class="string">&quot;xxxxxxxxx@qq.com&quot;</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">username = base64.b64encode(username.encode()).decode()</span><br><span class="line">password = base64.b64encode(password.encode()).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line">clientSocket.connect((mailserver, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO CarpeDiem\r\n&#x27;</span></span><br><span class="line">clientSocket.send(heloCommand.encode())</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv1)</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;AUTH LOGIN\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((username + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((password + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;235&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;235 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send MAIL FROM command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;MAIL FROM: &lt;&#x27;</span> + fromaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send RCPT TO command and print server response.</span></span><br><span class="line">clientSocket.sendall((<span class="string">&#x27;RCPT TO: &lt;&#x27;</span> + toaddress + <span class="string">&#x27;&gt;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send DATA command and print server response.</span></span><br><span class="line">clientSocket.send(<span class="string">&#x27;DATA\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;354&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;354 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send message data.</span></span><br><span class="line">message = <span class="string">&#x27;from:&#x27;</span> + fromaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;to:&#x27;</span> + toaddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;subject:&#x27;</span> + subject + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;Content-Type:&#x27;</span> + contenttype + <span class="string">&#x27;\t\n&#x27;</span></span><br><span class="line">message += <span class="string">&#x27;\r\n&#x27;</span> + msg</span><br><span class="line">clientSocket.sendall(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Message ends with a single period.</span></span><br><span class="line">clientSocket.sendall(endmsg.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send QUIT command and get server response.</span></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;QUIT\r\n&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close connection</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 有些邮箱默认关闭SMTP服务，比如本文使用的qq邮箱。需要在设置中打开SMTP服务。另外，qq邮箱在打开SMTP服务后，会设置一个授权码，在程序使用这个授权码作为密码登录，而不是平时使用的密码。</p><p>一切正常的话，运行效果如下图所示，将会看到服务器返回的每条消息，其中包含每次操作后返回的状态码。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.euksoeo322w.webp#pic_center" width = 36%><p>同时，我们还可以登陆发件人邮箱和收件人邮箱，在发件人的已发送文件夹中和收件人的收件箱中都能看到这封被发送的邮件。左图为qq邮箱，右图为网易163邮箱。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.56cyk5j0h1g0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.60g5ulueg0o0.webp#pic_left"  width = "45%"></center></p><hr><h2 id="2-网络应用开发"><a href="#2-网络应用开发" class="headerlink" title="2 网络应用开发"></a>2 网络应用开发</h2><h3 id="2-1-发送电子邮件"><a href="#2-1-发送电子邮件" class="headerlink" title="2.1 发送电子邮件"></a>2.1 发送电子邮件</h3><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p><p>smtplib和email，这俩模块是Python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。</p><ul><li>smtplib模块主要负责发送邮件：是一个发送邮件的动作，连接邮箱服务器，登录邮箱，发送邮件（有发件人，收信人，邮件内容）。</li><li>email模块主要负责构造邮件：指的是邮箱页面显示的一些构造，如发件人，收件人，主题，正文，附件等。</li></ul><p><strong>代码说明：</strong></p><ol><li>smtplib模块</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">smtplib.SMTP()              <span class="comment"># 实例化SMTP()</span></span><br><span class="line"></span><br><span class="line">login(user, password)</span><br><span class="line"><span class="comment"># user：登录邮箱的用户名。</span></span><br><span class="line"><span class="comment"># password：登录邮箱的密码，像笔者用的是网易邮箱，网易邮箱一般是网页版，需要用到客户端密码，需要在网页版的网易邮箱中设置授权码，该授权码即为客户端密码。</span></span><br><span class="line"></span><br><span class="line">sendmail(from_addr, to_addrs, msg,…)</span><br><span class="line"><span class="comment"># from_addr：邮件发送者地址</span></span><br><span class="line"><span class="comment"># to_addrs：邮件接收者地址。字符串列表[‘接收地址1’,‘接收地址2’,‘接收地址3’,…]</span></span><br><span class="line"><span class="comment"># msg：发送消息：邮件内容。一般是msg.as_string():as_string()是将msg(MIMEText对象或者MIMEMultipart对象)变为str。</span></span><br><span class="line"></span><br><span class="line">quit()      <span class="comment"># 用于结束SMTP会话。</span></span><br></pre></td></tr></table></figure><p><strong>2) email模块</strong></p><p>email模块下有mime包，mime英文全称为<code>“Multipurpose Internet Mail Extensions”</code>，即多用途互联网邮件扩展，是目前互联网电子邮件普遍遵循的邮件技术规范。</p><p>该mime包下常用的有三个模块：text, image, multpart。</p><p>导入方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br></pre></td></tr></table></figure><p>构造一个邮件对象就是一个Message对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure><p>下面的代码演示了如何在Python发送普通的文字邮件。</p><p><strong>1. 发送普通文字邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230428</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header </span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 设定邮件发送者和接受者</span></span><br><span class="line">    host_server = <span class="string">&#x27;smtp.qq.com&#x27;</span>             <span class="comment"># qq 邮箱smtp服务器</span></span><br><span class="line">    sender = <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>              <span class="comment"># 发件人邮箱</span></span><br><span class="line">    pwd = <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span></span><br><span class="line">    receivers = [<span class="string">&#x27;xxxxxxx@gmail.com&#x27;</span>, <span class="string">&#x27;xxxxxx@163.com&#x27;</span>]              <span class="comment"># 收件人邮箱</span></span><br><span class="line">    mail_title = <span class="string">&quot;Python自动发送的邮件&quot;</span>                               <span class="comment"># 邮件标题  </span></span><br><span class="line">    mail_content = <span class="string">&quot;您好，这是使用python登录QQ邮箱发送邮件的测试——xq&quot;</span>   <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()               <span class="comment"># 初始化一个邮件主体</span></span><br><span class="line">    message[<span class="string">&#x27;Subject&#x27;</span>] = Header(mail_title, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    message[<span class="string">&#x27;From&#x27;</span>] = sender</span><br><span class="line">    message[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;;&quot;</span>.join(receivers)</span><br><span class="line">    message.attach(MIMEText(mail_content, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment"># 邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    smtper = SMTP_SSL(host_server)      <span class="comment"># ssl登录</span></span><br><span class="line">    <span class="comment"># login(user,password):</span></span><br><span class="line">    <span class="comment"># user:登录邮箱的用户名。</span></span><br><span class="line">    <span class="comment"># password：登录邮箱的密码，这里用的是QQ邮箱，</span></span><br><span class="line">    <span class="comment"># 需要用到客户端密码，需要在QQ邮箱中设置授权码，该授权码即为客户端密码</span></span><br><span class="line">    smtper.login(sender, pwd)</span><br><span class="line">    smtper.sendmail(sender, receivers, message.as_bytes())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送完成!&quot;</span>)</span><br><span class="line">    <span class="comment"># quit(): 用于结束SMTP会话</span></span><br><span class="line">    smtper.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.6alnsifgg2o0.webp#pic_center" width = 64%><p><strong>2. 发送html格式邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.6yb1qqrncyo0.webp#pic_center" width = 36%><p><strong>3. 发送带附件的邮件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230419</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: Python 发送HTML格式邮件以及附件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP_SSL</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication  <span class="comment"># 用于添加附件</span></span><br><span class="line"></span><br><span class="line">host_server = <span class="string">&quot;smtp.qq.com&quot;</span>             <span class="comment"># qq邮箱smtp服务器</span></span><br><span class="line">sender_qq = <span class="string">&quot;xxxxxxx@qq.com&quot;</span>         <span class="comment"># 发件人邮箱</span></span><br><span class="line">password = <span class="string">&quot;xxxxxxxxxxxx&quot;</span>           <span class="comment"># 授权码</span></span><br><span class="line">receiver = <span class="string">&quot;xxxxxxxx@163.com&quot;</span></span><br><span class="line">mail_title = <span class="string">&quot;Python自动发送html格式的邮件&quot;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"><span class="comment"># 邮件正文内容</span></span><br><span class="line">mail_content = <span class="string">&quot;您好！&lt;p&gt;这是使用python登录QQ邮箱发送\</span></span><br><span class="line"><span class="string">                HTNL格式邮件的测试：&lt;/p&gt; &lt;p&gt;\</span></span><br><span class="line"><span class="string">                &lt;a href=&#x27;https://blog.csdn.net/xq151750111?spm=1010.2135.3001.5421&#x27;&gt;CSDN个人主页&lt;/a&gt;&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = Header(mail_title, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = sender_qq</span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = Header(<span class="string">&quot;测试邮箱&quot;</span>, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(mail_content, <span class="string">&#x27;html&#x27;</span>))</span><br><span class="line">attachment = MIMEApplication(<span class="built_in">open</span>(<span class="string">&quot;H:\\毕业设计\\LassoNet\\脑区选择.xlsx&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">attachment[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给附件重命名</span></span><br><span class="line">basename = <span class="string">&quot;test.xlsx&quot;</span></span><br><span class="line">attachment.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;&#x27;</span>, basename))</span><br><span class="line">msg.attach(attachment)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    smtp = SMTP_SSL(host_server)    <span class="comment"># ssl登录连接到邮件服务器</span></span><br><span class="line">    smtp.set_debuglevel(<span class="literal">True</span>)       <span class="comment"># False to disable debug</span></span><br><span class="line">    smtp.ehlo(host_server)          <span class="comment"># 跟服务器打招呼，告诉它我们准备连接</span></span><br><span class="line">    smtp.login(sender_qq, password)</span><br><span class="line">    smtp.sendmail(sender_qq, receiver, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件发送成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法发送邮件&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.6g3dk32y7kg0.webp#pic_center" width = 36%><h3 id="2-2-发送短信"><a href="#2-2-发送短信" class="headerlink" title="2.2 发送短信"></a>2.2 发送短信</h3><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a href="https://www.ihuyi.com/duanxin.html?e=591">互亿无线短信平台</a>（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    host  = <span class="string">&quot;106.ihuyi.com&quot;</span></span><br><span class="line">    sms_send_uri = <span class="string">&quot;/webservice/sms.php?method=Submit&quot;</span></span><br><span class="line">    <span class="comment"># 下面的参数需要填入自己注册的账号和对应的密码</span></span><br><span class="line">    params = urllib.parse.urlencode(&#123;<span class="string">&#x27;account&#x27;</span>: <span class="string">&#x27;API ID&#x27;</span>, <span class="string">&#x27;password&#x27;</span> : <span class="string">&#x27;API KEY&#x27;</span>, <span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;您的验证码是：666888。请不要把验证码泄露给其他人。&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>: <span class="string">&#x27;xxxxxxxxx&#x27;</span>, <span class="string">&#x27;format&#x27;</span>:<span class="string">&#x27;json&#x27;</span> &#125;)</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=<span class="number">80</span>, timeout=<span class="number">30</span>)</span><br><span class="line">    conn.request(<span class="string">&#x27;POST&#x27;</span>, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    jsonstr = response_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(json.loads(jsonstr))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>详细了解，请阅读：<a href="https://www.ihuyi.com/api/sms.html">短信验证码&#x2F;通知 - API文档</a></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Python实现自动发送邮件（详解）：<a href="https://blog.csdn.net/weixin_44827418/article/details/111255414">https://blog.csdn.net/weixin_44827418&#x2F;article&#x2F;details&#x2F;111255414</a></li><li>Python网络应用开发：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（七）-- ICMP Ping服务程序框架</title>
      <link href="/article/24fe53d6.html"/>
      <url>/article/24fe53d6.html</url>
      
        <content type="html"><![CDATA[<p>Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。</p><span id="more"></span><p>Ping的实现通常使用ICMP协议。ICMP协议在协议族中的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.ziro52u46eo.webp#pic_center" width = 48%><p>通过本文，你将更好地理解因特网控制报文协议（<code>ICMP</code>），学习使用<code>ICMP</code>请求和响应消息实现<code>Ping</code>程序。通过向目标主机发送<code>ICMP</code>回显包并监听<code>ICMP</code>回显应答来工作。回显有时称为<code>pong</code>。<code>ping</code>程序测量往返时间，记录数据包丢失，并输出接收到的回显包的统计摘要（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差）。</p><p>主要任务：用<code>python</code>开发自己的简单<code>Ping</code>程序。程序将使用<code>ICMP</code>协议，但为了保持简单，将不完全遵循<code>RFC 1739</code>中的正式规范。在本实训中只需要编写程序的客户端，因为服务器端所需的功能几乎内置于所有操作系统中。Ping程序的基本功能如下： Ping 程序能将 ping 请求发送到指定的主机，间隔大约一秒钟。每个消息包含一个带有时间戳的数据包。 每个数据包发送完后，程序最多等待一秒，用于接收响应。如果一秒后服务器没有响应，那么客户端应假设 ping 数据包或 pong 数据包在网络中丢失（或者服务器已关闭）。 统计摘要信息（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差） 本实训将使用原始套接字来使用ICMP协议。</p><p>下面将为为Ping客户端创建一个原始类型的套接字。</p><h2 id="1-Ping客户端创建原始套接字"><a href="#1-Ping客户端创建原始套接字" class="headerlink" title="1 Ping客户端创建原始套接字"></a>1 Ping客户端创建原始套接字</h2><h3 id="1-1-原始套接字"><a href="#1-1-原始套接字" class="headerlink" title="1.1 原始套接字"></a>1.1 原始套接字</h3><p>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。使用原始套接字进行网络通信的基本步骤为：</p><ul><li>（1）创建原始套接字、设置套接字选项和创建并填充相应协议头；</li><li>（2）用 <code>sendto()</code> 函数将组装好的数据发送出去；</li><li>（3）使用 <code>recvfrom()</code> 函数接收数据并解析；</li><li>（4）关闭套接字。</li></ul><p>在Python中使用套接字编程，需要先引入套接字（import socket）；使用 <code>socket()</code> 函数来创建套接字。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket(socket_family,socket_type,protocol=<span class="number">0</span>)</span><br><span class="line">socket_family可以是如下参数之一：</span><br><span class="line">  　　AF_INET IPv4（默认）</span><br><span class="line">　　  AF_INET6 IPv6</span><br><span class="line">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span><br><span class="line">socket_type可以是如下参数之一:</span><br><span class="line">　　  SOCK_STREAM　　流式socket , <span class="keyword">for</span> TCP （默认）</span><br><span class="line">　  　SOCK_DGRAM　　 数据报式socket , <span class="keyword">for</span> UDP</span><br><span class="line">　  　SOCK_RAW 原始套接字</span><br></pre></td></tr></table></figure><p>普通的套接字无法处理ICMP、IGMP等网络报文，而原始套接字 <code>SOCK_RAW</code> 可以；<code>SOCK_RAM</code> 用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。<code>SOCK_RAM</code> 通常仅限于高级用户或管理员运行的程序使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol参数：</span><br><span class="line">　　<span class="number">0</span>　（默认）与特定的地址家族相关的协议。如果是 <span class="number">0</span> ，则系统就会根据地址格式和套接类别，自动选择一个合适的协议。也可以使用</span><br><span class="line">  getprotobyname()指定要使用的协议名称如“ICMP”、“UDP”等。</span><br></pre></td></tr></table></figure><p>在本实验中，要创建一个使用IPV4地址族的的原始套接字，并指定使用ICMP协议，可以使用如下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmp = getprotobyname(<span class="string">&quot;icmp&quot;</span>)   /*指定ICMP协议</span><br><span class="line">rawsocket=socket(AF_INET, SOCK_RAW, icmp)</span><br></pre></td></tr></table></figure><h2 id="2-封装并发送ICMP报文"><a href="#2-封装并发送ICMP报文" class="headerlink" title="2 封装并发送ICMP报文"></a>2 封装并发送ICMP报文</h2><h3 id="2-1-ICMP协议"><a href="#2-1-ICMP协议" class="headerlink" title="2.1 ICMP协议"></a>2.1 ICMP协议</h3><p>ICMP协议：<code>Internet Control Message Protocol</code>（Internet控制报文协议）；由于IP协议并不是一个可靠的协议，它不保证数据被成功送达。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的，经常供IP层或更高层协议（TCP或UDP）使用。所以它经常被认为是IP层的一个组成部分。</p><p>制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着<font color=#9900CC><strong>“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议”</font></strong>。即，ICMP 是为了分担IP 一部分功能而被制定出来的。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.ed8xfkhqoh4.webp#pic_center" width = 48%><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p><p>在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.39oq4lvlrna0.webp#pic_center" width = 48%><ul><li>[1]给送信者的错误通知；[2]送信者的信息查询。</li><li>[1]是到IP 数据包被对方的计算机处理的过程中，发生了什么错误时被使用。不仅传送发生了错误这个事实，也传送错误原因等消息。</li><li>[2]的信息询问是在送信方的计算机向对方计算机询问信息时被使用。被询问内容的种类非常丰富，他们有目标IP 地址的机器是否存在这种基本确认，调查自己网络的子网掩码，取得对方机器的时间信息等。</li></ul><p>ICMP是TCP&#x2F;IP模型中网络层的重要成员，与IP协议、ARP协议、RARP 协议及 IGMP协议共同构成 TCP&#x2F;IP模型中的网络层。<code>ping</code> 和 <code>tracert</code> 是两个常用网络管理命令，<code>ping</code> 用来测试网络可达性，<code>tracert</code> 用来显示到达目的主机的路径。<code>ping</code> 和 <code>tracert</code> 都利用ICMP 协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。</p><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。但RFC认为ICMP是分担了IP的一部分功能。所以，ICMP也被认为是与IP同层的协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。看一下RFC 规定的数据包格式和报文内容吧。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.4xn5l5nbahs0.webp#pic_center" width = 48%><p>当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP的数据报文格式如下所示。所有报文的前4个字节都是一样的，其他的因报文类型不同而不一样。类型字段可以有15个不同的值，用以描述不同的ICMP报文。校验和字段覆盖整个ICMP报文，使用了和IP首部检验和一样的算法，详细请搜索TCP&#x2F;IP检验和算法。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.52nce9l7ak40.webp#pic_center" width = 48%><p><strong>字段说明：</strong></p><ul><li>类型：标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。    </li><li>代码：标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。    </li><li>校验和：对包括ICMP报文数据部分在内的整个ICMP&#96;数据报的校验和，以检验报文在传输过程中是否出现了差错。</li></ul><p><font color=#9900CC><strong>不同类型的报文是由类型字段和代码字段来共同决定。</font></strong>下表是各种类型的ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.5ol4guwagpk0.webp#pic_center" width = 48%><p>根据上表可知，ICMP协议大致分为两类，一种是查询报文，一种是差错报文。查询报文是用一对请求和应答定义的，它通常有以下几种用途:</p><ol><li>ping查询</li><li>子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）</li><li>时间戳查询（可以用来同步时间）</li></ol><p>而差错报文通常包含了引起错误的IP数据报的第一个分片的IP首部（和选项），加上该分片数据部分的前8个字节。RFC 792规范中定义的这8个字节中包含了该分组运输层首部的所有分用信息，这样运输层协议就可以向正确的进程提交ICMP差错报文。</p><p>当传送IP数据包发生错误时，比如主机不可达，端口不可达等，ICMP协议就会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。由上面可知，ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成，而前 16bit就组成了ICMP所要传递的信息。由数据链路层所能发送的最大数据帧，即MTU（Maximum Transmission Unit）为1500，计算易知ICMP协议在实际传输中数据包为：20字节IP首部 + 8字节ICMP首部+ 1472字节（数据大小）。</p><p>尽管在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的。如下</p><ol><li>ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）</li><li>目的地址是广播地址或多播地址的IP数据报。</li><li>作为链路层广播的数据报。</li><li>不是IP分片的第一片。</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。</li></ol><h3 id="2-2-ping程序原理分析"><a href="#2-2-ping程序原理分析" class="headerlink" title="2.2 ping程序原理分析"></a>2.2 ping程序原理分析</h3><p>ping程序是由Mike Muuss编写，目的是为了测试另一 台主机是否可达，现在已经成为一个常用的网络状态检查工具。该程序发送一份 ICMP回显请求报文给远程主机，并等待返回 ICMP回显应答。利用ping这种原理，已经出现了许多基于ping的网络扫描器，比如nmap、arping、fping、hping3等。所以随着Internet安全意识的增强，现在有些提供访问控制策略的路由器和防火墙已经可以设置过滤特定ICMP报文请求。因此并不能通过简单的ping命令判断远程主机是否在线。</p><p>ping 使用的是ICMP协议，它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。大多数的 TCP&#x2F;IP 实现都在内核中直接支持Ping服务器，ICMP回显请求和回显应答报文如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.klquqyz6p2o.webp#pic_center" width = 48%><p>ping的原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。通过计算ICMP应答报文数量和与接受与发送报文之间的时间差，判断当前的网络状态。这个往返时间的计算方法是：ping命令在发送ICMP报文时将当前的时间值存储在ICMP报文中发出，当应答报文返回时，使用当前时间值减去存放在ICMP报文数据中存放发送请求的时间值来计算往返时间。ping返回接受到的数据报文字节大小、TTL值以及往返时间。</p><p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的 ID号。这样 即使在同一台主机上同时运行了多个 ping程序实例，ping程序也可以识别出返回的信息。</p><p><code>ping</code> 操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.3qwubtumq28.webp#pic_center" width = 48%><p>过程如下：</p><ol><li><p>向目标服务器发送回送请求。<br>首先，向目标服务器发出回送请求（类型是8，代码是0）报文（同2）。在这个回送请求报文里，除了类型和代码字段，还被追加了标识符和序号字段。标识符和序号字段分别是16 位的字段。ping 命令在发送回送请求报文时，在这两个字段里填入任意的值。对于标识符，应用程序执行期间送出的所有报文里填入相同的值。对于序号，每送出一个报文数值就增加1。而且，回送请求的选项数据部分用来装任意数据。这个任意数据用来调整ping 的交流数据包的大小。</p></li><li><p>鹦鹉学舌一样返回回送回答。<br>计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求（类型是0，代码是0）（同3）。这个ICMP 回送回答报文在IP 层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP 地址字段被交换了，类型字段里填入了表示回送回答的0。也就是，从送信方来看，自己送出的ICMP 报文从目标服务器那里象鹦鹉学舌那样原样返回了。<br>送信方的计算机可以通过收到回送回答报文，来确认目标服务器在工作着。进一步，记住发送回送请求报文的时间，与接收到回送回答报文的时间一比较，就能计算出报文一去一回往复所需要的时间（同4）。但是，收到的回送回答报文里写的只是类型和代码的话，发送方计算机将无法判断它是否是自己发出去请求的回答。因此，前面说到的标识符和序号字段就有它的意义了。将这两个值与回送回答报文中的相同字段值一比较，送行方计算机就能够简单地检测回送回答是否正确了。执行ping 命令而调查的结果没什么问题的话，就将目标服务器的IP 地址，数据大小，往复花费的时间打印到屏幕上。</p></li><li><p>用ping 命令不能确定与对方连通的原因大致有三个。<br>1）目标服务器不存在；2)花在数据包交流上的时间太长ping 命令认为超时；3）目标服务器不回答ping 命令。如果是原因2），通过ping 命令的选项来延长到超时的等待时间，就能正确显示结果了。如果原因是1）或3）的话，仅凭ping 命令的结果就不能判断是哪方了。正如这样，ping 命令不一定一定能判断对方是否存在。</p></li></ol><p>一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。</p><p>时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。</p><h3 id="2-3-协议数据包的封装"><a href="#2-3-协议数据包的封装" class="headerlink" title="2.3 协议数据包的封装"></a>2.3 协议数据包的封装</h3><p>Python中处理二进制数据如存取文件、socket操作时，可以使用 Python 的 struct 模块来完成。使用该模块可以方便地来实现协议数据的封装与解封。</p><p>struct模块中最重要的三个函数是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pack(fmt, v1, v2, ...)     <span class="comment"># 按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</span></span><br><span class="line">unpack(fmt, string)        <span class="comment"># 按照给定的格式(fmt)解析字节流string，返回解析出来的数组</span></span><br><span class="line">calcsize(fmt)              <span class="comment"># 计算给定的格式(fmt)占用多少字节的内存</span></span><br></pre></td></tr></table></figure><p>其中fmt支持的格式如下表描述：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5mgm8e69x380.webp#pic_center" width = 48%><p>在完成封装后，将封装后的数据data，使用原始套接字的 <code>sendto()</code> 方法进行发送。<code>sendto()</code> 主要参数：</p><ul><li>packet：发送的数据</li><li>Addr：形式为 <code>(ipaddr，port)</code> 的元组</li></ul><h2 id="3-解析IP包ICMP头信息"><a href="#3-解析IP包ICMP头信息" class="headerlink" title="3 解析IP包ICMP头信息"></a>3 解析IP包ICMP头信息</h2><h3 id="3-1-接收ICMP报文"><a href="#3-1-接收ICMP报文" class="headerlink" title="3.1 接收ICMP报文"></a>3.1 接收ICMP报文</h3><p>使用原始套接字的 <code>recvfrom()</code> 函数接收报文，输入参数指定为报文最大长度，如1024；函数返回值为报文发送方的地址、报文内容。接收代码示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfpacket, addr = mysocket.recvfrom(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-解析ICMP报文"><a href="#3-2-解析ICMP报文" class="headerlink" title="3.2 解析ICMP报文"></a>3.2 解析ICMP报文</h3><p>ICMP报文内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP是IP的上层协议。</p><p>一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议类型字段值为1时，就说明这是一个ICMP报文。</p><p>ICMP报头如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.5fd06it998c0.webp#pic_center" width = 48%><p>解析ICMP报文可以使用Python中struct模块的 <code>upack()</code> 函数来实现。其参数：</p><ul><li>fmtstr: 格式化字符串</li><li>packet: 需要解析的字符数组</li></ul><p>函数的返回值可以是多个，根据格式串中指定的类型返回到相应变量中。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d=struct.unpack(<span class="string">&#x27;5s6sif&#x27;</span>,<span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><p>则从bytes这个数组中解析出a：5个字符的字符串（5s），b:6个字符的字符串(6s)，c为整型(i)，d为浮点型数据(f)。</p><p>对于Ping命令的ICMP报文，我们需从IP包中取出ICMP报头，位于20到28字节；从中可以取出报文类型type,代码code，校验和checksum，报文ID及报文序号字段；</p><p>对于类型为1的报文且其ID为需要接收的报文，从28字节后面开始解析发送的数据为发送时间，数据类型及长度根据发送的数据来确定。</p><ul><li>响应时间：计算收到报文的时间与发送报文（ICMP报文的数据部分）的时间差；</li><li>TTL：TTL指Time To Live生成周期，指定IP包被路由器丢弃之前允许通过的最大网段数量。在IPv4包头中TTL是一个8 bit字段，它位于IPv4包的第9个字节。因此只需从接收报文中解析出第9字节即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chesksum</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    校验</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(data)</span><br><span class="line">    m = n % <span class="number">2</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - m ,<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">sum</span> += (data[i]) + ((data[i+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>)   <span class="comment"># 传入data以每两个字节（十六进制）通过ord转十进制，第一字节在低位，第二个字节在高位</span></span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        <span class="built_in">sum</span> += (data[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 将高于16位与低16位相加</span></span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>) + (<span class="built_in">sum</span> &amp; <span class="number">0xffff</span>)</span><br><span class="line">    <span class="built_in">sum</span> += (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>)      <span class="comment"># 如果还有高于16位，将继续与低16位相加</span></span><br><span class="line">    answer = ~<span class="built_in">sum</span> &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="comment"># 主机字节序转网络字节序列（参考小端序转大端序）</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一次Ping的返回消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiveOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr, timeout</span>):</span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        </span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        <span class="built_in">type</span>, code, checksum, packetID, sequence = struct.unpack(<span class="string">&quot;!bbHHh&quot;</span>, header)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">and</span> packetID == ID:  <span class="comment"># type should be 0</span></span><br><span class="line">            byte_in_double =  struct.calcsize(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">            timeSent = struct.unpack(<span class="string">&quot;d&quot;</span>, recPacket[<span class="number">28</span>:<span class="number">28</span>+byte_in_double])[<span class="number">0</span>]</span><br><span class="line">            delay = timeReceived - startedSelect</span><br><span class="line">            ttl = struct.unpack(<span class="string">&quot;!b&quot;</span>, recPacket[<span class="number">8</span>:<span class="number">9</span>])[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> (delay, ttl, byte_in_double)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送一次Ping数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendOnePing</span>(<span class="params">mySocket, ID, sequence, destAddr</span>):</span><br><span class="line">    <span class="comment"># 头部构成： type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;!d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># 计算头部和数据的校验和</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, sequence)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向指定地址发送Ping消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doOnePing</span>(<span class="params">destAddr, ID, sequence, timeout</span>):</span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建原始套接字</span></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"> </span><br><span class="line">    sendOnePing(mySocket, ID, sequence, destAddr)</span><br><span class="line">    delay = receiveOnePing(mySocket, ID, sequence, destAddr, timeout)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数Ping</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># timeout=1指: 如果1秒内没从服务器返回，客户端认为Ping或Pong丢失。</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pinging &quot;</span> + dest + <span class="string">&quot; using Python:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每秒向服务器发送一次Ping请求</span></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># 返回进程ID</span></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        result = doOnePing(dest, myID, i, timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Request timed out.&quot;</span>)</span><br><span class="line">            loss += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delay = <span class="built_in">int</span>(result[<span class="number">0</span>]*<span class="number">1000</span>)</span><br><span class="line">            ttl = result[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">bytes</span> = result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Received from &quot;</span> + dest + <span class="string">&quot;: byte(s)=&quot;</span> + <span class="built_in">str</span>(<span class="built_in">bytes</span>) + <span class="string">&quot; delay=&quot;</span> + <span class="built_in">str</span>(delay) + <span class="string">&quot;ms TTL=&quot;</span> + <span class="built_in">str</span>(ttl))</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Packet: sent = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>) + <span class="string">&quot; received = &quot;</span> + <span class="built_in">str</span>(<span class="number">4</span>-loss) + <span class="string">&quot; lost = &quot;</span> + <span class="built_in">str</span>(loss))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6tiqidr3ru00.webp#pic_center" width = 36%><h2 id="4-ICMP-的应用–Traceroute"><a href="#4-ICMP-的应用–Traceroute" class="headerlink" title="4 ICMP 的应用–Traceroute"></a>4 ICMP 的应用–Traceroute</h2><h3 id="4-1-原理介绍"><a href="#4-1-原理介绍" class="headerlink" title="4.1 原理介绍"></a>4.1 原理介绍</h3><p>Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管 ping 工具也可以进行侦测，但是，因为 ip 头的限制，ping 不能完全的记录下所经过的路由器。所以 Traceroute 正好就填补了这个缺憾。</p><p>Traceroute 的原理是非常非常的有意思，它受到目的主机的 IP 后，首先给目的主机发送一个 TTL&#x3D;1(还记得 TTL 是什么吗?)的  UDP(后面就 知道 UDP 是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减1，而 TTL 变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL&#x3D;2的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 ip。从而避开了 ip 头只能记录有限路由 IP 的问题。</p><p>有人要问，我怎么知道 UDP 到没到达目的主机呢？这就涉及一个技巧的问题，TCP 和 UDP 协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较小的端口，比如说80，比如说23，等等。而 traceroute 发送的是端口号&gt;30000(真变态)的  UDP 报，所以到 达目的主机的时候，目的主机只能发送一个端口不可达的 ICMP 数据报给主机。主机接到这个报告以后就知道，主机到了，所以，说  Traceroute 是一个骗子一点也不为过。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.62nfc4shenk0.webp#pic_center" width = 48%><p><strong>过程如下：</strong></p><ol><li>执行tracert命令。<br>在Windows 上执行tracert 命令后，首先计算机向目的服务器发送IP 数据包。Windows 上使用的是与ping 同样的ICMP 回送请求报文。但是，有一点和通常的回送请求不一样。那是，最初将IP 首部的TTL(生存时间)字段设为1 这一点。</li></ol><p>路由器每转送一次数据包就将TTL 的值减1。当TTL 变为0 的时候，按规定将丢弃这个数据包。正如这样，与其说TTL 是时间，还不如说TTL 是经过路由器的个数。对于计算机发送出去的数据包，只要它与目标服务器不在同一局域网内，一定会被哪儿的路由器中继。这时如果TTL 的值是1，由于路由器的处理会变为0，则该数据包将会被丢弃（同2）。</p><ol start="2"><li>用超时报文来通知送信方。<br>路由器丢弃数据包的同时，用ICMP 报文来通知错误。这时使用的ICMP 报文是，类型为11，代码为0 的ICMP 超时报文。而且在选项数据字段里，将填入原先数据包的IP 首部和ICMP 的开始8 字节。正如ping 命令的时候看到的，ICMP 回送请求的先头8 字节里包含了标识符和序号字段。因此，送信方的计算机看了超时报文后，就知道是针对自己发出的回送请求的错误通知。</li></ol><p>计算机接到针对第一个数据包的ICMP 超时报文后，接下来将TTL 加1（TTL&#x3D;2）并同样地送出（同3）。这次通过第一个路由器，TTL 变为1，到达第二个路由器。但是第二个路由器象前面一样，由于TTL变为0，将不能转发该包。因此，同第一个路由器一样，将该包丢弃，并返回ICMP 超时报文。以后，收到错误的发送方计算机将TTL 加1，重复同样的工作（同4）。</p><ol start="3"><li>只有目标服务器的反应不同。<br>如此一个一个增加TTL，某个时候ICMP 回送请求报文将到达最终的目标服务器。这时，只有目标服务器与途中的路由器不同，不返回ICMP 超时报文。为什么呢？因为即使目标服务器收到TTL 为1 的数据包也不会发生错误。</li></ol><p>作为代替处理，服务器针对送信方计算机发出的ICMP 回送请求报文，返回ICMP 回送回答报文。也就是，送信方计算机与服务器之间，与ping 命令的执行一样了（同5）。得到了ICMP 回送回答报文的送信方知道了路经调查已经到了目标服务器，就结束了tracert 命令的执行（同6）。像这样，通过列出中途路由器返回的错误，就能知道构成到目标服务器路径的所有路由器的信息了。</p><ol start="4"><li>操作系统不同则实现方法略微不同。<br>到这里，以Windows 上的tracert 命令为例看了原理，有些别的操作系统的traceroute 命令的原理略微不同。</li></ol><p>具体来说，也有用向目标发送UDP 数据包代替ICMP 回送请求报文来实现的。虽说是用UDP，但途中的路由器的处理与図 8完全相同。只是UDP 数据包到达目标后的处理不同。目标计算机突然收到与通信无关的数据包，就返回ICMP 错误，因此根据返回数据包的内容来判断命令的中止。</p><h3 id="4-2-Python-实现"><a href="#4-2-Python-实现" class="headerlink" title="4.2 Python 实现"></a>4.2 Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230423</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 基于ICMP协议Traceroute实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kamene.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tracert_one</span>(<span class="params">dst,dport,ttl_no</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;发一个Traceroute包，参数需要目的地址，目的端口，TTL&#x27;&#x27;&#x27;</span></span><br><span class="line">    send_time = time.time()         <span class="comment"># 记录发送时间</span></span><br><span class="line">    Tracert_one_reply = sr1(IP(dst=dst, ttl=ttl_no)/UDP(sport=<span class="number">6600</span>, dport=dport)/<span class="string">b&#x27;my traceroute!!!&#x27;</span>, timeout = <span class="number">1</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Scapy中UDP默认源目端口53，需要将源端口也改掉，否则中间设备将不回应</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">11</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果收到TTL超时</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>, hop_ip, time_to_passed        <span class="comment"># 返回1表示并未抵达目的地</span></span><br><span class="line">        <span class="keyword">elif</span> Tracert_one_reply.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">3</span> <span class="keyword">and</span> Tracert_one_reply.getlayer(ICMP).code == <span class="number">3</span>:</span><br><span class="line">            <span class="comment"># 如果收到端口不可达</span></span><br><span class="line">            hop_ip = Tracert_one_reply.getlayer(IP).src</span><br><span class="line">            received_time = time.time()</span><br><span class="line">            time_to_passed = (received_time - send_time) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>, hop_ip, time_to_passed    <span class="comment"># 返回2表示抵达目的地</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">&#x27;.*NoneType.*&#x27;</span>,<span class="built_in">str</span>(e)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>     <span class="comment"># 测试失败返回None,没有回包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MY_Tracert</span>(<span class="params">dst,hops</span>):</span><br><span class="line">    dport = <span class="number">33434</span>           <span class="comment"># Traceroute的目的端口从33434开始计算</span></span><br><span class="line">    hop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> hop &lt; hops:</span><br><span class="line">        dport = dport + hop</span><br><span class="line">        hop += <span class="number">1</span></span><br><span class="line">        Result = Tracert_one(dst,dport,hop)</span><br><span class="line">        <span class="keyword">if</span> Result == <span class="literal">None</span>:      <span class="comment"># 如果测试失败就打印‘*’</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; *&#x27;</span>,flush=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">1</span>:    <span class="comment"># 如果未抵达目的，就打印这一跳和消耗的时间</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> Result[<span class="number">0</span>] == <span class="number">2</span>:    <span class="comment"># 如果抵达目的，就打印这一跳和消耗的时间，并且跳出循环！</span></span><br><span class="line">            time_to_pass_result = <span class="string">&#x27;%4.2f&#x27;</span> % Result[<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(hop) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(Result[<span class="number">1</span>]) + <span class="string">&#x27; &#x27;</span> + time_to_pass_result + <span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conf.route.add(net=<span class="string">&#x27;172.16.10.0/24&#x27;</span>,gw=<span class="string">&#x27;192.168.10.115&#x27;</span>)    <span class="comment"># 为Scapy添加路由</span></span><br><span class="line">    destIP=<span class="built_in">input</span>(<span class="string">&quot;目标IP&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    hops=<span class="built_in">input</span>(<span class="string">&quot;最大跳数&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    MY_Tracert(destIP, <span class="built_in">int</span>(hops))</span><br></pre></td></tr></table></figure><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.40tookmha7w0.webp#pic_center" width = 64%><blockquote><p>了解更多，请阅读：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">ICMP实现之端口扫描、ICMP实现之改变路由、ICMP实现之源点抑制、ICMP实现之MTU探索</a></p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>python实现ping工具：<a href="https://blog.csdn.net/jia666666/article/details/85254450">https://blog.csdn.net/jia666666/article/details/85254450</a></li><li>ICMP协议与ping原理以及用Python实现ping：<a href="https://cloud.tencent.com/developer/article/1156671">https://cloud.tencent.com/developer/article/1156671</a></li><li>《计算机网络－自顶向下方法》笔记：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES</a></li><li>完全理解icmp协议：<a href="https://www.cnblogs.com/iiiiher/p/8513748.html">https://www.cnblogs.com/iiiiher/p/8513748.html</a></li><li>Python网络编程2–实现Ping程序与Traceroute程序：<a href="https://www.jianshu.com/p/0c52955515c7">https://www.jianshu.com/p/0c52955515c7</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICMP 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（六）- UDP套接字编程</title>
      <link href="/article/929e2127.html"/>
      <url>/article/929e2127.html</url>
      
        <content type="html"><![CDATA[<p>本文将首先利用 Python 实现面向UDP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。</p><span id="more"></span><h2 id="1-创建UDP套接字"><a href="#1-创建UDP套接字" class="headerlink" title="1 创建UDP套接字"></a>1 创建UDP套接字</h2><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。<font color=#9900CC><strong>TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。</strong></font>可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。</p><p>数据包格式套接字（<code>Datagram Sockets</code>）也叫“无连接的套接字”，在代码中使用 <code>SOCK_DGRAM</code> 表示。可以将 <code>SOCK_DGRAM</code> 比喻成高速移动的摩托车快递，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的。</li></ul><p>数据包套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。</p><p>实际应用中，QQ 视频聊天和语音聊天主要使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。当然，SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</p><p>本部分将学习利用 UDP 套接字编程实现网络连通程序Ping。包含如何使用 UDP 套接字发送和接收数据报；如何设置适当的套接字超时；Ping 应用程序通信过程及计算网络统计信息（如丢包率）。</p><p>Ping 程序的基本原理：利用客户端发送一个数据包到远程机器，远程机器将收到的数据包返回到客户端（称为回显），客户端根据是否收到发送的消息及计算数据包的往返时间来反映网络是否连通及网络状态。</p><p>首先，要实现一个用 Python 编写的简单的 Ping 服务端程序，然后再实现对应的客户端程序。程序功能类似于现代操作系统中可用的标准 Ping 程序功能，不过这里使用简单的 UDP 协议，而不是标准互联网控制消息协议（ICMP）来进行通信的</p><h3 id="1-1-基于-UDP-协议的-Socket-套接字编程"><a href="#1-1-基于-UDP-协议的-Socket-套接字编程" class="headerlink" title="1.1 基于 UDP 协议的 Socket 套接字编程"></a>1.1 基于 UDP 协议的 Socket 套接字编程</h3><p>UDP 协议是非连接的协议，通信双方不用建立连接，而是直接把要发送的数据发送给对方。UDP 协议适用于一次传输数据量很少，对可靠性要求不高的应用场景。但由于UDP 协议没有类似于 TCP 的三次握手、可靠传输机制等，所以通信效率比较高。</p><p>UDP 协议的应用也非常广泛，比如知名的应用层协议：SNMP、DNS 都是基于 UDP的。一个常用的 UDP 通信的框架如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.2h2w2f6qok40.webp#pic_center" width = 64%><p>由图可以看出，客户端要发起一次请求，仅仅需要两个步骤（socket 和 sendto），而服务器端也仅仅需要三个步骤即可接收到来自客户端的消息（socket、bind、recvfrom）。和 TCP 通信不同的是，UDP 通信不需要监听（listen）及建立连接（accept）步骤，在创建及套接字后，可以直接使用 <code>sendto()</code> 及 <code>recvform()</code> 进行数据的发送及接收。</p><h3 id="1-2-UDP-Ping服务程序框架"><a href="#1-2-UDP-Ping服务程序框架" class="headerlink" title="1.2 UDP Ping服务程序框架"></a>1.2 UDP Ping服务程序框架</h3><p>在这个简单的 UDP Ping 服务器程序中，完成套接字创建及绑定后，当接收到消息后进行简单处理（这里是转化为大写），再将消息回传给相应的客户端。</p><h4 id="1-2-1-Ping服务端创建UDP套接字"><a href="#1-2-1-Ping服务端创建UDP套接字" class="headerlink" title="1.2.1 Ping服务端创建UDP套接字"></a>1.2.1 Ping服务端创建UDP套接字</h4><p>创建UDP套接字，绑定地址包含主机及其端口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">12000</span>))</span><br></pre></td></tr></table></figure><h4 id="1-2-2-UDP通信中发送与接收数据"><a href="#1-2-2-UDP通信中发送与接收数据" class="headerlink" title="1.2.2 UDP通信中发送与接收数据"></a>1.2.2 UDP通信中发送与接收数据</h4><p>在 UDP 通信中，使用 <code>sendto()</code> 函数发送 UDP 数据，将数据发送到套接字，输入参数 address 是形式为 <code>(host, port)</code> 的元组，指定远程地址，其中 <code>host</code> 表示服务器地址，<code>port</code> 表示服务器端口号。返回值是发送的字节数。</p><p>接收数据使用 <code>recvfrom()</code> 函数实现。输入参数为接收缓冲区大小。该函数接收 UDP 数据，与 <code>recv()</code> 类似，但返回值是 <code>(data, address)</code>。其中 <code>data</code> 是包含接收数据的字符串，<code>address</code> 是发送数据的套接字地址。</p><p><strong>示例如下：</strong></p><ul><li><p>接收数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg, addr = udp_server.recvfrom(BUFSIZE)   <span class="comment"># 使用套接字对象udp_server的recvfrom()方法接收数据</span></span><br></pre></td></tr></table></figure></li><li><p>发送数据</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp_server.sendto(msg,addr)     <span class="comment"># 使用套接字对象udp_server的sendto()方法发送数据</span></span><br></pre></td></tr></table></figure><p>完整的服务器程序一般都处于后台服务状态，通过不断循环等待客户端发送 <code>Ping</code> 消息，经过简单处理后，将消息发给相应的客户端。</p><p>在本实验中，为了避免大量资源的消耗，设置了一个接收消息计数器，当接收到消息超过设定值后，服务程序就退出（break）循环。</p><p>UDP为应用程序提供了不可靠的传输服务。消息可能因为路由器队列溢出，硬件错误或其他原因，而在网络中丢失。但由于在内网中很少丢包甚至不丢包，所以在本实验室的服务器程序添加人为损失来模拟网络丢包的影响。这里为了模拟，采用对接收到的消息计数器进行模运算，当模 3 的取值为 1 时，就不回传消息，返回接收下一条消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建UDP套接字</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定本机IP地址和端口号</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>))</span><br><span class="line"></span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接收客户端消息</span></span><br><span class="line">    message, address = serverSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将数据包消息转换为大写</span></span><br><span class="line">    message = message.upper()</span><br><span class="line">        </span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将消息传回给客户端</span></span><br><span class="line">    serverSocket.sendto(message, address)</span><br></pre></td></tr></table></figure><h3 id="1-3-客户端创建UDP套接字"><a href="#1-3-客户端创建UDP套接字" class="headerlink" title="1.3 客户端创建UDP套接字"></a>1.3 客户端创建UDP套接字</h3><p>创建 UDP 套接字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure><h4 id="1-3-1-设置套接字超时时间"><a href="#1-3-1-设置套接字超时时间" class="headerlink" title="1.3.1 设置套接字超时时间"></a>1.3.1 设置套接字超时时间</h4><p>在进行客户端向服务器发送 Ping 消息的过程中，有时候可能会因为网络原因造成一直连不上服务器（如服务器程序没有开启），这时如不手动停止，Socket 可能会一直尝试重连，造成资源的浪费。这就需要设置 <code>timeout</code> 来限制重连时间，当 Socket 尝试重连到指定的时间时，就会停止一切操作，并提示达到 <code>timeout</code> 设定阈值。设置超时时间一般在创建套接字后，在网络通信之前进行。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysocket.settimeout(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>代码作用为设定套接字的超时时间为 10 秒</p><p>客户端程序在创建完套接字后，通过循环向服务器发送消息，然后接收服务器回传的消息，通过计算收到消息及发送消息的时间差，来反映网络的状况。如果超时时间过后还没收到消息，则报出超时异常。</p><h4 id="1-3-2-客户端向服务器发送消息并接收消息"><a href="#1-3-2-客户端向服务器发送消息并接收消息" class="headerlink" title="1.3.2 客户端向服务器发送消息并接收消息"></a>1.3.2 客户端向服务器发送消息并接收消息</h4><p><strong>1. 消息编解码</strong></p><p>在网络通信中，网络线路中传输的是字节（二进制格式）流 <code>bytes</code>。但在我们发送的消息习惯用字符串 <code>string</code> 来表示，这时就需要用编码 <code>encode()</code> 和解码 <code>decode()</code> 函数来转换。</p><p><code>encode()</code> 函数：字符串类型（str）提供的方法，用于将字符串类型转换成 bytes 类型，这个过程也称为“编码”。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>注意，格式中用 [] 括起来的参数为可选参数，也就是说，在使用此方法时，可以使用 [] 中的参数，也可以不使用。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.53ukirqvzok0.webp#pic_center" width = 64%><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode()</span><br></pre></td></tr></table></figure><p>采用默认的 UTF-8 字符集将 str 编码为字节流</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode(<span class="string">&#x27;GBK&#x27;</span>)</span><br></pre></td></tr></table></figure><p>采用指定的 GBK 字符集将 str 编码为字节流</p><p><code>decode()</code> 函数：用于将 bytes 类型的二进制数据转换为 string 类型，这个过程也称为“解码”。其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>使用默认的 UTF-8 字符集进行解码为字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode()</span><br></pre></td></tr></table></figure><p>如果编码时采用的不是默认的 UTF-8 编码，则解码时要选择和编码时一样的格式，否则会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span> = <span class="built_in">str</span>.encode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line"><span class="built_in">bytes</span>.decode()  <span class="comment">#默认使用 UTF-8 编码，会抛出以下异常。</span></span><br><span class="line"><span class="built_in">bytes</span>.decode(<span class="string">&quot;GBK&quot;</span>)  <span class="comment">#不会抛出异常</span></span><br></pre></td></tr></table></figure><p>在 Ping 客户端程序中，发送消息时将发送消息的序号及发送时间发送到 Ping 服务器，然后接收消息，并将收到消息的时间与发送消息的时间差作为消息的延迟时间进行计算，并打印出来。</p><p>客户端程序为：</p><ol><li>使用UDP发送<code>ping</code>消息（注意：不同于TCP，您不需要首先建立连接，因为UDP是无连接协议。）</li><li>从服务器输出响应消息</li><li>如果从服务器受到响应，则计算并输出每个数据包的往返时延（RTT）（以秒为单位），</li><li>否则输出“请求超时”</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;127.0.0.1&#x27;</span> <span class="comment"># 服务器地址，本例中使用本机地址</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment"># 服务器指定的端口</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment"># 创建UDP套接字，使用IPv4协议</span></span><br><span class="line">clientSocket.settimeout(<span class="number">1</span>) <span class="comment"># 设置套接字超时值1秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">    sendTime = time.time()</span><br><span class="line">    message = (<span class="string">&#x27;Ping %d %s&#x27;</span> % (i+<span class="number">1</span>, sendTime)).encode()     <span class="comment"># 生成数据报，编码为bytes以便发送</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将信息发送到服务器</span></span><br><span class="line">        clientSocket.sendto(message, (serverName, serverPort))</span><br><span class="line">        <span class="comment"># 从服务器接收信息，同时也能得到服务器地址</span></span><br><span class="line">        modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">        rtt = time.time() - sendTime    <span class="comment"># 计算往返时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Reply from %s    RTT = %.3fs&#x27;</span> % (i+<span class="number">1</span>, serverName, rtt))         <span class="comment"># 显示信息</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Request timed out.&#x27;</span> % (i+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">clientSocket.close()            <span class="comment"># 关闭套接字</span></span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><p>在一台主机上运行<code>UDPPingerServer.py</code>，作为接收ping程序数据的服务器。</p><p>效果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.7g8vggsmopo0.webp#pic_center" width = 64%><p><strong>客户端：</strong></p><p>在另一台主机上运行<code>UDPPinger.py</code>，效果如下：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.2qzffvjk6qw0.webp#pic_center" width = 48%>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（五）-- TCP套接字编程</title>
      <link href="/article/84fa558.html"/>
      <url>/article/84fa558.html</url>
      
        <content type="html"><![CDATA[<p>本文将首先利用 Python 实现面向TCP连接的套接字编程基础知识：如何创建套接字，将其绑定到特定的地址和端口，以及发送和接收数据包。其次还将学习 HTTP 协议格式的相关知识。在此基础上，本篇将用 Python 语言开发一个简单的 Web 服务器，它仅能处理一个HTTP连接请求。</p><span id="more"></span><h2 id="1-Python3-网络编程"><a href="#1-Python3-网络编程" class="headerlink" title="1 Python3 网络编程"></a>1 Python3 网络编程</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Web 服务器的基本功能是接受并解析客户端的 HTTP 请求，然后从服务器的文件系统获取所请求的文件，生成一个由头部和响应文件内容所构成成的 HTTP 响应消息，并将该响应消息发送给客户端。如果请求的文件不存在于服务器中，则服务器应该向客户端发送“404 Not Found”差错报文。</p><p> &#x3D;&#x3D;具体的过程分为：&#x3D;&#x3D;</p><ul><li>当一个客户（浏览器）连接时，创建一个连接套接字；</li><li>从这个连接套接字接收 HTTP 请求；</li><li>解释该请求以确定所请求的特定文件；</li><li>从服务器的文件系统获得请求的文件；</li><li>创建一个由请求的文件组成的 HTTP 响应报文，报文前面有首部行；</li><li>经 TCP 连接向请求浏览器发送响应。</li><li>如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。</li></ul><p>要实现 Web 服务器，需使用套接字 Socket 编程接口来使用操作系统提供的网络通信功能。</p><p><font color=#9900CC><strong>Socket 是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，是一组编程接口。它把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。使用 Socket 后，无需深入理解 TCP&#x2F;UDP 协议细节（因为Socket 已经为我们封装好了），只需要遵循 Socket 的规定去编程，写出的程序自然就是遵循 TCP&#x2F;UDP 标准的。</strong></font>Socket 的地位如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.1wujw2azhhhc.webp#pic_center" width = 36%><p><font color=#9900CC><strong>从某种意义上说，Socket 由地址IP和端口Port构成。</font></strong>IP 是用来标识互联网中的一台主机的位置，而 Port 是用来标识这台机器上的一个应用程序，IP 地址是配置到网卡上的，而 Port 是应用程序开启的，IP 与 Port 的绑定就标识了互联网中独一无二的一个应用程序。</p><p><strong>套接字类型</strong></p><ul><li>流式套接字（SOCK_STREAM）：用于提供面向连接、可靠的数据传输服务。——TCP</li><li>数据报套接字（SOCK_DGRAM）：提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。——UDP</li><li>原始套接字（SOCK_RAW）：主要用于实现自定义协议或底层网络协议。</li></ul><p>在本 WEB 服务器程序实验中，采用流式套接字进行通信。其基本模型如下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.3r9nhi7ohm00.webp#pic_center" width = 48%><p>其工作过程如下：服务器首先启动，通过调用 <code>socket()</code> 建立一个套接字，然后调用绑定方法 <code>bind()</code> 将该套接字和本地网络地址联系在一起，再调用 <code>listen()</code> 使套接字做好侦听连接的准备，并设定的连接队列的长度。客户端在建立套接字后，就可调用连接方法 <code>connect()</code> 向服务器端提出连接请求。服务器端在监听到连接请求后，建立和该客户端的连接，并放入连接队列中，并通过调用 <code>accept()</code> 来返回该连接，以便后面通信使用。客户端和服务器连接一旦建立，就可以通过调用接收方法 <code>recv()/recvfrom()</code> 和发送 方法 <code>send()/sendto()</code> 来发送和接收数据。最后，待数据传送结束后，双方调用 <code>close()</code> 关闭套接字。</p><blockquote><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p></blockquote><hr><h2 id="2-创建TCP套接字"><a href="#2-创建TCP套接字" class="headerlink" title="2 创建TCP套接字"></a>2 创建TCP套接字</h2><h3 id="2-1-套接字"><a href="#2-1-套接字" class="headerlink" title="2.1 套接字"></a>2.1 套接字</h3><p><font color=#9900CC><strong>套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I&#x2F;O 插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是 IP 地址与端口 Port 的组合。</font></strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.1a0a2dxbsfr4.webp#pic_center" width = 48%><p>为了满足不同的通信程序对通信质量和性能的要求，网络系统提供了三种不同类型的套接字，以供用户在设计网络应用程序时根据不同的要求来选择。分别是：</p><ul><li>流式套接字（SOCK-STREAM）。提供一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在 TCP&#x2F;IP 协议簇中，使用 TCP 协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</li><li>数据报套接字（SOCK-DGRAM）。提供一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在 TCP&#x2F;IP 协议簇中，使用 UDP 协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</li><li>原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如 IP 或 ICMP ）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</li></ul><p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建 <code>socket</code> 对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。<font color=#9900CC><strong>这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</font></strong></p><p>Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。</p><h3 id="2-2-如何创建套接字"><a href="#2-2-如何创建套接字" class="headerlink" title="2.2 如何创建套接字"></a>2.2 如何创建套接字</h3><p>套接字 Socket 实质上提供了主机间进程通信的连接点。进程通信之前，双方首先必须各自创建一个连接点。否则是没有办法建立联系并相互通信的。Python 中，我们用 <code>socket()</code> 函数来创建套接字，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my_socket = socket(socket_family, socket_type, protocol=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">socket_family可以是如下参数之一：</span></span><br><span class="line"><span class="string">  　　AF_INET IPv4（默认）</span></span><br><span class="line"><span class="string">　　  AF_INET6 IPv6</span></span><br><span class="line"><span class="string">　　  AF_UNIX 只能够用于单一的Unix系统进程间通信</span></span><br><span class="line"><span class="string">socket_type可以是如下参数之一:</span></span><br><span class="line"><span class="string">　　  SOCK_STREAM　　流式socket , for TCP （默认）</span></span><br><span class="line"><span class="string">　  　SOCK_DGRAM　　 数据报式socket , for UDP</span></span><br><span class="line"><span class="string">　  　SOCK_RAW 原始套接字</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>Socket 对象(内建)方法</strong></p><table> <thead> <tr> <th align="left">函数</th> <th align="left">描述</th> </tr> </thead> <tbody><tr> <td align="left">服务器端套接字</td>  </tr> <tr> <td align="left">s.bind()</td> <td align="left">绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</td> </tr> <tr> <td align="left">s.listen()</td> <td align="left">开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td> </tr> <tr> <td align="left">s.accept()</td> <td align="left">被动接受TCP客户端连接,(阻塞式)等待连接的到来</td> </tr> <tr> <td align="left">客户端套接字</td>  </tr> <tr> <td align="left">s.connect()</td> <td align="left">主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td> </tr> <tr> <td align="left">s.connect_ex()</td> <td align="left">connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td> </tr> <tr> <td align="left">公共用途的套接字函数</td>  </tr> <tr> <td align="left">s.recv()</td> <td align="left">接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td> </tr> <tr> <td align="left">s.send()</td> <td align="left">发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td> </tr> <tr> <td align="left">s.sendall()</td> <td align="left">完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td> </tr> <tr> <td align="left">s.recvfrom()</td> <td align="left">接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td> </tr> <tr> <td align="left">s.sendto()</td> <td align="left">发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td> </tr> <tr> <td align="left">s.close()</td> <td align="left">关闭套接字</td> </tr> <tr> <td align="left">s.getpeername()</td> <td align="left">返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td> </tr> <tr> <td align="left">s.getsockname()</td> <td align="left">返回套接字自己的地址。通常是一个元组(ipaddr,port)</td> </tr> <tr> <td align="left">s.setsockopt(level,optname,value)</td> <td align="left">设置给定套接字选项的值。</td> </tr> <tr> <td align="left">s.getsockopt(level,optname[.buflen])</td> <td align="left">返回套接字选项的值。</td> </tr> <tr> <td align="left">s.settimeout(timeout)</td> <td align="left">设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td> </tr> <tr> <td align="left">s.gettimeout()</td> <td align="left">返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td> </tr> <tr> <td align="left">s.fileno()</td> <td align="left">返回套接字的文件描述符。</td> </tr> <tr> <td align="left">s.setblocking(flag)</td> <td align="left">如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td> </tr> <tr> <td align="left">s.makefile()</td> <td align="left">创建一个与该套接字相关连的文件</td> </tr> </tbody></table><h3 id="2-3-如何为套接字绑定主机及端口"><a href="#2-3-如何为套接字绑定主机及端口" class="headerlink" title="2.3 如何为套接字绑定主机及端口"></a>2.3 如何为套接字绑定主机及端口</h3><p>一个完整的 Socket 可以用一个通信双方的相关描述：<br>         $${协议,本地地址,本地端口,远程地址,远程端口}$$</p><p>实际应用中，在创建一个 Socket 时先用一个半相关描述（服务器这一半可以确定，而另一半尚不确定）:<br>         $${协议,本地地址,本地端口}$$<br>每一个 Socket 有一个本地的唯一端口号，由操作系统分配。</p><p>绑定指为套接字绑定地址包含主机及其端口。 在 AF_INET 下，以元组（host,port）的形式表示地址。</p><ul><li>host：用字符串表示主机的 IP 地址。表示本机<code>&#39;&#39;</code>，也可用 <code>127.0.0.1</code> 表示回环地址，或者主机的一般 IP 地址。</li><li>port：端口号，数字表示。1024 以下为系统约定，自定义的用 1024 以上。</li></ul><p>绑定通过套接字的绑定方法 <code>bind()</code> 来完成，输入参数为元组 <code>(host,port)</code>。<br><strong>绑定示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_socket.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1234</span>))         <span class="comment"># 绑定本地回环地址</span></span><br><span class="line">my_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">1234</span>))                  <span class="comment"># 自动获取IP地址</span></span><br></pre></td></tr></table></figure><h3 id="2-4-如何设置套接字监听"><a href="#2-4-如何设置套接字监听" class="headerlink" title="2.4 如何设置套接字监听"></a>2.4 如何设置套接字监听</h3><p>服务器程序在调用创建套接字 <code>socket()</code> 和绑定 <code>bind()</code> 之后需要处于监听状态，因为不知客户端什么时候开始进行请求连接。为此，需调用套接字的监听方法 <code>listen()</code>。</p><p>一个服务端可能同时面对多个客户端的连接请求，为此服务器程序需创建一个连接队列来保存的连接请求，并依次为连接请求建立相应连接。为此需设置队列的大小作为监听方法的参数。<br>监听示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_socket.listen(<span class="number">10</span>)    <span class="comment"># 设置连接队列大小为10，并使套接字处于监听状态。</span></span><br></pre></td></tr></table></figure><h3 id="2-5-服务端获取连接请求"><a href="#2-5-服务端获取连接请求" class="headerlink" title="2.5 服务端获取连接请求"></a>2.5 服务端获取连接请求</h3><h4 id="2-5-1-如何获取客户端的连接请求"><a href="#2-5-1-如何获取客户端的连接请求" class="headerlink" title="2.5.1 如何获取客户端的连接请求"></a>2.5.1 如何获取客户端的连接请求</h4><p>当服务器中的套接字监听到了连接请求之后，内核和客户建立连接，并将连接放入连接队列中。典型的服务器程序是可以同时服务多个客户端的，当有客户端发起连接时，服务器就调用 <code>accept()</code> 返回并接收这个连接，如果有大量客户端发起请求，服务器来不及处理，还没有 accept 的客户端就处于连接等待状态。如果服务器调用 <code>accept()</code> 时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection_socket，addr = my_socket.accept()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">返回值： </span></span><br><span class="line"><span class="string">connectionSocket 客户端连接套接字</span></span><br><span class="line"><span class="string">addr 连接的客户端地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的 connectionSocket 称为客户端连接套接字，是 <code>accept()</code> 接收到一个客户端连接请求后返回的一个新的套接字，它代表了服务端和客户端的连接。后面可以用于读取数据以及关闭连接。</p><h4 id="2-5-2-如何获取客户端发送的报文内容"><a href="#2-5-2-如何获取客户端发送的报文内容" class="headerlink" title="2.5.2 如何获取客户端发送的报文内容"></a>2.5.2 如何获取客户端发送的报文内容</h4><p>服务器与客户端的连接建立好之后，就可以接收或发送消息操作。相应有下面几组方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recv()/send()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure><p>接收报文方法 <code>recv()</code> 用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = socket.recv(buffersize)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">　　　　　功能 ： 接收对应客户端消息</span></span><br><span class="line"><span class="string">　　　　　参数 ： 一次最多接收多少字节</span></span><br><span class="line"><span class="string">　　　　　返回值 ： 接收到的内容</span></span><br><span class="line"><span class="string">　　　    *  如果没有消息则会阻塞等待</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-服务端读取请求文件内容"><a href="#2-6-服务端读取请求文件内容" class="headerlink" title="2.6 服务端读取请求文件内容"></a>2.6 服务端读取请求文件内容</h3><h4 id="2-6-1-如何获取客户端请求的网页文件名"><a href="#2-6-1-如何获取客户端请求的网页文件名" class="headerlink" title="2.6.1 如何获取客户端请求的网页文件名"></a>2.6.1 如何获取客户端请求的网页文件名</h4><p>HTTP 请求是客户端通过发送信息向服务器请求对资源的访问。HTTP 请求由三部分组成：请求行、请求头和请求正文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /index.html HTTP/<span class="number">1.1</span>   <span class="comment"># 请求方法 url 协议及版本号</span></span><br><span class="line">Host: localhost             <span class="comment"># 主机地址</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">5.1</span>; rv:<span class="number">10.0</span><span class="number">.2</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">10.0</span><span class="number">.2</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*/*;q=<span class="number">0.8</span></span><br><span class="line">Accept-Language: zh-cn,zh;q=<span class="number">0.5</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: &lt;a target=_blank href=<span class="string">&quot;http://localhost/&quot;</span> style=<span class="string">&quot;color: rgb(51, 102, 153); text-decoration: none;&quot;</span>&gt;http://localhost/&lt;/a&gt;</span><br><span class="line">Content-Length：<span class="number">25</span></span><br><span class="line">Content-<span class="type">Type</span>：application/x-www-form-urlencoded</span><br><span class="line">`     `</span><br><span class="line">username=aa&amp;password=<span class="number">1234</span>             <span class="comment"># 请求体</span></span><br></pre></td></tr></table></figure><p>从上方代码可以看出，请求网页文件名位于请求行（第一行）中用空格分隔的第二个部分。</p><p>在获得请求文件名后，读取文件内容使用文件操作来实现。Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。</p><h3 id="2-7-服务端响应请求头部信息"><a href="#2-7-服务端响应请求头部信息" class="headerlink" title="2.7 服务端响应请求头部信息"></a>2.7 服务端响应请求头部信息</h3><h4 id="2-7-1-WEB服务器响应消息头部定义"><a href="#2-7-1-WEB服务器响应消息头部定义" class="headerlink" title="2.7.1 WEB服务器响应消息头部定义"></a>2.7.1 WEB服务器响应消息头部定义</h4><p>WEB 服务器在接收到客户端的连接请求后，接下来就会响应该请求。HTTP 响应报文由三部分组成：响应行、响应头、响应体。如下图所示。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.36a8ikrs6si0.webp#pic_center" width = 48%><ul><li>响应行：一般由协议版本、状态码及其描述组成，比如 <code>HTTP/1.1 200 OK</code> 其中协议版本 <code>HTTP/1.1</code> 或者 <code>HTTP/1.0</code>，<code>200</code> 就是它的状态码，<code>OK</code> 则为它的描述。</li><li>响应头：用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理它回送的数据。</li></ul><p>常见的响应头字段含义：</p><ul><li>Allow：服务器支持哪些请求方法(如GET、POST等)。</li><li>Content-Encoding：文档的编码(Encode)方法。</li><li>Content-Length：表示内容长度。</li><li>Content-Type：表示后面的文档属于什么MIME类型。</li><li>Date：当前的GMT时间</li><li>Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。</li><li>Last-Modified：文档的最后改动时间。</li><li>Location：用于重定向接收者到一个新URI地址。</li><li>Refresh：告诉浏览器隔多久刷新一次，以秒计。</li><li>Server：服务器通过这个头告诉浏览器服务器的类型。</li></ul><p>在这个 WEB 服务器返回的头部信息示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Connection: close</span><br><span class="line">Content-<span class="type">Type</span>: text/html</span><br><span class="line">Content-Length: <span class="number">24</span></span><br></pre></td></tr></table></figure><h4 id="2-7-2-发送响应消息头部内容"><a href="#2-7-2-发送响应消息头部内容" class="headerlink" title="2.7.2 发送响应消息头部内容"></a>2.7.2 发送响应消息头部内容</h4><p>在定义好响应消息的头部信息后，使用套接字的 send 方法发送即可。在发送前需要使用编码 <code>encode()</code> 方法，将字符串转换为字节数组后发送。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(header.encode())</span><br></pre></td></tr></table></figure><h4 id="2-7-3-如何捕获请求文件读取错误的异常"><a href="#2-7-3-如何捕获请求文件读取错误的异常" class="headerlink" title="2.7.3 如何捕获请求文件读取错误的异常"></a>2.7.3 如何捕获请求文件读取错误的异常</h4><p>在本服务器程序中，采用 <code>try...except</code> 结构来捕获异常。当请求的文件不存在（可能是文件名错误或路径错误）及其他可能导致文件访问错误（如没有相应权限）时，就会产生 IOError 异常。从而进入异常处理部分代码。</p><p><strong>发送自定义的异常信息给客户端</strong></p><p>在异常处理代码中，定义响应客户端请求文件不存在的响应消息头代码 404 及消息内容not Found。</p><p>将此响应消息头发给客户端，可以使用 socket 的发送方法 <code>send()</code> 完成，发送前需要使用编码方法 <code>encode()</code> 对响应消息进行编码。</p><p><strong>完整代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line"><span class="comment"># Prepare a sever socket </span></span><br><span class="line">serverSocket.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6789</span>))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始WEB服务...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">            connectionSocket, addr = serverSocket.accept()</span><br><span class="line">            message = connectionSocket.recv(<span class="number">1024</span>) <span class="comment"># 获取客户发送的报文</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 读取文件内容</span></span><br><span class="line">            filename = message.split()[<span class="number">1</span>]       <span class="comment"># message=[&quot;POST&quot;, &quot;/index.html&quot;, &quot;HTTP/1.1&quot;, ...]</span></span><br><span class="line">            f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">            outputdata = f.read()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 向套接字发送头部信息</span></span><br><span class="line">            header = <span class="string">&#x27; HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n&#x27;</span> % (<span class="built_in">len</span>(outputdata))</span><br><span class="line">            connectionSocket.send(header.encode())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送请求文件的内容</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">                connectionSocket.send(outputdata[i].encode())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line">            connectionSocket.close()</span><br><span class="line">    <span class="keyword">except</span> IOError:             <span class="comment"># 异常处理</span></span><br><span class="line">            <span class="comment"># 发送文件未找到的消息</span></span><br><span class="line">            header = <span class="string">&#x27; HTTP/1.1 404 not Found&#x27;</span></span><br><span class="line">            <span class="comment">#########Begin#########</span></span><br><span class="line">            connectionSocket.send(header.encode())</span><br><span class="line">            <span class="comment">#########End#########</span></span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line">            connectionSocket.close()</span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    serverSocket.close()</span><br></pre></td></tr></table></figure><p>上面建立了一个只允许一个连接的服务器，在指定端口监听客户端的请求，从客户端发送的请求中提取文件名，若该文件存在于服务器上（如下文的<code>&quot;HelloWorld.html&quot;</code>），则生成一个状态码200的POST报文，并返回该文件；若该文件不存在，则返回一个404 Not Found报文。</p><p><strong>HelloWorld.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><p>在一台主机上的同一目录下放入<code>WebServer.py</code>和<code>HelloWorld.html</code>两个文件，并运行<code>WebServer.py</code>，作为服务器。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.1q8kc9lae4sg.webp#pic_center" width = 48%><p><strong>客户端：</strong></p><p>在另一台主机上打开浏览器，并输入”<a href="http://xxx.xxx.xxx.xxx:6789/HelloWorld.html">http://XXX.XXX.XXX.XXX:6789/HelloWorld.html</a>“ （其中”XXX.XXX.XXX.XXX”是服务器IP地址），以获取服务器上的<code>HelloWorld.html</code>文件。</p><p>一切正常的话，可以看到如下页面：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1kv6ji5c5ygw.webp#pic_center" width = 48%><p>输入新地址<code>&quot;http://XXX.XXX.XXX.XXX:6789/abc.html&quot;</code>，以获取服务器上不存在的<code>abc.html</code>。将出现以下页面（注意页面中的”HTTP ERROR 404”）：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.7jp8f2p1r000.webp#pic_center" width = 48%><h3 id="2-8-示例分析"><a href="#2-8-示例分析" class="headerlink" title="2.8 示例分析"></a>2.8 示例分析</h3><p><strong>1. 服务端</strong></p><p>下面的代码实现了一个提供时间日期的服务器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230420</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 一个提供时间日期的服务器</span></span><br><span class="line"><span class="comment"># @Filename: server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET, gethostname</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1. 创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    <span class="comment"># family=AF_INET - IPv4地址</span></span><br><span class="line">    <span class="comment"># family=AF_INET6 - IPv6地址</span></span><br><span class="line">    <span class="comment"># type=SOCK_STREAM - TCP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_DGRAM - UDP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_RAW - 原始套接字</span></span><br><span class="line">    server = socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2. 绑定IP地址和端口（端口用于区分不同的服务）</span></span><br><span class="line">    <span class="comment"># 同一个时间在同一个端口只能绑定一个服务否则报错</span></span><br><span class="line">    <span class="comment"># server.bind((&#x27;192.168.1.2&#x27;, 1030))</span></span><br><span class="line">    host = gethostname()            <span class="comment"># 获取本地主机名</span></span><br><span class="line">    port = <span class="number">9999</span>                     <span class="comment"># 绑定端口号</span></span><br><span class="line">    server.bind((host, port))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    <span class="comment"># 参数512可以理解为连接队列的大小，超过后排队</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器启动开始监听……&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.通过循环接收客户端的连接并作出相应的处理(提供服务)</span></span><br><span class="line">        <span class="comment"># accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行</span></span><br><span class="line">        <span class="comment"># accept方法返回一个元组其中的第一个元素是客户端对象</span></span><br><span class="line">        <span class="comment"># 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)</span></span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(addr) + <span class="string">&quot;连接到了服务器.&quot;</span>)</span><br><span class="line">        <span class="comment"># 5. 发送数据</span></span><br><span class="line">        client.send(<span class="built_in">str</span>(datetime.now()).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># 6. 断开连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>查找自己电脑IP和端口的方法：<br>  <strong>第一步： Win+R</strong><br>  <strong>第二步： 输入：cmd  然后点击确定（Enter）进入</strong><br>  <strong>第三步： 输入：ipconfig  然后Enter</strong><br>  <strong>第四步： 输入：netstat 然后Enter</strong>  一般用第一个就行</p></blockquote><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.1r14az76m0g0.webp#pic_center" width = 48%><p>运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.1lq3ku8fzvkw.webp#pic_left" width = "30%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.v6i83q4ig28.webp#pic_left"  width = "48%"></center></p><p>Windows开启telnet服务，见下图所示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.72oe6hf6xfc0.gif#pic_center" width = 48%><p>当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p><p><strong>2. 客户端</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: CarpeDiem</span></span><br><span class="line"><span class="comment"># @Date: 230420</span></span><br><span class="line"><span class="comment"># @Version: 1.0</span></span><br><span class="line"><span class="comment"># @Description: 一个接受时间日期的客户端</span></span><br><span class="line"><span class="comment"># @Filename: client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET, gethostname</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字对象默认使用IPv4和TCP协议</span></span><br><span class="line">    <span class="comment"># client = socket()</span></span><br><span class="line">    client = socket(family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.连接到服务器（需要指定IP地址和端口）</span></span><br><span class="line">    <span class="comment"># client.connect((&#x27;10.69.164.78&#x27;, 1030))</span></span><br><span class="line">    host = gethostname()            <span class="comment"># 获取本地主机名</span></span><br><span class="line">    port = <span class="number">9999</span>                     <span class="comment"># 绑定端口号</span></span><br><span class="line">    client.connect((host, port))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.从服务器接受数据, 接收小于 1024 字节的数据</span></span><br><span class="line">    <span class="built_in">print</span>(client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>现在我们打开两个终端，第一个终端执行 <code>server.py</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 server.py</span><br></pre></td></tr></table></figure><p>第二个终端执行 <code>client.py</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 client.py</span><br><span class="line">2023-04-19 17:04:30.293444</span><br></pre></td></tr></table></figure><p>这时我们再打开第一个终端，就会看到有以下信息输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;192.168.1.2&#x27;</span>, 11046)连接到了服务器.</span><br></pre></td></tr></table></figure><p>需要注意的是，上面的服务器并没有使用多线程或者异步I&#x2F;O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p><p><strong>服务器端代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> dumps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自定义线程类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileTransferHandler</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cclient</span>):</span><br><span class="line">            <span class="built_in">super</span>().__init__()</span><br><span class="line">            self.cclient = cclient</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">            my_dict = &#123;&#125;</span><br><span class="line">            my_dict[<span class="string">&#x27;filename&#x27;</span>] = <span class="string">&#x27;guido.jpg&#x27;</span></span><br><span class="line">            <span class="comment"># JSON是纯文本不能携带二进制数据</span></span><br><span class="line">            <span class="comment"># 所以图片的二进制数据要处理成base64编码</span></span><br><span class="line">            my_dict[<span class="string">&#x27;filedata&#x27;</span>] = data</span><br><span class="line">            <span class="comment"># 通过dumps函数将字典处理成JSON字符串</span></span><br><span class="line">            json_str = dumps(my_dict)</span><br><span class="line">            <span class="comment"># 发送JSON字符串</span></span><br><span class="line">            self.cclient.send(json_str.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            self.cclient.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    server = socket()</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(区分不同的服务)</span></span><br><span class="line">    server.bind((<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;服务器启动开始监听...&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guido.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将二进制数据处理成base64再解码成字符串</span></span><br><span class="line">        data = b64encode(f.read()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 启动一个线程来处理客户端的请求</span></span><br><span class="line">        FileTransferHandler(client).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> loads</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    client = socket()</span><br><span class="line">    client.connect((<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 定义一个保存二进制数据的对象</span></span><br><span class="line">    in_data = <span class="built_in">bytes</span>()</span><br><span class="line">    <span class="comment"># 由于不知道服务器发送的数据有多大每次接收1024字节</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="comment"># 将收到的数据拼接起来</span></span><br><span class="line">        in_data += data</span><br><span class="line">        data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将收到的二进制数据解码成JSON字符串并转换成字典</span></span><br><span class="line">    <span class="comment"># loads函数的作用就是将JSON字符串转成字典对象</span></span><br><span class="line">    my_dict = loads(in_data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    filename = my_dict[<span class="string">&#x27;filename&#x27;</span>]</span><br><span class="line">    filedata = my_dict[<span class="string">&#x27;filedata&#x27;</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/Hao/&#x27;</span> + filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将base64格式的数据解码成二进制数据并写入文件</span></span><br><span class="line">        f.write(b64decode(filedata))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;图片已保存.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“&#x2F;”总共64个字符表示从000000到111111的64种状态。<a href="https://zh.wikipedia.org/wiki/Base64">维基百科</a>上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>网络编程入门：<a href="https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.md">https://gitee.com/zengyujin/Python-100-Days/blob/master/Day01-15/14.网络编程入门和网络应用开发.md</a></li><li>Python3 网络编程：<a href="https://www.nowcoder.com/tutorial/10005/99e037cb31a1486a8cf8ea61eb58dc8c">https://www.nowcoder.com/tutorial/10005/99e037cb31a1486a8cf8ea61eb58dc8c</a></li><li>WEB服务器编程实现：<a href="https://www.educoder.net/shixuns/synqujxr/challenges">https://www.educoder.net/shixuns/synqujxr/challenges</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP 套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（四）-- TCP/IP协议族详解</title>
      <link href="/article/1ee3e5d0.html"/>
      <url>/article/1ee3e5d0.html</url>
      
        <content type="html"><![CDATA[<p>TCP&#x2F;IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。TCP&#x2F;IP协议模型，包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><span id="more"></span><p>基于TCP&#x2F;IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP&#x2F;IP模型与OSI模型各层的对照关系。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/024.5pqdp6bd4sw0.webp#pic_center" width = 48%><p><strong>1) 网络接口层</strong><br>        主要是指物理层次的一些接口，比如电缆等。</p><p><strong>2) 网络层</strong><br>        提供独立于硬件的逻辑寻址，实现物理地址与逻辑地址的转换。<br>        在 TCP &#x2F; IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）。</p><p><strong>3) 传输层</strong><br>        为网络提供了流量控制，错误控制和确认服务。<br>        在 TCP &#x2F; IP 协议族中有两个互不相同的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。</p><p><strong>4) 应用层</strong><br>        为网络排错，文件传输，远程控制和 Internet 操作提供具体的应用程序</p><p><strong><font color=#9900CC>重要协议：<ul><li>http (文本传输协议  当我们访问网页时使用的是http协议)  https 动态网页数据传输</li><li>  ftp  (文件传输协议  专门用于文件传输) </li><li>dhcp (自动ip地址分配协议   网络中要有一个dhcp服务器(路由器)) </li><li>   dns  (实现了域名到ip地址的解析)    ip地址    域名(www.qq.com) </li>实际网络之间通信用的是ip地址<br></br>dns服务器记录了常用的ip地址和域名的对应关系<li>icmp (ping 命令通过icmp协议发送出去的、装载错误报文信息) </li></ul></font> </strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">容易碰到的笔试面试题</span><br><span class="line">        1) tcp/ip有哪几层</span><br><span class="line">                应用层、传输层、网络层、网络接口层</span><br><span class="line">        2) 传输层有哪些协议</span><br><span class="line">                tcp   udp    icmp</span><br><span class="line">        3) 应用层有哪些协议</span><br><span class="line">                http  ftp  dns  dhcp</span><br><span class="line">        4) 请描述同一网段下主机A ping 主机B的全过程   (百度)</span><br><span class="line">                同一网段下   没用到dns</span><br><span class="line">                ping 192.168.1.100(不知道对方的网卡地址 MAC   MAC地址：每一个网卡有一个唯一地址(物理地址))    </span><br><span class="line">                如何得到对方MAC地址(用arp协议)</span><br><span class="line">                1) A发送一个ARP广播包，询问192.168.1.100的MAC地址是多少</span><br><span class="line">                2) B回送ARP包，包中携带自己的MAC地址(00 50 A9 90 88 07)    </span><br><span class="line">                3) A记录ip地址，ARP表中(以后不用发送广播包)（可以不写）</span><br><span class="line">                4) A 发送一个icmp报文给B</span><br><span class="line">                5) B收到回送一个icmp报文    </span><br></pre></td></tr></table></figure><hr><h2 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1 网络层"></a>1 网络层</h2><h3 id="1-1-IP协议"><a href="#1-1-IP协议" class="headerlink" title="1.1 IP协议"></a>1.1 IP协议</h3><p>IP协议是TCP&#x2F;IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><ul><li>A类IP地址: 0.0.0.0~127.255.255.255    IP 地址的前 8 位代表网络 ID ，后 24 位代表主机 ＩＤ。</li><li>B类IP地址:128.0.0.0~191.255.255.255   IP 地址的前 16 位代表网络 ID ，后 16 位代表主机 ＩＤ。</li><li>C类IP地址:192.0.0.0~239.255.255.255</li></ul><p>全是 0 的主机 ID 代表网络本身，比如说 IP 地址为 130.100.0.0 指的是网络 ID 为130.100 的 B 类地址。</p><p>全是 1 的主机 ID 代表广播，是用于向该网络中的全部主机方法消息的。 IP 地址为 130.100.255.255 就是网络 ID 为 130.100 网络的广播地址（二进制 IP 地址中全是 1 ，转换为十进制就是 255 ）</p><p>以十进制 127 开头的地址都是环回地址。目的地址是环回地址的消息，其实是由本地发送和接收的。主要是用于测试 TCP&#x2F;IP 软件是否正常工作。我们用 ping 功能的时候，一般用的环回地址是 127.0.0.1</p><h4 id="1-3-IP协议头"><a href="#1-3-IP协议头" class="headerlink" title="1.3 IP协议头"></a>1.3 IP协议头</h4><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/025.2hkf0vw2kgw0.webp#pic_center" width = 48%><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64</p><h3 id="1-4-ARP及RARP协议"><a href="#1-4-ARP及RARP协议" class="headerlink" title="1.4 ARP及RARP协议"></a>1.4 ARP及RARP协议</h3><p>ARP 是根据IP地址获取MAC地址的一种协议。</p><p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p><p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p><p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>RARP协议的工作与此相反，不做赘述。</p><h3 id="1-5-ICMP协议"><a href="#1-5-ICMP协议" class="headerlink" title="1.5 ICMP协议"></a>1.5 ICMP协议</h3><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><hr><h2 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2 传输层"></a>2 传输层</h2><h3 id="2-1-TCP和UDP协议"><a href="#2-1-TCP和UDP协议" class="headerlink" title="2.1 TCP和UDP协议"></a>2.1 TCP和UDP协议</h3><p>TCP&#x2F;UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/026.6oc8u9v1cf40.webp#pic_center" width = 48%><p><strong>面向报文(UDP)</strong></p><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文数据—大小有限制（64k）。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p><p><strong>面向字节流(TCP)</strong></p><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p><h3 id="2-2-TCP和UDP协议的一些应用"><a href="#2-2-TCP和UDP协议的一些应用" class="headerlink" title="2.2 TCP和UDP协议的一些应用"></a>2.2 TCP和UDP协议的一些应用</h3><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/027.mwy4ndfwxgw.webp#pic_center" width = 48%><p><strong>什么时候应该使用TCP？</strong></p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p><strong>什么时候应该使用UDP？</strong></p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><hr><h2 id="3-TCP“三次握手”和“四次挥手”"><a href="#3-TCP“三次握手”和“四次挥手”" class="headerlink" title="3 TCP“三次握手”和“四次挥手”"></a>3 TCP“三次握手”和“四次挥手”</h2><h3 id="3-1-三次握手"><a href="#3-1-三次握手" class="headerlink" title="3.1 三次握手"></a>3.1 三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。<font color=#9900CC><strong>三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</font></strong></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/028.3ue72zpsrbs0.webp#pic_center" width = 48%><ol><li>第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ol><p><strong>为什么要三次握手？</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><h3 id="3-2-四次挥手"><a href="#3-2-四次挥手" class="headerlink" title="3.2 四次挥手"></a>3.2 四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/029.4cz29awk4ty0.webp#pic_center" width = 40%><ol><li>第一次挥手： 主机A（可以使客户端，也可以是服务器端），设置Sequence Number，向主机B发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机A没有数据要发送给主机B了；</li><li>第二次挥手： 主机B收到了主机A发送的FIN报文段，向主机A回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机A进入FIN_WAIT_2状态；主机B告诉主机A，我“同意”你的关闭请求；</li><li>第三次挥手： 主机B向主机A发送FIN报文段，请求关闭连接，同时主机B进入LAST_ACK状态；</li><li>第四次挥手： 主机A收到主机B发送的FIN报文段，向主机B发送ACK报文段，然后主机A进入TIME_WAIT状态；主机B收到主机A的ACK报文段以后，就关闭连接；此时，主机A等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机A也可以关闭连接了。</li></ol><p><strong>为什么要四次挥手？</strong> </p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机A发出FIN报文段时，只是表示主机A已经没有数据要发送了，主机A告诉主机B，它的数据已经全部发送完毕了；但是，这个时候主机A还是可以接受来自主机B的数据；当主机B返回ACK报文段时，表示它已经知道主机A没有数据发送了，但是主机B还是可以发送数据到主机A的；当主机B也发送了FIN报文段时，这个时候就表示主机B也没有数据要发送了，就会告诉主机A，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么在第四次挥手后会有2个MSL的延时？</strong></p><p>MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。</p><p>假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。</p><hr><h2 id="4-TCP流量控制"><a href="#4-TCP流量控制" class="headerlink" title="4 TCP流量控制"></a>4 TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd &#x3D; 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。ACK表示首部中的确认位ACK，ack表示确认字段的值ack。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/030.1txsbpry9oxs.webp#pic_center" width = 48%><p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd &#x3D; 300 ，第二次又减到了 rwnd &#x3D; 100 ，最后减到 rwnd &#x3D; 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK &#x3D; 1 ，只有在ACK&#x3D;1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><hr><h2 id="5-TCP拥塞控制"><a href="#5-TCP拥塞控制" class="headerlink" title="5 TCP拥塞控制"></a>5 TCP拥塞控制</h2><h3 id="5-1-慢开始和拥塞避免"><a href="#5-1-慢开始和拥塞避免" class="headerlink" title="5.1 慢开始和拥塞避免"></a>5.1 慢开始和拥塞避免</h3><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p><strong>慢开始算法</strong></p><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/031.786waxk5a080.webp#pic_center" width = 48%><p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>另外，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li></ul><p><strong>拥塞避免</strong></p><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/032.vj0ehnw7ib4.webp#pic_center" width = 48%><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/033.5kw010mrs6s0.webp#pic_center" width = 48%><h3 id="5-2-快重传和快恢复"><a href="#5-2-快重传和快恢复" class="headerlink" title="5.2 快重传和快恢复"></a>5.2 快重传和快恢复</h3><p><strong>快重传</strong></p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/034.4np51k8fxnk0.webp#pic_center" width = 48%><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><p>应用层做为 TCP&#x2F;IP 协议的最高层级，对于我们移动开发来说，是接触最多的。</p><p><strong>运行在TCP协议上的协议：</strong></p><ul><li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 </li><li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本</li><li>FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。 </li><li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 </li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li><li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li><li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li></ul><p><strong>运行在UDP协议上的协议：</strong></p><ul><li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。 </li><li>NTP（Network Time Protocol，网络时间协议），用于网络同步。 </li><li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li></ul><p><strong>其他：</strong></p><ul><li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。</li><li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。 </li><li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。 </li><li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li></ul><hr><p>面试问题整理<br><a href="https://blog.csdn.net/u013354486/article/details/80588916">面试问题整理之TCP&#x2F;IP和网络编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP 协议族 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（三）-- SSL/TLS协议运行机制的概述</title>
      <link href="/article/ae7157b3.html"/>
      <url>/article/ae7157b3.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL&#x2F;TLS协议运行机制的概述》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --><p>互联网的通信安全，建立在SSL/TLS协议之上。</p><!-- /div --><!-- div id="more" class="asset-more" --><p>本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅<a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC文档</a>。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020501.jpg" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020501.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>一、作用</h2><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><blockquote>  <p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p><p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p><p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p></blockquote><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><blockquote>  <p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p><p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p></blockquote><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><p>——————————————————————————————————————————————————————————</p><h2>二、历史</h2><p>互联网加密通信协议的历史，几乎与互联网一样长。</p><blockquote>  <p>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</p><p>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</p><p>1996年，SSL 3.0版问世，得到大规模应用。</p><p>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer" target="_blank">TLS</a> 1.0版。</p><p>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的<a href="https://tools.ietf.org/html/rfc6176" target="_blank">修订版</a>。</p></blockquote><p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p><p>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p><p>——————————————————————————————————————————————————————————</p><h3>三、基本的运行过程</h3><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><p><strong>（1）如何保证公钥不被篡改？</strong></p><blockquote>  <p>解决方法：将公钥放在<a href="https://en.wikipedia.org/wiki/Digital_certificate" target="_blank">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p></blockquote><p><strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong></p><blockquote>  <p>解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</p></blockquote><p>因此，SSL/TLS协议的基本过程是这样的：</p><blockquote>  <p>（1） 客户端向服务器端索要并验证公钥。</p><p>（2） 双方协商生成"对话密钥"。</p><p>（3） 双方采用"对话密钥"进行加密通信。</p></blockquote><p>上面过程的前两步，又称为"握手阶段"（handshake）。</p><p>——————————————————————————————————————————————————————————</p><h2>四、握手阶段的详细过程</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。</p><h3>4.1 客户端发出请求（ClientHello）</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p><p>在这一步，客户端主要向服务器提供以下信息。</p><blockquote>  <p>（1） 支持的协议版本，比如TLS 1.0版。</p><p>（2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。</p><p>（3） 支持的加密方法，比如RSA公钥加密。</p><p>（4） 支持的压缩方法。</p></blockquote><p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="https://tools.ietf.org/html/rfc4366" target="_blank">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p><h3>4.2 服务器回应（SeverHello）</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><blockquote>  <p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。</p><p>（3） 确认使用的加密方法，比如RSA公钥加密。</p><p>（4） 服务器证书。</p></blockquote><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><h3>4.3 客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><blockquote>  <p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</p><p>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。</p><p>至于为什么一定要用三个随机数，来生成"会话密钥"，<a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank">dog250</a>解释得很好：</p><blockquote>  <p>"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"</p></blockquote><p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><h3>4.4 服务器的最后回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。</p><blockquote>  <p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020503.gif" class="lazyload placeholder" data-srcset="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020503.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>五、参考链接</h2><ul><li>MicroSoft TechNet, <a href="https://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx" target="_blank">SSL/TLS in Detail</a></li><li>Jeff Moser, <a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html" target="_blank">The First Few Milliseconds of an HTTPS Connection</a></li><li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">Transport Layer Security</a></li><li>StackExchange, <a href="https://security.stackexchange.com/questions/20803/how-does-ssl-work" target="_blank">How does SSL work?</a></li></ul><!-- /div --></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL/TLS 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（二）-- HTTP协议入门</title>
      <link href="/article/279b4884.html"/>
      <url>/article/279b4884.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP协议入门》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --><p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p><!-- /div --><!-- div id="more" class="asset-more" --><p>本文介绍 HTTP 协议的历史演变和设计思路。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.7dhbrewkz900.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.7dhbrewkz900.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" title=""></p><p>——————————————————————————————————————————————————————————</p><h2>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的<a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank"><strong>应用层协议</strong></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p><pre class=" language-http"><code class=" language-http">GET /index.html</code></pre><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><pre><code class="language-html">&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>服务器发送完毕，就关闭TCP连接。</p><p>——————————————————————————————————————————————————————————</p><h2>二、HTTP/1.0</h2><h3>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><pre class=" language-http"><code class=" language-http">GET / HTTP/1.0<span class="token keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<span class="token keyword">Accept:</span> */*</code></pre><p>可以看到，这个格式与0.9版有很大变化。</p><p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p><h3>2.3 回应格式</h3><p>服务器的回应如下。</p><pre class=" language-http"><code class=" language-http">HTTP/1.0 200 OK <span class="token keyword">Content-Type:</span> text/plain<span class="token keyword">Content-Length:</span> 137582<span class="token keyword">Expires:</span> Thu, 05 Dec 1997 16:00:00 GMT<span class="token keyword">Last-Modified:</span> Wed, 5 August 1996 15:55:28 GMT<span class="token keyword">Server:</span> Apache 0.84&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>回应的格式是"头信息 + 一个空行（<code>\r\n</code>） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。</p><h3>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><blockquote>  <ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg</li><li>image/png</li><li>image/svg+xml</li><li>audio/mp4</li><li>video/mp4</li><li>application/javascript</li><li>application/pdf</li><li>application/zip</li><li>application/atom+xml</li></ul></blockquote><p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p><p>除了预定义的类型，厂商也可以自定义类型。</p><pre class=" language-http"><code class=" language-http">application/vnd.debian.binary-package</code></pre><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p><p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Type:</span> text/html; charset=utf-8</code></pre><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Accept:</span> */*</code></pre><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p><pre><code class="language-html">&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;!-- 等同于 --&gt;&lt;meta charset="utf-8" /&gt; </code></pre><h3>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Encoding:</span> gzip<span class="token keyword">Content-Encoding:</span> compress<span class="token keyword">Content-Encoding:</span> deflate</code></pre><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Accept-Encoding:</span> gzip, deflate</code></pre><h3>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> keep-alive</code></pre><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> keep-alive</code></pre><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><p>——————————————————————————————————————————————————————————</p><h2>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h3>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Connection:</span> close</code></pre><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p><h3>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h3>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Content-Length:</span> 3495</code></pre><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank">"分块传输编码"</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><pre class=" language-http"><code class=" language-http"><span class="token keyword">Transfer-Encoding:</span> chunked</code></pre><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><pre class=" language-http"><code class=" language-http">HTTP/1.1 200 OK<span class="token keyword">Content-Type:</span> text/plain<span class="token keyword">Transfer-Encoding:</span> chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0</code></pre><h3>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p><p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p><blockquote><pre class=" language-http"><code class=" language-http"><span class="token keyword">Host:</span> www.example.com</code></pre></blockquote><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank">"队头堵塞"</a>（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><p>——————————————————————————————————————————————————————————</p><h2>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 </p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><p>——————————————————————————————————————————————————————————</p><h2>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><h3>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><p>——————————————————————————————————————————————————————————</p><h3>六、参考链接</h3><ul><li><a href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/" target="_blank">Journey to HTTP/2</a>, by Kamran Ahmed</li><li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">HTTP</a>, by Wikipedia</li><li><a href="https://tools.ietf.org/html/rfc1945" target="_blank">HTTP/1.0 Specification</a></li><li><a href="https://http2.github.io/http2-spec/" target="_blank">HTTP/2 Specification</a></li></ul> <!-- /div --></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络篇（一）-- 网络协议入门</title>
      <link href="/article/54ebc735.html"/>
      <url>/article/54ebc735.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章转载自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门》</a>，供学习使用。</p><span id="more"></span><div class="asset-content entry-content" id="main-content"><!-- div class="asset-body" --> <p>我们每天使用互联网，你是否想过，它是如何实现的？</p> <!-- /div --><!-- div id="more" class="asset-more" --><p>全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？</p><p>互联网的核心是一系列协议，总称为"互联网协议"（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。</p><p>下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。</p><p>=====================================================================================================</p><p><strong>互联网协议入门</strong></p><h2>一、概述</strong></h2><h3>1.1 五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p><p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p><p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.38nwepibeja0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/001.38nwepibeja0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>如上图所示，最底下的一层叫做"实体层"（Physical Layer），最上面的一层叫做"应用层"（Application Layer），中间的三层（自下而上）分别是"链接层"（Link Layer）、"网络层"（Network Layer）和"传输层"（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p><p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p><h3>1.2 层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p><p>大家都遵守的规则，就叫做"协议"（protocol）。</p><p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>二、实体层</h2><p>我们从最底下的一层开始。</p><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.7bhub0v9cro0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/002.7bhub0v9cro0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p><strong>这就叫做"实体层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>三、链接层</h2><h3>3.1 定义</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><p><strong>这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。</strong></p><h3>3.2 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank">"以太网"</a>（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.3sj550tq6ko0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/003.3sj550tq6ko0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>"标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容。</p><p>"标头"的长度，固定为18字节。"数据"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h3>3.3 MAC地址</h3><p>上面提到，以太网数据包的"标头"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.3kqm9zic6mm0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/004.3kqm9zic6mm0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.3blgbxit7ew0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/005.3blgbxit7ew0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h3>3.4 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1yajhsqchfc0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/006.1yajhsqchfc0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"（broadcasting）。</p><p><strong><font color=#9900CC>有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。</font></strong></p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>四、网络层</h2><h3>4.1 网络层的由来</h3><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.mrj64s4xek0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/007.mrj64s4xek0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。（"路由"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p><strong>这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。</strong></p><p>于是，"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p><strong><font color=#9900CC>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</strong></font></p><h3>4.2 IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.5u7v0i8645s0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/008.5u7v0i8645s0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"（subnet mask）。</p><p>所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，<strong><font color=#9900CC>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</strong></font></p><h3>4.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为"标头"和"数据"两个部分。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.64f4rdo4nkk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/009.64f4rdo4nkk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.5zhlnq0lgjk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/010.5zhlnq0lgjk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h3>4.4 ARP协议</h3><p>关于"网络层"，还有最后一点需要说明。</p><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，<strong><font color=#9900CC>有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</strong></font></p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>五、传输层</h2><h3>5.1 传输层的由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p><strong><font color=#9900CC>"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。</font></strong>因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。</p><h3>5.2 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由"标头"和"数据"两部分组成。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.6plmy6jn3to0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/011.6plmy6jn3to0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>"标头"部分主要定义了发出端口和接收端口，"数据"部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.52t1zltlu1g0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.52t1zltlu1g0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h3>5.3 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>六、应用层</h2><p>应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p><strong>"应用层"的作用，就是规定应用程序的数据格式。</strong></p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.59qyg4v1nis0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/013.59qyg4v1nis0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。<a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank">接下来</a>，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>七、一个小结</h2><p>先对前面的内容，做一个小结。</p><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.4dpg8ltt0oa0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/014.4dpg8ltt0oa0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>发送这个包，需要知道两个地址：</p><blockquote><p>　　* 对方的MAC地址</p><p>　　* 对方的IP地址</p></blockquote><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.5zkk0043ot00.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/015.5zkk0043ot00.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</p><table width="70%" border="1"><tbody><tr><td>场景</td><td>数据包地址</td></tr><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>八、用户的上网设置</h2><h3>8.1 静态IP地址</h3><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.5w0gc8mfxng0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/016.5w0gc8mfxng0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=30%></p><p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p><blockquote><p> * 本机的IP地址<br>　* 子网掩码<br>　* 网关的IP地址<br>　* DNS的IP地址</p></blockquote><p>下图是Windows系统的设置窗口。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.4m5ltvx8uq60.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/017.4m5ltvx8uq60.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作"静态IP地址上网"。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用"动态IP地址上网"。</p><h3>8.2 动态IP地址</h3><p>所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<a href="https://zh.wikipedia.org/zh/DHCP" target="_blank">DHCP协议</a>。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><h3>8.3 DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.3thi8oox1wk0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/018.3thi8oox1wk0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>　　（1）最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>　　（2）后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>　　（3）最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><h3>8.4 上网设置：小结</h3><p>这个部分，需要记住的就是一点：不管是"静态IP地址"还是"动态IP地址"，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p><blockquote><p>　　* 本机的IP地址<br>　　* 子网掩码<br>　　* 网关的IP地址<br>　　* DNS的IP地址</p></blockquote><p>有了这几个数值，电脑就可以上网"冲浪"了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p><p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><h2>九、一个实例：访问网页</h2><h3>9.1 本机参数</h3><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p><blockquote><p>　　* 本机的IP地址：192.168.1.100<br>　　* 子网掩码：255.255.255.0<br>　　* 网关的IP地址：192.168.1.1<br>　　* DNS的IP地址：8.8.8.8</p></blockquote><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.33qdb1us7i80.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/019.33qdb1us7i80.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><h3>9.2 DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。</p><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank">DNS协议</a>可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.4bq5vfqsa1w0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/020.4bq5vfqsa1w0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><h3>9.3 子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><h3>9.4 应用层协议</h3><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.74a6x63uktg0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/021.74a6x63uktg0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>HTTP部分的内容，类似于下面这样：</p><blockquote><p>　　GET / HTTP/1.1<br>　　Host: www.google.com<br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: ... ...</p></blockquote><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><h3>9.5 TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h3>9.6 IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><h3>9.7 以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.3r7z857cbfo0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/022.3r7z857cbfo0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><h3>9.8 服务器端响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.1xbl4h8urn5s.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/023.1xbl4h8urn5s.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=36%></p><p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p><!-- /div --></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基本使用</title>
      <link href="/article/62580e04.html"/>
      <url>/article/62580e04.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要记录使用 hexo 写博客并发布到个人网站上。建议先学习：<a href="https://qxienote.com/article/6c09ec5e.html">MarkDown</a></p><span id="more"></span><h2 id="1-新建、编辑并预览文章"><a href="#1-新建、编辑并预览文章" class="headerlink" title="1 新建、编辑并预览文章"></a>1 新建、编辑并预览文章</h2><p><strong>1. 新建文章</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] title       <span class="comment"># 或 hexo n [layout] title</span></span><br></pre></td></tr></table></figure><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用 post 布局，然后自动在 <code>source\_posts</code> 目录生成一个text1.md 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n text1</span><br></pre></td></tr></table></figure><p>当然你还可以指定布局：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n [layout_name] draft1</span><br></pre></td></tr></table></figure><p>该命令创建了一个使用特定布局的名为draft1的文章。</p><p>打开之前创建的 text1.md 文件，我们可以看到文章开头包含以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">text1</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-04-10 04:13:36</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">blog</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>你显示的内容可能未必与我一样，不必担心，这是由于我自定义过。只需要知道，上面的内容在hexo被称作Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在scaffolds&#x2F;目录下，可以看到hexo自带的三种布局其实就是三个.md文件：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/012.yh8sg3aoii.webp#pic_center" width = 48%><p>所有的文章都是放在主目录下source文件下的_posts目录下的，这里参考我的存放目录 <code>D:\Blog\source\_posts</code></p><p>这里作出两点说明：</p><p>该目录下可以再创建目录，系统可以识别到多层文件夹中的文章，方便分类；如果用命令生成的新文章一定是在_posts主目录下</p><p>我用 VSCode 写 MarkDown，非常好用，点开创建的文件，先看看里面有啥</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">第一篇文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-06-08 10:30:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>两个虚线之间的内容就是叫 Front-matter，主要是你文章的配置，具体配置如下，这里不同主题不一样，我以 Next 主题为例。</p><p>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td><a href="/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td><code>title</code></td><td>标题</td><td>文章的文件名</td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td><code>null</code></td></tr><tr><td><code>excerpt</code></td><td>纯文本的页面摘要。使用 <a href="/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td></td></tr><tr><td><code>disableNunjucks</code></td><td>启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和 <a href="/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td>false</td></tr><tr><td><code>lang</code></td><td>设置语言以覆盖 <a href="/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td>继承自 <code>_config.yml</code></td></tr></tbody></table><p>以下为文章的 Front-matter 示例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">第一篇文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-06-08 10:30:00</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">cover:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">coverImg:</span> <span class="string">/images/1.jpg</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">********************************</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，也可以使用</span> <span class="string">&lt;!--more--&gt;</span> <span class="string">强制截断</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Markdown</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">VSCode</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Markdown</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>你会发现，每次 <code>hexo n</code> 的时候 Front-matter 中内容少的可怜，那怎么修改默认的格式呢？只要去主目录下找到 scaffolds 文件夹下找到一个 post.md 文件修改即可，这里是我的目录<code>D:\Blog\scaffolds\post.md</code>，例如我的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">author:</span> <span class="string">Carpe</span> <span class="string">Diem</span></span><br><span class="line"><span class="comment"># 标签</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="comment"># 分类</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="comment"># 简述</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="comment"># 使用自定义封面 </span></span><br><span class="line"><span class="attr">img:</span> </span><br><span class="line"><span class="comment"># 是否置顶true，或者去掉</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 轮播</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="comment"># 轮播图</span></span><br><span class="line"><span class="attr">coverImg:</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="2-只在首页显示文章摘要"><a href="#2-只在首页显示文章摘要" class="headerlink" title="2 只在首页显示文章摘要"></a>2 只在首页显示文章摘要</h2><p><strong>方法一：写概述</strong></p><p>在文章的 <code>front-matter</code> 中添加 <code>description</code>，其中 <code>description</code> 中的内容就会被显示在首页上，其余一律不显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p><p><strong>方法二:文章截断</strong></p><p>在需要截断的地方加入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p><p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置SSL证书</title>
      <link href="/article/ecc40a95.html"/>
      <url>/article/ecc40a95.html</url>
      
        <content type="html"><![CDATA[<p>本文讲解如何使用SSL证书保护我们的应用，并在 Nginx 配置 HTTP 跳转到 HTTPS</p><h2 id="1-Ubuntu-20-04-上安装-Nginx"><a href="#1-Ubuntu-20-04-上安装-Nginx" class="headerlink" title="1 Ubuntu 20.04 上安装 Nginx"></a>1 Ubuntu 20.04 上安装 Nginx</h2><p>Nginx 发音 “engine x” ,是一个开源软件，高性能 HTTP 和反向代理服务器，用来在互联网上处理一些大型网站。它可以被用作独立网站服务器，负载均衡，内容缓存和针对 HTTP 和非 HTTP 的反向代理服务器。和 Apache相比，Nginx 可以处理大量的并发连接，并且每个连接占用一个很小的内存。</p><h3 id="1-1-前提条件"><a href="#1-1-前提条件" class="headerlink" title="1.1 前提条件"></a>1.1 前提条件</h3><p>在继续之前，保证以 sudo 用户身份登录，并且你不能运行 Apache 或者 其他处理进程在80端口和443端口。</p><h3 id="1-2-安装-Nginx"><a href="#1-2-安装-Nginx" class="headerlink" title="1.2 安装 Nginx"></a>1.2 安装 Nginx</h3><p>Nginx 在默认的 Ubuntu 源仓库中可用。想要安装它，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><p>一旦安装完成，Nginx 将会自动被启动。你可以运行下面的命令来验证它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 设置nginx开机启动</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">systemctl enable nginx.service</span><br><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p>输出类似下面这样：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/034.5zxqznpeapc0.webp#pic_center" width = 48%><h3 id="1-3-配置防火墙"><a href="#1-3-配置防火墙" class="headerlink" title="1.3 配置防火墙"></a>1.3 配置防火墙</h3><p>现在你已经在你的服务器上安装和运行了 Nginx，你需要确保你的防火墙被配置好，允许流量通过 HTTP（80）和 HTTPS（443）端口。假设你正在使用UFW，你可以做的是启用 <code>‘Nginx Full’ profile</code>，它包含了这两个端口：</p><p>UFW 全称为 Uncomplicated Firewall，是 Ubuntu 系统上配置 iptables 防火墙的工具。UFW 提供一个非常友好的命令用于创建基于IPV4，IPV6的防火墙规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span><br></pre></td></tr></table></figure><p>想要验证状态，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><p>输出将会像下面这样：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/036.59l1rkr9xrk0.webp#pic_center" width = 48%><h3 id="1-4-测试安装"><a href="#1-4-测试安装" class="headerlink" title="1.4 测试安装"></a>1.4 测试安装</h3><p>想要测试你的新 Nginx 安装，在你的浏览器中打开<a href="http://your_ip,你应该可以看到默认的/">http://YOUR_IP，你应该可以看到默认的</a> Nginx 加载页面，像下面这样：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/035.5u53rg3bzp00.webp#pic_center" width = 48%><h3 id="1-5-Nginx-配置文件结构以及最佳实践"><a href="#1-5-Nginx-配置文件结构以及最佳实践" class="headerlink" title="1.5 Nginx 配置文件结构以及最佳实践"></a>1.5 Nginx 配置文件结构以及最佳实践</h3><ul><li>所有的 Nginx 配置文件都在 <code>/etc/nginx/</code> 目录下。</li><li>主要的 Nginx 配置文件是 <code>/etc/nginx/nginx.conf</code>。</li><li>为每个域名创建一个独立的配置文件，便于维护服务器。你可以按照需要定义任意多的 block 文件。</li><li>Nginx 服务器配置文件被储存在 <code>/etc/nginx/sites-available</code> 目录下。在 <code>/etc/nginx/sites-enabled</code> 目录下的配置文件都将被 Nginx 使用。</li><li>最佳推荐是使用标准的命名方式。例如，如果你的域名是mydomain.com，那么配置文件应该被命名为 <code>/etc/nginx/sites-available/mydomain.com.conf</code></li><li>如果你在域名服务器配置块中有可重用的配置段，把这些配置段摘出来，做成一小段可重用的配置。</li><li>Nginx 日志文件(access.log 和 error.log)定位在 <code>/var/log/nginx/</code> 目录下。推荐为每个服务器配置块，配置一个不同的access和error。</li><li>你可以将你的网站根目录设置在任何你想要的地方。最常用的网站根目录位置包括：<ul><li><code>/home/&lt;user_name&gt;/&lt;site_name&gt;</code></li><li><code>/var/www/&lt;site_name&gt;</code></li><li><code>/var/www/html/&lt;site_name&gt;</code></li><li><code>/opt/&lt;site_name&gt;</code></li></ul></li></ul><h3 id="2-HTTPS介绍"><a href="#2-HTTPS介绍" class="headerlink" title="2 HTTPS介绍"></a>2 HTTPS介绍</h3><p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL&#x2F;TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><p><strong>特点</strong></p><ul><li>内容加密：采用混合加密技术，中间者无法直接查看明文内容；</li><li>验证身份：通过证书认证客户端访问的是自己的服务器；</li><li>保护数据完整性：防止传输的内容被中间人冒充或者篡改。</li></ul><h3 id="2-1-HTTP-原理"><a href="#2-1-HTTP-原理" class="headerlink" title="2.1 HTTP 原理"></a>2.1 HTTP 原理</h3><p>HTTPS 主要由两部分组成：HTTP + SSL &#x2F; TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。</p><p>(1) 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP来完成，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和许可内容。</p><p>(2) 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><h3 id="2-2-HTTPS-原理"><a href="#2-2-HTTPS-原理" class="headerlink" title="2.2 HTTPS 原理"></a>2.2 HTTPS 原理</h3><p>(1) 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；<br>(2) 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；<br>(3) 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 &#x2F; 解密），并将加密后的信息发送给服务器；<br>(4) 客户端与服务器端根据pre_master_secret以及客户端与服务器的随机数值独立计算出加密和 MAC密钥；<br>(5) 客户端将所有握手消息的 MAC 值发送给服务器；<br>(6) 服务器将所有握手消息的 MAC 值发送给客户端；</p><h3 id="2-3-HTTPS-优缺点"><a href="#2-3-HTTPS-优缺点" class="headerlink" title="2.3 HTTPS 优缺点"></a>2.3 HTTPS 优缺点</h3><p><strong>优点</strong></p><ul><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS 协议是由 SSL+HTTP构建的可进行加密传输、身份认证的网络协议，要比HTTP安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性；</li><li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本；</li></ul><p><strong>缺点</strong></p><ul><li>相同网络环境下，HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。此外，HTTPS 协议还会影响缓存，增加数据开销和功耗；</li><li>成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</li></ul><h2 id="3-配置HTTPS"><a href="#3-配置HTTPS" class="headerlink" title="3 配置HTTPS"></a>3 配置HTTPS</h2><h3 id="3-1-准备"><a href="#3-1-准备" class="headerlink" title="3.1 准备"></a>3.1 准备</h3><p><strong>1. 一台可用的服务器</strong></p><p>首先需要有一台可用的服务器，后续用作域名解析。如果没有服务器可以先购买一台云服务器。</p><p><strong>2. 一个备案过的域名</strong></p><p>需要一个备过案的域名，用于解析服务器的IP地址。在对应购买的域名的服务商网站控制台可以完成备案。</p><p><strong>3. SSL证书</strong></p><p>SSL证书有免费和收费两个渠道。</p><p>我们这边主要介绍腾讯云和阿里云(排名不分先后)两个免费申请SSL证书的方式，当然资金允许情况下也可以直接购买。</p><p><strong>4. 阿里云申请免费SSL证书</strong></p><p>阿里云免费证书规则：自2021年起，免费证书申请将切换到证书资源包下每个实名个人&#x2F;企业主体在一个自然年内可以一次性领取20张免费证书，免费证书每张证书有效期一年。免费证书仅支持绑定一个单域名，不支持绑定通配符域名或者IP。</p><p>阿里云申请免费SSL证书文档：<a href="https://help.aliyun.com/document_detail/156645.htm?spm=a2c4g.11186623.2.7.2db71a63TXmPoB#task-2436672">官方文档地址</a></p><p><strong>5. 腾讯云申请免费SSL证书</strong></p><p>腾讯云免费证书规则：只支持绑定1个域名，可以支持绑定二级域名 abc.com、或是三级域名 example.abc.com。同一主域最多只能申请20张免费证书,每张有效期一年，免费证书到期后如需继续使用证书，需要重新申请并安装。</p><p>腾讯云申请免费SSL证书文档：<a href="https://cloud.tencent.com/document/product/400/6814">官方文档地址</a></p><h3 id="3-2-域名升级成HTTPS"><a href="#3-2-域名升级成HTTPS" class="headerlink" title="3.2 域名升级成HTTPS"></a>3.2 域名升级成HTTPS</h3><p>我们如果直接用域名解析IP地址，域名也是可以访问的，但是是HTTP环境的。 我们使用的Nginx来配置升级HTTPS</p><blockquote><p><a href="https://github.com/Tzlibai/Nginx.conf/blob/main/%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/nginx.conf">Github地址：完整的单域名nginx.conf文件配置(清晰注释) – 点击进入</a></p></blockquote><p>当我们在上面申请成功免费的SSL证书之后，点击下载证书。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/037.3u00n8uyq6m0.webp#pic_center" width = 48%><p>下载完成会得到一个压缩包，我们解压之后选择Nginx文件夹，里面的两个文件就是我们后续需要配置的文件。 下载到本地的压缩文件包解压后Nginx文件夹包含：</p><ul><li>.pem文件：是证书文件；</li><li>.key文件：证书的私钥文件。</li></ul><p>这时候我们打开我们的SSH工具，进入Nginx的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 进入nginx目录,默认安装在/etc/nginx，这个目录如果未找到，可以根据nginx安装的位置进入</span><br><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br></pre></td></tr></table></figure><p><strong>步骤一</strong></p><p>在Nginx的安装目录下创建cert目录，并且将下载的全部文件拷贝到 <code>/etc/nginx/cert</code> 目录中（使用SSH工具附带的本地文件上传功能，将本地证书文件和密钥文件上传到Nginx服务器的证书目录[示例中为 <code>/etc/nginx/cert</code>]）。如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并且命名为a.key；</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230608/038.3dneejzgol40.webp#pic_center" width = 48%><p><strong>步骤二</strong></p><p>然后开始Nginx配置,编辑Nginx配置文件（nginx.conf）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 进入nginx目录,默认安装在/etc/nginx，这个目录如果未找到，可以根据nginx安装的位置进入</span><br><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line"></span><br><span class="line">// 编辑nginx的配置文件</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p><strong>步骤三</strong></p><p>修改与证书相关的配置内容按i键进入编辑模式,增加代码，监听443端口，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen       443 ssl;</span><br><span class="line">      listen       [::]:443;</span><br><span class="line">      server_name  localhost;</span><br><span class="line">       ssl on;</span><br><span class="line"></span><br><span class="line">              root /usr/share/nginx/html;</span><br><span class="line">              index index.html index.htm;</span><br><span class="line">      <span class="comment">#证书文件名称</span></span><br><span class="line">      ssl_certificate cert/a.crt;</span><br><span class="line">      <span class="comment">#私钥文件名称</span></span><br><span class="line">      ssl_certificate_key cert/a.key;</span><br><span class="line"></span><br><span class="line">      ssl_session_cache shared:SSL:1m;</span><br><span class="line">      ssl_session_timeout  5m;</span><br><span class="line">      ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">      ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">      ssl_prefer_server_ciphers on;</span><br><span class="line">      <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      error_page 404 /404.html;</span><br><span class="line">          location = /40x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      error_page 500 502 503 504 /50x.html;</span><br><span class="line">          location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>步骤四</strong></p><p>执行命令 <code>/sbin/nginx -s reload</code> 重启服务器即可！（如果重启未成功，说明配置文件nginx.conf错误，检查是否有错误，后执行重启）</p><p><strong>步骤五</strong></p><p>验证是否安装成功,证书安装完成后，可通过访问证书的绑定域名验证该证书是否安装成功。</p><p>上述步骤成功之后，我们就可以通过 <code>https://www.域名.com</code> 来访问我们网站了，但是问题来了，因为我们申请的免费SSL证书是单域名绑定，也就是只能让<code>https://www.域名.com</code> 下的内容实现HTTPS访问，我们的二级域名 <code>api.域名.com</code> 还是只能 HTTP 访问。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>如何在 Ubuntu 20.04 上安装 Nginx：<a href="https://www.itcoder.tech/posts/how-to-install-nginx-on-ubuntu-20-04/">https://www.itcoder.tech/posts/how-to-install-nginx-on-ubuntu-20-04/</a></li><li>网站还是HTTP?快把你的域名和二级域名变成HTTPS：<a href="https://juejin.cn/post/6953649812097122312">https://juejin.cn/post/6953649812097122312</a></li><li>Nginx配置HTTP跳转到HTTPS：<a href="https://juejin.cn/post/7044911075480829959">https://juejin.cn/post/7044911075480829959</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 使用问题汇总</title>
      <link href="/article/cc21273e.html"/>
      <url>/article/cc21273e.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要汇总在使用 Git 进行提交和拉取文件时，遇到的问题的解决方案，以便下次查找。</p><h3 id="1-关于使用Git出现“git-Failed-to-connect-to-127-0-0-1-port-xxxx-Connection-refused”的问题解决方案"><a href="#1-关于使用Git出现“git-Failed-to-connect-to-127-0-0-1-port-xxxx-Connection-refused”的问题解决方案" class="headerlink" title="1 关于使用Git出现“git Failed to connect to 127.0.0.1 port xxxx: Connection refused”的问题解决方案"></a>1 关于使用Git出现“git Failed to connect to 127.0.0.1 port xxxx: Connection refused”的问题解决方案</h3><p><strong>1. 问题描述</strong></p><p>在使用 git 拉取、提交代码的时候，会出现 git Failed to connect to 127.0.0.1 port xxxx: Connection refused 的问题。</p><p>原因：无法连接到127.0.0.1: xxx端口: 连接被拒绝。</p><p><strong>2. 解决方案</strong><br>方案一：<br>思路：查询当前是否有代理，如果有就取消。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 首先，查一下当前全局的 http 代理：</span><br><span class="line">git config --global http.proxy</span><br><span class="line">// 如果有代理，就取消</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 再查 https 的代理：</span><br><span class="line">git config --global https.proxy</span><br><span class="line">// 同样的，有就取消</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>方案二：<br>上面的方案如果不行的话，再参考这个方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 首先，查一下代理：</span><br><span class="line"><span class="built_in">env</span>|grep -i proxy</span><br><span class="line">// 有就取消</span><br><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"></span><br><span class="line">// 再查</span><br><span class="line"><span class="built_in">env</span>|grep -i proxy</span><br><span class="line">// 正常情况下是没有代理了</span><br><span class="line">// 再次查询一下，如果还有的再取消</span><br></pre></td></tr></table></figure><p>方案三<br>修改环境变量<br>在系统变量中找到了变量<code>http_proxy</code>和<code>https_proxy</code>，用户变量也可以看看有没有，删除他就可以了。</p><p>重启计算机。</p><p>再用 git，正常了，再查<code>env|grep -i proxy</code>，代理没有了。</p><p><strong>3. 小结</strong></p><p>代理没有了，就可以正常拉取、提交代码了。</p><blockquote><p>本部分参考自：<a href="https://blog.csdn.net/XH_jing/article/details/115095225">关于使用Git出现“git Failed to connect to 127.0.0.1 port xxxx: Connection refused”的问题解决方案</a></p></blockquote><h3 id="2-error-src-refspec-master-does-not-match-any"><a href="#2-error-src-refspec-master-does-not-match-any" class="headerlink" title="2 error: src refspec master does not match any."></a>2 error: src refspec master does not match any.</h3><p><strong>1. 问题描述</strong></p><p>在将本地项目上传到新建的仓库时，出现了下图的错误：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/004.6d5q38zcl2o0.webp#pic_center" width = 48%><p>问题的内容是：<br>错误：SRC ReFSPEC 主控器不匹配任何。<br>错误：未能将某些引用推到 <code>git@github.com:molimi/MyBlog.git</code></p><p><strong>2. 解决方案</strong></p><p>其实只需要进行下面几步就能把本地项目上传到Github</p><ol><li>在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；</li><li>把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；</li><li>再通过 <code>git commit -m &quot;注释内容&quot;</code> 把项目提交到仓库；</li><li>在Github上设置好SSH密钥后，新建一个远程仓库，通过 <code>git remote add origin https://github.com/molimi/MyBlog.git</code> 将本地仓库和远程仓库进行关联；</li><li>最后通过 <code>git push -u origin master</code> 把本地仓库的项目推送到远程仓库（也就是Github）上；（若新建远程仓库的时候自动创建了README文件会报错，解决办法看上面）。</li></ol><blockquote><p>本部分参考自：<a href="https://blog.csdn.net/qq_38198952/article/details/82792279">error: src refspec master does not match any. 错误的解决办法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构与算法篇（一）-- 算法分析基础</title>
      <link href="/article/d46e4964.html"/>
      <url>/article/d46e4964.html</url>
      
        <content type="html"><![CDATA[<p>近期在学习《数据结构与算法分析Python》，本篇主要介绍算法分析的基础，介绍Python中List和Dic常用操作的时间复杂度，最后用一个变位词的例子比较不同算法的复杂度。</p><span id="more"></span><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>算法分析主要就是从计算资源消耗的角度来评判和比较算法，更高效利用计算资源，或者更少占用计算资源的算法，就是好算法。计算资源主要分为两种，一种是算法解决问题过程中需要的存储空间或内存，另一种是算法的执行时间。</p><p><strong>温馨提示：</strong> 存储空间受到问题自身数据规模的变化影响要区分哪些存储空间是问题本身描述所需，哪些是算法占用，这个不容易</p><p>算法复杂度表示法：</p><ul><li>大 $O(n)$ 表示法：表示了所有上限中最小的那个上限</li><li>大 $Ω$ 表示法：表示了所有下限中最大的那个下限</li><li>大 $\theta$ 表示法：如果上下限相同，那么就可以用大 $\theta$ 表示</li></ul><p>算法：解决问题的方法和步骤</p><ul><li>评价算法的好坏：渐近时间复杂度和渐近空间复杂度。</li><li>渐近时间复杂度的大O标记：<ul><li>$O(c)$- 常量时间复杂度 - 布隆过滤器 &#x2F; 哈希存储</li><li>$O(log_2n)$ - 对数时间复杂度 - 折半查找（二分查找）</li><li>$O(n)$ - 线性时间复杂度 - 顺序查找 &#x2F; 计数排序</li><li>$O(n*log_2n)$ - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）</li><li>$O(n^2)$ - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）</li><li>$O(n^3)$ - 立方时间复杂度 - Floyd算法 &#x2F; 矩阵乘法运算</li><li>$O(2^n)$ - 几何级数时间复杂度 - 汉诺塔</li><li>$O(n!)$ - 阶乘时间复杂度 - 旅行经销商问题 - NPC</li></ul></li></ul><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/005.522kgotj5gs0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/006.wrpp4q8w3s0.webp#pic_left"  width = "48%"></center></p><h2 id="2-Python数据类型的性能"><a href="#2-Python数据类型的性能" class="headerlink" title="2 Python数据类型的性能"></a>2 Python数据类型的性能</h2><p>list 类型各种操作（interface）的实现方法有很多，如何选择具体哪种实现方法？总的方案就是，让最常用的操作性能最好，牺牲不太常用的操作。准则：80% 的功能其使用率只有20%</p><p>List基本操作的大O数量级</p><table><thead><tr><th>Operation</th><th>Big-O Efficiency</th></tr></thead><tbody><tr><td>index[]</td><td>O(1)</td></tr><tr><td>index assignment</td><td>O(1)</td></tr><tr><td>append</td><td>O(1)</td></tr><tr><td>pop()</td><td>O(1)</td></tr><tr><td>pop(i)</td><td>O(n)</td></tr><tr><td>insert(i, item)</td><td>O(n)</td></tr><tr><td>del operator</td><td>O(n)</td></tr><tr><td>iteration</td><td>O(n)</td></tr><tr><td>contains(in)</td><td>O(n)</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td></tr><tr><td>del slice</td><td>O(n)</td></tr><tr><td>set slice</td><td>O(n+k)</td></tr><tr><td>reverse</td><td>O(n)</td></tr><tr><td>concatenate</td><td>O(k)</td></tr><tr><td>sort</td><td>O(nlogn)</td></tr><tr><td>multiply</td><td>O(nk)</td></tr></tbody></table><p>字典与列表不同，根据关键码（key）找到数据项，而列表是根据位置（index）。最常用的取值get和赋值set，其性能为 $O(1)$；另一个重要操作<code>contains(in)</code>是判断字典中是否存在某个关键码（key），这个性能也是 $O(1)$</p><p>Dict基本操作的大O数量级</p><table><thead><tr><th>Operation</th><th>Big-O Efficiency</th></tr></thead><tbody><tr><td>copy</td><td>O(n)</td></tr><tr><td>get item</td><td>O(1)</td></tr><tr><td>set item</td><td>O(1)</td></tr><tr><td>delete item</td><td>O(1)</td></tr><tr><td>contains (in)</td><td>O(1)</td></tr><tr><td>iteration</td><td>O(n)</td></tr></tbody></table><p>更多，请参考Python官方的算法复杂度网站：<a href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a></p><p><strong>例子</strong></p><p><code>timeit</code> 模块对函数计时：创建一个Timer对象，指定需要反复运行的语句和只需要运行一次的“安装语句”；然后调用这个对象的 <code>timeit</code> 方法，其中可以指定反复运行多少次，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line">t = Timer(<span class="string">&quot;函数名()&quot;</span>,<span class="string">&quot;from __main__ import 函数名&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(“%f seconds\n” % t.timeit(number = <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环连接列表&quot;&quot;&quot;</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        l = l + [i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;append方式&quot;&quot;&quot;</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        l.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;列表推导式&quot;&quot;&quot;</span></span><br><span class="line">    l = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test4</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;range函数调用转成列表&quot;&quot;&quot;</span></span><br><span class="line">    l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Timer(<span class="string">&quot;test1()&quot;</span>, <span class="string">&quot;from __main__ import test1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;concat %f seconds\n&quot;</span> % t1.timeit(number=<span class="number">1000</span>))           <span class="comment"># concat 1.077540 seconds</span></span><br><span class="line"></span><br><span class="line">t2 = Timer(<span class="string">&quot;test2()&quot;</span>, <span class="string">&quot;from __main__ import test2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;append %f seconds\n&quot;</span> % t2.timeit(number=<span class="number">1000</span>))           <span class="comment"># append 0.049203 seconds</span></span><br><span class="line"></span><br><span class="line">t3 = Timer(<span class="string">&quot;test3()&quot;</span>, <span class="string">&quot;from __main__ import test3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;comprehension %f seconds\n&quot;</span> % t3.timeit(number=<span class="number">1000</span>))    <span class="comment"># comprehension 0.039851 seconds</span></span><br><span class="line"></span><br><span class="line">t4 = Timer(<span class="string">&quot;test4()&quot;</span>, <span class="string">&quot;from __main__ import test4&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list range %f seconds\n&quot;</span> % t4.timeit(number=<span class="number">1000</span>))       <span class="comment"># list range 0.016467 seconds</span></span><br></pre></td></tr></table></figure><p>结论：由于不同计算机，运算时间有差异，但可以发现：列表连接（concat）最慢，List range最快，速度相差近100倍，append也要比concat快得多</p><h2 id="3-线性结构"><a href="#3-线性结构" class="headerlink" title="3 线性结构"></a>3 线性结构</h2><p>线性结构是一种有序数据项的集合，其中每个数据项都有唯一的前驱和后继，除了第一个没有前驱，最后一个没有后继，新的数据项加入到数据集中时，只会加入到原有某个数据项之前或之后，具有这种性质的数据集，就称为线性结构。</p><p>不同线性结构的关键区别在于数据项增减的方式，有的结构只允许数据项从一端添加，而有的结构则允许数据项从两端移除。</p><p>接下来学习的主要是栈Stack，队列Queue，双端队列Deque和列表List</p><p>性结构：线性结构是-种有序数据项的集合，其中每个数据项都有唯一的前驱和后继（数据集）</p><h3 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h3><p>栈的特性：反转次序，后进先出（主要应用：网页、word编辑）</p><p>抽象数据类型“栈”定义为如下的操作：（默认左端为栈底，右端为栈顶）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack( )：创建一个空栈，不包含任何数据项</span><br><span class="line">push(item)：将item加入栈顶，无返回值，append()</span><br><span class="line">pop( )：将栈顶数据项移除，并返回，栈被修改pop()</span><br><span class="line">peek( ):“窥视” 栈顶数据项，返回栈顶的数据项但不移除，栈不被修改。</span><br><span class="line">isEmpty( )：返回栈是否为空栈</span><br><span class="line">size( )：返回栈中有多少个数据项</span><br></pre></td></tr></table></figure><p>栈的应用：简单括号匹配（最后打开的右括号必须与第一个左括号匹配），十进制转换为二进制。</p><p>中缀表达式（优先级），前后缀表达式转换，所以在很多情况下，表达式的计算机表示都避免用复杂的中缀形式；在前缀和后缀表达式中，操作符的次序完全决定了运算的次序，不再有混淆<br>所以说，无论表达式多复杂，需要转换成前缀或者后缀，只需要两个步骤：将中缀表达式转换为全括号形式；将所有的操作符移动到子表达式所在的左括号(前缀)或者右括号(后缀)处，替代之，再删除所有的括号</p><h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><p>队列是一种有次序的数据集合，其特征是新数据项的添加总发生在一端(通常为“尾rear”端)，而现存数据项的移除总发生在另一端(通常称为首front”端)，原则：先进先出，队列仅有一个入口和一个出口。（主要应用：打印队列，进程调度，键盘缓冲，）主要适用于实际模拟仿真<br>抽象数据类型Queue由如下操作定义：（默认左端为队尾，右端为队首）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue( )：创建一个空队列对象，返回值为Queue对象</span><br><span class="line">enqueue(item)：将数据项item添加到队尾，无返回值insert(<span class="number">0</span>,item)  复杂度O(n)</span><br><span class="line">dequeue( )：从队首移除数据项，返回值为队首数据项，队列被修改复杂度O(<span class="number">1</span>)</span><br><span class="line">isEmpty( )：测试是否空队列，返回布尔值</span><br><span class="line">size( )：返回队列中数据项的个数</span><br></pre></td></tr></table></figure><h3 id="3-3-双端队列"><a href="#3-3-双端队列" class="headerlink" title="3.3 双端队列"></a>3.3 双端队列</h3><p>双端队列Deque：一种有次序的数据集，跟队列相似，其两端可以称作“首“”“尾”端，但deque中数据项既可以从队首加入，也可以从队尾加入；数据项也可以从两端移除。某种意义上说，双端队列集成了栈和队列的能力。（应用：回文词判定）</p><p>deque定义的操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque()：创建一个空双端队列</span><br><span class="line">addFront(item)：将item加入队首</span><br><span class="line">addRear(item)：将item加入队尾</span><br><span class="line">removeFront( )：从队首移除数据项，返回值为移除的数据项</span><br><span class="line">removeRear( )：从队首移除数据项，返回值为移除的数据项</span><br><span class="line">isEmpty( )：返回deque是否为空</span><br><span class="line">size( )：返回deque中包含数据项的个数</span><br></pre></td></tr></table></figure><h3 id="3-4-列表"><a href="#3-4-列表" class="headerlink" title="3.4 列表"></a>3.4 列表</h3><p>无序表List：一种数据项按照相对位置存放的数据集。操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>( )：创建一个空列表</span><br><span class="line">add(item)：添加一个数据项到列表中，假设item原先不存于列表中</span><br><span class="line">remove(item)：从列表中移除item，列表被修改，item原先应存在于列表中</span><br><span class="line">search(item)：在列表中查找item，返回布尔类型值</span><br><span class="line">isEmpty( )：返回列表是否为空</span><br><span class="line">size( )：返回列表包含了多少数据项</span><br><span class="line">append(item)：添加一个数据项到列表末尾，假设item原先不存在于列表中</span><br><span class="line">index(item)：返回数据项在表中的位置</span><br><span class="line">insert(pos,item)：将数据项插入到位置pos，假设item原先不存在列表中，同时原列表具有足够多个数据项，能让item占据位置pos</span><br><span class="line">pop( )：从列表末尾移除数据项，假设原列表至少有一个数据项</span><br><span class="line">pop(pos)：移除位置为pos的数据项，假设原列表存在位置pos</span><br></pre></td></tr></table></figure><p>列表List（数据项的增减方式不同）<br>采用链表实现无序表，数据项存放位置并没有规则，但如果在数据项之间建立链接指向，就可以保持其前后相对位置。链表实现的最基本元素是节点Node（包含数据项本身，以及指向下一个节点的引用信息）。<br>有序表OrderedList：有序表是一种数据项依照其某可比性质(如整数大小、字母表先后)来决定在列表<br>中的位置。操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OrderedList( )：创建一个空列表</span><br><span class="line">add(item)：添加一个数据项到列表中，假设item原先不存于列表中</span><br><span class="line">remove(item)：从列表中移除item，列表被修改，item原先应存在于列表中</span><br><span class="line">search(item)：在列表中查找item，返回布尔类型值</span><br><span class="line">isEmpty( )：返回列表是否为空</span><br><span class="line">size( )：返回列表包含了多少数据项</span><br><span class="line">index(item)：返回数据项在表中的位置</span><br><span class="line">pop( )：从列表末尾移除数据项，假设原列表至少有一个数据项</span><br><span class="line">pop(pos)：移除位置为pos的数据项，假设原列表存在位置pos</span><br></pre></td></tr></table></figure><h2 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4 案例分析"></a>4 案例分析</h2><p>案例一：“变位词”判断问题<br>问题描述：所谓“变位词”是指两个词之间存在组成字母的重新排列关系，如heart和earth，python和typhon，这里为了降低难度：假设参与判断的两个词仅由小写字母构成，而且长度相等。</p><p>解题目标：写一个bool函数，以两个词作为参数，返回这两个词是否变位词</p><p><strong>1. 检查标记</strong><br>（1）每个位置进行比对，用字符串1的字符遍历字符串2，检查标记一个字符要用特定值None 来代替，作为标记。然而，由于字符串不可变，首先要把第二个字符串转化成一个列表。第一个字符串中的每一个字符都可以在列表的字符中去检查，如果找到，就用None 代替以示标记。算法复杂度：$O(n^2)$</p><p>参考代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagram_solution</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    a_list = <span class="built_in">list</span>(s2)</span><br><span class="line">    still_ok = <span class="literal">True</span></span><br><span class="line">    pos1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> pos1 &lt; <span class="built_in">len</span>(s1) <span class="keyword">and</span> still_ok:</span><br><span class="line">        pos2 = <span class="number">0</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos2 &lt; <span class="built_in">len</span>(s2) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> s1[pos1] == a_list[pos2]:</span><br><span class="line">                a_list[pos2] = <span class="literal">None</span></span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            pos1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            still_ok = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> still_ok</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;cadb&#x27;</span>))           <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abababa&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>))        <span class="comment"># False    </span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abgsgg&#x27;</span>, <span class="string">&#x27;ababjjsj&#x27;</span>))     <span class="comment"># False    </span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><strong>2. 排序比较法</strong></p><p>尽管s1和s2并不相同，但若为变位词它们一定包含完全一样的字符，利用这一特点，我们可以采用另一种方法。我们首先从a到z给每一个字符串按字母顺序进行排序，如果它们是变位词，那么我们将得到两个完全一样的字符串。此外，我们可以先将字符串转化为列表，再利用Python 中内建的<code>sort</code>方法对列表进行排序。下面代码展示了这种方法。由于用到排序算法，所以算法复杂度为$O(nlogn)$。<br>参考代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagram_solution</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    a_list1 = <span class="built_in">list</span>(s1)</span><br><span class="line">    a_list2 = <span class="built_in">list</span>(s2)</span><br><span class="line">    a_list1.sort()</span><br><span class="line">    a_list2.sort()</span><br><span class="line">    <span class="keyword">return</span> (a_list1 == a_list2)   <span class="comment"># 排序后比较</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abcde&#x27;</span>, <span class="string">&#x27;edcba&#x27;</span>))       <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;edcba&#x27;</span>))        <span class="comment"># False</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abababab&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>))     <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><strong>3. 暴力匹配法</strong><br>解决这个问题的典型暴力方法是尝试所有的可能。为了解决变位词检测问题，我们可以简单地构造一个由s1中所有字符组成的所有可能的字符串的列表，并检查s2是否在列表中。然而这个方法有一个困难之处。当我们构造由s1中字符组成的所有可能字符串时，第一个字符有n个可能，第二个字符有n-1种可能，第三个则是n-2种，以此类推。所有可能字符串的总数是$n*(n-1)<em>(n-2)</em>…<em>3</em>2*1$。也就是n!。尽管这些字符串中的一些可能是重复的，但程序不能提前预见到，所以还是会产生$n!$个字符串。看前言里的算法复杂度，就知道$O(n!)$增长比$O(2^n)$还要快。</p><ol start="4"><li>计数比较法</li></ol><p>解决变位词问题的最后一个方法利用了任何变位词都有相同数量的a，相同数量的b，相同数量的c等等。为判断两个字符串是否为变位词，我们首先计算每一个字符在字符串中出现的次数。由于共有26个可能的字符，我们可以利用有26 个计数器的列表，每个计数器对应一个字符。每当我们看到一个字符，就在相对应的计数器上加一。最终，如果这两个计数器列表相同，则这两个字符串是变位词。下面展示了这种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">s</span>):</span><br><span class="line">    count_list = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        pos = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        count_list[pos] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anagram_solution</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> count(s1) == count(s2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pleap&#x27;</span>))                   <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abd&#x27;</span>, <span class="string">&#x27;ggsabad&#x27;</span>))                   <span class="comment"># False</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;abab&#x27;</span>, <span class="string">&#x27;bbaa&#x27;</span>))                     <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(anagram_solution(<span class="string">&#x27;gsgddjkdsdgds&#x27;</span>, <span class="string">&#x27;dsdgdsgsgddjk&#x27;</span>))   <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>这个方法有一些循环操作。然而不同于第一个方法，所有循环都不是嵌套的。前两个计数字符数的循环都是n重。而因为字符串中总共有26种可能的字符，第三个比较两个计数列表的循环总是执行26步。把它们全部加起来就得到$T(n)&#x3D;2n+26$，也就是$O(n)$。这样，我们就找到了一个解决这个问题的线性复杂度的算法。</p><p><strong>小结</strong><br>关于空间需求，尽管最后一个方法可以以线性的时间复杂度来运行，但是这是以使用了额外的空间来存储两个计数器列表为代价的。换句话说，这个算法牺牲了空间来换取时间。这是一个常见的现象。很多情况下你需要在时间和空间的权衡中做出选择。在这个例子中，额外的空间消耗并不足道。但是如果可能的字母多达几百万种，这将是一个问题。作为一个计算机科学家，当要做出算法选择时，需要你根据具体问题来决定利用计算资源的最好方式。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 复杂度分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你要选择一个怎样的伴侣，去渡过自己的一生？</title>
      <link href="/article/85f919bc.html"/>
      <url>/article/85f919bc.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要转自———小吏深度 || 你要选择一个怎样的伴侣，去渡过自己的一生？理论+实践，挺有启发性的，整理到博客自己来阅读吧。</p><span id="more"></span><p>今天主要谈的问题是，我们要选择一个什么样的伴侣去步入婚姻殿堂。</p><p>这个问题比较大，我们一步步来推演。</p><h2 id="壹：为什么学生时代颜值即正义？"><a href="#壹：为什么学生时代颜值即正义？" class="headerlink" title="壹：为什么学生时代颜值即正义？"></a>壹：为什么学生时代颜值即正义？</h2><p>学生时代的时候，无论男孩还是女孩，都是对那些颜高的校草校花超级迷恋，对于物质和精神层面并不怎么在意。</p><p>为啥会这样呢？</p><p>1、因为<strong>学生时代是个有限博弈的规则模式</strong>，在这个赛道上，评判价值的关键点和展示点太少，而且所有的男孩女孩此时储备还都不够，无法将努力和储备转化为生产力。</p><p>2、因为孩子们此时都还啥都没见过，见识太低。学识和见识水平还相差不大，经济实力更是没太大机会发挥，此时只能比较那些看得见的东西。</p><p>所以颜值即正义，男孩拿把吉他嚎两嗓子就容易给女孩弹懵了。</p><p>所谓最单纯的美好也在于此。</p><p>很多男女生们此时可以当舔狗还很骄傲，风中流泪还自我感觉很美好。</p><p>说到底，是因为校园求爱的失败不像步入社会后输的那么鲜血淋漓，甚至连输的资格都没有。</p><p>因为参与评比的综合维度太低。</p><p>但这并不意味着很多别的层面就不起作用了。</p><p>我们大学时还是经常能看到开奔驰的孩子身边总是最漂亮的妞，或者男神旁边挎着一个一般的姑娘，但全身上下的行头都是普通学生望尘莫及的。</p><p>但这个阶段，总体来讲，颜值即正义，性魅力最抢手。</p><p>等到大学毕业进入社会后，孩子们突然发现换了天地。</p><p>太多之前没见过的维度突然被加入到了生活中。</p><p>颜值和性魅力已经不再那么稳固的高居处对象的榜首了。</p><p>你是男神，你月薪一万，家里有房，有车，那基本上可以继续吊打月薪三万，家里三套房，三辆车的普通男孩。</p><p>毕竟如果其他维度都能说得过去的话，谁都仍然希望身边睡得是个看着顺眼的。</p><p>但是，颜值的正义已经不能包打四方了。</p><p>比如当你除了你的男神外，还有一个家里月收租一百万，住豪宅开豪车的丑男孩想要明媒正娶的抬你回家时，比较可以肯定的是，你男神此时的性吸引力就开始不值一提了。</p><p>同样还是那个男神，你突然就会觉得他好幼稚，好绣花枕头，那个百万收租的男孩放个屁都觉得有一股别样的韵味。</p><p>为什么会这样？</p><p>这是基因里自带的思考方式。建议读读<a href="https://book.douban.com/subject/26683297/">《进化心理学》</a>和<a href="https://book.douban.com/subject/35153840/">《欲望的演化：人类的择偶策略》</a></p><p>人的性魅力，无论她多么的美若天仙，无论他多么的俊美雄壮，通常在朝夕相处后最多最多在三年的时间里你多巴胺和羟色胺的分泌就开始大幅度减量，你就会失去对他的感觉和性吸引力。</p><p>这是天性。</p><p>这也就意味着，当你思考婚姻问题时，前面二十多年的感觉和经验通常不管用了。</p><p>结果很多男孩女孩在切换角色的过程中出了大问题。</p><h2 id="贰：婚姻对象选择时要考虑的三个维度"><a href="#贰：婚姻对象选择时要考虑的三个维度" class="headerlink" title="贰：婚姻对象选择时要考虑的三个维度"></a>贰：婚姻对象选择时要考虑的三个维度</h2><p>每个男生女生，在即将进入婚姻的时候都会琢磨好多事情。</p><p>通常越琢磨越乱，越挑越花眼，越等发现等的人越不来。</p><p>问一个问题给没结婚的自己，婚姻为了啥？已经结了婚的同志们也可以思考下，这些年过明白了吗？</p><p>婚姻这个问题之所以被人慨叹“怎么选都是错”，其实是因为你没结婚的时候永远不知道这段旅程考验你的到底都是些什么。</p><p>绝大多数家长又通常不会对自己的婚姻进行一个详尽的总结，甚至会在自己的伤痛中总结出一些错误的观点比如“看住男人的钱”和“单亲家庭的孩子不要选择”等等并不真正准确的指标去影响孩子的判断，要么就是看不上孩子挑的对象，但又不能给出孩子一个合理信服的原因。</p><p>总结一下，就是我们身边的绝大多数人没办法准确的总结出来婚姻的本质和幸福与否的标准。</p><p>这道题没有标准答案，也没有分数线，还没有辅导老师。</p><p>但却成为了我们几乎刚步入社会后就被家长们逼着去解决的问题。</p><p>婚后幸福的，通常要么是命好中了概率的彩票，要么就是有超级智慧的父母在保驾护航。</p><p>咱们今天从源头开始说起，“婚姻”到底是为了什么？</p><p>这要从法学的概念上来引申，因为我们之所以选择结婚，是因为这种形式合理合法。</p><p><strong>婚姻在法学意义上有三层含义：</strong></p><ol><li>以男女两性结合为基础；</li><li>以共同生活为目的；</li><li>具有夫妻身份的公示性。</li></ol><p>比较懵圈是吧，没事咱们来解释一下婚姻是为了啥：</p><ol><li>为了解决繁殖问题。</li><li>为了让男女双方在物质上1+1》2；</li><li>为了让男女双方在精神上1+1》2；</li></ol><p>如果你只考虑性生活而不考虑孩子问题完全就可以不结婚；</p><p>如果你没有两人贷款买房子等现实压力，或者夫妻去深圳上海积分的考虑，或者豪门强强联合做大做强的资产联盟考虑，本质上也可以不结婚；</p><p>如果你觉得自己的精神领域已经足够高端，完全可以面对这叵测的世界不被影响自己内心深处永远春暖花开，其实你也是可以不用考虑结婚的。</p><p>现在之所以剩女的数量越来越大，质量还都相当高，本质上就是人家很多优质女孩能够无视那三个问题。</p><p>既然我碰不到能够让我上面三点问题更好的优质男孩，那我也没必要去委屈自己嫁给一个啥都搞不定的熊孩子。</p><p>在我国，男孩对比女孩成熟度的巨大差距导致了优质有责任的男孩刚一上货架就被适龄女孩们迅速瓜分，剩下的好女孩们看不上那些注定问题多多的男孩子，但是年龄又对女孩并不友好。</p><p>所有的那些兴趣、性趣、感觉、美好等等在恋爱升级到婚姻的过程中本质上都应该成为上述三点的补充。</p><p>如果你决定和这个人进行婚姻的法律形式捆绑，你一定还是要考虑到上面那三点的：</p><ol><li>你觉得你和他&#x2F;她在一起后物质基础上会1+1》2，或者说你自己就可以覆盖到两个人的物质生活而且你愿意给这个人花一辈子钱；</li><li>你觉得你和这个人在一起后，你的精神殿堂会变得更加高端，更加辽阔，或者你的那些脆弱和痛苦在一个人承受不了的时候，他&#x2F;她能够帮你撑过那些苦难的岁月；</li><li>你对他&#x2F;她不光有性欲，还有繁殖欲，你想和他&#x2F;她养育彼此的血脉。</li></ol><p>并不是说，我们一定要找到上面三点都满足的才能考虑解决。</p><p>因为我们通常不会有那么好命的。</p><p>天之道损有余而补不足，万物皆有残缺的。</p><p>众生皆苦，当你遇到了上述三点都达标而且彼此都极度心动的异性时，极大概率那只是最后为了让你知道痛苦和放下的感觉。</p><p>通常上面三个维度都没有短板的时候，就可以考虑为结婚对象了。</p><p>如果有一个维度，是长板，那就相当优质了。</p><p>或者说有的维度有明显的短板，但你有信心能够消除对方这块短板时，也可以去进一步往下思考。</p><p>总之，面对婚姻对象，我们要接受的第一个态度是：<font color=#9900CC><strong>永远不要认为会有完美！只是各个维度的一种权衡。</strong></font></p><p><font color=#9900CC><strong>最好的婚姻，是能权衡着走一辈子的一个契约形式，你的伴侣一定会有短板，要看你是否愿意因为他&#x2F;她的长板而迁就他&#x2F;她的短板。</strong></font></p><p><font color=#9900CC><strong>最好的婚姻，是永远保持并拓宽“长板”的吸引力和竞争力，与此同时不断补上自己的“短板”。</strong></font></p><p>再重申下这个概念，最好的婚姻，是永远保持住“长板”的新引力和竞争力，与此同时不断补上自己的“短板”。</p><p>我亲爱的弟弟妹妹们，这句话我建议抄下来放在一个醒目的地方时时刻刻提醒下自己。</p><p>这应该是我们做人一辈子的准则，与此同时也应该是你挑另一半时的重要依据。</p><p>你们都会变得越来越好，你们都会在这漫长一生中获得自己应有的价值。</p><h2 id="叁：婚后生活中，最关键的三个指标"><a href="#叁：婚后生活中，最关键的三个指标" class="headerlink" title="叁：婚后生活中，最关键的三个指标"></a>叁：婚后生活中，最关键的三个指标</h2><p>前面我们说了婚姻在法律意义上要解决繁殖、物质、精神三个问题，在具体内化到婚后生活后，分别代表哪三个环节呢？</p><p><strong>1. 性能力</strong></p><p>前面我们说了颜值的效果只能维持两年，但婚姻是一辈子的事，而且性欲望也是一辈子的事情。</p><p>人是有性需求的，你家里媳妇或者老爷们要是天天憋得眼珠子通红你那个婚姻指定好不了，想白头到老那就是个梦。</p><p>在此我强烈建议男孩子们，千万千万别看A片。</p><p>看A片会把你的肾气无形中耗干，将来你的夫妻生活一定会抬不起头来。</p><p>所谓“早泄”的本质，是肾气不足。</p><p>你肾气不足就固不住精，所以在阴阳相交的时候你的阳气率先就跑了。</p><p>所谓“阳痿”的本质，是肾气不足以及心血管系统不够强大支撑不了这么强大耗能的运动，是身体对肾和心脏以及血管的一个自发保护。</p><p>我在这不是建议女孩子们挨个睡一遍哈，判断一个男孩的身体状况其实比较容易。</p><p>眼睛冒不冒光，脸色是发亮还是发黑，体育运动怎么样，坚持一件事情是否有韧性，是否能深度的完成一项大工作。</p><p>性能力差的人肾气和元气都不行，眼睛肯定是浑浊的，脸色尤其是眼下一定是发黑的，特别容易累，走一会儿脑子就不好受，干啥事都是没有长性的，也肯定干不成什么深度的大项目工程。</p><p>你不看A片，生活有规律，注意体育锻炼，你的性能力就不用担心抬不起头来，你在事业上深耕也根本不用担心体力和脑力不够。</p><p>有的朋友说，会有撒切尔夫人那样每天睡四小时的天生精力狂人，最新的基因研究显示还是人家的基因上有优势，菲尔普斯的乳酸消化速度是普通人的五倍，所以人家可以走马灯似的赶场游泳然后北京奥运会拿八块金牌。</p><p>相信我，绝大多数的领域根本用不着拼天赋。</p><p>你没必要成为那0.01%！</p><p>你爬到前10%就相当牛了，而前10%要求的那些标准远远用不着什么天赋异禀，做个规律生活的人就完全够用达标了。</p><p><font color=#9900CC><strong>小总结：为了事业和婚姻，拒绝色情，爱惜身体。</strong></font></p><p><strong>2. 物质条件</strong></p><p>前面我们说过，婚姻要两个人在物质上期望做到1+1》2。</p><p>这并不是一种简单的堆叠，婚后生活中会演变为一个相当复杂的问题，因为人的欲望是无尽的。</p><p>关于择偶的物质问题，这并不简简单单是选择富裕家庭的普通孩子还是选择普通家庭的奋斗孩子的问题，而是你本人是否是个有成功欲的人。</p><p>你要是觉得每天开开心心就挺好，你没有太大的成功欲望，那你最优质的婚恋对象，一定是个家境还算殷实，同样也没啥太大志向和想法的伴侣。</p><p>对于你来讲，物质的要求可以提炼为“稳定”。</p><p>乘风破浪的富商冒险家其实并不适合你，一个家里殷实到点下班回家的公务员才是你最好的选择。</p><p>有的朋友会问：我也搞不清自己的内心，我自己没啥奋斗欲望，但我却希望找个特牛X特有钱的成功者来带我装X带我飞。</p><p>上面这种情况是“穷人思维”，说明你的心智还不成熟，你本人还不适合谈婚论嫁，你的婚姻大概率怎么选都是错。</p><p>要么考虑明白适合自己不奋斗的消费观和价值观该是啥样子，要么去先匹配好适合自己欲望的奋斗水平。</p><p>你如果是个奋斗狂魔，是个梦想成功的，或者是个成功欲望超强的，那也请找个和你同类型的伴侣，而不是天天追剧打游戏无忧无虑的另一半。</p><p>这个“同类型”，是指在各自领域上有追求和梦想并为之不断努力的人。</p><p>奋斗与创业是一个世上最不可测的事情。</p><p>它大概率会让人输的体无完肤，输的让身边所有人把风凉话说尽，让你爱的人本该无忧无虑的生活被破坏；</p><p>它同样概率会让这个人鲤鱼化龙，脱胎换骨，你成功后，是大概率无法和那个一直没啥变化的他&#x2F;她继续走下去的。</p><p>并不是说两口子都是奋斗型的将来过日子天天跟俩疯子似的，而是说两个人在各自领域上不断努力的过程中，很多产生的共识都是殊途同归的，两个人会减少很多不必要的矛盾。</p><p>通常只有这样，将来你这个家庭才能抵御的住各种各样远远超于普通家庭的风浪和质疑。</p><p>一个热衷于稳定，一个梦想于成功，这样的婚姻注定在磨合上有着巨大的痛苦。</p><p>“稳定”这东西意味着不折腾；“成功”这东西意味着玩命折腾。</p><p>在优先稳定的生活和爱情中，通常对夫妻陪伴，孩子陪伴，父母陪伴，旅游、逛街、看电视等等这种天伦之乐极度重视。</p><p>在追逐成功的生活和爱情中，通常天天忙得跟上了弦的发条一样，时间极度不够用，在夫妻和子女陪伴等家庭生活中会相当缺位。</p><p>这两种人要是做了两口子，一个认为你天天陪不了我；一个认为我都快累死了为的是谁啊你也不理解我，这天然就是中巨大的矛盾错位。</p><p>本质上其实谁也没错。</p><p>就是最开始选对象的时候没琢磨明白。</p><p><font color=#9900CC><strong>小总结：看准自己想要啥样的生活，然后选择同类型的伴侣。</strong></font></p><p><strong>3. 精神生活</strong></p><p>我们常常会听说过一句话：两口子要互补才会和谐。</p><p>这句话的原意，是一个人粗心大意一个人心细如发；一个人左脑强一个人右脑强，这种能力上的互补对于两口子相当重要。</p><p>因为婚姻本质上有很多物质的问题，两口子本质上也是合伙人，所以在能力天赋上两个人如果能互补那相当伟大。</p><p>但是吧，这句话却通常被用来了在脾气上产生巨大不和谐时劝两口子凑合过时常说的一句话。</p><p>一个暴脾气，一个好脾气，然后一个大言不惭的旁观者说两口子在性格上要互补。</p><p>性格这东西是最不需要什么互补的！相反的脾气和性格绝对不会带来什么互补，带来的永远是冰火两重天！</p><p>所谓的一个暴脾气和一个好脾气在一起过一辈子也过下来了的本质不过是好脾气在拿自己的情商和意志去“兼容”那个暴脾气。</p><p>要么就是暴脾气的物质能力能够补偿对好脾气施暴后的心灵创伤。</p><p>那是不是意味着两个人都没有脾气，就适合过一辈子呢？</p><p>也并非如此。</p><p>性格上，最大的问题不在于脾气的大小，而是在于这个人能不能沟通以及愿意为了你而磨合改正。</p><p>两个人都没啥脾气，但生活中仍然肯定会有各种各样的小矛盾与小分歧，俩人都憋着，小矛盾就终有一天会憋成大矛盾，也许哪天急眼了两个人就过不下去了。</p><p>同样，一个人脾气大也不可怕，男孩功名看气概，有的时候就是会有脾气的。</p><p>你考量的关键点，是准确的判断出来他&#x2F;她在发完脾气之后能不能进行沟通，能不能倾听你的想法并愿意今后磨合改正让自己的脾气越来越小。</p><p>所谓的牛人从来不在家里发脾气，本质上是因为牛人的沟通能力都很强，而且牛人一直在改变自己去让家庭矛盾越来越少。</p><p>这个人在恋爱中如果在多次明确沟通后仍然控制不了自己的脾气，通常只有三种可能：</p><ol><li>这个人极度自私；</li><li>这个人自视甚高；</li><li>这个人并不爱你。</li></ol><p>无论是哪种可能，你都没必要去选择跟这样的人迈向婚姻的那一步。</p><p>谈恋爱时都无所谓，大不了就分手嘛！</p><p>但婚姻的成本极高！不是你那么轻松就能掰扯开的。</p><p>一旦你打算往婚姻方向上走，一定要观察你们在矛盾冲突后，是否能够坐下来分析明白彼此这次矛盾的引爆点在哪。</p><p>有一句超级扯淡的话叫做：家里不是能讲理的地方。</p><p>这句话拆散了一个又一个本来可以白头到老的家庭。</p><p>家里不能讲理的时候只有一种可能：就是这矛盾已经大到复杂到说不清了的程度！</p><p>金钱、时间、亲属、误会、失望、陈年旧账······已经多维度的掺和在一块了。</p><p>最终只能拿这么一句话打马虎眼。</p><p>最后要么就是两口子互相觉得自己不合适，但为了孩子或家产老人啥的只能糊弄下去，要么就是这矛盾大到没法过了然后一拍两散。</p><p>大风起于青萍之末，相信我，生活是很具体的，沟通是为你婚姻保驾护航的最关键武器。</p><p>比如谈恋爱的时候，你觉得你工作时需要专注四大皆空，你对象觉得你这样就是不爱她不拿她当回事。</p><p>这就得去沟通。</p><p>你要说明白你工作专注是为了产生核心竞争力，核心优势大了才能给她更美好的生活才不是拿嘴去爱她，你可以在陪她的时候专心致志陪她等等。</p><p>她如果觉得不行无法达成共识，或者说当时能同意，但随后一而再再而三对已经达成的共识不尊重，你就要思考这个伴侣是否适合走到谈婚论嫁的这一步了。</p><p>因为这属于你们将来安身立命的问题，未来会有太多次的机会出现矛盾，我想想都替你愁的慌。</p><p>或者你就去迁就，去一切以他&#x2F;她为中心，将来所有的生命中出现和他&#x2F;她撞车的事时一切以人家为重的改变。</p><p>你觉得这样义无反顾没怨言的话，那也行。</p><p>但又一个问题来了，没有了自我的人，通常不会得到等价的尊重，这条道路注定艰辛崎岖，你要想清楚。</p><p>肆：挑对象实际上是在找“双胞胎”的自己</p><p>说了这一大堆，其实是在说咋去挑对象的事吗？</p><p>其实是在讲咋样让自己变成一个优质的伴侣，随后你去谨慎的挑选和自己同样价值的人。</p><p>最后总结下：</p><p>1、自己的身体和伴侣的身体都很重要，注意身材，保持锻炼，远离色情。</p><p>你需要一个精力旺盛的身体去迎接生活的洗礼和事业的挑战，你需要一个过硬的身体去履行自己的性义务。</p><p>2、婚后的物质基础很重要，你要对自己的性格与财富观念有一个预期。</p><ul><li>你是事业型的？还是生活型的？</li><li>最好找和自己相似类型的。</li><li>婚姻和谐的本质是减少摩擦，而不是熊熊烈火燃烧你我。</li></ul><p>3、在不嫖不赌不暴力倾向等硬伤之外，是否会进行沟通以及是否会愿意为你磨合及改正，这相当重要。</p><p>阅读这篇文章的弟弟妹妹都是人中龙凤，未来所要面对的思考和问题，注定会比太多的同龄人要多的多。</p><p>婚姻是一个人一生中堪称最大的课题，我希望能够帮你们多一个维度的思考，也希望我的弟弟妹妹们能够幸福美满的度过自己未来人生中的每一天。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 好文收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生伴侣 </tag>
            
            <tag> 亲密关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next 主题 -- 基本配置</title>
      <link href="/article/db7d7796.html"/>
      <url>/article/db7d7796.html</url>
      
        <content type="html"><![CDATA[<p>当前用得最多的是next主题，那为什么用得多呢？当然是符合大多数人的审美。我使用的是next(v7.8.0)，下载地址：<a href="https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next</a></p><span id="more"></span><h2 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1 基本设置"></a>1 基本设置</h2><h3 id="1-1-主题设置"><a href="#1-1-主题设置" class="headerlink" title="1.1 主题设置"></a>1.1 主题设置</h3><p>打开博客根目录 Blog 文件夹，右键 <code>Git Bash</code>，输入如下代码将next主题下载到目录 <code>Blog/themes</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>打开根目录下的 <code>_config.yml</code>(称为站点配置文件)，修改主题（注意冒号后都要有空格）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">CarpeDiem&#x27;s</span> <span class="string">Blog</span>         <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;虽不能至，心向往之&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。&#x27;</span>       <span class="comment"># 简介或格言</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&quot;Python, Linux, Java, 算法, 人工智能&quot;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Carpe</span> <span class="string">Diem</span>     <span class="comment"># 作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>           <span class="comment"># 主题语言 en/zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span>           <span class="comment"># 中国的时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-bamboo</span>          <span class="comment"># 主体修改为 next</span></span><br></pre></td></tr></table></figure><p>主题语言主要是看你的themes&#x2F;next&#x2F;language中的简体中文是 zh-CN 还是 zh-Hans：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/010.6bt308ce0240.webp#pic_center" width = 48%><p>next主题有四种，如下图依次为Muse、Mist、Pisces、Gemini（你可以每个设置一遍，确定一个喜欢的），这里选的是Gemini，打开目录 <code>Blog/themes/next/</code> 下的_config.yml（称为主题配置文件），只要将你选的主题前的#删除就行了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span>          <span class="comment"># 选择的主题</span></span><br></pre></td></tr></table></figure><p>温馨提示：注意区分 根目录 Blog 下的 _config.yml 和 <code>Blog/themes/next/</code> 下的_config.yml，搞混就找不到相应的配置</p><p>回到根目录打开 <code>Git Bash</code>，输入如下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><h3 id="1-2-设置菜单"><a href="#1-2-设置菜单" class="headerlink" title="1.2 设置菜单"></a>1.2 设置菜单</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，查找menu，将前面的#删除就行了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                      <span class="comment">#首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>      <span class="comment">#归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span>       <span class="comment">#分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span>                 <span class="comment">#标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span>               <span class="comment">#关于</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">/resources/</span> <span class="string">||</span> <span class="string">download</span>   <span class="comment">#资源</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar    #日历</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat      #腾讯公益404</span></span><br></pre></td></tr></table></figure><p>“||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href="https://fontawesome.com.cn/search-download">图标库 - Font Awesome 中文网</a> 这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。resources 是我自己添加的。</p><p>新添加的菜单需要翻译对应的中文，打开 <code>theme/next/languages/zh-CN.yml</code>，在 menu 下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br></pre></td></tr></table></figure><p>在根目录下打开 <code>Git Bash</code>，输入如下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;resources&quot;</span></span><br></pre></td></tr></table></figure><p>此时在根目录的sources文件夹下会生成categories、tags、about、resources四个文件，每个文件中有一个 <code>index.md</code> 文件，修改内容分别如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">资源</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-10 22:07:08</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;resources&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段 comments 并将值设置为false。</p><h3 id="1-3-设置建站时间"><a href="#1-3-设置建站时间" class="headerlink" title="1.3 设置建站时间"></a>1.3 设置建站时间</h3><p>打开主题配置文件即 <code>themes/next</code> 下的_config.yml，查找since：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2023-06</span>      <span class="comment"># 建站时间</span></span><br></pre></td></tr></table></figure><h3 id="1-4-设置头像"><a href="#1-4-设置头像" class="headerlink" title="1.4 设置头像"></a>1.4 设置头像</h3><p>打开主题配置文件即 <code>themes/next</code> 下的 <code>_config.yml</code>，查找avatar，url后是图片的链接地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span>   <span class="comment">#图片的位置，也可以是http://xxx.com/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>   <span class="comment">#头像展示在圈里</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>  <span class="comment">#头像随光标旋转</span></span><br></pre></td></tr></table></figure><h3 id="1-5-网站图标设置"><a href="#1-5-网站图标设置" class="headerlink" title="1.5 网站图标设置"></a>1.5 网站图标设置</h3><p>我是在这个网站找的图标，免费的图标素材网站：<a href="https://www.easyicon.cc/">Easyicon</a></p><p>下载16x16和32x32的图标后，打开主题配置文件，查找favicon，只要修改small和medium为你的图标路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h3 id="1-6-设置动态背景"><a href="#1-6-设置动态背景" class="headerlink" title="1.6 设置动态背景"></a>1.6 设置动态背景</h3><p><strong>1. canvas nest 风格</strong></p><p>在themes&#x2F;next目录下打开Git Bash，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-canvas-nest <span class="built_in">source</span>/lib/canvas-nest</span><br></pre></td></tr></table></figure><p>打开主题配置文件即 themes&#x2F;next 下的 _config.yml，找到 canvas-nest，将<code>enable：false</code> 改为true：（如果找不到 canvas-nest，可能是文件修改了，试试将下面的代码复制粘贴到 themes&#x2F;next 中）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;0,0,255&quot;</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># The number of lines</span></span><br></pre></td></tr></table></figure><p><strong>2. JavaScript 3D library风格</strong></p><p>在themes&#x2F;next目录下打开Git Bash，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-three <span class="built_in">source</span>/lib/three</span><br></pre></td></tr></table></figure><p>打开主题配置文件即themes&#x2F;next下的_config.yml，找到three，这里有三种风格，可以试一下看看喜欢哪种风格，直接将false改为true就行了，我已经选了canvas-nest，就没有选这种风格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="1-7-添加顶部加载条"><a href="#1-7-添加顶部加载条" class="headerlink" title="1.7 添加顶部加载条"></a>1.7 添加顶部加载条</h3><p>在themes&#x2F;next目录下打开Git Bash，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure><p>打开主题配置文件即themes&#x2F;next下的_config.yml，找到pace，将enable：false改为true，你还可以选择类型（theme）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure><h3 id="1-8-设置侧边栏显示效果"><a href="#1-8-设置侧边栏显示效果" class="headerlink" title="1.8 设置侧边栏显示效果"></a>1.8 设置侧边栏显示效果</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，找到Sidebar Settings，设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position. #设置侧边栏位置</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  - post    默认显示模式</span></span><br><span class="line">  <span class="comment">#  - always  一直显示</span></span><br><span class="line">  <span class="comment">#  - hide    初始隐藏</span></span><br><span class="line">  <span class="comment">#  - remove  移除侧边栏</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure><h3 id="1-9-侧边栏推荐阅读"><a href="#1-9-侧边栏推荐阅读" class="headerlink" title="1.9 侧边栏推荐阅读"></a>1.9 侧边栏推荐阅读</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，搜索links（里面写你想要的链接）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_settings:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">推荐网站</span>          <span class="comment"># 修改名称</span></span><br><span class="line">  <span class="comment"># Available values: block | inline</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">block</span></span><br><span class="line"></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="comment">#Title: http://yoursite.com</span></span><br><span class="line">  <span class="string">菜鸟教程:</span> <span class="string">https://www.runoob.com/</span></span><br><span class="line">  <span class="string">C语言中文网:</span> <span class="string">http://c.biancheng.net/sitemap/</span></span><br><span class="line">  <span class="string">CS自学指南:</span> <span class="string">https://csdiy.wiki/</span></span><br><span class="line">  <span class="attr">Road To Coding:</span> <span class="string">https://www.r2coding.com/#/</span></span><br><span class="line">  <span class="string">计算机专业学习路线:</span> <span class="string">https://hackway.org/docs/cs/intro</span></span><br><span class="line">  <span class="string">鱼C论坛:</span> <span class="string">https://fishc.com.cn</span></span><br></pre></td></tr></table></figure><h3 id="1-10-添加社交链接"><a href="#1-10-添加社交链接" class="headerlink" title="1.10 添加社交链接"></a>1.10 添加社交链接</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，搜索social：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/molimi</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:qxie8888@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/xq151750111</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-codiepie</span></span><br></pre></td></tr></table></figure><p>“||”前面的是链接，后面的是 FontAwesome 图标名称。</p><h3 id="1-11-设置博文内链接为蓝色"><a href="#1-11-设置博文内链接为蓝色" class="headerlink" title="1.11 设置博文内链接为蓝色"></a>1.11 设置博文内链接为蓝色</h3><p>打开themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;post&#x2F;post.styl文件，将下面的代码复制到文件最后：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.post-body</span> <span class="string">p</span> <span class="string">a&#123;</span></span><br><span class="line">     <span class="attr">color:</span> <span class="comment">#0593d3;</span></span><br><span class="line">     <span class="attr">border-bottom:</span> <span class="string">none;</span></span><br><span class="line">     <span class="string">&amp;:hover</span> &#123;</span><br><span class="line">       <span class="attr">color:</span> <span class="comment">#0477ab;</span></span><br><span class="line">       <span class="attr">text-decoration:</span> <span class="string">underline;</span></span><br><span class="line">     &#125;</span><br><span class="line">   <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-12-显示文章字数和阅读时长"><a href="#1-12-显示文章字数和阅读时长" class="headerlink" title="1.12 显示文章字数和阅读时长"></a>1.12 显示文章字数和阅读时长</h3><p>从根目录Blog打开Git Bash，执行下面的命令，安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后打开站点配置文件，在文件末尾加上下面的代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure><h3 id="1-13-文章末尾添加版权说明"><a href="#1-13-文章末尾添加版权说明" class="headerlink" title="1.13 文章末尾添加版权说明"></a>1.13 文章末尾添加版权说明</h3><p>查找主题配置文件themes&#x2F;next&#x2F;_config.yml中的creative_commons：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>  <span class="comment"># 将false改为true即可显示版权信息</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure><h3 id="1-14-添加评论"><a href="#1-14-添加评论" class="headerlink" title="1.14 添加评论"></a>1.14 添加评论</h3><p>针对 Hexo 静态博客的 nexT主题 继承了多种评论系统，此处介绍两种相对好用的评论系统： Valine、Gitment 和 Utterances 。</p><p><strong>1. Valine 评论系统</strong></p><p>Valine 评论系统，此款系统不需要登录，无后端，nexT 主题最新也已经支持安装。</p><p>因为 Valine 是基于 LeanCloud 系统的，所以先在 LeanCloud 中注册账号，LeanCloud官网：<a href="https://console.leancloud.cn/login">https://console.leancloud.cn/login</a>，注册登陆后，访问控制台，创建应用，选择开发版，确定创建，如下图</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/007.63c1igtf5a40.webp#pic_center" width = 48%><p>创建成功，生成了 AppID 和 AppKey，在控制台—应用凭证 查看，如下图</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/008.3bs8wz462a20.webp#pic_center" width = 48%><p>在主题的配置文件_config.yml中，修改关于 valine 的配置，如下图</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/009.3xocq7i43e20.webp#pic_center" width = 48%><p>上述设置仅作参考！<br>最后，重新部署即可。</p><p><strong>2. Gitment 评论系统</strong></p><p>Gitment 评论系统是基于 Github 开发的，是依靠 GitHub Issues 的评论系统，Next 主题最新也已经支持安装。</p><p>安装前提：更新 Next 主题（5.1.2 主题及以上）</p><p><strong>1. 注册 OAuth application</strong></p><ol><li>在 github 中进行注册，进入 <a href="https://github.com/settings/profile">https://github.com/settings/profile</a></li><li>点击左侧 Developer settings</li><li>点击左侧Oauth Apps</li><li>点击 Register a new application</li></ol><p>注册完成之后，得到：Client ID 和 Client Secret</p><p><strong>2. 新建存放博客评论仓库</strong></p><p>在 github 中建一个项目，专门用来存储你的博客评论</p><p><strong>3. 配置 nexT 主题文件</strong></p><p>编辑主题配置文件：<code>themes\ next主题 \ _config.yml</code>，找到有关 gitment 的设置，如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitment:</span>   </span><br><span class="line">  <span class="attr">enable:</span>  <span class="literal">true</span></span><br><span class="line">  <span class="attr">mint:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">lazy:</span> <span class="literal">false</span>  <span class="comment">#评论懒加载，如果true，则默认不展示评论，点击按钮查看评论</span></span><br><span class="line">  <span class="attr">cleanly:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">language:</span> </span><br><span class="line">  <span class="attr">github_user:</span> <span class="comment">#github名称</span></span><br><span class="line">  <span class="attr">github_repo:</span> <span class="string">BlogComments</span><span class="comment">#上一步新建存放评论的仓库名</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">b8bad0exxxx</span><span class="comment">#上面注册 OAuth Application 的 Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">bcee560xxxxxx</span><span class="comment">#上面注册 OAuth Application 申请的 Client Secret</span></span><br><span class="line">  <span class="attr">proxy_gateway:</span> </span><br><span class="line">  <span class="attr">redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint</span></span><br></pre></td></tr></table></figure><p><strong>4. 初始化</strong></p><p>在设置完成后，Hexo重新部署。每篇文章都要点击初始化评论按钮。</p><p><strong>5. 管理</strong></p><p>评论显示在新建存放评论的仓库中的 issue 中。</p><p><strong>6. 关闭</strong></p><p>可以单独关闭某个页面的评论，在页面的 Front-matter 中添加 comments 字段，设为 false。比如标签页不想要评论，则在标签页面中做如下设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxxxxxxx</span><br><span class="line">date: <span class="number">2023</span>-06-06 <span class="number">17</span>:05:<span class="number">24</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>3. Utterances 评论系统</strong></p><p>这里主要介绍基于 Github Issues 的轻量级博客评论系统 Utterances。主要介绍 Utterances 的配置与使用</p><p>Utterances是一个基于Github Issues的轻量级评论系统，可用于博客、Wiki等。它具有以下优点：</p><ul><li>开源</li><li>不追踪，无广告，始终免费</li><li>所有的数据都存储在Github Issues</li><li>样式基于Github的Primer设计语言</li><li>夜间模式</li><li>轻量级；原生TypeScript；在“常青树”浏览器上不使用网络字体，JavaScript框架或Polyfill。</li></ul><p>快速上手</p><ol><li>在 GitHub 上新建一个公开仓库（Repository），安装 <a href="https://github.com/apps/utterances">Utterances GitHub App</a> 至该仓库。</li><li>在你的网页需要插入 Utterances 评论的位置，粘贴以下代码（username，reponame 分别修改为你的 GitHub 用户名，仓库名）。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">repo</span>=<span class="string">&quot;username/reponame&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">issue-term</span>=<span class="string">&quot;pathname&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">theme</span>=<span class="string">&quot;github-light&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">async</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>刷新网页就可以看到Utterances评论框了。</li></ol><p>了解更多配置，请移步——<a href="https://blog.njilc.com/post/self-hosted-utterances-tutorial">自托管Utterances教程：基于Github Issues的轻量级博客评论系统</a></p><h3 id="1-15-修改永久链接的默认格式"><a href="#1-15-修改永久链接的默认格式" class="headerlink" title="1.15 修改永久链接的默认格式"></a>1.15 修改永久链接的默认格式</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。</p><p>在 Hexo 根目录下的 _config.yml 文件采用初始设置。这里因为用“年月日”会让文章链接的层次太深，所以我用”article”代替：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line">permalink: article/:title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>生成的文章链接就是 (标题为“我的个人博客”)：<code>https://[你的网站域名]/article/我的个人博客.html</code></p><p>链接中出现中文显然不太好，所以下面给出三种替代中的方法。</p><p><strong>1. 安装插件方法一（推荐）</strong></p><p>在 Hexo 根目录下使用 <code>git bash</code> 执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件，修改为如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment"># permalink: article/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">article/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>然后在 <code>git bash</code> 按顺序运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><p>再打开网站的文件就可以看到效果————<code>https://[你的网站域名]/article/60762.html</code>（其中60762就是随机生成的）</p><p><strong>2. 安装插件方法二</strong></p><p>中文链接转拼音，在 Hexo 根目录下使用 <code>git bash</code> 执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 _config.yml 文件中，修改以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:title.html</span></span><br><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span>    <span class="comment"># default: &#x27;-&#x27;</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>然后在 <code>git bash</code> 按顺序运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><p>再打开网站的文件就可以看到效果。<code>https://[你的网站域名]/article/wo-de-ge-ren-bo-ke.html</code>（标题为“我的个人博客”）</p><p>**3. 采用urlname<br>**<br>在写每篇md文章的时候，在 Front-matter 里加上urlname：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Next 主题介绍</span><br><span class="line">date: 2023-06-06 15:31:11</span><br><span class="line">urlname: 2023060601</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 _config.yml 文件中，修改以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:urlname.html</span>  <span class="comment"># urlname值文章里必须填写，格式2023060601</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>然后在 <code>git bash</code> 按顺序运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><p>再打开网站的文件就可以看到效果。<code>https://[你的网站域名]/article/2023060601.html</code></p><p><strong>小结</strong></p><p>第一种方法是我试过中最好的；第三次之，因为每次都要手动加上urlname；而第二种，当文章的中文标题名字过长时，效果并不好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/article/f3fb008f.html"/>
      <url>/article/f3fb008f.html</url>
      
        <content type="html"><![CDATA[<p>发博客，总会因为各种原因不过审，那就自己申请域名搭博客，这样既可以记录技术，又可以写自己的感悟。</p><span id="more"></span><p>搭建博客需要的前提条件：</p><ul><li>GitHub&#x2F;Gitee 账户</li><li>安装 Git</li></ul><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1 购买域名"></a>1 购买域名</h2><p>购买域名有几个网站，可以在<a href="https://www.godaddy.com/zh-sg/offers/domains/godaddycom?isc=gennbacn07&countryview=1&currencyType=CNY&utm_source=baidu&utm_medium=cpc&utm_term=Title&utm_campaign=zh-cn_corp_sem_x_b_x_bz_001&utm_content=Brandzone%20PC&gclid=CIXh9LjPmecCFdOavAoddDkHcw&gclsrc=ds">Godaddy</a>上，也可以在<a href="https://wanwang.aliyun.com/">万网</a>，<a href="https://cloud.tencent.com/?fromSource=gwzcw.2212127.2212127.2212127&utm_medium=cpd&utm_id=gwzcw.2212127.2212127.2212127">腾讯云</a>等网站购买，我是在万网上购买的，一个.com的域名第一年就69元。</p><p>首先用支付宝登录万网，点击查询自己想要注册的域名是否已经被注册</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/112.1ehd79l0zgf4.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/112.1ehd79l0zgf4.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="112" width=36%/><p>如果你需要的域名没有被注册，点击加入清单，再点击立即结算</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/113.3hm2ohhzcvk0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/113.3hm2ohhzcvk0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="113" width=48%/>先选择你要的年限，再点击个人，接着点击创建新的信息模板：<img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/114.6vy5ufotxb0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/114.6vy5ufotxb0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="114" width=48%/><p>填完下图信息，点击 保存 即可：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/115.4z85yyc8xrk0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/115.4z85yyc8xrk0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="115" width=36%/><p>接下来，先验证邮箱，再实名认证，然后打开万网给你发的邮件验证，实名认证需要上传身份证，此时模板还是未认证状态，等认证通过，勾选模板，再勾选我已阅读，点击立即购买即可完成。</p><h2 id="2-安装-node-js-和-Hexo"><a href="#2-安装-node-js-和-Hexo" class="headerlink" title="2 安装 node.js 和 Hexo"></a>2 安装 node.js 和 Hexo</h2><h3 id="2-1-安装-node-js"><a href="#2-1-安装-node-js" class="headerlink" title="2.1 安装 node.js"></a>2.1 安装 node.js</h3><p>下载地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/116.2m2s8oqd4zi0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/116.2m2s8oqd4zi0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="116" width=30%/><p>如上图，直接点击下载，完成后双击安装，安装直接默认 next 就好，很简单，需要改的也就是安装位置改一下，我是在D盘新建了一个文件夹 nodejs，安装在这个文件夹里。如果要看详细到每一步的话，可以看一下这个文章：<a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程</a>。</p><p>安装成功，文件夹结构如下，并在上面安装过程中已自动配置了环境变量和安装好了 npm 包（也可以手动配置），此时可以执行 <code>node -v</code> 和 <code>npm -v</code> 分别查看 node 和 npm 的版本号：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/134.5u91jsytfjk0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/134.5u91jsytfjk0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="134" width=48%/><p>因为在执行例如 <code>npm install webpack -g</code> 等命令全局安装的时候，默认会将模块安装在 <code>C:\Users\用户名\AppData\Roaming</code> 路径下的npm和npm_cache中，不方便管理且占用C盘空间，如下图所示：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/135.1pcyhnd2eeo0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/135.1pcyhnd2eeo0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="135" width=24%/><p>所以这里配置自定义的全局模块安装目录，在 node.js 安装目录下新建两个文件夹 node_global 和 node_cache，然后在cmd命令下执行如下两个命令：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/136.222iqanek05c.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/136.222iqanek05c.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="136" width=48%/><p>执行成功。然后在环境变量 -&gt; 系统变量中新建一个变量名为 “NODE_PATH”， 值为 <code>“D:\Program Files\nodejs\node_global\node_modules”</code>，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/142.3a74zjfl9w80.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/142.3a74zjfl9w80.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="142" width=36%/><p>最后编辑用户变量里的Path，将相应npm的路径改为：<code>D:\Program Files\nodejs\node_global</code>，如下：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/138.pzitxkoa17k.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/138.pzitxkoa17k.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="138" width=48%/><p>在 cmd 命令下执行 <code>npm install webpack -g</code>：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/139.5wybpub3wc00.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/139.5wybpub3wc00.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="139" width=36%/><p>温馨提示：注意在建立两个文件夹 node_global 与 node_cache 时，需要右键设置“属性”，将用户具有完全属性的权限，否则在 <code>npm install webpack</code> 时会报错。</p><p>然后 webpack 这个模块已经在我们设置默认的文件夹中了：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/140.3oapxqi22ig0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/140.3oapxqi22ig0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="140" width=36%/><h3 id="2-2-安装-Hexo"><a href="#2-2-安装-Hexo" class="headerlink" title="2.2 安装 Hexo"></a>2.2 安装 Hexo</h3><p>Hexo就是我们的个人博客网站的框架，在安装之前，我们要先在GitHub上创立一个仓库，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/141.15czm339hzi8.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/141.15czm339hzi8.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="141" width=36%/><p><strong>1. 下载 Hexo</strong></p><p>接下来就是安装Hexo，首先在D盘建立一个文件夹 Blog，点开 Blog 文件夹，y以管理员运行 CMD 终端（也可以鼠标右键打开 <code>Git Bash Here</code>），输入 npm 命令安装 Hexo，安装完成后，输入 <code>hexo init</code> 命令初始化博客，然后输入 <code>hexo g</code> 静态部署，这时网页已经部署完成，输入 <code>hexo s</code> 命令可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/004.4pekxs40zji0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/004.4pekxs40zji0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="004" width=40%/><p>浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以打开新部署的网页：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/003.vo16jvph5z4.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/003.vo16jvph5z4.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="003" width=30%/><p><strong>2. 将 Hexo 部署到 GitHub</strong></p><p>现在回到我们的 Blog 文件夹，用笔记本打开 <code>_config.yml</code> 文件，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/006.1dz8z5aa290g.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/006.1dz8z5aa290g.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="006" width=36%/><p>下滑到文件底部，填上如下内容：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/005.3k0fdvwucpw0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/005.3k0fdvwucpw0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="005" width=30%/><p>你的仓库地址就是下图这个：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/007.45l40fnl3u20.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/007.45l40fnl3u20.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="007" width=36%/><p>继续安装Git部署插件，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/008.12k2ai4luxw0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/008.12k2ai4luxw0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="008" width=36%/><p>然后分别输入以下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   <span class="comment"># 清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment"># 生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment"># 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/009.4824fabnrsi0.webp#pic_left" width = "48%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/010.12r1yrmi7aq8.webp#pic_left"  width = "48%"></center></p><p>完成以后，打开浏览器，输入 <a href="https://xxx.github.io/">https://xxx.github.io</a> 就可以打开你的网页了。</p><h3 id="2-3-解析域名"><a href="#2-3-解析域名" class="headerlink" title="2.3 解析域名"></a>2.3 解析域名</h3><p>第一步：登录万网，点击控制台，在你已购买的域名后点击解析添加一条解析记录：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/011.3ekdvo6ka6w0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/011.3ekdvo6ka6w0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="011" width=48%/><p>那个IPV4地址可以通过ping得到，具体方法是：打开cmd输入下面命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping molimi.github. -<span class="number">4</span>       <span class="comment"># ping + 你的GitHub的网址 </span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/012.6fttpyogc3o0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/012.6fttpyogc3o0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="012" width=36%/><p>第二步：打开 Blog 文件夹里的 source 文件夹，添加 CNAME 文件，可以先创建一个 CNAME.txt 文件，打开后写上你的域名，不要加 www 否则每次访问都必须加 www，但如果不带有 www，以后访问的时候带不带 www 都可以访问，保存后记得要重命名，将 .txt 删除，如下图：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/013.3jkkos4ga9a0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/013.3jkkos4ga9a0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="013" width=36%/><p>第三步回到 Blog 文件夹，右键打开 Git Bash，依次输入下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开 GitHub，看看CNAME文件是否已经在你的项目中：</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/014.5ui049889rw0.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客搭建/014.5ui049889rw0.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="014" width=48%/><p>这样就完成啦！这时候你就可以浏览器直接输入你的域名就会进入你搭建的网页啦！</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>从零开始搭建个人博客：<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></li><li>node.js 安装详细步骤教程：<a href="https://blog.csdn.net/antma/article/details/86104068">https://blog.csdn.net/antma/article/details/86104068</a></li><li>hexo+github搭建个人博客(超详细教程)：<a href="https://blog.csdn.net/AinUser/article/details/77609180">https://blog.csdn.net/AinUser/article/details/77609180</a></li><li>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo">https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名购买 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础篇（二）-- 数据类型和运算符</title>
      <link href="/article/8a42c3c2.html"/>
      <url>/article/8a42c3c2.html</url>
      
        <content type="html"><![CDATA[<p>这一部分主要对Python的数据类型包括：数字、字符串、列表、元组、集合、字典进行介绍，然后介绍运算符，转义字符、数据类型转换、算术运算符、赋值运算符、位运算、比较运算符、逻辑运算符等。</p><span id="more"></span><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h2><p>所有的编程语言都支持变量，变量是编程的起点，程序需要将数据存储到变量中。在编程语言中，变量是数据的载体，简单的说就是一块用来保存数据的内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><ul><li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li><li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）</li></ul><p>变量在<code>Python</code>内部是有类型的，比如<code>int</code>、<code>float</code> 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，<code>Python</code>是动态类型语言，可以将不同类型的数据赋值给同一个变量，所以变量的类型是随时可以改变的。</p><p>任何编程语言都需要处理数据，比如数字、字符串、字符等，我们可以直接使用数据，也可以将数据保存到变量中，方便以后使用。</p><p><code>Python</code>中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在<code>Python</code>中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。等号（&#x3D;）用来给变量赋值。</p><p><strong>变量与常量</strong></p><p>常量是在程序运行过程中，值不能改变的量。<code>Python</code>中并未提供定义常量的保留字，在<code>PEP8</code>规定常量有大写字母和下划线组成。</p><p><code>Python</code>中，使用内置函数<code>type()</code>返回变量类型，使用<code>id()</code>返回变量所指内存区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>AGE_OF_NICK = <span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(AGE_OF_NICK)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(AGE_OF_NICK)</span><br></pre></td></tr></table></figure><p>在内存中存储的数据可以有多种类型。字符型、数值型、布尔型都是<code>Python</code>语言中提供的基本数据类型。</p><h3 id="1-1-数字"><a href="#1-1-数字" class="headerlink" title="1.1 数字"></a>1.1 数字</h3><p><code>Python</code>中提供了数字类型保存数值，数字类型包括整数、浮点数和复数。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。当你指定一个值时，Number 对象就会被创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>number = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>1、整数</strong></p><p>整数包括正整数、负整数和零。在<code>Python3</code>中，不管对于多大或者多小的整数，只用一种类型存储，就是<code>int</code>。<code>Python</code>整数的取值范围是无限的，不管多大或者多小的数字，<code>Python</code>都能轻松处理。当所用数值超过计算机自身的计算能力时，<code>Python</code>会自动转用高精度计算（大数计算）。</p><p>整数类型包括十进制整数、八进制整数、十六进制整数和二进制整数。<br>1）十进制形式</p><p>我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。</p><p>2）二进制形式</p><p>由 0 和 1 两个数字组成，书写时以<code>0b</code>或<code>0B</code>开头。例如，101 对应十进制数是 5。</p><p>3）八进制形式</p><p>八进制整数由 0~7 共八个数字组成，以<code>0o</code>或<code>0O</code>开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。</p><p>4）十六进制形式</p><p>由 <code>0~9</code> 十个数字以及 <code>A~F</code>（或 a~f）六个字母组成，书写时以<code>0x</code>或<code>0X</code>开头</p><p><strong>数字分隔符：</strong> 对于很大的数，例如10000000000，很难数清楚0的个数。为了提高数字的的可读性，<code>Python 3.x</code>允许使用下划线_作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。</p><p><strong>2、小数&#x2F;浮点数</strong></p><p>浮点数由整数部分和小数部分组成，主要用于处理包括小数的数。有两种书写形式：</p><ol><li><p>十进制形式<br>这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。</p></li><li><p>指数形式<br>Python 小数的指数形式的写法为：</p></li></ol><blockquote><p>aEn 或 aen<br>a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 $a\times 10^n$。</p></blockquote><p><strong>温馨提示：</strong> 注意，只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">12e4</span>)</span><br><span class="line"><span class="number">120000.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">12.3</span>*<span class="number">0.1</span>)</span><br><span class="line"><span class="number">1.2300000000000002</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> <code>12.3*0.1</code>的计算结果很明显是 1.23，但是<code>print</code>的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的。对于浮点数，不能直接使用比较判断是否相等。</p><p><strong>3、复数类型</strong></p><p>复数由实部（real）和虚部（imag）组成，并且使用<code>j</code>或者<code>J</code>表示虚部。可以用<code>a + bj</code>，或者·complex(a,b)·表示， 复数的实部和虚部都是浮点型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a.real)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(a.imag)</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure><p><strong>4、布尔类型</strong></p><p>布尔类型主要用来表示真值或假值。在<code>Python</code>中，标识符<code>True</code>和<code>False</code>被解释为布尔值。另外，<code>Python</code>中的布尔值可以转化为数值，<code>True</code>表示1，<code>False</code>表示0。</p><p>在<code>Python</code>中，所有的对象都可以进行真值测试。其中，只有下面列出的几种情况得到的值为假，其他对象在<code>if</code>或者<code>while</code>语句中都表现为真。</p><ul><li>False 或 None。</li><li>数值中的零，包括0、0.0、虚数0。</li><li>回空序列，包括字符串、空元组、空列表、空字典。</li><li>自定义对象的实例，该对象的<code>_bool_</code>方法返回<code>False</code>或者<code>_len_</code>方法返回0。</li></ul><p><strong>温馨提示：</strong><code>Python</code>中的布尔类型的值可以进行数值运算，例如，<code>“False +1”</code>的结果为1。但是不建议对布尔类型的值进行数值运算。</p><h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2 字符串"></a>1.2 字符串</h3><p>字符串就是连续的字符序列，可以是计算机所能表示的一切字符的集合。<font color=#9900CC><strong><code>Python</code>中字符串属于不可变序列，使用单引号<code>&#39;...&#39;</code>，双引号<code>&#39;&#39;...&#39;&#39;</code>，或<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>括起来。</font></strong><code>Python</code>中单引号和双引号使用完全相同，只能单行；使用三引号(‘’’或”””)可以指定一个多行字符串。详细用法如下：</p><ul><li>字符串可以用<code>+</code>运算符连接在一起，用<code>*</code>运算符重复。</li><li><code>Python</code>中的字符串有两种索引方式，从左往右以 0 开始，最大范围是字符串长度少1；从右往左以 -1 开始，最大范围是字符串开头。</li><li><code>Python</code>没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量<code>[头下标:尾下标:步长]</code>，其中头下标是从 0 开始算起，可以是正数或负数；尾下标可以为空表示取到头或尾；步长表示间隔。获取的子字符串包含头下标的字符，但不包含尾下标的字符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>；<span class="number">5</span>])</span><br><span class="line">llo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>*<span class="number">2</span>)</span><br><span class="line">Hello World!Hello World!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>+<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">Hello World!Test</span><br></pre></td></tr></table></figure><h3 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用<code>[ ]</code>标识，是<code>python</code>最通用的复合数据类型。</p><p>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客图库/001.3d88ipk687i0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/博客图库/001.3d88ipk687i0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width=50%><p>加号<code>+</code>是列表连接运算符，星号<code>*</code>是重复操作。如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span> + tinylist    <span class="comment"># 打印组合的列表</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>[‘runoob’, 786, 2.23, ‘john’, 70.2]<br>runoob<br>[786, 2.23]<br>[2.23, ‘john’, 70.2]<br>[123, ‘john’, 123, ‘john’]<br>[‘runoob’, 786, 2.23, ‘john’, 70.2, 123, ‘john’]</p></blockquote><h3 id="1-4-元组"><a href="#1-4-元组" class="headerlink" title="1.4 元组"></a>1.4 元组</h3><p>元组是另一个数据类型，类似于 List（列表）。元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第四个（不包含）的元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span> + tinytuple   <span class="comment"># 打印组合的元组</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>(‘runoob’, 786, 2.23, ‘john’, 70.2)<br> runoob<br> (786, 2.23)<br>  (2.23, ‘john’, 70.2)<br>  (123, ‘john’, 123, ‘john’)<br>  (‘runoob’, 786, 2.23, ‘john’, 70.2, 123, ‘john’)</p></blockquote><p><strong>温馨提示：</strong> 元组是不允许更新的，而列表是允许更新的。</p><h3 id="1-5-集合"><a href="#1-5-集合" class="headerlink" title="1.5 集合"></a>1.5 集合</h3><p><code>Python</code>中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。从形式上看，和字典类似，<code>Python</code>集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔，如下所示：</p><blockquote><p>{element1, element2, …, elementn}</p></blockquote><p>从内容上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误。</p><h3 id="1-6-字典"><a href="#1-6-字典" class="headerlink" title="1.6 字典"></a>1.6 字典</h3><p>字典(dictionary)是除列表以外<code>Python</code>之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值<code>value</code>组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>]          <span class="comment"># 输出键为&#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>This is one<br>This is two<br>{‘dept’: ‘sales’, ‘code’: 6734, ‘name’: ‘runoob’}<br>[‘dept’, ‘code’, ‘name’]<br>[‘sales’, 6734, ‘runoob’]</p></blockquote><p><strong>小结</strong></p><ul><li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li><li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</li></ul><hr><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2 运算符"></a>2 运算符</h2><p>运算符将各种类型的数据连接在一起形成表达式。Python 的运算符丰富但不混乱，比如 Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱。</p><p><code>Python</code>的运算符包括算术运算符、赋值运算符、比较运算符、逻辑运算符和位运算符。使用运算符将不同类型数据按照一定规则连接在一起的式子称为表达式。</p><h3 id="2-1-转义字符"><a href="#2-1-转义字符" class="headerlink" title="2.1 转义字符"></a>2.1 转义字符</h3><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>换行符，将光标位置移到下一行开头</td></tr><tr><td>\r</td><td>回车符，将光标位置移到本行开头</td></tr><tr><td>\t</td><td>水平制表符，也即 Tab 键，一般相当于四个空格</td></tr><tr><td>\a</td><td>蜂鸣器响铃</td></tr><tr><td>\b</td><td>退格（Backspace），将光标位置移到前一列</td></tr><tr><td>\0</td><td>空</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\</td><td>反斜线</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\</td><td>在字符串行尾的续行符，即一行未完，转到下一行继续写</td></tr></tbody></table><p><strong>温馨提示：</strong> 反斜杠可以用来转义，使用<code>r</code>可以让反斜杠不发生转义。 如<code>r&quot;this is a line with \n&quot;</code>则<code>\n</code>会显示，并不是换行。</p><h3 id="2-2-数据类型转换"><a href="#2-2-数据类型转换" class="headerlink" title="2.2 数据类型转换"></a>2.2 数据类型转换</h3><table class="reference"><tbody><tr><th>函数</th><th>描述</th></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-int.html" target="_blank" rel="noopener noreferrer">int(x [,base])</a></p></td><td><p>将x转换为一个整数</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-float.html" target="_blank" rel="noopener noreferrer">float(x)</a></p></td><td><p>将x转换到一个浮点数</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-complex.html" target="_blank" rel="noopener noreferrer">complex(real [,imag])</a></p></td><td><p>创建一个复数</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-str.html" target="_blank" rel="noopener noreferrer">str(x)</a></p></td><td><p>将对象 x 转换为字符串</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-repr.html" target="_blank" rel="noopener noreferrer">repr(x)</a></p></td><td><p>将对象 x 转换为表达式字符串</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-eval.html" target="_blank" rel="noopener noreferrer">eval(str)</a></p></td><td><p>用来计算在字符串中的有效Python表达式,并返回一个对象</p></td></tr><tr valign="top"><td><p><a href="att-tuple-tuple.html" target="_blank" rel="noopener noreferrer">tuple(s)</a></p></td><td><p>将序列 s 转换为一个元组</p></td></tr><tr valign="top"><td><p><a href="att-list-list.html" target="_blank" rel="noopener noreferrer">list(s)</a></p></td><td><p>将序列 s 转换为一个列表</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-set.html" target="_blank" rel="noopener noreferrer">set(s)</a></p></td><td><p>转换为可变集合</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-dict.html" target="_blank" rel="noopener noreferrer">dict(d)</a></p></td><td><p>创建一个字典。d 必须是一个序列 (key,value)元组。</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-frozenset.html" target="_blank" rel="noopener noreferrer">frozenset(s)</a></p></td><td><p>转换为不可变集合</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-chr.html" target="_blank" rel="noopener noreferrer">chr(x)</a></p></td><td><p>  将一个整数转换为一个字符</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-unichr.html" target="_blank" rel="noopener noreferrer">unichr(x)</a></p></td><td><p>将一个整数转换为Unicode字符</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-ord.html" target="_blank" rel="noopener noreferrer">ord(x)</a></p></td><td><p> 将一个字符转换为它的整数值</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-hex.html" target="_blank" rel="noopener noreferrer">hex(x)</a></p></td><td><p>  将一个整数转换为一个十六进制字符串</p></td></tr><tr valign="top"><td><p><a href="https://www.runoob.com/python/python-func-oct.html" target="_blank" rel="noopener noreferrer">oct(x)</a></p></td><td><p> 将一个整数转换为一个八进制字符串</p></td></tr></tbody></table><h3 id="2-3-算术运算符"><a href="#2-3-算术运算符" class="headerlink" title="2.3 算术运算符"></a>2.3 算术运算符</h3><p>这里以 $a&#x3D;10, b&#x3D;20$ 为例</p><table class="reference"><tbody><tr><th>运算符</th><th>描述</th><th>实例</th></tr><tr><td>+</td><td>加 - 两个对象相加</td><td> a + b 输出结果 30</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td> a - b 输出结果 -10</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td> a * b 输出结果 200</td></tr><tr><td>/</td><td>除 - x除以y</td><td> b / a 输出结果 2</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td> b % a 输出结果 0</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td> a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td>//</td><td>取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td> <pre class="prettyprint prettyprinted" style=""><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="lit">9</span><span class="com">//2</span><span class="pln"></span><span class="lit">4</span><span class="pln"></span><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">9</span><span class="com">//2</span><span class="pln"></span><span class="pun">-</span><span class="lit">5</span></pre></td></tr></tbody></table><p><strong>1、&#x2F; 和 &#x2F;&#x2F; 除法运算符</strong></p><p><code>Python</code>支持<code>/</code>和<code>//</code>两个除法运算符，但它们之间是有区别的：</p><ul><li><code>/</code>表示普通除法，使用它计算出来的结果和数学中的计算结果相同。</li><li><code>//</code>表示整除，只保留结果的整数部分，舍弃小数部分；注意是直接丢掉小数部分，而不是四舍五入。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">20</span>/<span class="number">4</span>)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">20</span>//<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">20.4</span>/<span class="number">4</span>)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong></p><ul><li><code>/</code>的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。当有小数参与运算时，<code>//</code>结果才是小数，否则就是整数。</li><li>需要注意的是，除数始终不能为 0，除以 0 是没有意义的，这将导致<code>ZeroDivisionError</code>错误。在某些编程语言中，除以 0 的结果是无穷大（包括正无穷大和负无穷大）。</li></ul><p><strong>2、% 求余运算符</strong></p><p><code>%</code>运算符用来求得两个数相除的余数，包括整数和小数。<code>Python</code>使用第一个数字除以第二个数字，得到一个整数的商，剩下的值就是余数。对于小数，求余的结果一般也是小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;7.7%2.2 =&quot;</span>, <span class="number">7.7</span>%<span class="number">2.2</span>)</span><br><span class="line"><span class="number">7.7</span>%<span class="number">2.2</span> = <span class="number">1.0999999999999996</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;-7.7%2.2 =&quot;</span>, -<span class="number">7.7</span>%<span class="number">2.2</span>)</span><br><span class="line">-<span class="number">7.7</span>%<span class="number">2.2</span> = <span class="number">1.1000000000000005</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;7.7%-2.2 =&quot;</span>, <span class="number">7.7</span>%-<span class="number">2.2</span>)</span><br><span class="line"><span class="number">7.7</span>%-<span class="number">2.2</span> = -<span class="number">1.1000000000000005</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;-7.7%-2.2 =&quot;</span>, -<span class="number">7.7</span>%-<span class="number">2.2</span>)</span><br><span class="line">-<span class="number">7.7</span>%-<span class="number">2.2</span> = -<span class="number">1.0999999999999996</span></span><br></pre></td></tr></table></figure><p>从运行结果可以发现两点：</p><ul><li>只有当第二个数字是负数时，求余的结果才是负数。换句话说，求余结果的正负和第一个数字没有关系，只由第二个数字决定。</li><li><code>%</code>两边的数字都是整数时，求余的结果也是整数；但是只要有一个数字是小数，求余的结果就是小数。</li></ul><h3 id="2-4-赋值运算符"><a href="#2-4-赋值运算符" class="headerlink" title="2.4 赋值运算符"></a>2.4 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取模赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>:&#x3D;</td><td>海象运算符，可在表达式内部为变量赋值</td><td>b &#x3D; [(a:&#x3D;0)+1, a-1, a*1, a&#x2F;1]</td></tr></tbody></table><p><strong>温馨提示：</strong> 海象运算符是<code>Python3.8</code>版本新增运算符。</p><h3 id="2-5-比较运算符"><a href="#2-5-比较运算符" class="headerlink" title="2.5 比较运算符"></a>2.5 比较运算符</h3><p>比较运算符，也称关系运算符，用于对常量、变量或表达式的结果进行大小比较。如果这种比较是成立的，则返回 True（真），反之则返回 False（假）。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于——比较对象是否相等，返回True&#x2F;False</td></tr><tr><td>!&#x3D;</td><td>不等于——比较两个对象是否相等，返回True&#x2F;False</td></tr><tr><td>&gt;</td><td>大于——判断x是否大于y，返回True&#x2F;False</td></tr><tr><td>&lt;</td><td>小于——判断x是否小于y，返回True&#x2F;False</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于——判断x是否大于等于y，返回True&#x2F;False</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于——判断x是否小于等于y，返回True&#x2F;False</td></tr></tbody></table><p>补充：在<code>Python</code>中，当需要判断一个变量是否介于两个值之间时，可以采用“值1&lt;变量&lt;值2”的形式，例如“0&lt;a&lt;100”。</p><h3 id="2-6-逻辑运算符"><a href="#2-6-逻辑运算符" class="headerlink" title="2.6 逻辑运算符"></a>2.6 逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>逻辑与运算，a and b，如果a为False，返回a的计算值，否则返回b的计算值</td></tr><tr><td>or</td><td>逻辑或运算，a or b，如果a是True，则返回a的计算值，否则返回b的计算值</td></tr><tr><td>not</td><td>逻辑非运算，not a，如果a为 True，返回 False，反之，则返回True</td></tr></tbody></table><p>对于<code>and</code>运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 <code>Python</code>按照下面的规则执行<code>and</code>运算：</p><ul><li>如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时<code>and</code>会把左边表达式的值作为最终结果。</li><li>如果左边表达式的值为真，那么最终值是不能确定的，<code>and</code>会继续计算右边表达式的值，并将右边表达式的值作为最终结果。</li></ul><p>对于<code>or</code>运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以<code>Python</code>按照下面的规则执行<code>or</code>运算：</p><ul><li>如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时<code>or</code>会把左边表达式的值作为最终结果。</li><li>如果左边表达式的值为假，那么最终值是不能确定的，<code>or</code>会继续计算右边表达式的值，并将右边表达式的值作为最终结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;Python&quot;</span>)</span><br><span class="line">Pyhton</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">18.5</span> <span class="keyword">or</span> <span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="number">18.5</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 在<code>Python</code>中，<code>and</code>和<code>or</code>不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。另外，<code>and</code>和<code>or</code>运算符会将其中一个表达式的值作为最终结果，而不是将<code>True</code>或者<code>False</code>作为最终结果。</p><h3 id="2-7-位运算符"><a href="#2-7-位运算符" class="headerlink" title="2.7 位运算符"></a>2.7 位运算符</h3><p>位运算符把数字看作二进制进行计算。Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13，二进制格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = 0011 <span class="number">1100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">0000</span> <span class="number">1101</span></span><br></pre></td></tr></table></figure><table class="reference"><tbody><tr><th>运算符</th><th>描述</th><th>实例</th></tr><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td> (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td> 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td> (a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1 </td><td> (a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td> 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。<span class="marked">~x</span> 类似于 <span class="marked">-x-1</span></td><td> (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由 <span class="marked">&lt;&lt;</span> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td><td> a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把"&gt;&gt;"左边的运算数的各二进位全部右移若干位，<span class="marked">&gt;&gt;</span> 右边的数字指定了移动的位数 </td><td> a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><p><strong>温馨提示：</strong> 由于移位运算的速度很快，在程序中遇到表达式乘以或除以2的n次幂的情况时，一般采用移位运算来代替。</p><h3 id="2-8-其他运算符"><a href="#2-8-其他运算符" class="headerlink" title="2.8 其他运算符"></a>2.8 其他运算符</h3><p><strong>1、成员运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td></tr></tbody></table><p><strong>2、身份运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>is</td><td>判断两个标识符是不是引用自一个对象，返回True&#x2F;False</td></tr><tr><td>is not</td><td>判断两个标识符是不是引用自不同对象，返回True&#x2F;False</td></tr></tbody></table><blockquote></blockquote><p><code>is</code>判断两个对象是否相同，就是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了。 <code>==</code>用于判断引用变量的值是否相等。</p><h3 id="2-9-运算符优先级"><a href="#2-9-运算符优先级" class="headerlink" title="2.9 运算符优先级"></a>2.9 运算符优先级</h3><p>优先级高的优先计算，优先级一样的从左往右依次计算(此为3.8官方文档数据)</p><table><thead><tr><th>优先级</th><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>(experession,…)，[expression,…]，{key:datum,…}，{expression,…}</td><td>绑定或元组显示,列表显示,字典显示,设置显示</td></tr><tr><td>2</td><td>x[index]，x[index:index]，f(arguments…)，x.attribute</td><td>抽取（下标）切片（寻址段）调用（函数调用），属性引用</td></tr><tr><td>3</td><td>await x</td><td>await表达式</td></tr><tr><td>4</td><td>**</td><td>乘方</td></tr><tr><td>5</td><td>+x，-x，~x</td><td>正，负，按位非 NOT</td></tr><tr><td>6</td><td>*，/，%,//,@</td><td>乘法、除法、取余、整除、矩阵乘</td></tr><tr><td>7</td><td>+,-</td><td>加法与减法</td></tr><tr><td>8</td><td>&lt;&lt;,&gt;&gt;</td><td>移位</td></tr><tr><td>9</td><td>&amp;</td><td>按位与AND</td></tr><tr><td>10</td><td>^</td><td>按位异或XOR</td></tr><tr><td>11</td><td>|</td><td>按位或OR</td></tr><tr><td>12</td><td>&lt;，&lt;=，&gt;，&gt;=，!=，==，in，not in，is，is not</td><td>比较运算，包括成员检测和标识号检测</td></tr><tr><td>13</td><td>not x</td><td>布尔逻辑“非” NOT</td></tr><tr><td>14</td><td>and</td><td>布尔逻辑“与” AND</td></tr><tr><td>15</td><td>or</td><td>布尔逻辑“或” OR</td></tr><tr><td>16</td><td>if–else</td><td>条件表达式</td></tr><tr><td>17</td><td>lambda</td><td>Lambda表达式</td></tr><tr><td>18</td><td>:=</td><td>海象运算符</td></tr></tbody></table><p><strong>温馨提示：</strong> 虽然<code>Python</code>运算符存在优先级的关系，但不推荐过度依赖运算符的优先级，这会导致程序的可读性降低。因此，建议编程时：</p><ul><li>不要把一个表达式写得过于复杂，如果一个表达式过于复杂，可以尝试把它拆分来书写。</li><li>不要过多地依赖运算符的优先级来控制表达式的执行顺序，这样可读性太差，应尽量使用<code>( )</code>来控制表达式的执行顺序。</li></ul><hr><blockquote><p>以上内容仅作为自己学习使用，主要整理自以下Python教程网站：</p><ul><li>C语言中文网Python教程：<a href="http://c.biancheng.net/python/variable/">http://c.biancheng.net/python/variable/</a></li><li>菜鸟教程：<a href="https://www.runoob.com/python/python-variable-types.html">https://www.runoob.com/python/python-variable-types.html</a></li><li>廖雪峰Python教程：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832">https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节气习俗</title>
      <link href="/article/b81b9daf.html"/>
      <url>/article/b81b9daf.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要记录一些重要的节日和节气的注意事项，希望给大家带来好运！</p><span id="more"></span><p>春节，华人最重要的节日，如何过，各地早就约定俗成，无需赘述。简单补充一下，说说一些易行的居家开运小方法，大家可以尝试下图个吉利：</p><ol><li><p>除尘。想必大部分人春节前都会对家里进行清洁，打扫除尘，洗洗涮涮。有个地方千万别漏掉，就是自家的卫生间，要清洁干净。从民俗上说，国内一些地方有敬厕神的习俗，扶桑也有种招财的法术，核心方法是每天在特定时间清理自家厕所，恭敬厕神，则财源滚滚。一些国际金融家在考察创业投资对象，进行实地考察时，对于细节的考察，比较注重两个地方 ，一个是老板的办公室，另一个是公司供内员工使用的厕所的清洁程度。创业之初，老板的办公室小而整洁，可以多少反映出老板务实自信不务虚的价值观，厕所则反映出细微处管理命令的执行力度和老板对生活对员工的态度。把卫生间打扫干净，是很吉利的事情。洋快餐卫生间的清洁程度一直都很高，没少赚国人的钱吧，笑。公司是否有钱途看卫生间，别人家里是否有钱，也可以去他家卫生间瞧瞧，笑。</p></li><li><p>贴福字。大门和最外层窗户的福字是坚决不能倒着贴的，否则福到你家门外就撒泼打滚不进去了，笑。汉字有繁简之分，更有倒正之分，字是有能量的。大门上，窗户上的吉祥画，吉祥话，如福字，都要正着贴。如果想取巧转运，可以讨个吉利：在需要转运的人卧室门上，或者里屋的墙壁，或者床头，倒着贴福字，把福引到需要者身边。自己的办公室内，还有办公桌隔断上，都可以倒着贴福字。</p></li><li><p>春节，是一家人团圆充电的时候，特别是对于千里之外归乡的游子来说，同一个姓氏的族人聚集在一起，抛开烦心事，说一些吉利话，你能感受到温暖安心，在一年更替时，心神安定，对来年的事业健康运势都是一种正能量的补充。祖坟风水好尚能福泽子孙，何况长辈健在时的团圆呢。能使人心安，使人谦卑，多听听长辈的唠叨，去粗取精，对自己的人生也有指导作用。</p></li><li><p>鞭炮。小朋友要注意安全第一，燃放危险程度低的小烟花小鞭炮就好。成年人有条件的自己燃放鞭炮，没条件的可以适当观看别人燃放鞭炮，效果差不多。人在紧张时肾上腺素激增，男性在影院看大片，炮弹轰鸣刀刀见血觉得特过瘾，肾上腺素激增可以使人更积极，更富有朝气，百邪不侵。女孩因为禀赋原因，对动作大片等使人肾上腺激增的东西大都不敢兴趣，过年时可以出去看看放炮的人群，听听炮声。古人没大片看，没摇滚音乐听，但是中国人很聪明，用爆竹声来振发阳气，激荡心神，驱赶鬼神，过年时放炮振发阳气，然后吃饺子吃美食来补充能量，你看，古人多么智慧。如果今年过得郁闷不得志，运气不好，那就出去听听炮声，或者亲手放鞭炮。如果觉得炮声很烦，那就别强迫自己去放鞭炮，特别是岁数大的人，一切以舒适为度。</p></li></ol><p>大年初四治治赖债不还者，即如何讨债。在红纸上写下对方姓名、住址、金额（如有八字更好），再念三遍：遁甲太阴显用！某某人名！速速还我银两。然后烧掉，将灰烬倒在自己住家周边水沟、河流等，实在不行冲在下水道也可以。上述方法在年初四使用最佳，当然此后也可用，注意：可以在使用一次后的七七四九天后再次使用，赖债者不还都难啦。</p><p>太君曰：“四立:是立春、立夏、立秋、立冬，四绝:为春分、夏至、秋分、冬至。”碰到这种季节的前后几天，地球轨道上的磁场和电波都会自然震动，影响气流、云层和天气变化。气流快，在季节前变天，曰气盛。气流慢，季节后变天，谓气衰。天气会骤变。患台风、寒潮或高温、暴雨。这个时候人和动物都会随着季节换毛和更新血脉，因此人们在这种时间要顺天循道，不能酗酒乱性、舟车探险，要戒烦戒燥，虚心静气，可防治伤寒流感传染病及慢性病者的旧病复发。避免不必要的人身伤害！遵者平安长寿。</p><p>立春这天“阳和起蛰，品物皆春”，过了立春，万物复苏生机勃勃，一年四季从此开始。</p><p>躲春，中国命理学认为，立春这一天，黄赤夹角应该是315度，由于磁场和气场的缘故，通常会比较乱，无论是家中还是办公室，容易招惹口舌事非。因此要进行躲春，否则一年内可能都非常不顺利。躲春这一天不宜搬迁、看望病重患者及参加丧事等，以免招惹晦气，影响一整年的运气。不妄动、不争论，乐呵呵的度过这一天。</p><p>古代有一个传说：立春快到来的时候，县官会带着本地的知名人士去土地里挖一个坑，然后把羽毛、鸡毛等轻物质放在坑里，等到了某个时辰，坑里的羽毛和鸡毛会从坑里飘上来，这个时刻就是立春时辰，开始放鞭炮庆祝，预祝明年风调雨顺、五谷丰登。</p><p>立春日祈福：找出自己年柱上之在自己三合的生肖， 三合的时辰(申子辰、已酉丑、寅午戍、亥卯未)【如猴生肖者， 可在子时或辰， 在子或辰位】，三合的方位，用锤敲墙或地三下，待土地公公感灵遂通，为你开天门，接福增运！<br>三合方位：东【卯兔】；南【午马】；西【酉鸡】；北【子鼠】。 东北偏东【寅虎】；西南偏西【申猴】；东南偏南【巳蛇】。西北偏北【亥猪】。 东南偏东【辰龙】；西北偏西【戌狗】；东北偏北【丑牛】；西南偏南【未羊】。</p><p><strong>二月二龙抬头、剃龙头</strong></p><p>民间普遍认为在这一天剃头，会使人红运当头、福星高照，因此，民谚说“二月二剃龙头，一年都有精神头”。孩子要“剃喜头”，保佑健康成长，长大后出人头地；大人要“剃龙头”辞旧迎新，希望带来好运。要是准备理髮，得早点去排队！</p><ul><li>四离指春分、秋分、夏至、冬至的前一天，称为离日。</li><li>四绝指立春、立夏、立秋、立冬的前一天，叫做绝日。</li></ul><p>碰到这种季节的前后几天，地球轨道上的磁场和电波都会自然震动，影响气流、云层和天气变化。气流快，在季节前变天，曰气盛。气流慢，季节后变天，谓气衰。天气会骤变。患台风、寒潮或高温、暴雨。这个时候人和动物都会随着季节换毛和更新血脉，因此人们在这种时间要顺天循道，不能酗酒乱性、舟车探险，要戒烦戒燥，虚心静气，可防治伤寒流感传染病及慢性病者的旧病复发。</p><p><strong>春分，这几天不宜劳累、熬夜等</strong></p><ul><li>春分、秋分、夏至、冬至的前一天，在术数上叫做“离日”。 </li><li>立春、立夏、立秋、立冬的前一天，叫做“绝日”。</li><li>按玄学的说法，四离日和四绝日，为四季相交，节令转移阴阳杂乱之时。</li></ul><p><strong>立夏，节气前后不宜熬夜酗酒等</strong></p><p><strong>端午节和一些禁忌</strong></p><p>端午节左右不要让小孩随便下水或接近水源的地方。</p><p>五月将至，农历五月俗称毒月，其中九日为伤身损气耗精元之日，分别为五月初五、初六、初七、十五、十六、十七、二五、二六、二七，其中端午为九毒日之首，故这一天民间有喝雄黄酒、插艾草等避邪驱毒的仪式。中国的每一个传统节日，都寓含着古德先贤智慧经验的传承以及先人对后人的无尽慈爱！</p><p>农历五月 农历五月俗称毒月。其中，五月初五、初六、初七、十五、十六、十七以及二五、二六、二七，此九天为“天地交泰九毒日”；“十四”为天地交泰日，一共十天。这十天内，务必端容肃己，严禁杀生，行淫，否则严重伤身损气耗精元。五月俗称“恶月”。君子应节制嗜欲，食物清淡，减少酸味，增加苦味，益肝补肾。此时节应静养，与自然和谐平定心气。天地主气交合及造化万物之辰，最宜戒酒色禁忌。</p><p>端午节午时：农历五月初五（从中午十一点到中午的十三点，而正午则是十二点）从井里打的水</p><ul><li>无根午时水：端午午时下雨接的雨水。</li><li>解暑午时水：用黄瓜的芯加盐泡成解暑的午时水。</li></ul><p>午时水用三种功效，一是饮用，泡茶或者制成解暑的午时水，甚至是制成酒；二是洗澡；三是清扫；人们用汲来的午时水加入一些白酒和少许雄黄粉(中药)，用以喷洒房间庭院，或洗澡、洗脸、洗手脚。传说，喝过午时水的都能活过九十八岁；用午时水加雄黄洗澡，那一年入夏不会生痱子，外出不会被蛇咬</p><p><strong>夏至</strong></p><p>要了解自己的旺运方位</p><ul><li>属相为鼠、牛、鸡的朋友，夏季旺运方位在西方</li><li>属相为蛇、马、猪的朋友，夏季旺运方位在东方</li><li>属相为龙、羊、狗的朋友，夏季旺运方位在南方</li><li>属相为虎、兔、猴的朋友，夏季旺运方位在北方</li></ul><p>夏天已到，此时，是喝姜枣茶养身最好的时候！养身方法：每年从立夏那一天开始，每天早上喝生姜红枣茶，一直喝到入伏的头一天。</p><p>三伏晒：【三伏晒太阳祛病法】三伏当天的上午九点到下午三点(9点～11是巳时，中午11点～1点是午时、1点～3点是未时)，赤身在烈日中暴晒，有点像欧美流行的裸身日光浴，但是古人发现，三伏这一天做足日光浴，不但能祛男男女女的陈年痼疾，也可医新病，效果之好，甚至痊愈除根。</p><p>立秋：用红纸书写“今日立秋，百病皆休”字样贴于墙上（入户门一侧的墙上即可），以起到预防疾病之目的。<br>立秋当天最好要避免男女同房做爱，否则容易产生情绪波动、抑郁的情绪，因为立秋阳气渐衰、阴气渐长，会伤及阳气，最终导致运势受损。有些地方立秋当日要避免洗澡、以及在田间行走，否则不利。</p><p>鬼节，农历七月阎罗打开地狱放出鬼，八月初关闭。<br>有些事情在这个月能不做最好不要做，例如搬家，去河边海边游泳，去医院探望病人，看尸体，参加白事，对视尸体的眼睛，说脏话，在野外树林里便溺，在野外树林河边海边的车内做那种事情<br>本月给鬼施食，捐寿盒，都能获得回报。</p><p>七月初一全素食，七月七日凌晨1点前不睡觉，十月十五这一天很少说话，基本不说话</p><p>七夕的时候，别忘了多喝水，参与体内循环代谢。</p><p>处暑的水好，身体有恙的多喝点水治病，开水生水井水湖水都行。喝白水，越早喝越好 参与体内循环代谢</p><p>伏天是养阳气的时候，空调温度不要太低，不要贪凉，在能承受的范围内多出一些汗，增强大脑对核心温度的调节能力，有助于健康。</p><p>秋冬：人的血压在秋季会逐渐升高，使体内气血更高效的到达全身各处以应对即将到来的寒冬，吃同样的东西，这个季节身体吸收的最快，所以秋冬之交养生效果最佳，是进补的季节。</p><p>【九九重阳禁忌】今日乃道佛二家一年难得几次的宜开光加持之日！<br>今日娃子们当尽孝心，忌对外送物！不可嫁娶，不可参加婚宴，不可兴土木！切记。桑拓木，满执位，冲马煞南！娃娃们要理发做头发的，今天最好不过了，除晦气煞气也！今日切忌不可安床！不可动家里床位！还有，今日万万不可入不认识的人的家中！大凶！</p><p>延寿的方法是每天吃饭必有一顿白米饭，一天吃的食物种类不会少于十种，每逢七月初一全素食，七月七日凌晨1点前不睡觉，十月十五这一天很少说话，基本不说话。</p><p><strong>拜斗</strong></p><p><strong>冬至提醒</strong></p><p>明年一年的身体健康与否，取决于你今晚子时体内阳气生发得是否旺盛，所以今晚万万不可熬夜，白天宜温补。19点后尽量少吃东西少喝水，23-5点最好不要小便，以免走失子时刚刚生发的弱阳。</p><p>冬至前后，节令转移，磁场、电波自然震动，要保持良好的心境，戒烦戒燥。<br>冬至温补羊肉为佳。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 生活常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节气 </tag>
            
            <tag> 生活习俗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个时代“寒门再难出贵子”</title>
      <link href="/article/98fdd8aa.html"/>
      <url>/article/98fdd8aa.html</url>
      
        <content type="html"><![CDATA[<p>最近刚读了天涯上的一篇帖子讨论这个时代为什么寒门再难出贵子，里面很多观点可以让自己反思为什么总是迷茫和受挫，从而更好地前行，愿我们每个人都可以跳出自我局限，从而成长为更好的自己。</p><span id="more"></span><p>读完感受，一个人的出身是影响发展的很重要的因素，但不是唯一的，下面的摘录：</p><p>在一个物欲横流的时代，当金钱决定一切，成为人得终极信仰的时候，这时候也是“门阀”，阶层相应出现的年代。马克思说过：阶级一旦形成，那么处于各个阶级的人想打破阶级的鸿沟壁垒几乎不可能。</p><p>家庭条件差些大多都是有些狡黠的，做事心理有很大的计算过程，这个计算过程对父母来讲是好事，比较节省，但是对自己发展，交友，人生态度是一个很大的思维框架，往往会跟随自己的一生……</p><p>如何活是一个问题，无非就是轻松简单点，安稳点，保障高点，很多孩子也包括当年的楼主在学校的时候，觉得心比天高，但是到了社会上摔打几年，有发现这个江山真是铁打得，社会不是那么好混的，很重要的一点在即将毕业将要选择进行什么工作的时候，真的需要精心来思虑一段时间，包括我们这些成年的面临跳槽，同样需要认真的去思考，指导这个思考最重要的就是一定要有自知之明，一定要明白自己的条件，自己的能力，自己的背景，这里面不能有半点幻想的成分……</p><p><strong>人生很有意思，你怎么对它，它怎么对待你，你拿人生开玩笑，不认真，人生立马偿还你一个你的人生是笑话，你如果选择不认真，那么立马人生就对你不认真，其实人生在某种可控范围内是可以规划的。</strong></p><p>一个人也许一辈子两家事最重要。第一：是去找一份工作，一份待遇较好，有发展前途的工作。第二，是选择一个他或者她结婚。。。在这两项中，告诉你，工作不会抛弃你，工作能养活你，让你活着不用靠人施舍，当你的工作处理好了，婚姻是一个自然的过程的，但是如果你要是想着先成家，再立业，我会告诉你，我身边有朋友因为颠倒了顺序现在离婚了。</p><p>人是靠本能和欲望活着的，婚姻是一个相互交换，相互承诺的本质，构成是两个人，这里而是有利益衡量的，如果婚姻的天平不是那么平衡了，要么一个人永远受气，要不不受气就是分手。我们的社会已经不再是30年前，结婚了就是一辈子，了解这些，做好自己，婚姻也差不到那里……</p><p>学习的真正作用——储备知识，锻炼思维，进而增强能力，获取更多你身边人不具备，不会，不懂得知识。因为是这样你可以从做父母，身边人，周围人做不了的事情，你积累的越多的知识，掌握越多的思维技巧，你就会脱颖而出。遗憾的是多数家长理解不了学习的目的是淘汰不学习的，学习好的目的是淘汰学习不好的。教育，小学，初中，高中，大学，研究生，一级一级实际上是个完美的淘汰制度。</p><p>十几年的学习的真正作用——储备知识，锻炼思维，进而增强能力。真正的目的在于建立良好的思维习惯，而不是学习得了多少分，上了哪个学校……</p><p>多数人在为了一份薪水，或者为了自己创业那点小生意，起早贪黑，可是他们真的很卖力，真的很贫穷，为什么还是那么艰辛？其实重要的是，忽略了努力是需要有方向的，需要有指导的，如果在一个错误的思维指导下，也许累死你的努力换来的就是一个只能糊口微薄收入，谈何改变自己，付出真的就有回报吗？前提是你的付出是正确的付出，要不在努力付出自己也只是一个机器，一个日复一日损耗生命力换取微薄薪资挣扎在生存线的悲哀一族。</p><p>有多少律师在自己家办公？有多少律师满处散发名片？有多少律师在苦苦挣扎？这些人不努力吗？这些人在学校也是好学生，踏入社会也玩命的努力，但是为什么还过得那么艰辛？是因为什么？是没有跟对人，是没有做对事，绝对不能说他们不努力！也恰恰因为这样，“努力就有回报”成了一个骗局。因为努力就有回报是有前提条件的，前提条件，是要跟对人，是要人给你机会，是要做对事，如果忽略了这些前提，努力不但没有回报，努力会让你让越走越错，越努力越限制。正如著名拿破仑的论点：“愚蠢而又勤奋的人，绝对不能任用。”什么是愚蠢的人？要是真的愚蠢就不烦恼了，拿破仑的愚蠢是有着错误思维的那群人，一开始就忽略了正确的思维，在那里抱残守缺坚守着，还在这个方向上一直勤奋耕耘，除了错上加错，没有别的任何结局。跟对人，做对事，在一个完善的思维才有可能使得努力成为回报，要不然真的是抱残守缺成了愚蠢而又勤奋，那种就是绝对会失败，绝对不会被拿破仑任用的那群人。</p><p>家庭才是性格的养成地。思维的形成，做人做事的外延内涵的思维框架一直有着家庭成长环境的烙印。性格决定命运，思维决定发展，人的机遇决定一切。</p><p>为每个成功人士，每个成功机会都是有着当初的时代背景，社会发展机遇，和个人机遇作为强力辅助形成了这是优秀人物的人生辉煌。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 个人成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天涯论坛 </tag>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础篇（一）-- 十分钟学会基础语法</title>
      <link href="/article/175d115.html"/>
      <url>/article/175d115.html</url>
      
        <content type="html"><![CDATA[<p>Python 作为现在特别流行的编程语言，本文将带你走进 Python 的世界，首先介绍 Python 的语言特性以及如何学号 Python 编程，接着讲解 Python 基本编程，从而让我们实现简单的交互式编程和脚本式编程。</p><span id="more"></span><h2 id="1-Python简介"><a href="#1-Python简介" class="headerlink" title="1 Python简介"></a>1 Python简介</h2><h3 id="1-1-精通一门编程语言的必要性"><a href="#1-1-精通一门编程语言的必要性" class="headerlink" title="1.1 精通一门编程语言的必要性"></a>1.1 精通一门编程语言的必要性</h3><p>随着信息技术的发展，计算机技术应用越来越广泛，目前主流领域如下：</p><ul><li><font color=#9900CC><strong>科学计算：</strong></font>是现代计算机应用的一个重要领域；</li><li><font color=#9900CC><strong>数据处理：</strong></font>用计算机来加工、管理与操作任何形式的数据资料，主要包括数据的采集、转换、分组、组织、计算、排序、存储、检索等；</li><li><font color=#9900CC><strong>人工智能：</strong></font>用计算机来模仿人的智能，使计算机具有识别语言、文字、图形和进行推理、学习以及适应环境的能力；</li><li><font color=#9900CC><strong>网络应用：</strong></font>在信息共享、文件传输、电子商务等领域迅速发展。</li><li><font color=#9900CC><strong>辅助技术：</strong></font>用计算机辅助进行工程设计、产品制造、性能测试，可以使设计工作半自动化或自动化；</li><li><font color=#9900CC><strong>过程控制：</strong></font>用计算机作为控制部件对单台设备或整个生产过程进行控制；</li></ul><h3 id="1-2-Python是什么"><a href="#1-2-Python是什么" class="headerlink" title="1.2 Python是什么"></a>1.2 Python是什么</h3><p><strong>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</strong> Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字和一些标点符号，它具有比其他语言更有特色的语法结构。</p><ul><li><p>Python 是一种 <font color=#9900CC><strong>解释型语言：</strong></font>开发过程中没有了编译这个环节，类似于PHP和Perl语言；</p></li><li><p>Python 是 <font color=#9900CC><strong>交互式语言：</strong></font>可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码；</p></li><li><p>Python 是 <font color=#9900CC><strong>面向对象语言：</strong></font>Python支持面向对象的风格或代码封装在对象的编程技术；</p></li><li><p>Python 是 <font color=#9900CC><strong>初学者的语言：</strong></font>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到浏览器再到游戏。</p></li></ul><blockquote><p> <font color=#9900CC><strong>编译型语言：</strong></font>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。<br> <font color=#9900CC><strong>解释型语言：</strong></font>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。<br>想要了解更多，请参考：<a href="http://c.biancheng.net/view/4136.html">编译型语言和解释型语言的区别</a></p></blockquote><h3 id="1-3-Python语言特点"><a href="#1-3-Python语言特点" class="headerlink" title="1.3 Python语言特点"></a>1.3 Python语言特点</h3><p><strong>1、面向对象</strong></p><p><strong>Python语言具有很强的面向对象特性，简化了面向对象的实现，它消除了保护类型、抽象类、接口等面向对象的元素，使得面向对象的概念更容易理解。</strong></p><p><strong>2、内置的数据结构</strong></p><p>Python提供了一些内置的数据结构，这些数据结构实现了类似Java中集合类的功能。内置数据结构的出现简化了程序设计。<strong>Python的数据结构包括元组、列表、字典、集合等。</strong> 元组相当于“只读”的数组，列表可以作为可变长度的数组使用，字典相当于Java中的HashTable类型。</p><p><strong>3、简洁</strong></p><p>Python语言的关键字比较少，它没有分号、begin、 end等标记，代码块使用空格或Tab键缩进的方式来分隔。此外，<strong>Python代码简洁、短小、易于阅读。</strong> Python简化了循环语句，即使程序结构很复杂也能快速读懂。</p><p><strong>4、健壮</strong></p><p><strong>Python提供了异常处理机制，能捕获程序的异常情况。</strong> 此外Python的堆栈跟踪对象能够指出程序出错的位置和出错的原因。异常机制能够避免不安全退出的情况，同时能够帮助程序员调试程序。</p><p><strong>5、跨平台</strong></p><p>Python会先被编译为与平台相关的二进制代码，然后再解释执行。这种方式类似于Java，但Python的执行速度提高了。<strong>Python编写的应用程序可以运行在Windows、Unix、Linux等不同的操作系统上。</strong> 在一种操作系统上编写的Python代码只需做少量修改，就可移植到其他的操作系统上。</p><p><strong>6、可扩展</strong></p><p>Python是采用C开发的语言，因此可以使用C扩展Python，可以给Python添加新的模块、新的类。同时Python可以嵌入C、C++语言开发项目中，使程序具备脚本语言的特性。因此，<strong>Python 又常被称为“胶水”语言。</strong></p><p><strong>7、动态性</strong></p><p>Python 与JavaScript、PHP、Perl等语言类似，<strong>它不需要另外声明变量、直接赋值即可创建一个新的变量。</strong></p><p><strong>8、强类型语言</strong></p><p>Python的变量创建后会对应一种类型，它可根据赋值表达式的内容决定变量的类型。Python在内部建立了管理这些变量的机制，不同类型的变量需要类型转换。</p><p><strong>9、应用广泛</strong></p><p><strong>Python语言应用于数据库、网络、图形图像、数学计算、Web开发、操作系统扩展等领域。</strong> 有许多第三方库支持Python，例如：PIL（图像处理库）、Tkinter（创建图形用户界面）、Django（交互式网站）、Pygame（2D动画）、SCIPy（科学计算）、Twisted（网络编程）等。</p><p>Python的以上特性使得软件的代码大幅度减少，开发任务进一步简化，我们编程的关注点不再是语言特性，而是程序所要实现的任务。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2fy4k52udl0k.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2fy4k52udl0k.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" width="80%"><h3 id="1-4-Python的应用领域"><a href="#1-4-Python的应用领域" class="headerlink" title="1.4 Python的应用领域"></a>1.4 Python的应用领域</h3><p>Python 通常应用于编写下述应用程序：</p><ul><li><font color=#9900CC><strong>脚本</strong></font>——这些简短的程序自动执行常见的管理任务，如在系统中新增用户、将文件上传到网站、在不使用浏览器的情况下下载网页等。</li><li><font color=#9900CC><strong>网站开发</strong></font>——作为快速创建动态网站的工具，Django、Bottle和Tope等Python项目深受开发人员欢迎。</li><li><font color=#9900CC><strong>文本处理</strong></font>——Python在字符串和文本文件处理方面提供了强大的支持。</li><li><font color=#9900CC><strong>图像处理</strong></font>——如PIL库(目前已不再维护，取而代之的有Pillow)科学计算。网上有许多卓越的Python科学计算库，提供了用以统计、数学计算和绘图的函数。如：NumPy 。</li><li><font color=#9900CC><strong>教育</strong></font>——鉴于Python简洁实用，越来越多的学习将其作为第一门编程教学语言。</li></ul><p>Python的主要运用领域有：</p><ul><li><font color=#9900CC><strong>云计算：</strong></font>云计算最热的语言，典型的应用OpenStack；</li><li><font color=#9900CC><strong> WEB应用开发：</strong></font>许多优秀的WEB框架，许多大型网站是Python开发、YouTube、Dropbox、Douban……典型的Web框架包括：Django、flask、TurboGears、web2py 等等；</li><li><font color=#9900CC><strong>科学计算和人工智能：</strong></font>Python 在人工智能领域内的机器学习、神经网络、深度学习等方面，都是主流的编程语言， 此外，Python擅长进行科学计算和数据分析，支持各种数学运算，可以绘制出更高质量的 2D 和 3D 图像；</li><li><font color=#9900CC><strong>自动化运维：</strong></font>系统操作和维护，通常情况下，Python 编写的系统管理脚本，无论是可读性，还是性能、代码重用度以及扩展性方面，都优于普通的 shell 脚本；</li><li><font color=#9900CC><strong>金融：</strong></font>定量交易、金融分析，在金融工程领域，Python使用越来越广泛；</li><li><font color=#9900CC><strong>图形 GUI：</strong></font>PyQT，WXPython，TkInter；</li><li>Python在<font color=#9900CC><strong>网络爬虫、游戏开发、机器人控制编程</strong></font>等领域也有广泛应用。</li></ul><h3 id="1-5-Python编程环境搭建"><a href="#1-5-Python编程环境搭建" class="headerlink" title="1.5 Python编程环境搭建"></a>1.5 Python编程环境搭建</h3><ol><li><p><font color=#9900CC><strong> Window 平台安装 Python：</strong></font>打开浏览器访问：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a> ，点击下载 executable installer，x86 表示是 32 位的安装程序，x86-64 表示 64 位的。详细安装过程，请参考：<a href="http://c.biancheng.net/view/4161.html">http://c.biancheng.net/view/4161.html</a></p></li><li><p><font color=#9900CC><strong>Unix &amp; Linux 平台安装 Python3：</strong></font>打开浏览器访问：<a href="https://www.python.org/downloads/source/">https://www.python.org/downloads/source/</a>，选择适用于 Unix&#x2F;Linux 的源码压缩包，然后解压缩并安装。详细安装过程，请参考：<a href="http://c.biancheng.net/view/4162.html">http://c.biancheng.net/view/4162.html</a></p></li><li><p><font color=#9900CC><strong>MAC平台安装Python3：</strong></font>打开浏览器访问：<a href="https://www.python.org/downloads/mac-osx/">https://www.python.org/downloads/mac-osx/</a>，下载最新版安装即可。</p></li></ol><p>安装完成之后，需要<font color=#9900CC><strong>配置环境变量，</strong></font>详细过程可以参考：<a href="https://www.runoob.com/python3/python3-install.html">Python3 环境搭建</a></p><p>此外，还推荐下载其他IDE进行Python编程，IDE 是 Intergreated Development Environment 的缩写，中文称为集成开发环境，用来表示辅助程序员开发的应用软件。换言之，<strong>集成开发环境就是一系列开发工具的组合套装。</strong> 一般情况下，程序员可选择的 IDE 类别是很多的，比如说，用 Python 语言进行程序开发，既可以选用 Python 自带的 IDLE，也可以选择使用 PyCharm 和 Notepad++ 作为 IDE。</p><ul><li>PyCharm下载和安装教程（包含Python解释器）：<a href="http://c.biancheng.net/view/5804.html">http://c.biancheng.net/view/5804.html</a></li><li>Python Eclipse+PyDec下载和安装教程：<a href="http://c.biancheng.net/view/5810.html">http://c.biancheng.net/view/5810.html</a></li><li>Python VS Code下载和安装教程：<a href="http://c.biancheng.net/view/5813.html">http://c.biancheng.net/view/5813.html</a></li></ul><h3 id="1-6-Python学习"><a href="#1-6-Python学习" class="headerlink" title="1.6 Python学习"></a>1.6 Python学习</h3><p>下面推荐几篇内容不错的关于Python学习路线和不同方向的进阶教程，有时间可以对照一下，看看自己还有多长的路要走。</p><ol><li><a href="https://blog.csdn.net/u014044812/article/details/88079011?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161843724916780261926748%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161843724916780261926748&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-88079011.pc_search_result_hbase_insert&utm_term=python&spm=1018.2226.3001.4187">Python学习路线（2021修正版）</a></li><li><a href="https://blog.csdn.net/xufive/article/details/102993570?ops_request_misc=&request_id=&biz_id=102&utm_term=python&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-102993570.pc_search_result_hbase_insert&spm=1018.2226.3001.4187">致Python初学者</a></li><li><a href="https://blog.csdn.net/luanpeng825485697/article/details/78347433?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161843724916780271586245%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161843724916780271586245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-9-78347433.pc_search_result_hbase_insert&utm_term=python&spm=1018.2226.3001.4187">python系列文章(基础，应用，后端，运维，自动化测试，爬虫，数据分析，可视化，机器学习，深度学习系列内容)</a></li><li><a href="https://blog.csdn.net/weixin_44318830/article/details/103739987?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161843724916780271586245%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161843724916780271586245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-18-103739987.pc_search_result_hbase_insert&utm_term=python&spm=1018.2226.3001.4187">全网最全Python学习路线图+14张思维导图</a></li></ol><hr><h2 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2 基础语法"></a>2 基础语法</h2><h3 id="2-1-标识符"><a href="#2-1-标识符" class="headerlink" title="2.1 标识符"></a>2.1 标识符</h3><p>标识符主要作用就是作为变量、函数、类、模块以及其他对象的名称，<strong>Python 中标识符的命名不是随意的，而是要遵守一定的命令规则，</strong> 如下：</p><ol><li>标识符对大小写敏感，且第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符不能和 Python 中的保留字相同。</li><li>标识符中不能包含空格、@、% 以及 $ 等特殊字符。</li></ol><blockquote><p>在Python中，以下划线开头的标识符有特殊含义，如下</p><ul><li>以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；</li><li>以双下划线开头的标识符（如__add）表示类的私有成员；</li><li>以双下划线作为开头和结尾的标识符（如 __init__），是专用标识符。<br>综上，除非特定场景需要，应避免使用以下划线开头的标识符。</li></ul></blockquote><p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了，但我们应尽量避免使用汉字作为标识符，容易遇到奇葩的错误。</p><blockquote><p>不同场景中的标识符，其名称也有一定的规范可循，具体如下：</p><ul><li>当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register 等。</li><li>当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 com.mr、com.mr.book 等。</li><li>当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。</li><li>模块内部的类名，可以采用 “下划线+首字母大写” 的形式，如 _Book；</li><li>函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；</li><li>常量命名应全部使用大写字母，单词之间可以用下划线分割；</li></ul></blockquote><h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h3><p>关键字即保留字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> 开发程序时，不能将保留字作为变量、函数、类、模块和其他对象的名称来使用。在<code>Python</code>中，所有保留字区分大小写。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>为了规范页面编码，方便他人了解文件所用编码，建议在文件中使用中文编码声明注释。默认情况下，<strong>Python3源码文件以“可变长编码”的UTF-8编码，所有字符串都是unicode字符串。</strong> UTF-8编码把一个<code>Unicode</code>字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。了解更多，可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896">ASCII、GB2312、Unicode、UTF-8编码</a><br>在Linux下为源码文件指定编码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><h3 id="2-3-代码规范"><a href="#2-3-代码规范" class="headerlink" title="2.3 代码规范"></a>2.3 代码规范</h3><p><strong>1、注释</strong></p><p>注释（Comments）用来向用户提示或解释某些代码的作用和功能，它可以出现在代码中的任何位置。Python 解释器在执行代码时会忽略注释，不做任何处理，就好像它不存在一样。Python中单行注释以 <code>#</code> 开头，多行注释可以用多个<code>#</code>，也可以使用<code>&#39;&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>) <span class="comment"># 第二个注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第三个注释</span></span><br><span class="line"><span class="string">第四个注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第五注释</span></span><br><span class="line"><span class="string">第六注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>温馨提示：</strong> Python 多行注释不支持嵌套。添加注释时，一定要有意义，即注释能充分解释代码的功能及用途。注释除了可以解释代码的功能与用途，也可以用于临时注释不想执行的代码。</p><p><strong>2、行与缩进</strong></p><p><code>Python</code>最具特色的就是使用缩进来表示代码块，不需要使用大括号<code>&#123; &#125;</code>。<code>Python</code>对代码缩进要求非常严格，同一级别的代码块缩进必须相同。如果不采用合理的代码缩进，将抛出<code>SyntaxError</code>异常。<strong>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数，通常情况下是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。</strong> 示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。将首行及后面的代码组称为一个子句(clause)。</p></blockquote><p><strong>3、多行语句</strong></p><p>Python通常是一行写完一条语句，但如果语句很长，我们可以使用<strong>右反斜杠（\）</strong> 来实现多行语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">item_two + \</span><br><span class="line">item_three</span><br></pre></td></tr></table></figure><p>在[]，{}，或（）中的多行语句，不需要使用反斜杠（\），例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math; <span class="built_in">print</span>(math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p><strong>4、空行</strong></p><p><strong>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</strong></p><p>空行与代码缩进不同，空行并不是<code>Python</code>语法的一部分。书写时不插入空行，<code>Python</code>解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><blockquote><p>Python 采用 <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。下面列出PEP 8 中初学者应严格遵守的一些编码规则：</p><ol><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块。</li><li>不要在行尾添加分号，也不要用分号将两条命令放在同一行。</li><li>建议每行不超过 80 个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠 \ 进行连接。（例外：导入模块的语句过长；注释里的URL）</li><li>使用必要的空行可以增加代码的可读性，通常在顶级定义（如函数或类的定义）之间空两行，而方法定义之间空一行，另外在用于分隔某些功能的位置也可以空一行。</li><li>通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。</li><li>应该避免在循环中使用“+”和“&#x3D;”运算符累加字符串。这是因为字符串是不可变的，这样做会创建不必要的临时对象。推荐将每个子字符串加入列表，然后在循环结束后使用<code>join()</code>方法连接列表。</li><li>适当使用异常处理结构提高程序容错性，但不能过多依赖异常处理结构，适当的显式判断还是必要的。</li></ol></blockquote><p><strong>5、命名规范</strong></p><ul><li>模块名尽量短小，并且全部使用小写字母，可以使用下划线分隔多个字母。例如，<code>game_main</code>、<code>game_register</code>、<code>bmiexponent</code>都是推荐使用的模块名称。</li><li>包名尽量短小，并且全部使用小写字母，不推荐使用下划线。例如，<code>com.mingrisoft</code>、<code>com.mr</code>、<code>com.mr.book</code>都是推荐使用的包名称，而<code>com_mingrisoft</code>就是不推荐的。</li><li>类名采用单词首字母大写形式(即<code>Pascal</code>风格)。例如，定义一个借书类，可以命名为BorrowBooke。</li><li>模块内部的类采用下划线“_”+<code>Pascal</code>风格的类名组成。例如，在<code>BorrowBook</code>类中的内部类，可以使用<code>_BorrowBook</code>命名。</li><li>函数、类的属性和方法的命名规则同模块类似，也是全部使用小写字母，多个字母间用下划线“_”分隔。</li><li>常量命名时全部使用大写字母，可以使用下划线。</li><li>使用单下划线“_”开头的模块变量或者函数是受保护的，在使用<code>from xxx import *</code>语句从模块中导入时这些变量或者函数不能被导入。</li><li>使用双下划线“_”开头的实例变量或方法是类私有的。</li></ul><h3 id="2-4-导入模块"><a href="#2-4-导入模块" class="headerlink" title="2.4 导入模块"></a>2.4 导入模块</h3><p>模块就是<code>Python</code>程序，<strong>在<code>Python</code>中导入模块后，我们就可以使用该模块里定义的类、方法或者变量，这样既可以提高代码的可重用性，又可以避免变量冲突，我们通常用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。</strong> 像<code>def</code>一样，<code>import</code> 和 <code>from</code> 是可执行的语句，他们可以出现在 <code>if</code> 中，可以出现在函数中，执行到这些语句的时候才会进行解析，换句话说，被导入的模块和变量名只有在对应的 <code>import</code> 或 <code>from</code> 语句执行后才可以使用。</p><blockquote><p>  模块，可以理解为是对代码更高级的封装，即把能够实现某一特定功能的代码编写在同一个 .py 文件中，并将其作为一个独立的模块，这样既可以方便其它程序或脚本导入并使用，同时还能有效避免函数名和变量名发生冲突。</p></blockquote><p><strong>1、import语句</strong></p><p>既可以一行导入单个模块，也可以一行内导入多个模块，这里以常用的 <code>math</code> 和 <code>random</code> 模块为例，具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math<span class="comment"># 导入math整个模块</span></span><br><span class="line"><span class="built_in">print</span>(math.pi)<span class="comment"># 使用math模块名作为前缀来访问模块中的成员</span></span><br></pre></td></tr></table></figure><p>一次导入多个模块，多个模块之间用逗号隔开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math,random<span class="comment"># 导入math、random两个模块</span></span><br><span class="line"><span class="built_in">print</span>(math.pi)<span class="comment"># 输出π的近似值，十五位小数</span></span><br><span class="line"><span class="built_in">print</span>(random.random())<span class="comment"># 生成一个[0, 1.0)的随机小数</span></span><br></pre></td></tr></table></figure><blockquote><p>Python 不建议一行 import 所有模块，而是推荐用多行 import 来导入模块。更多的是出于操作便利性的原因，与代码本身无关，这样更易于阅读；更易于编辑；更易于维护。</p></blockquote><blockquote><p>import工作方式：Python会在两个地方寻找这个模块，第一个地方是在sys.path（可以运行代码import sysprint(sys.path)查看），一般安装的Python库的目录都可以在sys.path中找到（要将Python的安装目录添加到电脑的环境变量），对于安装好的库，我们直接import即可。第二个地方就是运行文件所在的目录。如果在一个模块的顶层导入，那么它的作用域就是全局的；如果在函数中导入，那么它的作用域是局部的。 如果模块是被第一次导入，它将被加载并执行。</p></blockquote><p><strong>2、import-as</strong></p><p>导入整个模块时，也可以为模块指定别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m<span class="comment"># 导入math整个模块，并制定别名为m</span></span><br><span class="line"><span class="built_in">print</span>(m.pi)<span class="comment"># 使用m模块别名作为前缀来访问模块中的成员</span></span><br></pre></td></tr></table></figure><p>在导入多个模块时，也可以为模块指定别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m, random <span class="keyword">as</span> ran<span class="comment"># 导入math、random两个模块，并为math指定别名m，为random指定别名ran</span></span><br><span class="line"><span class="built_in">print</span>(m.pi)</span><br><span class="line"><span class="built_in">print</span>(ran.random())</span><br></pre></td></tr></table></figure><p><strong>3、from-import</strong></p><p>下面使用 <code>from...import</code> 导入指定成员，即把指定成员导入到当前作用域，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi<span class="comment"># 导入math模块的pi成员</span></span><br><span class="line"><span class="built_in">print</span>(pi)<span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br></pre></td></tr></table></figure><p>导入模块成员时，也可以为成员指定别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi <span class="keyword">as</span> P<span class="comment"># 导入math模块的pi成员，并指定别名P</span></span><br><span class="line"><span class="built_in">print</span>(P)<span class="comment"># 使用导入成员（并指定别名）的语法，直接使用成员的别名访问</span></span><br></pre></td></tr></table></figure><p><code>form...import</code> 导入模块成员时，支持一次导入多个成员，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi, sqrt<span class="comment"># 导入math模块的pi，sqrt成员</span></span><br><span class="line"><span class="built_in">print</span>(pi)<span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br><span class="line"><span class="built_in">print</span>(sqrt(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>一次导入多个模块成员时，也可指定别名，同样使用 as 关键字为成员指定别名，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi <span class="keyword">as</span> P, sqrt <span class="keyword">as</span> sq<span class="comment"># 导入math模块的pi，sqrt成员，并为其指定别名P，sq</span></span><br><span class="line"><span class="built_in">print</span>(P)<span class="comment"># 使用导入成员（并指定别名）的语法，直接使用成员的别名访问</span></span><br><span class="line">paint(sq(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>在使用 <code>from...import</code> 语法时，可以一次导入指定模块内的所有成员（存在不同模块，相同成员名的情况，从而发生冲突，此方式不推荐），如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> *<span class="comment"># 导入math棋块内的所有成员</span></span><br><span class="line"><span class="built_in">print</span>(pi)<span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br><span class="line"><span class="built_in">print</span>(sqrt(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><blockquote><p>只在两种场合下建议使用这样的方法，一个场合是：目标模块中的属性非常多，反复键入模块名很不方便，例如 Tkinter (Python&#x2F;Tk) 和 NumPy (Numeric Python) 模块，可能还有 socket 模块。另一个场合是在交互解释器下，这样可以减少输入次数。</p></blockquote><h3 id="2-5-输入输出"><a href="#2-5-输入输出" class="headerlink" title="2.5 输入输出"></a>2.5 输入输出</h3><p><code>input()</code>是 Python 的内置函数，用于从控制台读取用户输入的内容。**<code>input()</code>函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)<span class="comment"># 数据以字符串的形式返回</span></span><br><span class="line">number1 = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>)<span class="comment"># eval()去掉&quot; &quot;，将字符串转化为有效的表达式，来求值，并返回计算结果，和str()功能刚好相反</span></span><br><span class="line">number2 = val(<span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;val() 函数当识别到非数字，停止读入字符串,字符串中的空格和换行符会被去掉。即如果字符串内有字母或其他非数字字符，</span></span><br><span class="line"><span class="string">val()函数只转换第一个非数字字符之前的数字。当字符串的首字符为非数字时，返回值为0。该函数也可以识别进制符号&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>print()</code> 默认输出是换行的，如果要实现不换行，需要在变量末尾加上 <code>end=&quot; &quot;</code>，输出多个变量时，print() 函数默认以空格隔开多个变量，想要使用不同的分隔符，可以使用缺省参数<code>seq=&#39;:&#39;</code>，可以通过<code>help(&quot;print&quot;)</code>了解更多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;网站：&quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;百度&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment"># str.format()实现字符串格式化，大括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;GitHub&#x27;</span>, <span class="string">&#x27;CSDN&#x27;</span>))<span class="comment"># 括号中的数字用于指向传入对象在format()中的位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你是:%s, %d岁&quot;</span> % (<span class="string">&quot;CSDN&quot;</span>, <span class="number">22</span>)<span class="comment"># % 操作符也可以实现字符串格式化</span></span><br><span class="line"><span class="comment"># 推荐使用str.format()，&#123;&#125;里可以添加可选项：和格式标识符，这样可以对值进行更好的格式化</span></span><br></pre></td></tr></table></figure><blockquote><p>%或者{}都可以看做转换说明符，转换说明符（Conversion Specifier）只是一个占位符，它会被后面表达式（变量、常量、数字、字符串、加减乘除等各种形式）的值代替。</p></blockquote><p><strong>1、%使用</strong></p><center><strong>表1 Python转换说明符</strong></center><table><thead><tr><th>转换说明符</th><th>解释</th></tr></thead><tbody><tr><td>%d、%i</td><td>转换为带符号的十进制整数</td></tr><tr><td>%o</td><td>转换为带符号的八进制整数</td></tr><tr><td>%x、%X</td><td>转换为带符号的十六进制整数</td></tr><tr><td>%e、%E</td><td>转化为科学计数法表示的浮点数（输出e的大小写不一样）</td></tr><tr><td>%f、%F</td><td>转化为十进制浮点数</td></tr><tr><td>%g、%G</td><td>智能选择使用 %f 或 %e 格式</td></tr><tr><td>%c</td><td>格式化字符及其 ASCII 码</td></tr><tr><td>%r</td><td>使用 repr() 函数将表达式转换为字符串</td></tr><tr><td>%s</td><td>使用 str() 函数将表达式转换为字符串</td></tr></tbody></table><p><strong>(1) 整数的输出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%o&#x27;</span> % <span class="number">24</span>)<span class="comment"># 转换为八进制输出</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%d&#x27;</span> % <span class="number">24</span>）</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p><strong>(2) 浮点数的输出</strong></p><ul><li>%f ——默认保留小数点后面六位，例：%.3f，保留3位小数位</li><li>%e ——保留小数点后面六位有效数字，指数形式输出，例：%.3e，保留3位小数位，使用科学计数法</li><li>%g ——在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法，例：%.3g，保留3位有效数字，使用小数或科学计数法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">6.6666</span>)<span class="comment"># 取3位小数</span></span><br><span class="line"><span class="number">6.666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;%.3e&#x27;</span> % <span class="number">1.11</span>)<span class="comment"># 取3位小数，用科学计数法</span></span><br><span class="line"><span class="number">1.110e+00</span></span><br></pre></td></tr></table></figure><p><strong>(3) 字符串输出</strong></p><ul><li>%10s——右对齐，占位符10位</li><li>%-10s——左对齐，占位符10位</li><li>%.2s——截取2位字符串</li><li>%10.2s——10位占位符，截取两位字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%10s&#x27;</span> % <span class="string">&#x27;hello&#x27;</span>)<span class="comment"># 右对齐，取10位，不够则补位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%-10.2s&#x27;</span> % <span class="string">&#x27;hello&#x27;</span>)  <span class="comment"># 左对齐，取10位，并截取两位字符串，并用空格补位</span></span><br></pre></td></tr></table></figure><p><strong>2、format使用</strong></p><p><strong>(1) 位置匹配</strong></p><ul><li>不带编号，即“{}”</li><li>带数字编号，可调换顺序，即“{1}”、“{2}”</li><li>带关键字，即“{key1}”、“{key2}”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; &#123;1&#125; &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>))<span class="comment"># 带数字编号，并打乱顺序</span></span><br><span class="line">hello world hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;key1&#125; &#123;key2&#125; &#123;key1&#125;&#x27;</span>.<span class="built_in">format</span>(key1=<span class="string">&#x27;world&#x27;</span>, key2=<span class="string">&#x27;hello&#x27;</span>))<span class="comment"># 带关键字</span></span><br><span class="line">world hello world</span><br></pre></td></tr></table></figure><p><strong>(2) 格式转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;:b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">2</span>))<span class="comment"># 转换为二进制输出</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;:%&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0.2</span>))<span class="comment"># 将数值乘以100，然后以小数点保留六位格式打印，值后面会有一个百分号</span></span><br><span class="line"><span class="number">20.000000</span>%</span><br></pre></td></tr></table></figure><p><strong>(3) 进阶用法</strong></p><ul><li>指定小数精度和输出宽度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:8.4f&#125;&#x27;</span>.<span class="built_in">format</span>(pi))<span class="comment"># 位置为0，最小宽度为8，小数点后4位；:m.nf表示宽度为m，小数位为n，m和n都可以不指定</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:10s&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Hello&#x27;</span>))<span class="comment"># 输出字符串的宽度至少为10</span></span><br></pre></td></tr></table></figure><ul><li>指定对齐方式<br>&lt;——左对齐，&gt;——右对齐，^——居中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:^10s&#125; and &#123;:&gt;10s&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Github&#x27;</span>, <span class="string">&#x27;CSDN&#x27;</span>))<span class="comment"># 取10位居中，取10位右对齐</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:*^10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;CSDN&#x27;</span>))<span class="comment"># 使用*填充</span></span><br></pre></td></tr></table></figure><p>Python格式化输出，了解更多，请参考：<a href="https://www.cnblogs.com/fat39/p/7159881.html">%用法和format用法</a></p><h3 id="2-6-内建函数"><a href="#2-6-内建函数" class="headerlink" title="2.6 内建函数"></a>2.6 内建函数</h3><p>Python 解释器自带的函数叫做内置函数，这些函数可以直接使用，不需要导入某个模块。</p><blockquote><p>内置函数与标准库函数的对比：内置函数是解释器的一部分，它随着解释器的启动而生效；标准库函数是解释器的外部扩展，导入模块以后才能生效。一般来说，内置函数的执行效率要高于标准库函数。</p></blockquote><p>上一小节的 <code>print()</code> 函数就是内置函数，Python 解释器还提供了更多内置函数，以下按字母表顺序列出：</p><center><strong>表2 Python3 内置函数</strong></center><table class="docutils align-default"><colgroup><col style="width: 20%" /><col style="width: 18%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 22%" /></colgroup><tbody><tr class="row-even"><td><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></td><td><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></td><td><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></td><td><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></td><td><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></td><td><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></td><td><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></td><td><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></td><td><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></td><td><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></td><td><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></td><td><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></td><td><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></p></td><td><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></p></td><td><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></p></td><td><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></p></td><td><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></p></td><td><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></p></td><td><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></p></td><td><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></p></td><td><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></p></td><td><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></p></td><td><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></p></td><td><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></p></td><td><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a></p></td><td><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></p></td><td><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></p></td><td><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></p></td><td><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></p></td><td><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></p></td><td><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></p></td><td><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></p></td><td><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></p></td><td><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></p></td><td><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></p></td><td><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></p></td><td><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></p></td><td><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></p></td><td><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></p></td><td><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></p></td><td><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></p></td></tr><tr class="row-even"><td><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></p></td><td><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></p></td><td><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></p></td><td><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></p></td><td><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></p></td><td><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></p></td><td><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></p></td><td><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></p></td><td><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></p></td></tr></tr><tr class="row-even"><td><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></p></td><td><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></p></td><td><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></p></td><td><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></p></td><td><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></p></td></tr><tr class="row-odd"><td><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></p></td><td><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></p></td><td><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></p></td><td><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></p></td><td></td></tr></tbody></table><p>各个内置函数的具体功能和用法，可以查看：<a href="https://docs.python.org/zh-cn/3/library/functions.html">https://docs.python.org/zh-cn/3/library/functions.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 基本使用</title>
      <link href="/article/6c09ec5e.html"/>
      <url>/article/6c09ec5e.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍 Markdown 基本使用，主要包括文本格式，如标题设置、加粗文本、斜体、下划线、删除线、引用、列表等；接着介绍插入表格、超链接、图片等。</p><span id="more"></span><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1 基本用法"></a>1 基本用法</h2><h3 id="1-1-文本格式"><a href="#1-1-文本格式" class="headerlink" title="1.1 文本格式"></a>1.1 文本格式</h3><p><strong>1. 设置分级标题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><strong>2. 加粗文本</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**我的博客**</span><br></pre></td></tr></table></figure><p><strong>印象笔记</strong></p><p><strong>3. 斜体</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*印象笔记*</span><br><span class="line">**天天向上**</span><br><span class="line">*努力学习*</span><br></pre></td></tr></table></figure><p><em>印象笔记</em><br><strong>天天向上</strong><br><em>努力学习</em></p><hr><p><strong>4. 下划线</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>how are you<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure><p><u>how are you</u></p><p><strong>5. 删除线</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~印象笔记不支持Markdown~~</span><br></pre></td></tr></table></figure><p><del>印象笔记不支持Markdown</del></p><p><strong>6. 添加分割线</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><p>哈哈</p><hr><p>那就这样吧</p><hr><p><strong>7. 引用文本</strong></p><p>文本前加<code>&gt;</code>就可以了，如下所示：</p><blockquote><p>鲁迅说：“横眉冷对千夫指，俯首甘为孺子牛”。</p></blockquote><p><strong>8. 添加符号列表和数字列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何写代码</span><br><span class="line">1. 下载编辑器</span><br><span class="line">2. 找到代码框架</span><br><span class="line">3. 根据语法编写</span><br></pre></td></tr></table></figure><p>如何写代码</p><ol><li>下载编辑器</li><li>找到代码框架</li><li>根据语法编写</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 编辑器正确</span><br><span class="line">- 语法合法</span><br></pre></td></tr></table></figure><ul><li>编辑器正确</li><li>语法合法</li></ul><hr><p><strong>9. 添加待办事项</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第十周工作安排</span><br><span class="line">* [x] 周一上课</span><br><span class="line">* [ ] 周二写作业</span><br><span class="line">* [X] 周三锻炼</span><br></pre></td></tr></table></figure><p>第十周工作安排</p><ul><li><input checked="" disabled="" type="checkbox"> 周一上课</li><li><input disabled="" type="checkbox"> 周二写作业</li><li><input checked="" disabled="" type="checkbox"> 周三锻炼</li></ul><h3 id="1-2-内容插入"><a href="#1-2-内容插入" class="headerlink" title="1.2 内容插入"></a>1.2 内容插入</h3><p><strong>1. 插入链接</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度百科](https://baike.baidu.com/)</span><br></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/">百度百科</a></p><p><strong>2. 插入图片</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![img](https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.nmjr2hxcr5c.webp)</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.nmjr2hxcr5c.webp" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.nmjr2hxcr5c.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>3. 插入表格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|账户类型|免费账户|标准账户|高级账户|</span><br><span class="line">|---|---|---|---|</span><br><span class="line">| 帐户流量 | 60M | 1GB | 10GB |</span><br><span class="line">| 设备数目 | 2台 | 无限制 | 无限制 |</span><br><span class="line">| 当前价格 | 免费 | ￥8.17/月 | ￥12.33/月|</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>账户类型</th><th>免费账户</th><th>标准账户</th><th>高级账户</th></tr></thead><tbody><tr><td>帐户流量</td><td>60M</td><td>1GB</td><td>10GB</td></tr><tr><td>设备数目</td><td>2台</td><td>无限制</td><td>无限制</td></tr><tr><td>当前价格</td><td>免费</td><td>￥8.17&#x2F;月</td><td>￥12.33&#x2F;月</td></tr></tbody></table><p><strong>4. 插入行内代码或代码块</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#python</span><br><span class="line">import turtle</span><br><span class="line">turtle.pensize(50)</span><br><span class="line">turtle.down</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**5. 插入数学公式**</span><br><span class="line"></span><br><span class="line">印象笔记 Markdown 支持绝大多数的 LaTeX 数学公式，行间公式使用`$$f(x)=sin(x)$$`，行内公式使用`$\pmb&#123;A&#125;\in&#123;\mathcal&#123;R&#125;&#125;$`</span><br><span class="line">~~你太菜了~~</span><br><span class="line"></span><br><span class="line">```math</span><br><span class="line">e^&#123;i/pi&#125; +1 = 0</span><br></pre></td></tr></table></figure><p>详细了解，可以参考：<a href="https://www.zybuluo.com/codeep/note/163962#3">Cmd Markdown 公式指导手册</a></p><p><strong>6. 设置目录</strong></p><p>设置之后可以自动根据设置的分级标题来自动生成目录。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@[TOC]</span><br></pre></td></tr></table></figure><h2 id="2-多学几招"><a href="#2-多学几招" class="headerlink" title="2 多学几招"></a>2 多学几招</h2><p>Markdown也支持HTML格式，于是可以设置复杂的文本格式，比如页内跳转、图片大小，图片标题的设置等等</p><p><strong>1. 字体颜色设置</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#9900CC</span> &gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span> /etc/sudoers<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span>       </span><br></pre></td></tr></table></figure><p><font color=#9900CC ><strong> &#x2F;etc&#x2F;sudoers</strong></font>   </p><p><strong>2. 多个空格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. 换行</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. 复杂的表格设计</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span> <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>可分享的(shareable)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>不可分享的(unshareable) <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>不可变的(static) <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/usr(软件放置处)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/etc(配置文件)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/opt(第三方软件)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/boot(开机及内核文件)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>可变动的(variable) <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/var/mail(用户邮件信箱)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>/var/run(程序相关)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/var/news(新闻组)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>/var/lock(文件锁相关)<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th> </th>    <th colspan="3">可分享的(shareable)</th>    <th colspan="3">不可分享的(unshareable) </th>  </tr>  <tr>    <td rowspan="2"><center>不可变的(static) </center></td>    <td colspan="3"><center>/usr(软件放置处)</center></td>    <td colspan="3"><center>/etc(配置文件)</center></td>  </tr>  <tr>    <td colspan="3"><center>/opt(第三方软件)</center></td>    <td colspan="3"><center>/boot(开机及内核文件)</center></td>  </tr>  </tr>  <tr>    <td rowspan="2"><center>可变动的(variable) </center></td>    <td colspan="3"><center>/var/mail(用户邮件信箱)</center></td>    <td colspan="3">/var/run(程序相关)</center></td>  </tr>  <tr>    <td colspan="3"><center>/var/news(新闻组)</center></td>    <td colspan="3"><center>/var/lock(文件锁相关)</center></td>  </tr>  </table>  <p><strong>5. 合并单元格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>6. 给图片添加题注</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> <span class="attr">src</span>=<span class="string">&quot;这里输入图片地址&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;&quot;</span>&gt;</span>这里输入题注<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span> <span class="attr">class</span> = <span class="string">&quot;half&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> =<span class="string">&quot;https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2lqrscnuavs0.webp#pic_left&quot;</span> <span class="attr">width</span> = <span class="string">&quot;32%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/003.748m7etco700.webp#pic_left&quot;</span>  <span class="attr">width</span> = <span class="string">&quot;36%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改width的值就可以修改图片大小。</p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2lqrscnuavs0.webp#pic_left" width = "32%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/003.748m7etco700.webp#pic_right"  width = "36%"></center></p><p><strong>7. 页内跳转</strong></p><p>定义一个锚(id)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用markdown语法：[点击跳转](#jump)</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;jump&quot;</span>&gt;</span>跳转到的地方<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 PicX 创建免费的图床神器</title>
      <link href="/article/a559cbc7.html"/>
      <url>/article/a559cbc7.html</url>
      
        <content type="html"><![CDATA[<p>写博客文章时，图片的上传和存放是一个问题，我们也许会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片。为了解决这些问题，做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床。其返回一个图片的URL，使用 <code>markdown+图片url</code> 的方式写作文章，然后就可以直接使用链接引入图片。最后，整篇文章复制即可，再也不用担心图片的问题了。</p><span id="more"></span><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>PicX，基于 GitHub API 开发的图床管理神器，图片外链使用 jsDelivr 进行全球 CDN 加速。免费、稳定、高效。免下载、免安装，只需一个 <strong>GitHub 账号</strong>，打开网站即可进行配置使用，轻松解决图床难题。</p><p>一共3个步骤就完成设置了</p><ol><li>创建 GitHub 仓库</li><li>获取 GitHub Token</li><li>配置图床</li></ol><p>网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpicx.xpoet.cn%2F" target="_blank" title="https://picx.xpoet.cn/" ref="nofollow noopener noreferrer">picx.xpoet.cn/</a></p><p>仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FXPoet%2Fpicx" target="_blank" title="https://github.com/XPoet/picx" ref="nofollow noopener noreferrer">github.com/XPoet/picx</a></p><p>文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FXPoet%2Fpicx%2Fblob%2Fmaster%2FREADME.md" target="_blank" title="https://github.com/XPoet/picx/blob/master/README.md" ref="nofollow noopener noreferrer">github.com/XPoet/picx/…</a></p><p><strong>1. 创建 GitHub 仓库</strong></p><p>创建 一个用来存储图片的 GitHub 仓库，仓库属性必须选 Public 。</p><p>点击链接 <a href="https://github.com/">https://github.com/</a> 快速新建仓库</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/123.5icizwyveeg0.webp#pic_center" width = 48%/><p><strong>2. 创建 GitHub Token</strong></p><p>PicX 的图床服务依赖于 <code>GitHub Token</code>，在开始使用之前，你必须先 创建 一个带有 repo 权限的 <code>GitHub Token</code>。</p><p>点击 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 快速新建 GitHub Token</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/124.25nlu5i5j1ds.webp#pic_center" width = 48%/><p>这里我们填完名称和勾选上repo选项之后呢，然后直接点击 Generate token 按钮，即可生成一个token，如下图：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/001.6lklllgnfxc0.webp#pic_center" width = 48%/><p>注意：这里英文的意思是：确保立即复制您的个人访问令牌。你将无法再看到它！那万一没了重新生成一个就行。</p><p><strong>3. 配置图床</strong></p><p><strong>1) 一键自动配置</strong></p><p>填写 GitHub Token，点击 “一键自动配置” 按钮会自动创建 GitHub 仓库，并完成仓库、分支和目录之间的绑定。</p><ul><li>一键自动配置 &gt; 创建的仓库：picx-images-hosting</li><li>一键自动配置 &gt; 创建的分支：master</li><li>一键自动配置 &gt; 创建的目录：yyyyMMdd (当天日期，例如：20230403)</li></ul><p>如果你刚开始使用 PicX，那么推荐使用一键自动配置，非常方便。当然你也可以随时切换成手动配置。</p><p><strong>2) 手动配置</strong></p><p>填入刚刚在Github生成的Token，点击确认Token。会自动获取该用户下的仓库</p><p>如果你绑定的仓库有多个分支，那么会出现选择分支的下拉列表，否则直接进入选择目录。</p><p>多个分支情况，选择其中一个即可。PicX 暂时不支持新建分支，需要你手动去创建。只有一个分支情况，无分支下拉列表。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/128.62w39qmdbb00.webp#pic_center" width = 48% /><ul><li>新建目录：需手动输入一个新目录。</li><li>根目录：图片将直接存储在仓库根目录下。</li><li>自动目录：自动生成日期格式 YYYYMMDD 的目录。例如：20230526</li><li>选择仓库目录：自动获取仓库下所有目录，选择一个即可。</li></ul><p>至此，完成图床配置，点击 “确认” 按钮即可跳转到图片上传界面。</p><blockquote><p>如果想对图片进行一个分类怎么办呢？<br>这个也很简单，新建一个文件夹然后再上传，等到下次还要上传到这个文件夹，我们在目录方式中勾选选择仓库目录，就会展示你创建的所有文件夹。然后进行选择。</p></blockquote><p><a href="https://qxienote.com/">https://qxienote.com/</a></p><p><strong>4. 上传图片</strong></p><p>在上传图片界面，你可以使用 拖拽文件、复制粘贴、选择文件 这三种方式选择你的图片到上传区域。</p><ul><li>你可以拖拽 一张 或 多张 图片到上传区域。</li><li>你可以先将一张图片复制（快捷键 Ctrl+C &#x2F; Command+C）到系统剪贴板，然后在 PicX 上传界面通过按下快捷键 Ctrl+V &#x2F; Command+V 将图片粘贴到上传区域。</li><li>你可以选择 一张 或 多张 图片到上传区域。</li></ul><p>选择图片完成后，在上传之前，可以自由修改图片名。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/131.1zt39d3iin5s.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/131.1zt39d3iin5s.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="131" width=48% /><p>勾选中哈希化，会在图片名称加上一串哈希值，确保图片名的唯一性，强烈建议开启。</p><p>图片上传成功之后，会自动复制图片链接到系统剪贴板，也可以点击 “复制链接” 按钮进行复制。</p><p><strong>5. 图床管理</strong></p><p>点击左侧菜单栏的图床管理，我们可以看到当前目录是我们选择的 2230526</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/132.3r5biof03tg0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/132.3r5biof03tg0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="132" width=48% /><p>双击目录图标，可进入下一级目录，点击图片，可放大预览。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/133.94otifievhs.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/133.94otifievhs.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="133" width=48% /><p>支持的操作：</p><ul><li>在属性面板，可以查看到图片名称和图片大小。</li><li>在重命名输入框键入新名称后，按回车键确认。</li><li>删除单张图片&#x2F;批量删除多张图床</li><li>复制&#x2F;批量复制链接</li></ul><p><strong>6. 我的设置</strong></p><p>在我的设置界面，你可以体验到 PicX 图床丰富多彩的功能，根据自己需求调整最佳配置。</p><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/130.6ywi4j6ahwc.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/230526/130.6ywi4j6ahwc.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="130" width=48% /><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>使用 PicX 创建免费的图床神器：<a href="https://juejin.cn/post/6991273636493524999">https://juejin.cn/post/6991273636493524999</a></li><li>图床配置：<a href="https://picx-docs.xpoet.cn/usage-guide/config.html">https://picx-docs.xpoet.cn/usage-guide/config.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIGC使用教程（一）-- ChatGPT 注册与基本使用</title>
      <link href="/article/ad3c5526.html"/>
      <url>/article/ad3c5526.html</url>
      
        <content type="html"><![CDATA[<p>本篇带你走进 AIGC 的基本使用，一步一步注册 ChatGPT，申请自己的 API 进行使用，解决代理的问题，最后介绍如何本地部署 ChatGPT，以及通过免费云平台搭建代理转发，从而不需要使用魔法就可以访问。</p><span id="more"></span><h2 id="1-ChatGPT-注册"><a href="#1-ChatGPT-注册" class="headerlink" title="1 ChatGPT 注册"></a>1 ChatGPT 注册</h2><p>受限于ChatGPT的服务器以及相关要求影响，其注册比较繁琐，在国内是无法使用的，而我们又想体验一下ChatGPT，具体ChatGPT怎么注册呢？我综合了网络上的各种注册教程，整理了这篇文章，供大家学习和使用。</p><h3 id="1-1-工具准备"><a href="#1-1-工具准备" class="headerlink" title="1.1 工具准备"></a>1.1 工具准备</h3><p>注册&#x2F;登录环境要求：</p><ul><li>注册和登陆需要 magic 环境。</li><li>需要有一个可以接收验证码的 magic 手机号，同样地区也是如上述网络环境之外的地区手机号（注意部分虚拟手机号的厂家无法接受验证码，请注意甄别）。</li></ul><p><strong>1. 注册工具准备</strong></p><p>在注册ChatGPT之前，需要准备好以下几个工具：</p><ol><li>一个邮箱（我们用的Gmail邮箱，经测试其他邮箱也可以）</li><li>magic 工具（自行百度，或者私信我）</li><li>一个 magic 手机号（后文将详细告诉你如何花少许人民币获取一个临时 magic 手机号）</li></ol><p>在以上三个工具中，可能大部分人前两个工具已经有了。但很多人没有 magic 手机号。下面我们一起来看一下如何快速，低费用获取一个能接收ChatGPT验证短信的 magic 手机号。</p><p><strong>2. 购买一个临时国外手机号</strong></p><p>首先，登录一个 magic 临时手机号购买网站：<a href="https://sms-activate.org/">https://sms-activate.org/</a></p><ol><li>进入 <a href="https://sms-activate.org/">SMS-Activate是在线接收短信的虚拟号码服务平台</a> 的首页，选择右上角【注册】按钮，在弹出的窗口中继续选择【注册】按钮：</li></ol><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2qq2oz4gnhi0.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/001.2qq2oz4gnhi0.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="012" width = 48%/><ol><li>输入邮箱、设置密码完成账号注册,（不建议用国内的邮箱，避免收不到问题，最好是Gmail之类的），密码长度在8位以上且必须包含拉丁字母和数字，至少一个大写字母。登录你的邮箱，然后你会收到一封标题为《确认电子邮件来注册SMS-Activate账户》这样的邮件，点击邮件中的【确认】按钮，注册成功后，在账号中，点击右上角的充值。提示：如果收件箱找不到，看一下垃圾箱或者黑名单&#x2F;规则之类是不是过滤掉了。如果实在没有，建议换一个邮箱试试。</li></ol><img src="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2yj3a24fot40.webp#pic_center" class="lazyload placeholder" data-srcset="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/002.2yj3a24fot40.webp#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="013" width = 48%/><ol><li>确认帐号注册成功后，登录平台，不过帐号还需要充值才能使用，可以使用支付宝充值。还是右上角，选择【余额】，然后选择【充值】按钮，接着选择支付宝进行充值，这里现在要求至少充值2美元，输入2，点击最下角的支付，然后进入支付宝扫码付款页面，扫码支付即可，自动汇率换算支付人民币14.93元（你注册时可能由于汇率不同金额会有差异）。</li></ol><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/003.2v8qjmcqw4e0.webp#pic_left" width = "30%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/004.3pzrnjbmbcy0.webp#pic_left"  width = "36%"></center></p><ol><li>充值完成后，注意看个人页面右上角的余额有没有变化。然后看左侧，找到“openAI”这个，点击展开（如果没有，在选择服务-服务搜索里直接搜索一下）：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/005.4zg8mxa5h9o0.webp#pic_center" width = 24%><ol><li>接着，选择手机号码的归属地，哪个便宜买哪个。选好后直接点击对应国家后面的购物车图片即可：</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/006.6zlth6754ls0.webp#pic_center" width = 24%><ol><li>购买后，账号页面右侧，可以看到你购买的手机号，然后返回到ChatGPT的页面，填入对应的手机号码，页面会自动显示出收到的短信。</li></ol><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/007.48y0wpvvj4g0.webp#pic_center" width = 36%><p>关于这个国外手机号说四点：</p><ul><li>这里显示的号码是包含国家代码的。比如*国手机号+254771961634，你在网站上填写手机号时，需要去掉前面的 254 这个国别代码。另外在接收验证码时，建议使用低价的印尼等手机号，印度经常挤爆收不到；如果长时间没有收到验证码，可更换成其他区域尝试。</li><li>这是一个临时手机号，有效时长20分钟</li><li>20分钟内如果没有收到验证码，可以点右侧的叉号，退订，费用还会返还。（注：一般在ChatGPT注册页面发出验证码后一分钟左右便可以收到验证码。收不到验证短信可以在20分钟到期前退订，三分钟以上收不到验证码建议就不用再等了）</li><li>如遇到无法登录的情况，请打开谷歌浏览器的无痕窗口进行登录，一般会很快登录账号。</li></ul><p>另外保留这个显示 magic 手机号的页面处于打开状态即可，便于快速回来查收验证短信。重点是：在手机验证页面，一定要注意选择正确的国家（注意国旗）！一定要注意选择正确的国家！一定要注意选择正确的国家！</p><h3 id="1-2-注册流程"><a href="#1-2-注册流程" class="headerlink" title="1.2 注册流程"></a>1.2 注册流程</h3><p><strong>1. 进入注册</strong><br>打开ChatGPT的官方网站，链接为 <a href="https://openai.com/">https://openai.com/</a>，然后点击【Sign Up】进入下一步。</p><p>如果页面无法正常显示，需要更换其他的网络节点，或者清理下浏览器cookie再次尝试。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/008.4m2curnqu1a0.webp#pic_center" width = 36%><p><strong>2. 邮箱注册</strong></p><p>注册方式为邮箱注册，可以用微软帐号或者谷歌帐号登录，微软账号或者谷歌账号好像不需要验证，国内或者其他邮箱地址都需要进行验证（比如QQ邮箱是需要验证的）。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/009.1a9537ruo4rk.webp#pic_center" width = 24%><p><strong>3. 填写姓名信息</strong></p><p>邮箱通过后，会提示你输入姓名，按照要求进行输入即可。如果显示该IP地址注册数量过多，则需要更换节点（更换节点时，无需对浏览器进行重启，刷新页面即可）。</p><p><strong>4. 验证手机号（重点！！！）</strong><br>随后将会进入手机验证的环节，记住：这里不能选择国内的手机号，国内的手机号无法进行注册。</p><p>如果是只想体验一下产品的朋友，可直接在某海鲜市场购买服务，实时帮你接收验证码，非常快速。动手能力强一些的朋友，可以通过虚拟接码平台进行接收验证码。</p><p>选择手机号国别，并输入第二步中购买的手机号码，点击发送验证短信（send code）：（例如，我们买的是手机号，则选择Kenya，后面输入手机号时注意国家区号不要重复输入）</p><p>然后返回到第二步中购买手机号的页面，查收短信：(一般一分钟左右可以收到短信)</p><h3 id="1-3-申请-API"><a href="#1-3-申请-API" class="headerlink" title="1.3 申请 API"></a>1.3 申请 API</h3><p>OpenAI账号注册完成后，登录界面如下所示。点击右上角View API keys—&gt; Create new secret key，可以生成属于你自己的API，有了这个API，就可以用于开发基于ChatGPT API的应用程序。</p><p><center class = "half"><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/010.3ruq1w73inu0.webp#pic_left" width = "24%"><img src = "https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/024.56cyk54rvtc0.webp#pic_left"  width = "48%"></center></p><p>需要注意的是，出于安全原因，这个API只展示一次，请务必在关闭对话框之前，将其复制到你其他的地方保管。</p><p>另外，点击左侧栏的Usage ,可以方便清晰看到token的使用量情况，数据5分钟更新一次。OpenAI官方针对每一个新注册的账户，提供$5免费token使用额度。这样一想，前面花费不到$5免费token使用额度。不过需要注意的是，免费额度有时间限制，过期了额度就作废。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/011.wvukprqvcq8.webp#pic_center" width = 48%><hr><h2 id="2-API-使用"><a href="#2-API-使用" class="headerlink" title="2 API 使用"></a>2 API 使用</h2><h3 id="2-1-简单测试"><a href="#2-1-简单测试" class="headerlink" title="2.1 简单测试"></a>2.1 简单测试</h3><p>使用 Python 简单测试，你只需 <code>import openai</code> 包，带上刚申请的API，模型选择——<code>text-davinci-003</code> 就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"> </span><br><span class="line">openai.api_key = <span class="string">&#x27;sk-xxxxxx&#x27;</span>        <span class="comment"># 填写个人API</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat_gpt</span>(<span class="params">prompt</span>):</span><br><span class="line">     prompt = prompt</span><br><span class="line">     model_engine = <span class="string">&quot;text-davinci-003&quot;</span></span><br><span class="line">     completion = openai.Completion.create(</span><br><span class="line">         engine=model_engine,</span><br><span class="line">         prompt=prompt,</span><br><span class="line">         max_tokens=<span class="number">1024</span>,</span><br><span class="line">         n=<span class="number">1</span>,</span><br><span class="line">         stop=<span class="literal">None</span>,</span><br><span class="line">         temperature=<span class="number">0.5</span>,</span><br><span class="line">         timeout=<span class="number">1000</span>,</span><br><span class="line">     )</span><br><span class="line"> </span><br><span class="line">     response = completion.choices[<span class="number">0</span>].text</span><br><span class="line">     <span class="built_in">print</span>(response)</span><br><span class="line"> </span><br><span class="line">chat_gpt(<span class="string">&quot;现在几点了&quot;</span>)          <span class="comment"># 现在是北京时间下午4点30分。</span></span><br></pre></td></tr></table></figure><blockquote><p>更多的例子，请自行参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenai.com%2Fblog%2Fintroducing-chatgpt-and-whisper-apis" target="_blank" title="https://openai.com/blog/introducing-chatgpt-and-whisper-apis" ref="nofollow noopener noreferrer">官方例子</a>以及<a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fapi-reference%2Fintroduction" target="_blank" title="https://platform.openai.com/docs/api-reference/introduction" ref="nofollow noopener noreferrer">官方API文档</a>。</p></blockquote><h3 id="2-2-设置代理"><a href="#2-2-设置代理" class="headerlink" title="2.2 设置代理"></a>2.2 设置代理</h3><p>有的同学可能会遇到以下问题，这里综合了网上的解决办法。</p><blockquote><p>返回错误信息：<br>raise error.APIConnectionError(openai.error.APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host&#x3D;’api.openai.com’, port&#x3D;443): Max retries exceeded with url: &#x2F;v1&#x2F;chat&#x2F;completions (Caused by SSLError(SSLEOFError(8, ‘EOF occurred in violation of protocol (_ssl.c:1131)’)))</p></blockquote><p><strong>1. urllib3 降低版本到 1.25.11</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install urllib3==<span class="number">1.25</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><blockquote><p>参考大佬文章：<a href="https://zhuanlan.zhihu.com/p/350015032">Python 遭遇 ProxyError 问题记录</a></p></blockquote><p>简单来说就是 1.26.0 版本的 urllib3 添加了 HTTPS 支持，但代理服务器不支持 HTTPS，所以报错（pip走代理报错也差不多类似原因，具体请参考上文，有详细解读）</p><p><strong>2. 修改openai源码（亲测成功）</strong></p><p>根据自己安装openai包的路径，找到并打开 <code>api_requestor.py</code>，我的路径为：<code>C:\***\***\.conda\envs\py3.8\lib\site-packages\openai\api_requestor.py</code>，找到下面的部分：<code>if not hasattr(_thread_context, &quot;session&quot;):</code>，并在此方法上方加入代理，如下图框的部分。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/012.r0cjtzw1ank.webp#pic_center" width = 48%><p><strong>代理部分：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proxy = &#123;</span></span><br><span class="line"><span class="comment">#    &#x27;http&#x27;: &#x27;http://&lt;代理ip&gt;:&lt;代理端口&gt;&#x27;,</span></span><br><span class="line"><span class="comment">#    &#x27;https&#x27;: &#x27;https://&lt;代理ip&gt;:&lt;代理端口&gt;&#x27;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"> </span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://localhost:7890&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口号是你用对应软件的代理端口，我这里是7890。</p><p>在 <code>“result = _thread_context.session.request(”</code> 中加入代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = _thread_context.session.request(</span><br><span class="line">    method,</span><br><span class="line">    abs_url,</span><br><span class="line">    headers=headers,</span><br><span class="line">    data=data,</span><br><span class="line">    files=files,</span><br><span class="line">    stream=stream,</span><br><span class="line">    timeout=request_timeout <span class="keyword">if</span> request_timeout <span class="keyword">else</span> TIMEOUT_SECS,</span><br><span class="line">    <span class="comment"># proxies=_thread_context.session.proxies,      # 注释掉原本的代理</span></span><br><span class="line">    proxies=proxy                                   <span class="comment"># 添加自己的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>参考大佬文章：<a href="https://www.cnblogs.com/ghj1976/p/diao-yongopenai-deapi-chu-xianrequest-timed-out-ch.html">调用OpenAI的API出现Request timed out处理</a></p></blockquote><p><strong>3、代码里设置环境变量（亲测成功）</strong></p><p>添加以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">os.environ[<span class="string">&quot;http_proxy&quot;</span>] = <span class="string">&quot;http://localhost:7890&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;https_proxy&quot;</span>] = <span class="string">&quot;http://localhost:7890&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-ChatGPT-本地部署"><a href="#3-ChatGPT-本地部署" class="headerlink" title="3 ChatGPT 本地部署"></a>3 ChatGPT 本地部署</h2><h3 id="3-1-使用魔法"><a href="#3-1-使用魔法" class="headerlink" title="3.1 使用魔法"></a>3.1 使用魔法</h3><p><strong>第一步，将 ChatGPT 的源代码从 Github 上下载到本地</strong></p><p>以下是命令示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xtekky/chatgpt-clone.git</span><br></pre></td></tr></table></figure><p>这样就可以克隆代码到您的电脑上。</p><p><strong>第二步是安装环境</strong></p><p>这里选用熟悉的 Conda 安装，首先进入项目目录，然后运行以下命令来创建虚拟环境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n chatgpt-py3<span class="number">.9</span> python=<span class="number">3.9</span>        <span class="comment"># 创建虚拟环境</span></span><br><span class="line">conda activate chatgpt-py3<span class="number">.9</span>                    <span class="comment"># 激活环境</span></span><br><span class="line">cd ../chatgpt-clone                             <span class="comment"># 进入项目</span></span><br></pre></td></tr></table></figure><p>没有 Anconda 的，可以使用 Python 的 <code>venv</code> 包，首先进入项目目录，然后运行以下命令来创建虚拟环境（Linux）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd chatgpt-clone</span><br><span class="line">python -m venv venv</span><br><span class="line">source venv/<span class="built_in">bin</span>/activate            <span class="comment"># macOS/Linux</span></span><br></pre></td></tr></table></figure><p>如果您在使用 Windows 系统，需要使用以下的命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">venv\Scripts\activate.bat</span><br></pre></td></tr></table></figure><p><strong>第三步：安装所需要的依赖</strong></p><p>使用以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><strong>第四步：修改配置文件</strong></p><p>找到项目目录下的 config.josn 文件，并将文件中的 openai_key 替换成您自己的 key。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/013.7hmsme73cv80.webp#pic_center" width = 64%><p><strong>第五步：配置 magic 端口</strong></p><p>因为 ChatGPT 在本质上是调用 OpenAI 的接口，因此在运行该项目之前，需要让命令行工具具有 magic 能力（用魔法，前面讲过了）。</p><p>可以在命令行工具里输入以下命令（注意：您需要修改这个端口号！）</p><p><strong>Linux</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span> http_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span> all_proxy=socks5://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br><span class="line"><span class="built_in">set</span> https_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> http_proxy_user=user</span><br><span class="line"><span class="built_in">set</span> http_proxy_pass=<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> https_proxy_user=user</span><br><span class="line"><span class="built_in">set</span> https_proxy_pass=<span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：一定要加 http:&#x2F;&#x2F;，直接写域名或者 IP 不行。http 和 https 都要设置。然后如果想验证是否成功配置了代理的话，用 ping 命令是不可以的；ping的协议不是https，也不是https，是ICMP协议。可以使用 <code>curl -vv http://www.google.com</code>这条命令来验证。</p></blockquote><p>cmd，Git Bash，PowerShell 设置的方式不同</p><ul><li>cmd 中用 set http_proxy 设置</li><li>Git Bash 中用 export http_proxy 设置</li><li>PowerShell 中按照这样设置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#<span class="doctag">NOTE:</span> registry keys for IE 8, may vary for other versions</span></span><br><span class="line">$regPath = <span class="string">&#x27;HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings&#x27;</span></span><br><span class="line"></span><br><span class="line">function Clear-Proxy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyEnable -Value <span class="number">0</span></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyServer -Value <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyOverride -Value <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;http_proxy&#x27;</span>, $null, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;https_proxy&#x27;</span>, $null, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="type">Set</span>-Proxy</span><br><span class="line">&#123;</span><br><span class="line">    $proxy = <span class="string">&#x27;http://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyEnable -Value <span class="number">1</span></span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyServer -Value $proxy</span><br><span class="line">    <span class="type">Set</span>-ItemProperty -Path $regPath -Name ProxyOverride -Value <span class="string">&#x27;&lt;local&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;http_proxy&#x27;</span>, $proxy, <span class="string">&#x27;User&#x27;</span>)</span><br><span class="line">    [Environment]::SetEnvironmentVariable(<span class="string">&#x27;https_proxy&#x27;</span>, $proxy, <span class="string">&#x27;User&#x27;</span>)</span><br></pre></td></tr></table></figure><p>也可以在代码里设置环境变量</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/014.qkw15yc8g8g.webp#pic_center" width = 48%><p><strong>第六步就是运行 ChatGPT 项目并进行访问了</strong></p><p>你只需要在命令行输入 python run.py，然后在浏览器中访问相应的链接就好了。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/015.d6bfqrwxovk.webp#pic_center" width = 48%><p>首先，您可以像使用普通的 GPT 一样使用暗黑版。但是，为什么他被称之为 “暗黑版” 呢？因为当您使用了暗黑模式之后，ChatGPT 将突破底线，以一种更加深入和黑暗的方式回答您的问题。以下是如何使用暗黑版的提示：</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/016.ic4al3nz228.webp#pic_center" width = 48%><h3 id="3-2-通过免费云平台搭建代理转发"><a href="#3-2-通过免费云平台搭建代理转发" class="headerlink" title="3.2 通过免费云平台搭建代理转发"></a>3.2 通过免费云平台搭建代理转发</h3><p>第一步，我们需要登录云平台并进入应用选择菜单。下面是云平台官网链接：<a href="https://cloud.sealos.io/">https://cloud.sealos.io/</a></p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/017.arkjwnce80c.webp#pic_center" width = 36%><p>第二步，首次进入的用户需要新建一个应用，并进行应用的基本配置。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/018.1fs4xplnxlxc.webp#pic_center" width = 48%><p>第三步，通过高级配置来实现代理转发。</p><p>您现在可以进入高级设置选项卡来配置代理转发功能。</p><ul><li>点开高级配置</li><li>点击新增 configmap</li><li>文件名写: <code>/etc/nginx/nginx.conf</code></li><li>文件值为刚刚复制的那段代码</li><li>点击确认</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/019.3w5pf0dgrew0.webp#pic_center" width = 36%><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/020.15fxydbv0f9c.webp#pic_center" width = 48%><p><strong>nginx 配置代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">worker_rlimit_nofile <span class="number">51200</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    resolver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>;</span><br><span class="line">    proxy_ssl_server_name on;</span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    server_names_hash_bucket_size <span class="number">512</span>;</span><br><span class="line">    client_header_buffer_size 64k;</span><br><span class="line">    large_client_header_buffers <span class="number">4</span> 64k;</span><br><span class="line">    client_max_body_size 50M;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout       240s;</span><br><span class="line">    proxy_read_timeout          240s;</span><br><span class="line">    proxy_buffer_size 128k;</span><br><span class="line">    proxy_buffers <span class="number">4</span> 256k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xxxxx.cloud.sealos.io; <span class="comment"># 这个地方替换成 sealos 提供的内容</span></span><br><span class="line"></span><br><span class="line">        location ~ /openai/(.*) &#123;</span><br><span class="line">            <span class="comment"># auth check</span></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">            proxy_pass https://api.openai.com/$<span class="number">1</span>$is_args$args;</span><br><span class="line">            proxy_set_header Host api.openai.com;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="comment"># 如果响应是流式的</span></span><br><span class="line">            proxy_set_header Connection <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">            chunked_transfer_encoding off;</span><br><span class="line">            proxy_buffering off;</span><br><span class="line">            proxy_cache off;</span><br><span class="line">            <span class="comment"># 如果响应是一般的</span></span><br><span class="line">            proxy_buffer_size 128k;</span><br><span class="line">            proxy_buffers <span class="number">4</span> 256k;</span><br><span class="line">            proxy_busy_buffers_size 256k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，点击部署应用按钮。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/021.16j17a5gndj4.webp#pic_center" width = 48%><p>第五步，如果成功，你将看到下面的结果。最后，你可以点击详情获得外部访问链接。</p><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/022.36lusgudolk0.webp#pic_center" width = 48%><p>第六步，如果你正在使用暗黑版的 OpenAI GPT，并且想要更轻松地使用以上方法，那么你可以修改 <code>config.json</code> 文件中的两个参数，具体操作请看下面：</p><ul><li>将 <code>proxy.enable</code> 设置为 false；</li><li>将 <code>openai_api_base</code> 改为在上一步获取的对外链接后加 <code>/openai</code>。</li></ul><img src ="https://cdn.staticaly.com/gh/molimi/image-hosting@main/ChatGPT/023.3gy8v0zm7xo0.webp#pic_center" width = 64%><p>最后，你可以通过命令运行暗黑版 GPT，就可以实现无魔法访问。好了，以上就是通过免费云平台搭建代理转发，实现对 OpenAI GPT 的免费访问的全部步骤。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>ChatGPT注册教程攻略：<a href="https://www.xnbeast.com/create-openai-chatgpt-account/">https://www.xnbeast.com/create-openai-chatgpt-account/</a></li><li>2023年最新国内ChatGPT注册教程：<a href="https://juejin.cn/post/7220696541309108285">https://juejin.cn/post/7220696541309108285</a></li><li>Python 遭遇 ProxyError 问题记录：<a href="https://zhuanlan.zhihu.com/p/350015032">https://zhuanlan.zhihu.com/p/350015032</a></li><li>ChatGPT Plus官方推荐新手教程：<a href="https://chatgpt-plus.github.io/chatgpt-plus/">https://chatgpt-plus.github.io/chatgpt-plus/</a></li><li>ChatGPT本地部署：<a href="https://juejin.cn/post/7236668895867764773">https://juejin.cn/post/7236668895867764773</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> AIGC </category>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> OPENAI </tag>
            
            <tag> AIGC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
